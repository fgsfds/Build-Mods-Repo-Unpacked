include scripts/NEWSOUNDS.CON
include scripts/AADEFS.CON
include scripts/AAUSER.CON
include scripts/EBIKE.CON

precache 1820 1973 1
precache 2080 2217 1
precache 2690 2809 1
precache 5120 5596 1
precache 5632 5864 1
precache 6144 6250 1
precache 6656 6804 1
precache 7680 7798 1

precache 8176 8191 1
precache 8448 8494 1
precache 8555 8680 1
precache 8681 8684 1
precache 8875 8958 1
precache 8905 8937 1
precache 9472 9641 1
precache 9722 9726 1
precache 9966 9978 1
precache 10240 10429 1
precache 10624 10729 1
precache 10923 10945 1
precache 12080 12153 1

precache 13004 13047 1
precache 13312 13584 1
precache 14085 14215 1
precache 14376 14505 1
precache 15304 15351 1
precache 15460 15505 1
precache 16510 16530 1
precache 16540 16584 1
precache 16767 16778 1
precache 16844 16878 1
precache 16790 16878 1
precache 16896 17151 1
precache 17408 17660 1
precache 18176 18362 1
precache 18505 18533 1
precache 18590 18655 1
precache 20424 20454 1
gamevar ATTVOLUME 0 0
gamevar ATTLEVEL 0 0
gamevar FAKEVOLUME 0 0 // SET BACK TO 0 IF NONZERO, USED FOR BONUS SCREEN

defstate next_att_map

	set tempG NO // becomes YES when new map is found
	
	ife attmid NO // tutorial not done yet
	{
		set attmid 1
		set ATTLEVEL 11
		set ATTVOLUME 5
		set attmusic -1
		break
	}
	
	ifge plevel 5
	ifl attmid 2
	{
		set attmid 2
		set ATTLEVEL 41
		ifge attbosses 6 set attbosses 0
		add ATTLEVEL attbosses
		add attbosses 1, ifge attbosses 6 set attbosses 0
		savegamevar attbosses
		set ATTVOLUME 0
		set attmusic -1
		break
	}
	
	set temp ATTLENGTH
	ife challenge YES set temp 12
	
	ifge plevel temp
	{
		al plevel
		ife challenge YES
		{
			set attmid 3
			set ATTLEVEL 51
			set ATTVOLUME 0
			set attmusic -1
		}
		else
		{
			set attmid 3
			set ATTLEVEL 47
			ifge attbosses 6 set attbosses 0
			add ATTLEVEL attbosses
			set ATTVOLUME 0
			set attmusic -1
		}
		break
	}
	
	gettimedate temp tempb tempc x x x x x
	add temp 1 add tempb 1 add tempc 1
	mul temp tempb
	mul temp tempc
	shiftvarr temp 6
	whilevarn temp 0
    {
    ifrnd 1 { }
    subvar temp 1
    }

	whilevarn tempG YES
	{
		rand tempI TOTALATTMAPS
		
		ifl plevel 3 { rand tempI 62 add tempI 63 } // simple starting map in third episode
		
		add tempI 1
		
		set tempF 0
		whilevarn tempF RECATTMAPS
		{
			ife tempI recentmaps[tempF] set tempI -1
			add tempF 1
			ife tempI -1 set tempF RECATTMAPS
		}
		ifn tempI -1 set tempG YES
	}
	// update recentmaps array to make new selection most recent map
	set tempF RECATTMAPS, sub tempF 1
	set temp tempF, sub temp 1
	whilevarn temp -1
	{
		setarray recentmaps[tempF] recentmaps[temp]
		sub tempF 1
		sub temp 1
	}
	setarray recentmaps[0] tempI
	writearraytofile recentmaps 1250
	// translate selected map number into usable VOLUME and LEVEL numbers
	ifle tempI 63
	{
		set ATTVOLUME 1
		set ATTLEVEL tempI
	}
	else
	ifle tempI 126
	{
		set ATTVOLUME 2
		set ATTLEVEL tempI
		sub ATTLEVEL 63
	}
	else
	ifle tempI 190
	{
		set ATTVOLUME 3
		set ATTLEVEL tempI
		sub ATTLEVEL 127
	}
	else
	{
		set ATTVOLUME 5
		set ATTLEVEL tempI
		sub ATTLEVEL 191
		add ATTLEVEL 12
	}
	set TMP_A attmusic
	rand attmusic 62
	add attmusic 1
	ife attmusic TMP_A sub attmusic 1
	
ends

defstate autosave

	ifn AUTOSAVE YES break
	ife player[].cursectnum -1 break
	ifgapzl 32 break
	getp[].cursectnum mysector
	switch sector[mysector].floorpicnum
	case FLOORSLIME
	case FLOORPLASMA
	case PURPLELAVA
	break
	default
		ife player[].falling_counter 0
		{
			savenn 9
			getp[].player_par lastsave
		}
	break
	endswitch
ends

defstate writehighscores
	ife scoreswrote YES break
	set temp 0
	whilevarvarn temp MAXSCORES
	{
		ifg totalxp highscores[temp]
		{
			set tempb MAXSCORES
			sub tempb 1
			set tempc tempb
			sub tempc 1
			whilevarvarn tempb temp
			{
				setarray highscores[tempb] highscores[tempc]
				sub tempb 1
				sub tempc 1
			}
			setarray highscores[temp] totalxp
			set temp MAXSCORES
		}
		else
		add temp 1
	}
	writearraytofile highscores 3106
	// set totalxp 0
	set scoreswrote YES
	set vendor_screen 5
	set lastscreen vendor_screen
	set tempselect -1
ends

// This function swaps the data of walls J and K, except for the point2 fields

defstate swapwall
ifvarvarn J K {
getwall[J].x temp
getwall[K].x tempb
setwall[J].x tempb
setwall[K].x temp
getwall[J].y temp
getwall[K].y tempb
setwall[J].y tempb
setwall[K].y temp
getwall[J].cstat temp
getwall[K].cstat tempb
setwall[J].cstat tempb
setwall[K].cstat temp
getwall[J].picnum temp
getwall[K].picnum tempb
setwall[J].picnum tempb
setwall[K].picnum temp
getwall[J].overpicnum temp
getwall[K].overpicnum tempb
setwall[J].overpicnum tempb
setwall[K].overpicnum temp
getwall[J].shade temp
getwall[K].shade tempb
setwall[J].shade tempb
setwall[K].shade temp
getwall[J].pal temp
getwall[K].pal tempb
setwall[J].pal tempb
setwall[K].pal temp
getwall[J].xrepeat temp
getwall[K].xrepeat tempb
setwall[J].xrepeat tempb
setwall[K].xrepeat temp
getwall[J].yrepeat temp
getwall[K].yrepeat tempb
setwall[J].yrepeat tempb
setwall[K].yrepeat temp
getwall[J].xpanning temp
getwall[K].xpanning tempb
setwall[J].xpanning tempb
setwall[K].xpanning temp
getwall[J].ypanning temp
getwall[K].ypanning tempb
setwall[J].ypanning tempb
setwall[K].ypanning temp
getwall[J].lotag temp
getwall[K].lotag tempb
setwall[J].lotag tempb
setwall[K].lotag temp
getwall[J].hitag temp
getwall[K].hitag tempb
setwall[J].hitag tempb
setwall[K].hitag temp
getwall[J].extra temp
getwall[K].extra tempb
setwall[J].extra tempb
setwall[K].extra temp
getwall[J].nextwall temp
getwall[K].nextwall tempb
setwall[J].nextwall tempb
setwall[K].nextwall temp
getwall[J].nextsector temp
getwall[K].nextsector tempb
setwall[J].nextsector tempb
setwall[K].nextsector temp
}
ends

defstate mirrorplayer

	getactor[].x x
	mulvar x -1
	seta[].x x
	// setp[].posx x
	getactor[].y y
	getactor[].z z
	updatesectorz x y z temp
	
	changespritesect THISACTOR temp
	//setp[].cursectnum temp
	
	getactor[].ang angvar
	ifvarg angvar 1024 setvar temp 1536
	else setvar temp 512
	subvarvar temp angvar
	mulvar temp 2
	addvarvar angvar temp
	setactor[].ang angvar
	// setplayer[].ang angvar

ends

// This helper function sets temp to 1 if a wall's picnum is identified
// as a wall switch. Otherwise, it sets temp to 0.
// The input picum is also given in temp.
defstate iswallswitch
    switch temp
        case 130 // ACCESSSWITCH
        case 131 // ACCESSSWITCH+1; Not usable, but checked for consistency
        case 132 // SLOTDOOR
        case 133 // SLOTDOOR+1
        case 134 // LIGHTSWITCH
        case 135 // LIGHTSWITCH+1
        case 136 // SPACEDOORSWITCH
        case 137 // SPACEDOORSWITCH+1
        case 138 // SPACELIGHTSWITCH
        case 139 // SPACELIGHTSWITCH+1
        case 140 // FRANKENSTINESWITCH
        case 141 // FRANKENSTINESWITCH+1
        case 146 // MULTISWITCH
        case 147 // MULTISWITCH+1
        case 148 // MULTISWITCH+2
        case 149 // MULTISWITCH+3
        case 162 // DIPSWITCH
        case 163 // DIPSWITCH+1
        case 164 // DIPSWITCH2
        case 165 // DIPSWITCH2+1
        case 166 // TECHSWITCH
        case 167 // TECHSWITCH+1
        case 168 // DIPSWITCH3
        case 169 // DIPSWITCH3+1
        case 170 // ACCESSSWITCH2
        case 171 // ACCESSSWITCH2+1; Not usable, but checked for consistency
        case 712 // LIGHTSWITCH2
        case 713 // LIGHTSWITCH2+1
        case 860 // POWERSWITCH1
        case 861 // POWERSWITCH1+1
        case 862 // LOCKSWITCH1
        case 863 // LOCKSWITCH1+1
        case 864 // POWERSWITCH2
        case 865 // POWERSWITCH2+1
        case 1155 // HANDPRINTSWITCH
//      case 1156 // Unrelated to HANDPRINTSWITCH, but checked in Duke3D's code
        case 1142 // ALIENSWITCH
        case 1143 // ALIENSWITCH+1
        case 1122 // PULLSWITCH
        case 1123 // PULLSWITCH+1
        case 1111 // HANDSWITCH
        case 1112 // HANDSWITCH+1
            setvar temp 1
            break
        default
            setvar temp 0
            break
    endswitch
ends

defstate mirror

// Adjust sector ceilings and floors
setvar I 0
whilevarvarn I NUMSECTORS
{
    // If bit 2 (swap x&y) is set, invert bit 5 (y-flip).
    // Otherwise, invert bit 4 (x-flip).

    getsector[I].ceilingstat A
    ifvarand A 4 xorvar A 32 else xorvar A 16
    setsector[I].ceilingstat A

    getsector[I].floorstat A
    ifvarand A 4 xorvar A 32 else xorvar A 16
    setsector[I].floorstat A

    addvar I 1
}

// Horizontally flip the walls
setvar I 0
whilevarvarn I NUMWALLS
{
    // Flip each wall point's x coordinate. This will temporary make
    // the map technically invalid, because a sector's exterior walls
    // (e.g., all walls of a convex sector) will be sorted in
    // anti-clockwise order, instead of clockwise. This is fixed later.
    getwall[I].x A
    mulvar A -1
    setwall[I].x A
    // Initialize SWAPWALLS for later use
    setarray SWAPWALLS[I] -1
    // Visually flip a wall's tile, except for specific tile numbers
    getwall[I].picnum temp
    switch temp
        case 277 case 394 case 415 case 498 case 499
        case 500 case 502 case 518 case 519 case 520 case 521 case 522 case 523 case 524 case 525
        case 526 case 527 case 528 case 529 case 530 case 531 case 532 case 533 case 534 case 535
        case 568 case 593 case 594 case 598 case 599 case 600 case 612 case 613 case 614 case 639
        case 657 case 666 case 667 case 687 case 699 case 721 case 728 case 736 case 766 case 776 
        case 777 case 778 case 784 case 817 case 818 case 822 case 826 case 835 case 838 case 837
        case 841 case 839 case 848 case 849 case 856 case 858 case 871 case 872 case 937 case 938 
        case 945 case 946 case 949 case 961 case 963 case 964 case 965 case 966 case 967 case 968
        case 970 case 980 case 992 case 1043 case 1044 case 1046 case 1047 case 1064 case 1065 case 1066
        case 1072 case 1210 case 1211 case 1212 case 1214 case 1215 case 1217 case 1244 case 1245
        case 2486 case 2492 case 2493 case 2500 case 2504 case 2505 case 2506 case 3370 case 3371 case 3372
        case 3373 case 3374 case 3382 case 3383 case 3391 case 3402 case 3403 case 3421 case 3422 case 3423
        case 4096 case 4108 case 4125 case 4126 case 4238 case 4306 case 4307 case 4318 case 4323
        case 4329 case 4447 case 4450 case 4451 case 4477 case 4472 case 4475 case 4476
        case 4478 case 4479 case 4484 case 4485 case 4486 case 4487 case 4488 case 4492 case 4499
        case 4494 case 4504 case 4505 case 4506 case 4507 case 4508 case 4553 case 4564 case 4565
        case 4578 case 4579 case 4597 case 4598 case 4599 case 4889 case 4891 case 4892 case 4896 
        case 4897 case 4898 case 4899 case 4903 case 4904 case 4905 case 4906 case 4907 case 4908
        case 4924 case 4925 case 4926 case 4927 case 4928 case 4929 case 4930 case 4931 case 4932
        case 4933 case 4934 case 4937 case 4938 case 4939 case 4942 case 4945 case 4947 case 4948
        case 4950 case 4951 case 4952 case 4956
            break
        default
            state iswallswitch
            ifvarn temp 0 break

            getwall[I].cstat temp
            xorvar temp 8
            setwall[I].cstat temp
            break
    endswitch
    addvar I 1
}

// Make exterior walls clockwise-ordered again, one cycle after the other
setvar I 0
whilevarvarn I NUMWALLS
{
    // A cycle's first and last wall numbers will be A and K, respectively
    setvarvar A I
    getwall[I].point2 B
    setvarvar K I
    whilevarvarn A B
    {
        addvar K 1
        getwall[K].point2 B
    }
    // Swap walls I and A (K), then I+1 and A-1, and so on
    setvarvar A K
    setvarvar J I
    setvarvar L K
    subvarvar L J
    divvar L 2
    addvar J 1
    whilevarn L 0
    {
        state swapwall
        setarray SWAPWALLS[J] K
        setarray SWAPWALLS[K] J
        addvar J 1
        addvar K -1
        addvar L -1
    }

    // Repeatedly swap the x,y fields of walls J (first wall)
    // and each other wall in the cycle, in the given order.
    setvarvar J I
    whilevarvarn I A
    {
        setvarvar K I
        addvar K 1
        getwall[J].x B
        getwall[J].y C
        getwall[K].x D
        getwall[K].y E
        setwall[J].x D
        setwall[J].y E
        setwall[K].x B
        setwall[K].y C

        addvar I 1
    }

    // Continue to the next cycle
    addvar I 1
}

// Fix the nextwall fields by using the SWAPWALLS array
setvar I 0
whilevarvarn I NUMWALLS
{
    getwall[I].nextwall A
    ifvarn A -1
        ifvarn SWAPWALLS[A] -1
            setwall[I].nextwall SWAPWALLS[A]

    addvar I 1
}

// Process actors/sprites. cstat isn't changed here.
setvar I 0
whilevarn I 16384
{
    // Flip the x coordinate
    getactor[I].x A
    mulvar A -1
    setactor[I].x A
    getactor[I].picnum picnum
    
    // Flip the angle
    getactor[I].ang A
    ifvarg A 1024
    {
        setvar B 1536
    } else {
        setvar B 512
    }
    subvarvar B A
    mulvar B 2
    addvarvar A B

    setactor[I].ang A

    // Adjust sector effectors
    getactor[I].lotag temp
    ifvare picnum SECTOREFFECTOR ifvare temp 0
    {
        getactor[I].pal temp
        ifvare temp 2 setactor[I].pal 0 else
        ifvare temp 0 setactor[I].pal 2
    }
    ifvare picnum SECTOREFFECTOR ifvare temp 11
    {
        ifvarg A 0 ifvarl A 1025 subvar A 1
        else
            ifvarg A 1024 ifvarl A 2047 addvar A 1
        addvar A 1025
        ifvarg A 2047 subvar A 2048
        setactor[I].ang A
    }

    addvar I 1
}

ifg player[].player_par 1 
{
	setp[].posx sprite[player[].i].x
	setp[].posy sprite[player[].i].y
	setp[].ang sprite[player[].i].ang
}

ends

defstate pkick_check

	ife sprite[player[].i].extra 0 break
	
	ifn qk_proxy 0 { setp[].quick_kick 0 break }
	
	ife pchar 0 
	{
		ifvarand altcostume 8
		set qk_proxy 15
	}
	else
		set qk_proxy 15
ends

defstate shield_discount

	// discounts
	set temp 1
	{
		whilevarn temp 7
		{
			ife es_owned[temp] YES 
			{
				ifle tempd 7000
					sub tempd 4000
				else
				ifg temp 3
					sub tempd 8000
			}
			add temp 1
		}
		ifl tempd 100 set tempd 100
		
	}

ends

defstate nova_discount

	// discounts
	set temp 7
	{
		whilevarn temp 10
		{
			ife es_owned[temp] YES sub tempd 4000
			add temp 1
		}
		ifl tempd 100 set tempd 100
		
	}

ends

defstate pricetable

	set tempd 0
	switch TMP_B
	
	case 1 set tempd 5000 state shield_discount break
	case 2 set tempd 6000 state shield_discount break
	case 3 set tempd 7000 state shield_discount break

	case 4 ife gametype 0 ife vrtrip 0 set tempd 12000 else set tempd 16000 state shield_discount break
	case 5 ife gametype 0 ife vrtrip 0 set tempd 16000 else set tempd 20000 state shield_discount break
	case 6 ife gametype 0 ife vrtrip 0 set tempd 20000 else set tempd 24000 state shield_discount break
	case 7 case 8 case 9 set tempd 8000 state nova_discount break
	
	case 100 // vanilla pistol
		set tempd 1000
	break
	case 101 // glock18
		set tempd 5000
		ife weap_owned[101] YES shiftr tempd 2
	break
	case 102 // AP rounds
		set tempd 6000
		ife weap_owned[102] YES shiftr tempd 2
	break
	case 103 // dual wield
		set tempd 6000
		ife weap_owned[103] YES shiftr tempd 2
	break
	case 104 // alien pistol
		set tempd 1000
		ife weap_owned[104] YES shiftr tempd 2
	break
	case 105 // alien pistol upgrade
		set tempd 6000
		ife weap_owned[105] YES shiftr tempd 2
	break
	case 106 // doubled pistol ammo
		set tempd 4000
		ife weap_owned[106] YES shiftr tempd 1
	break
	
	case 107 // increased pistol reload speed
		set tempd 5000
	break

	case 110 // vanilla shotty
		set tempd 1000
	break
	case 111 // explosive shells
		set tempd 5000
		ife weap_owned[111] YES shiftr tempd 2
	break
	case 112 // DB shotty
		set tempd 2000
	break
	case 113 // DB shotty + reload
		set tempd 3000
	break
	case 114 // atomic shotty
		set tempd 3000
	break
	case 115 // rad shells
		set tempd 4000
	break
	case 116 // burst fire
		set tempd 5000
	break
	case 120 // vanilla chaingun
		set tempd 1000
	break
	case 121 // minigun
		set tempd 7000
		ife weap_owned[121] YES shiftr tempd 1
	break
	case 122 // AP
		set tempd 6000
		ife weap_owned[122] YES shiftr tempd 2
	break
	case 123 // +max ammo
		set tempd 4000
		ife weap_owned[123] YES shiftr tempd 2
	break
	case 124 // executioner
		set tempd 5000
		ife weap_owned[124] YES shiftr tempd 2
	break
	case 125 // chain gang
		set tempd 2000
		ife weap_owned[125] YES div tempd 2
	break
	case 130 // vanilla RPG
		set tempd 1000
	break
	case 131 // smart RPG
		set tempd 6000
		ife weap_owned[131] YES shiftr tempd 2
	break
	case 132 // fast rox
		set tempd 2000
		ife weap_owned[132] YES shiftr tempd 2
	break
	case 133 // multi rox
		set tempd 4000
		ife weap_owned[133] YES shiftr tempd 2
	break
	case 140 // regular pipebombs
		set tempd 1000
	break
	case 141 // cluster pipebombs
		set tempd 6000
		ife weap_owned[241] YES shiftr tempd 1 else
		ife weap_owned[141] YES shiftr tempd 1
		
	break
	case 142 // smart bomblets
		set tempd 8000
		ife weap_owned[242] YES shiftr tempd 1 else
		ife weap_owned[142] YES shiftr tempd 1
	break
	case 150 // regular shrinker
		set tempd 1000
	break
	case 151 // BMFG
		ife VOLUME 6 ifge LEVEL 12 set tempd 12000 else
		set tempd 8000
		ife weap_owned[151] YES shiftr tempd 2
	break
	case 152 // BMFG altfire
		set tempd 3000
		ife weap_owned[152] YES shiftr tempd 2
	break
	case 153 // plasma rifle double ammo
		set tempd 2000
		ife weap_owned[153] YES shiftr tempd 1
		ife weap_owned[253] YES shiftr tempd 1
	break
	case 154 // babifier
		set tempd 1000
	break
	case 155 // fan service
		set tempd 4000
		ife weap_owned[156] YES set tempd 2000
		ife weap_owned[56] YES set tempd 2000
	break
	case 156 // BFF ray
		set tempd 6000
		ife weap_owned[155] YES set tempd 3000
		ife weap_owned[55] YES set tempd 3000
	break
	case 157 // plasma rifle
		set tempd 1000
	break
	
	case 160 // normal devastator
		set tempd 1000
	break
	case 161 // meteorator
		set tempd 6000
	break
	case 162 // quad barrels
		set tempd 8000
		ife weap_owned[162] YES shiftr tempd 2
	break
	case 170 // railgun
		set tempd 1000
	break
	case 171 // barret
		set tempd 6000
		ife weap_owned[171] YES shiftr tempd 2 else
		ife weap_owned[271] YES shiftr tempd 2
	break
	case 172 // barret semi-auto
		set tempd 9000
		ife weap_owned[172] YES shiftr tempd 2 else
		ife weap_owned[272] YES shiftr tempd 2
	break
	case 180 // laser tripbomb
		set tempd 3000
		ife weap_owned[180] YES shiftr tempd 2
	break
	case 181 // spider bomb
		set tempd 8000
		ife weap_owned[181] YES shiftr tempd 2
	break
	case 182 // spider mobility upgrade
		set tempd 3000
		ife weap_owned[182] YES shiftr tempd 2
	break
	case 183 // DEATHBEAM MINE
		set tempd 3000
		ife weap_owned[183] YES shiftr tempd 2
	break
	case 190 // REGULAR FREEZER
		set tempd 1000
	break
	case 191 // FREEZE BEAM
		set tempd 7000
		ife weap_owned[191] YES shiftr tempd 1
	break
	case 194 // DEFLECT BULLETS
		set tempd 6000
		ife weap_owned[194] YES shiftr tempd 1 else
		ife weap_owned[294] YES shiftr tempd 1
	break

	// BOMBSHELL UPGRADES
	case 200 // regular DE pistol
		set tempd 1000
	break
	case 201 // shelly glock18
		set tempd 5000
		ife weap_owned[1] YES shiftr tempd 2
	break
	case 202 // shelly AP
		set tempd 6000
		ife weap_owned[2] YES shiftr tempd 2
		ife weap_owned[202] YES shiftr tempd 2
	break
	case 203 // shelly dual pistols
		set tempd 6000
		ife weap_owned[3] YES shiftr tempd 2
	break
	case 204 // alien pistol
		set tempd 1000
		ife weap_owned[4] YES shiftr tempd 2
	break
	case 205 // alien pistol upgrade
		set tempd 6000
		ife weap_owned[5] YES shiftr tempd 2
	break
	case 206 // doubled pistol ammo
		set tempd 4000
		ife weap_owned[6] YES shiftr tempd 1 else
		ife weap_owned[206] YES shiftr tempd 1
	break
	
	case 207 // increased pistol reload speed
		set tempd 5000
	break

	case 210 // shelly shotgun
		set tempd 1000
	break
	case 211 // explosive rounds
		set tempd 5000
		ife weap_owned[11] YES shiftr tempd 2
	break
	case 212 // semi-auto shotgun
		set tempd 7000
	break
	case 214 // bow
		set tempd 2000
	break
	case 215 // explosive arrows
		set tempd 4000
		ifvarand shellyupgrades[SHOTGUN_WEAPON] 16 shiftr tempd 1
		ifvarand shellyupgrades[SHOTGUN_WEAPON] 64 shiftr tempd 1
		// 8
	break
	case 216 // multishot arrows
		set tempd 4000
		ifvarand shellyupgrades[SHOTGUN_WEAPON] 8 shiftr tempd 1
		ifvarand shellyupgrades[SHOTGUN_WEAPON] 64 shiftr tempd 1
		// 16
	break
	case 217 // electric arrows
		set tempd 4000
		ifvarand shellyupgrades[SHOTGUN_WEAPON] 8 shiftr tempd 1
		ifvarand shellyupgrades[SHOTGUN_WEAPON] 16 shiftr tempd 1
		// 64
	break
	case 220 // regular M4
		set tempd 1000
	break
	case 221 // double m4
		set tempd 7000
		ife weap_owned[21] YES shiftr tempd 1
	break
	case 222 // AP M4
		set tempd 6000
		ife weap_owned[22] YES shiftr tempd 2
	break
	case 223 // +max ammo M4
		set tempd 4000
		ife weap_owned[23] YES shiftr tempd 2
	break
	case 224 // executioner
		set tempd 5000
		ife weap_owned[24] YES shiftr tempd 2
	break
	case 225 // chain gang
		set tempd 2000
		ife weap_owned[25] YES div tempd 2
	break
	case 230 // vanilla RPG
		set tempd 1000
	break
	
	case 231 // smart RPG
		set tempd 6000
		ife weap_owned[31] YES shiftr tempd 2
	break
	case 232 // fast rox
		set tempd 2000
		ife weap_owned[32] YES shiftr tempd 2
	break
	case 233 // multi rox
		set tempd 4000
		ife weap_owned[33] YES shiftr tempd 2
	break
	
	case 240 // regular turret
		set tempd 6000
	break
	case 241 // missile turret
		set tempd 6000
		ife weap_owned[241] YES shiftr tempd 1 else
		ife weap_owned[41] YES shiftr tempd 1
	break
	case 242 // armored turrets
		set tempd 6000
		ife weap_owned[242] YES shiftr tempd 1 else
		ife weap_owned[42] YES shiftr tempd 1
	break
	case 250 // regular shrinker
		set tempd 1000
	break
	case 251 // BMFG
		ife VOLUME 6 ifge LEVEL 12 set tempd 12000 else
		set tempd 8000
		ife weap_owned[51] YES shiftr tempd 2
	break
	case 252 // BMFG altfire
		set tempd 3000
		ife weap_owned[52] YES shiftr tempd 2
	break
	case 253 // plasma ammo doubled
		set tempd 2000
		ife weap_owned[53] YES shiftr tempd 1
		ife weap_owned[253] YES shiftr tempd 1
	break
	case 254 // babifier
		set tempd 1000
	break
	case 255 // fan service
		set tempd 4000
		ife weap_owned[156] YES set tempd 2000
		ife weap_owned[56] YES set tempd 2000
	break
	case 256 // BFF ray
		set tempd 6000
		ife weap_owned[55] YES set tempd 3000
		ife weap_owned[155] YES set tempd 3000
	break
	case 257 // plasma rifle
		set tempd 1000
	break
	
	case 260 // regular devastator
		set tempd 1000
	break
	case 261 // sticky bombs
		set tempd 5000
	break
	case 262 // quad barrels
		set tempd 8000
		ife weap_owned[62] YES shiftr tempd 2 else
		ife weap_owned[262] YES shiftr tempd 2
	break
	case 270 // regular railgun
		set tempd 1000
	break
	case 271 // barret
		set tempd 6000
		ife weap_owned[71] YES shiftr tempd 2 else
		ife weap_owned[271] YES shiftr tempd 2
	break
	case 272 // barret semi-auto
		set tempd 9000
		ife weap_owned[72] YES shiftr tempd 2 else
		ife weap_owned[272] YES shiftr tempd 2
	break
	case 280 // tripbombs
		set tempd 3000
		ife weap_owned[80] YES shiftr tempd 2 else
		ife weap_owned[280] YES shiftr tempd 2
	break
	case 281 // spider bombs
		set tempd 8000
		ife weap_owned[81] YES shiftr tempd 2 else
		ife weap_owned[281] YES shiftr tempd 2
	break
	case 282 // spider mobility upgrade
		set tempd 3000
		ife weap_owned[82] YES shiftr tempd 2 else
		ife weap_owned[282] YES shiftr tempd 2
	break
	case 283 // DEATHBEAM MINE
		set tempd 3000
		ife weap_owned[83] YES shiftr tempd 2 else
		ife weap_owned[283] YES shiftr tempd 2
	break
	case 290 // INCINERATOR
		set tempd 1000
	break
	case 291 // INCINERATOR UPGRADE
		set tempd 6000
		ife weap_owned[91] YES shiftr tempd 1
	break
	case 294 // DEFLECT BULLETS
		set tempd 6000
		ife weap_owned[94] YES shiftr tempd 1 else
		ife weap_owned[294] YES shiftr tempd 1
	break
	
		// WES UPGRADES
	case 300 // regular DE pistol
		set tempd 1000
	break
	
	case 302 // Wes AP
		set tempd 6000
		ife weap_owned[2] YES shiftr tempd 2 else
		ife weap_owned[102] YES shiftr tempd 2
	break
	
	case 304 // alien pistol
		set tempd 1000
		ife weap_owned[4] YES shiftr tempd 2 else
		ife weap_owned[104] YES shiftr tempd 2
	break
	case 305 // alien pistol upgrade
		set tempd 6000
		ife weap_owned[5] YES shiftr tempd 2 else
		ife weap_owned[105] YES shiftr tempd 2
	break
	case 306 // doubled pistol ammo
		set tempd 4000
		ife weap_owned[6] YES shiftr tempd 1 else
		ife weap_owned[106] YES shiftr tempd 1
	break
	
	case 307 // increased pistol reload speed
		set tempd 5000
	break

	case 310 // wes shotgun
		set tempd 1000
	break

	case 312 // semi-auto shotgun
		set tempd 7000
	break
	case 314 // bow
		set tempd 2000
	break
	case 315 // RADIOACTIVE arrows
		set tempd 4000
		ifvarand wesupgrades[SHOTGUN_WEAPON] 16 shiftr tempd 1
		ifvarand wesupgrades[SHOTGUN_WEAPON] 512 shiftr tempd 1
		// 8
	break
	case 316 // multishot arrows
		set tempd 4000
		ifvarand wesupgrades[SHOTGUN_WEAPON] 8 shiftr tempd 1
		ifvarand wesupgrades[SHOTGUN_WEAPON] 512 shiftr tempd 1
		// 16
	break
	case 317 // ELEMENTAL arrows
		set tempd 4000
		ifvarand wesupgrades[SHOTGUN_WEAPON] 8 shiftr tempd 1
		ifvarand wesupgrades[SHOTGUN_WEAPON] 16 shiftr tempd 1
		// 64
	break
	case 320 // regular uzi
		set tempd 1000
	break
	case 322 // AP uzi
		set tempd 6000
		ife weap_owned[22] YES shiftr tempd 2 else
		ife weap_owned[122] YES shiftr tempd 2
	break
	case 323 // +max ammo uzi
		set tempd 4000
		ife weap_owned[23] YES shiftr tempd 2 else
		ife weap_owned[123] YES shiftr tempd 2
	break
	case 324 // executioner
		set tempd 5000
		ife weap_owned[24] YES shiftr tempd 2 else
		ife weap_owned[124] YES shiftr tempd 2
	break
	case 325 // chain gang
		set tempd 2000
		ife weap_owned[25] YES div tempd 2 else
		ife weap_owned[125] YES div tempd 2
	break
	case 330 // vanilla RPG
		set tempd 1000
	break

	
	case 340 // regular freeze bombs
		set tempd 1000
	break
	case 341 // cluster freeze bombs
		set tempd 6000
		ife weap_owned[141] YES shiftr tempd 1 else
		ife weap_owned[41] YES shiftr tempd 1
		
	break
	case 342 // seeking freeze bombs
		set tempd 8000
		ife weap_owned[142] YES shiftr tempd 1 else
		ife weap_owned[42] YES shiftr tempd 1
	break

	case 351 // bloodzombie
		set tempd 3000
	break
	case 353 // plasma ammo doubled
		set tempd 2000
		ife weap_owned[53] YES shiftr tempd 1 else
		ife weap_owned[153] YES shiftr tempd 1
	break
	
	case 355 // SCAR full auto
		set tempd 3000
	break

	case 357 // plasma rifle
		set tempd 1000
	break
	
	case 360 // regular devastator
		set tempd 1000
	break
	
	case 362 // quad barrels
		set tempd 8000
		ife weap_owned[62] YES shiftr tempd 2 else
		ife weap_owned[162] YES shiftr tempd 2
	break
	case 370 // regular railgun
		set tempd 1000
	break
	case 371 // barret
		set tempd 6000
		ife weap_owned[71] YES shiftr tempd 2 else
		ife weap_owned[171] YES shiftr tempd 2
	break
	case 372 // barret semi-auto
		set tempd 9000
		ife weap_owned[72] YES shiftr tempd 2 else
		ife weap_owned[172] YES shiftr tempd 2
	break
	case 380 // tripbombs
		set tempd 3000
		ife weap_owned[80] YES shiftr tempd 2 else
		ife weap_owned[180] YES shiftr tempd 2
	break
	case 381 // spider bombs
		set tempd 8000
		ife weap_owned[81] YES shiftr tempd 2 else
		ife weap_owned[181] YES shiftr tempd 2
	break
	case 382 // spider mobility upgrade
		set tempd 3000
		ife weap_owned[82] YES shiftr tempd 2 else
		ife weap_owned[182] YES shiftr tempd 2
	break
	
	case 383 // DEATHBEAM MINE
		set tempd 3000
		ife weap_owned[83] YES shiftr tempd 2 else
		ife weap_owned[183] YES shiftr tempd 2
    break
	
	case 390 // BLADE LAUNCHER
		set tempd 1000
	break
	case 391 // BLADE LAUNCHER UPGRADE
		set tempd 6000
	break
	case 394 // DEFLECT BULLETS
		set tempd 6000
		ife weap_owned[94] YES shiftr tempd 1 else
		ife weap_owned[194] YES shiftr tempd 1
	break
	
	case 600 // EMT TRAINING
		set tempd 8000
	break
	
	case 601 // UPGRADED MEDKIT
		set tempd 8000
	break
	
	case 602 // NORMAL GOGGLES
		set tempd 1000
	break
	
	case 603 // AIMBOT GOGGLES
		set tempd 6000
	break
	
	case 604 // COVER CUBE CRUSHER
		set tempd 3000
	break
	
	case 605 // HOLOBAGGER
		set tempd 8000	
	break
	
	case 606 // NORMAL BOOTS
		set tempd 1000
	break
	
	case 607 // DASH BOOTS
		set tempd 5000
	break
	
	case 610 // HEALTH +25
		set tempd healthbuff
		mul tempd 70
	break
	
	case 611 // COIN MAGNET
		set tempd 5000
	break
	
	case 612 // low health regen
		set tempd 5000
	break
	
	case 613 // EDF rescue
		set tempd 15000
	break
	
	case 614 // quicker kicks
		set tempd 6000
	break
	
	case 615 // I-FRAMES+ ; USED TO BE RADAR
		set tempd iframes_max
		add tempd 16
		mul tempd tempd
		mul tempd 8
		add tempd 952
	break
	
	case 616 // no self damage
		set tempd 8000
	break
	
	case 617 // companion sideguns
		set tempd 14000
	break
	
	case 620 // duke perk
		set tempd 4000
	break
	
	case 621 // bombshell perk
		set tempd 8000
	break
	
	case 622 // wes perk
		set tempd 6000
	break
	
	case 623 // auto-revive
		set tempd 4000
	break
	
	default 
		set tempd 0
		// this should only happen if the player has selected a blank area with no item
	break
	
	endswitch
	
	// ife gametype 0 ife myshelly -1 { mul tempd 4 div tempd 5 }

ends

include scripts/weapons_hud.CON


defstate setshieldarrays

// basic weak shield
setarray es_hpmax[1] 50
setarray es_delay[1] 180
setarray es_speed[1] 5

// fast, weak shield
setarray es_hpmax[2] 30
setarray es_delay[2] 100
setarray es_speed[2] 4

// strong, slow shield
setarray es_hpmax[3] 70
setarray es_delay[3] 250
setarray es_speed[3] 4

// SECOND ROW OF SHIELDS MUCH MORE EXPENSIVE AND JUST PLAIN BETTER

setarray es_hpmax[4] 100
setarray es_delay[4] 180
setarray es_speed[4] 3

setarray es_hpmax[5] 70
setarray es_delay[5] 120
setarray es_speed[5] 2

setarray es_hpmax[6] 140
setarray es_delay[6] 240
setarray es_speed[6] 2

// last 3 shields may not be used; last 3 slots on vendor screen for nova mods
setarray es_hpmax[7] 125
setarray es_delay[7] 150
setarray es_speed[7] 2

setarray es_hpmax[8] 70
setarray es_delay[8] 80
setarray es_speed[8] 1

setarray es_hpmax[9] 220
setarray es_delay[9] 240
setarray es_speed[9] 1

ends

defstate clearshock
	set startshocktime -1
	setarray shockchain[0] -1
	setarray shockchain[1] -1
	setarray shockchain[2] -1
	setarray shockchain[3] -1
	setarray shockchain[4] -1
	ifactorsound THISACTOR ELECTRICLOOP stopactorsound THISACTOR ELECTRICLOOP
ends

defstate sawon
	set WEAPON0_FIREDELAY 2
	set WEAPON0_SHOOTS SAWPROJ
	set WEAPON0_FLAGS 268
	set WEAPON0_TOTALTIME 8
	set gotsaw YES
ends

defstate sawoff
	set WEAPON0_FIREDELAY 7
	set WEAPON0_SHOOTS KNEE
	set WEAPON0_FLAGS 292
	set WEAPON0_TOTALTIME 14
	set gotsaw NO
ends

defstate setplasmagun

	set WEAPON9_SHOOTS PLAYERPLASMA
	set WEAPON9_FIRESOUND TERMLASER
	set WEAPON9_INITIALSOUND -1
	set WEAPON9_SHOTSPERBURST 0
	set WEAPON9_TOTALTIME 4
	set WEAPON9_FIREDELAY 2
	set WEAPON9_FLAGS 0
	set WEAPON9_FLASHCOLOR 16711780
	
ends

defstate switchrailgun
	
	ifvarand gotrailgun 2 // just put railgun in top position
	{
		set WEAPON7_FIREDELAY 2
		set WEAPON7_TOTALTIME 18
		set WEAPON7_HOLDDELAY 3
		set WEAPON7_FLAGS 0
		set WEAPON7_SHOOTS RAILPROJ
		set WEAPON7_FIRESOUND RIFLEFIRE
		set WEAPON7_SHOTSPERBURST 0
		set WEAPON7_INITIALSOUND RIFLEREADY
		set WEAPON7_SELECTSOUND RIFLEREADY
		set WEAPON7_SPAWN 0
		set WEAPON7_SOUND2SOUND 0
		
		set temp NO
		ife pchar 0 ifvarand dukeupgrades[DEVISTATOR_WEAPON] 4 set temp YES
		ife pchar 1 ifvarand shellyupgrades[DEVISTATOR_WEAPON] 4 set temp YES
		ife pchar 2 ifvarand wesupgrades[DEVISTATOR_WEAPON] 4 set temp YES
		ife temp YES
		{
			set WEAPON7_SPAWN SHELL
			set WEAPON7_SPAWNTIME 4
			set WEAPON7_FIRESOUND BARRETFIRE
			set WEAPON7_TOTALTIME 30
			set WEAPON7_SOUND2SOUND BARRETBOLT
			set WEAPON7_SOUND2TIME 12
			set WEAPON7_SHOOTS BARRETPROJ
			set WEAPON7_FLAGS 16384
			set WEAPON7_INITIALSOUND SELBARRET
			set WEAPON7_SELECTSOUND SELBARRET
		}
	}
	else // just put railgun in bottom position
	{
		set WEAPON7_FIREDELAY 3
		set WEAPON7_TOTALTIME 6
		set WEAPON7_HOLDDELAY 5
		set WEAPON7_FLAGS 72
		set WEAPON7_SHOOTS RPG
		set WEAPON7_FIRESOUND DUKEDEV
		ife pchar 0 ifvarand dukeupgrades[DEVISTATOR_WEAPON] 2 set WEAPON7_SHOTSPERBURST 4 else
		ife pchar 2 { ifvarand wesupgrades[DEVISTATOR_WEAPON] 2 set WEAPON7_SHOTSPERBURST 10 else set WEAPON7_SHOTSPERBURST 5 } else
		set WEAPON7_SHOTSPERBURST 2
		set WEAPON7_INITIALSOUND -1 // CAT_FIRE
		set WEAPON7_SELECTSOUND SELECT7
		set WEAPON7_SOUND2SOUND 0
		ife pchar 1
		{
			set WEAPON7_FIRESOUND GRENADE_SHOOT
			set WEAPON7_INITIALSOUND -1
			ifvarand shellyupgrades[DEVISTATOR_WEAPON] 2 set WEAPON7_SHOTSPERBURST 2 else
			set WEAPON7_SHOTSPERBURST 0
			set WEAPON7_SHOOTS GRENADEPROJ
			set WEAPON7_TOTALTIME 12
			set WEAPON7_FLAGS 0
			
			ifvarand shellyupgrades[DEVISTATOR_WEAPON] 1
			{
				set WEAPON7_SHOOTS STICKYPROJ
				set WEAPON7_SHOTSPERBURST 3
				set WEAPON7_FLAGS 72
			}
		}
		ife pchar 2
		{
			set WEAPON7_FIRESOUND NEWSHOTFIRE
			set WEAPON7_INITIALSOUND -1
			
			ifvarand wesupgrades[DEVISTATOR_WEAPON] 2 set WEAPON7_SHOTSPERBURST 10 else
			set WEAPON7_SHOTSPERBURST 5
			set WEAPON7_SHOOTS EXPBULLET
			set WEAPON7_TOTALTIME 6
			set WEAPON7_FLAGS 0
		}
	}
ends

defstate shellyweapons

	set WEAPON1_FLAGS 32768
	set WEAPON1_RELOAD 34
	set WEAPON1_TOTALTIME 9
	set WEAPON1_SHOOTS DEAGLEBULLET
	set WEAPON1_SPAWN SHELL
	set WEAPON1_FIRESOUND DEAGLE_FIRE
	set WEAPON1_RELOADSOUND1 DEAGLE_CLIPOUT
	set WEAPON1_RELOADSOUND2 DEAGLE_CLIPIN
	ife LASERMODE 3 set WEAPON1_SELECTSOUND SELECT7 else
	ife LASERMODE YES set WEAPON1_SELECTSOUND SWITCHTOLASER else
	set WEAPON1_SELECTSOUND DEAGLE_SLIDE
	set WEAPON1_SHOTSPERBURST 0
	set PISTOLCLIP 12
	
	ifvarand shellyupgrades[KNEE_WEAPON] 1 // deflect bullets
	{
		setarray weap_owned[294] YES
		setarray weap_owned[194] YES
		setarray weap_owned[94] YES
		set tempb dukeupgrades[KNEE_WEAPON]
		orvar tempb 1
		setarray dukeupgrades[KNEE_WEAPON] tempb
		set tempb wesupgrades[KNEE_WEAPON]
		orvar tempb 1
		setarray wesupgrades[KNEE_WEAPON] tempb
		
	}
	
	ifvarand shellyupgrades[PISTOL_WEAPON] 16 // alien pistol upgrade
	{
		setarray weap_owned[5] YES
		set tempb dukeupgrades[PISTOL_WEAPON]
		orvar tempb 16
		setarray dukeupgrades[PISTOL_WEAPON] tempb
		set tempb wesupgrades[PISTOL_WEAPON]
		orvar tempb 16
		setarray wesupgrades[PISTOL_WEAPON] tempb
		setarray weap_owned[105] YES
		setarray weap_owned[205] YES
	}
	
	ifvarand shellyupgrades[PISTOL_WEAPON] 32 // +max ammo
	{
		setarray weap_owned[6] YES
		set tempb dukeupgrades[PISTOL_WEAPON]
		orvar tempb 32
		setarray dukeupgrades[PISTOL_WEAPON] tempb
		setarray weap_owned[106] YES
		
		set tempb wesupgrades[PISTOL_WEAPON]
		orvar tempb 32
		setarray wesupgrades[PISTOL_WEAPON] tempb
		setarray weap_owned[206] YES
		smaxammo PISTOL_WEAPON 400
	}
	
	
	ifvarand shellyupgrades[PISTOL_WEAPON] 8 // glock18
	{
		setarray weap_owned[101] YES
		set WEAPON1_SHOOTS SHOTSPARK1
		set PISTOLCLIP 33
		set WEAPON1_RELOAD 30
		set WEAPON1_FIRESOUND GLOCKFIRE
		set WEAPON1_FLAGS 98380
		
		ifvarand shellyupgrades[PISTOL_WEAPON] 4 // dual
		{
			setarray weap_owned[103] YES
			set WEAPON1_RELOAD 56
			set WEAPON1_SHOTSPERBURST 2
			set WEAPON1_TOTALTIME 6 
			orvar WEAPON1_FLAGS 64
			set PISTOLCLIP 40
		}
		else
		set WEAPON1_TOTALTIME 4
		
		set WEAPON1_RELOADSOUND1 GLOCKMAGOUT
		set WEAPON1_RELOADSOUND2 GLOCKMAGIN
		set WEAPON1_SELECTSOUND GLOCKMAGIN
	}
	else
	ifvarand shellyupgrades[PISTOL_WEAPON] 4
	{
		setarray weap_owned[103] YES
		set WEAPON1_RELOAD 58
	}
	ifvarand shellyupgrades[PISTOL_WEAPON] 1
		setarray weap_owned[102] YES
	
	set WEAPON2_RELOAD 12
	set WEAPON2_FIREDELAY 3
	set WEAPON2_TOTALTIME 24
	set WEAPON2_CLIP 0
	set WEAPON2_SHOOTS SHOTSPARK1
	set WEAPON2_SHOTSPERBURST 7
	set WEAPON2_SOUND2SOUND FASTCOCK
	set WEAPON2_SOUND2TIME 12
	set WEAPON2_SPAWNTIME 18
	set WEAPON2_FLAGS 1024
	set WEAPON2_SPAWN SHOTGUNSHELL
	set WEAPON2_FIRESOUND T2SHOTTY // SHOTGUN_FIRE
	set WEAPON2_SELECTSOUND FASTCOCK
	
	ifvarand shellyupgrades[SHOTGUN_WEAPON] 1 // explosive rounds
	{
		setarray weap_owned[111] YES
		setarray weap_owned[11] YES
		set tempb dukeupgrades[SHOTGUN_WEAPON]
		orvar tempb 1
		setarray dukeupgrades[SHOTGUN_WEAPON] tempb
	}
		
	ifvarand shellyupgrades[SHOTGUN_WEAPON] 4 // has bow
	ifvarand gotbow 2
	{
		setarray weap_owned[114] YES
		set WEAPON2_FIREDELAY 16
		set WEAPON2_FLAGS 256
		set WEAPON2_SHOOTS ARROWPROJ
		ife arrowtype 3 set WEAPON2_SHOTSPERBURST 3 else
		set WEAPON2_SHOTSPERBURST 1
		set WEAPON2_TOTALTIME 20
		set WEAPON2_RELOAD 0
		set WEAPON2_SPAWN 0
		set WEAPON2_SOUND2SOUND -1
		set WEAPON2_SOUND2TIME 0
		set WEAPON2_FIRESOUND -1
		set WEAPON2_SELECTSOUND SELECTBOW
	}
	else
	ifvarand shellyupgrades[SHOTGUN_WEAPON] 128 // semi-auto
	{
		set WEAPON2_TOTALTIME 11
		set WEAPON2_CLIP 999 // 8
		set WEAPON2_RELOAD 40
		
		set WEAPON2_RELOADSOUND1 FASTCOCK
		set WEAPON2_RELOADSOUND2 GLOCKMAGIN
		
		set temp wesupgrades[SHOTGUN_WEAPON]
		orvar temp 128
		setarray wesupgrades[SHOTGUN_WEAPON] temp
		setarray weap_owned[112] YES
		setarray weap_owned[212] YES
	}

	ifvarand shellyupgrades[SHOTGUN_WEAPON] 8 // explosive arrows
		setarray weap_owned[115] YES
	ifvarand shellyupgrades[SHOTGUN_WEAPON] 16 // multishot arrows
		setarray weap_owned[116] YES
	ifvarand shellyupgrades[SHOTGUN_WEAPON] 64 // electric arrows
		setarray weap_owned[117] YES
		
	ifvarand shellyupgrades[CHAINGUN_WEAPON] 8 orvar gotshock 1 else
	{
		ifvarand gotshock 2 xorvar gotshock 2
		ifvarand gotshock 1 xorvar gotshock 1
	}
	
	ifvarand shellyupgrades[CHAINGUN_WEAPON] 16 // chain gang
	{
		setarray weap_owned[225] YES
		setarray weap_owned[125] YES
		setarray weap_owned[25] YES
		set tempb dukeupgrades[CHAINGUN_WEAPON]
		orvar tempb 16
		setarray dukeupgrades[CHAINGUN_WEAPON] tempb
		set tempb wesupgrades[CHAINGUN_WEAPON]
		orvar tempb 16
		setarray wesupgrades[CHAINGUN_WEAPON] tempb
	}
	ifvarand shellyupgrades[CHAINGUN_WEAPON] 8 // EXECUTIONER
	ifvarand gotshock 2
	{
		setarray weap_owned[124] YES
		set WEAPON3_SHOOTS SHOCKBEAM
		set WEAPON3_FIRESOUND LIGHTNINGFIRE
		set WEAPON3_FLAGS 0
		set WEAPON3_TOTALTIME 14
		set WEAPON3_FLASHCOLOR 16744576 
		set WEAPON3_CLIP 0
		set WEAPON3_RELOAD 0
		set WEAPON3_SPAWN 0
		set WEAPON3_SPAWNTIME 0
		set WEAPON3_SELECTSOUND SWITCHTOLASER
	}
	else
	ifvarand shellyupgrades[CHAINGUN_WEAPON] 1
	{
		setarray weap_owned[121] YES
		set WEAPON3_CLIP 30
		set WEAPON3_SHOOTS CHAINGUN
		set WEAPON3_FIRESOUND SHELLYFIRE
		set WEAPON3_RELOAD 60
		set WEAPON3_SELECTSOUND M4READY
		set WEAPON3_SHOTSPERBURST 2
		set WEAPON3_FLAGS 73812
		set WEAPON3_SPAWN SHELL
		set WEAPON3_SPAWNTIME 1
	}
	else
	{
		set WEAPON3_CLIP 30
		set WEAPON3_SHOOTS SHOTGUN
		set WEAPON3_FIRESOUND SHELLYFIRE
		set WEAPON3_RELOAD 60
		set WEAPON3_SELECTSOUND M4READY
		set WEAPON3_SHOTSPERBURST 0
		set WEAPON3_FLAGS 73812
		set WEAPON3_SPAWN SHELL
		set WEAPON3_SPAWNTIME 1
	}
	ifvarand shellyupgrades[CHAINGUN_WEAPON] 2 // AP
	{
		setarray weap_owned[222] YES
		setarray weap_owned[122] YES
		setarray weap_owned[22] YES
		set tempb dukeupgrades[CHAINGUN_WEAPON]
		orvar tempb 2
		setarray dukeupgrades[CHAINGUN_WEAPON] tempb
		set tempb wesupgrades[CHAINGUN_WEAPON]
		orvar tempb 2
		setarray wesupgrades[CHAINGUN_WEAPON] tempb
	}

	ifvarand shellyupgrades[CHAINGUN_WEAPON] 4 // +max ammo
	{
		setarray weap_owned[23] YES
		set tempb dukeupgrades[CHAINGUN_WEAPON]
		orvar tempb 4
		setarray dukeupgrades[CHAINGUN_WEAPON] tempb
		set tempb wesupgrades[CHAINGUN_WEAPON]
		orvar tempb 4
		setarray wesupgrades[CHAINGUN_WEAPON] tempb
		setarray weap_owned[123] YES
		setarray weap_owned[223] YES
		smaxammo CHAINGUN_WEAPON 400
	}
	
	ifvarand shellyupgrades[RPG_WEAPON] 1
		setarray weap_owned[131] YES
	ifvarand shellyupgrades[RPG_WEAPON] 2
	{
		setarray weap_owned[132] YES
		setarray weap_owned[32] YES
		set tempb dukeupgrades[RPG_WEAPON]
		orvar tempb 2
		setarray dukeupgrades[RPG_WEAPON] tempb
	}
	ifvarand shellyupgrades[RPG_WEAPON] 4
	{
		setarray weap_owned[133] YES
		setarray weap_owned[33] YES
		set tempb dukeupgrades[RPG_WEAPON]
		orvar tempb 4
		setarray dukeupgrades[RPG_WEAPON] tempb
	}
	ife nukeselect YES
	{
		set WEAPON4_FIRESOUND RPG_BIGSHOOT
		set WEAPON4_TOTALTIME 30
		set WEAPON4_FIREDELAY 5
	}
	else
	{	
		ifvarand shellyupgrades[RPG_WEAPON] 1 
		{
			set WEAPON4_FIRESOUND ROCKETFIRE2 
			set WEAPON4_TOTALTIME 20
		}
		else
		{
			set WEAPON4_FIRESOUND RPG_SHOOT
			set WEAPON4_TOTALTIME 30
		}
		set WEAPON4_FIREDELAY 4
	}
	
	ifvarand shellyupgrades[HANDBOMB_WEAPON] 1
		setarray weap_owned[141] YES
	set PIPEBOMB_CONTROL 2
	set GRENADE_LIFETIME 60
	
	ifvarand dukeupgrades[SHRINKER_WEAPON] 1
	{
		set tempb shellyupgrades[SHRINKER_WEAPON]
		orvar tempb 1
		ifvarand dukeupgrades[SHRINKER_WEAPON] 2 { orvar tempb 2 setarray weap_owned[152] YES }
		setarray shellyupgrades[SHRINKER_WEAPON] tempb
	}
	
	set WEAPON6_FLASHCOLOR 8454016
	set WEAPON6_SELECTSOUND SWITCHTOLASER
	set WEAPON6_FLAGS 2
	set WEAPON6_INITIALSOUND SHRINKER_FIRE
	smaxammo SHRINKER_WEAPON 50
	ifvarand shellyupgrades[SHRINKER_WEAPON] 1
	{
		setarray weap_owned[151] YES
		set WEAPON6_SHOOTS BMFGPROJ
		set WEAPON6_FIRESOUND -1
		set WEAPON6_FIREDELAY 30 // 14
		set WEAPON6_TOTALTIME 40 // 24
	}
	else
	{
		set WEAPON6_SHOOTS SHRINKER
		set WEAPON6_FIRESOUND 0
		set WEAPON6_FIREDELAY 10
		set WEAPON6_TOTALTIME 12
	}

	
	state switchrailgun
	
	
	ifvarand shellyupgrades[DEVISTATOR_WEAPON] 1
		setarray weap_owned[161] YES
		
		
	ifvarand shellyupgrades[DEVISTATOR_WEAPON] 2
	{
		setarray weap_owned[62] YES
		setarray weap_owned[162] YES
		setarray weap_owned[262] YES
		set tempb dukeupgrades[DEVISTATOR_WEAPON]
		orvar tempb 2
		setarray dukeupgrades[DEVISTATOR_WEAPON] tempb
		set tempb wesupgrades[DEVISTATOR_WEAPON]
		orvar tempb 2
		setarray wesupgrades[DEVISTATOR_WEAPON] tempb
	}	
		
	ifvarand shellyupgrades[DEVISTATOR_WEAPON] 4
		setarray weap_owned[171] YES
	
	ifvarand shellyupgrades[TRIPBOMB_WEAPON] 1
	{
		setarray weap_owned[181] YES
		set WEAPON8_FLAGS 16640
		set WEAPON8_SHOOTS SPIDERMINEFALLING
	}
	else
	{
		setarray weap_owned[180] YES
		set WEAPON8_WORKSLIKE 8
		set WEAPON8_FLAGS 3072
		set WEAPON8_SHOOTS HANDHOLDINGLASER
	}
	
	ifvarand shellyupgrades[TRIPBOMB_WEAPON] 2 // SPIDER MOBILITY
	{
		setarray weap_owned[282] YES
		setarray weap_owned[182] YES
		setarray weap_owned[82] YES
		set tempb dukeupgrades[TRIPBOMB_WEAPON]
		orvar tempb 2
		setarray dukeupgrades[TRIPBOMB_WEAPON] tempb
		set tempb wesupgrades[TRIPBOMB_WEAPON]
		orvar tempb 2
		setarray wesupgrades[TRIPBOMB_WEAPON] tempb
	}
	
	ifvarand shellyupgrades[TRIPBOMB_WEAPON] 4 // DEATHBEAM
	{
		setarray weap_owned[83] YES
		setarray weap_owned[183] YES
		set tempb dukeupgrades[TRIPBOMB_WEAPON]
		orvar tempb 4
		setarray dukeupgrades[TRIPBOMB_WEAPON] tempb
	}
	
	ife weap_owned[53] YES setarray weap_owned[153] YES
	ife weap_owned[153] YES
	{
		set tempb shellyupgrades[FREEZE_WEAPON]
		orvar tempb 2
		setarray shellyupgrades[FREEZE_WEAPON] tempb
	}
	
	ifvarand gotplasma 2 state setplasmagun
	else
	ifvarand shellyupgrades[FREEZE_WEAPON] 1
	{
		setarray weap_owned[191] YES
		set WEAPON9_SHOOTS FIREBEAM
		set WEAPON9_FIRESOUND -1 // FLAMER_SHOOT
		set WEAPON9_INITIALSOUND -1
		set WEAPON9_SHOTSPERBURST 0
		set WEAPON9_TOTALTIME 5
		set WEAPON9_FIREDELAY 3
		set WEAPON9_FLAGS 65536
		set WEAPON9_FLASHCOLOR 255
	}
	else
	{
		setarray weap_owned[190] YES
		set WEAPON9_SHOOTS FIREBOLT
		set WEAPON9_FIRESOUND FLAMER_SHOOT
		set WEAPON9_INITIALSOUND -1
		set WEAPON9_SHOTSPERBURST 3
		set WEAPON9_TOTALTIME 5
		set WEAPON9_FIREDELAY 3
		set WEAPON9_FLAGS 65536
		set WEAPON9_FLASHCOLOR 16744576
	}

	set WEAPON11_FIREDELAY 3
	set WEAPON11_CLIP 0
	set WEAPON11_SHOOTS GROWSPARK 
	set	WEAPON11_SHOTSPERBURST 0
	set WEAPON11_FIRESOUND BAB_IMPACT 
	set WEAPON11_SELECTSOUND SWITCHTOLASER
	set WEAPON11_FLAGS 2
	set WEAPON11_TOTALTIME 5
	set WEAPON11_FLASHCOLOR 24575 
	smaxammo GROW_WEAPON 99
	
	ifvarand shellyupgrades[GROW_WEAPON] 1
	{
		setarray weap_owned[55] YES
		setarray weap_owned[155] YES
		set tempb dukeupgrades[GROW_WEAPON]
		orvar tempb 1
		setarray dukeupgrades[GROW_WEAPON] tempb
	}
	ifvarand shellyupgrades[GROW_WEAPON] 2
	{
		setarray weap_owned[56] YES
		setarray weap_owned[156] YES
		set tempb dukeupgrades[GROW_WEAPON]
		orvar tempb 2
		setarray dukeupgrades[GROW_WEAPON] tempb
	}

ends

defstate wesweapons

	set WEAPON1_FLAGS 32768
	set WEAPON1_RELOAD 34
	set WEAPON1_SPAWN -1
	set WEAPON1_TOTALTIME 8
	set WEAPON1_SHOOTS WESBULLET
	set WEAPON1_FIRESOUND REVOLVER_FIRE
	set WEAPON1_RELOADSOUND1 DUMPCYLINDER
	set WEAPON1_RELOADSOUND2 GLOCKMAGIN
	ife LASERMODE 3 set WEAPON1_SELECTSOUND SELECT7 else
	ife LASERMODE YES set WEAPON1_SELECTSOUND SWITCHTOLASER else
	set WEAPON1_SELECTSOUND GLOCKMAGIN
	set WEAPON1_SHOTSPERBURST 0
	set PISTOLCLIP 8
	ifg THISCLIP PISTOLCLIP set THISCLIP PISTOLCLIP
	

	ifvarand wesupgrades[KNEE_WEAPON] 1 // deflect bullets
	{
		setarray weap_owned[294] YES
		setarray weap_owned[194] YES
		setarray weap_owned[94] YES
		set tempb dukeupgrades[KNEE_WEAPON]
		orvar tempb 1
		setarray dukeupgrades[KNEE_WEAPON] tempb
		set tempb shellyupgrades[KNEE_WEAPON]
		orvar tempb 1
		setarray shellyupgrades[KNEE_WEAPON] tempb
	}
	
	ifvarand wesupgrades[PISTOL_WEAPON] 16 // alien pistol upgrade
	{
		setarray weap_owned[205] YES
		set tempb shellyupgrades[PISTOL_WEAPON]
		orvar tempb 16
		setarray shellyupgrades[PISTOL_WEAPON] tempb
		set tempb dukeupgrades[PISTOL_WEAPON]
		orvar tempb 16
		setarray dukeupgrades[PISTOL_WEAPON] tempb
		setarray weap_owned[5] YES
		setarray weap_owned[105] YES
	}
	
	ifvarand wesupgrades[PISTOL_WEAPON] 32 // +max ammo
	{
		setarray weap_owned[206] YES
		set tempb dukeupgrades[PISTOL_WEAPON]
		orvar tempb 32
		setarray dukeupgrades[PISTOL_WEAPON] tempb
		setarray weap_owned[6] YES
		setarray weap_owned[106] YES
		smaxammo PISTOL_WEAPON 400
	}

	ifvarand wesupgrades[PISTOL_WEAPON] 4 // dual
	{
		setarray weap_owned[203] YES
		set WEAPON1_TOTALTIME 9
	}
	ifvarand wesupgrades[PISTOL_WEAPON] 1 // AP
	setarray weap_owned[202] YES
	
	ifvarand wesupgrades[SHOTGUN_WEAPON] 4 // has bow
	ifvarand gotbow 2
	{
		setarray weap_owned[114] YES
		set WEAPON2_FIREDELAY 16
		set WEAPON2_FLAGS 256
		set WEAPON2_SHOOTS ARROWPROJ
		ife arrowtype 3 set WEAPON2_SHOTSPERBURST 3 else
		set WEAPON2_SHOTSPERBURST 1
		set WEAPON2_TOTALTIME 20
		set WEAPON2_RELOAD 0
		set WEAPON2_SPAWN 0
		set WEAPON2_SOUND2SOUND -1
		set WEAPON2_SOUND2TIME 0
		set WEAPON2_FIRESOUND -1
		set WEAPON2_SELECTSOUND SELECTBOW
	}
	else
	{
		set WEAPON2_RELOAD 12
		set WEAPON2_FIREDELAY 3
		set WEAPON2_TOTALTIME 26
		set WEAPON2_CLIP 0
		set WEAPON2_SHOOTS SHOTSPARK1
		set WEAPON2_SHOTSPERBURST 8
		set WEAPON2_SOUND2SOUND NEWSHOTCOCK
		set WEAPON2_SOUND2TIME 12
		set WEAPON2_SPAWNTIME 18
		set WEAPON2_FLAGS 1024
		set WEAPON2_SPAWN SHOTGUNSHELL
		set WEAPON2_FIRESOUND WES_SHOTTY
		set WEAPON2_SELECTSOUND NEWSHOTCOCK
		
		ifvarand wesupgrades[SHOTGUN_WEAPON] 128 // semi-auto
		{
			set WEAPON2_TOTALTIME 11
			set WEAPON2_CLIP 999 // 8
			set WEAPON2_RELOAD 40
			
			set WEAPON2_RELOADSOUND1 FASTCOCK
			set WEAPON2_RELOADSOUND2 GLOCKMAGIN
			
			set tempb shellyupgrades[SHOTGUN_WEAPON]
			orvar tempb 128
			setarray shellyupgrades[SHOTGUN_WEAPON] tempb
			setarray weap_owned[112] YES
			setarray weap_owned[212] YES
		}
	}
	
	
	ifvarand wesupgrades[SHOTGUN_WEAPON] 1 // explosive
	{
		setarray weap_owned[11] YES
		setarray weap_owned[111] YES
		set tempb shellyupgrades[SHOTGUN_WEAPON]
		orvar tempb 1
		setarray shellyupgrades[SHOTGUN_WEAPON] tempb
	}
	
	
	set WEAPON3_SHOTSPERBURST 0
	
	ifvarand wesupgrades[CHAINGUN_WEAPON] 8 orvar gotshock 1 else
	{
		ifvarand gotshock 2 xorvar gotshock 2
		ifvarand gotshock 1 xorvar gotshock 1
	}
	ifvarand wesupgrades[CHAINGUN_WEAPON] 16 // chain gang
	{
		setarray weap_owned[125] YES
		setarray weap_owned[25] YES
		set tempb shellyupgrades[CHAINGUN_WEAPON]
		orvar tempb 16
		setarray shellyupgrades[CHAINGUN_WEAPON] tempb
		set tempb dukeupgrades[CHAINGUN_WEAPON]
		orvar tempb 16
		setarray dukeupgrades[CHAINGUN_WEAPON] tempb
	}
	ifvarand wesupgrades[CHAINGUN_WEAPON] 8 // EXECUTIONER
	ifvarand gotshock 2
	{
		setarray weap_owned[24] YES
		setarray weap_owned[124] YES
		setarray weap_owned[224] YES
		set WEAPON3_SHOOTS SHOCKBEAM
		set WEAPON3_FIRESOUND LIGHTNINGFIRE
		set WEAPON3_FLAGS 0
		set WEAPON3_TOTALTIME 14
		set WEAPON3_FLASHCOLOR 16744576 
		set WEAPON3_CLIP 0
		set WEAPON3_RELOAD 0
		set WEAPON3_SPAWN 0
		set WEAPON3_SPAWNTIME 0
		set WEAPON3_SELECTSOUND SWITCHTOLASER
		
	}
	else
	{
		
		set WEAPON3_CLIP 32
		set WEAPON3_SHOOTS CHAINGUN
		set WEAPON3_FIRESOUND SHELLYFIRE
		set WEAPON3_RELOAD 45
		set WEAPON3_SELECTSOUND M4READY
		set WEAPON3_SHOTSPERBURST 0
		set WEAPON3_FLAGS 73812
		set WEAPON3_SPAWN SHELL
		set WEAPON3_SPAWNTIME 1
		ifvarand wesupgrades[CHAINGUN_WEAPON] 1 // dual wielding
		set WEAPON3_SHOTSPERBURST 2
	}
	
	ifvarand wesupgrades[CHAINGUN_WEAPON] 2 // AP rounds
	{
		setarray weap_owned[22] YES
		setarray weap_owned[122] YES
		set tempb shellyupgrades[CHAINGUN_WEAPON]
		orvar tempb 2
		setarray shellyupgrades[CHAINGUN_WEAPON] tempb
		set tempb dukeupgrades[CHAINGUN_WEAPON]
		orvar tempb 2
		setarray dukeupgrades[CHAINGUN_WEAPON] tempb
		
	}
	
	ifvarand wesupgrades[CHAINGUN_WEAPON] 4 // +max ammo
	{
		setarray weap_owned[123] YES
		set tempb shellyupgrades[CHAINGUN_WEAPON]
		orvar tempb 4
		setarray shellyupgrades[CHAINGUN_WEAPON] tempb
		setarray weap_owned[23] YES
		smaxammo CHAINGUN_WEAPON 400
	}
	
	ife nukeselect YES
	{
		set WEAPON4_FIRESOUND RPG_BIGSHOOT
		set WEAPON4_TOTALTIME 30
		set WEAPON4_FIREDELAY 5
	}
	else
	{
		set WEAPON4_FIRESOUND RPG_BIGSHOOT
		set WEAPON4_TOTALTIME 50
		set WEAPON4_SOUND2TIME 25
		set WEAPON4_SOUND2SOUND RPGPICK
		set WEAPON4_FIREDELAY 4
	}
	set PIPEBOMB_CONTROL 2
	set GRENADE_LIFETIME 60
	
	ifvarand dukeupgrades[HANDBOMB_WEAPON] 1
	{
		set tempb wesupgrades[HANDBOMB_WEAPON]
		orvar tempb 1
		setarray wesupgrades[HANDBOMB_WEAPON] tempb
	}
	ifvarand dukeupgrades[HANDBOMB_WEAPON] 2
	{
		set tempb wesupgrades[HANDBOMB_WEAPON]
		orvar tempb 2
		setarray wesupgrades[HANDBOMB_WEAPON] tempb
	}
	ifvarand wesupgrades[HANDBOMB_WEAPON] 1
		setarray weap_owned[241] YES
		
	ifvarand wesupgrades[HANDBOMB_WEAPON] 2
		setarray weap_owned[242] YES
		
	set WEAPON6_INITIALSOUND 0
	set WEAPON6_FIREDELAY 2
	set WEAPON6_SHOOTS BLOODBULLET 
	set WEAPON6_FIRESOUND RPG_SPLIT 
	set WEAPON6_SELECTSOUND GLOCKMAGIN
	set WEAPON6_CLIP 99999
	set WEAPON6_RELOAD 50
	set WEAPON6_RELOADSOUND1 SKARCLIPOUT
	set WEAPON6_RELOADSOUND2 SKARCLIPIN
	set WEAPON6_FLAGS 16384
	set WEAPON6_TOTALTIME 4
	set WEAPON6_FLASHCOLOR 24575
	smaxammo SHRINKER_WEAPON 200
	
	ifvarand wesupgrades[DEVISTATOR_WEAPON] 1
		setarray weap_owned[61] YES
		
	
		
	ifvarand wesupgrades[DEVISTATOR_WEAPON] 2
	{
		setarray weap_owned[62] YES
		setarray weap_owned[162] YES
		set tempb shellyupgrades[DEVISTATOR_WEAPON]
		orvar tempb 2
		setarray shellyupgrades[DEVISTATOR_WEAPON] tempb
		
		set tempb dukeupgrades[DEVISTATOR_WEAPON]
		orvar tempb 2
		setarray dukeupgrades[DEVISTATOR_WEAPON] tempb
	}
	
	ifvarand wesupgrades[DEVISTATOR_WEAPON] 4 // barret upgrade
		setarray weap_owned[271] YES
	

	state switchrailgun
	
	ifvarand wesupgrades[TRIPBOMB_WEAPON] 1
	{
		setarray weap_owned[281] YES
		set WEAPON8_FLAGS 16640
		set WEAPON8_SHOOTS SPIDERMINEFALLING
	}
	else
	{
		setarray weap_owned[280] YES
		set WEAPON8_WORKSLIKE 8
		set WEAPON8_FLAGS 3072
		set WEAPON8_SHOOTS HANDHOLDINGLASER
	}
	
	ifvarand wesupgrades[TRIPBOMB_WEAPON] 2 // SPIDER MOBILITY
	{
		setarray weap_owned[282] YES
		setarray weap_owned[182] YES
		setarray weap_owned[82] YES
		set tempb shellyupgrades[TRIPBOMB_WEAPON]
		orvar tempb 2
		setarray shellyupgrades[TRIPBOMB_WEAPON] tempb
		set tempb dukeupgrades[TRIPBOMB_WEAPON]
		orvar tempb 2
		setarray dukeupgrades[TRIPBOMB_WEAPON] tempb
	}
		
	ifvarand dukeupgrades[TRIPBOMB_WEAPON] 4 // DEATHBEAM
	{
		setarray weap_owned[83] YES
		setarray weap_owned[183] YES
		setarray weap_owned[283] YES
		set tempb shellyupgrades[TRIPBOMB_WEAPON]
		orvar tempb 4
		setarray shellyupgrades[TRIPBOMB_WEAPON] tempb
		set tempb dukeupgrades[TRIPBOMB_WEAPON]
		orvar tempb 4
		setarray dukeupgrades[TRIPBOMB_WEAPON] tempb
	}
	
	ife weap_owned[153] YES setarray weap_owned[53] YES
	ife weap_owned[53] YES
	{
		set tempb wesupgrades[FREEZE_WEAPON]
		orvar tempb 2
		setarray wesupgrades[FREEZE_WEAPON] tempb
	}
	
	ifvarand gotplasma 2 state setplasmagun
	else
	{
		set WEAPON9_SHOOTS BLADEPROJ
		set WEAPON9_INITIALSOUND -1
		set WEAPON9_FIRESOUND BLADE_FIRE
		set WEAPON9_SHOTSPERBURST 0
		ifvarand wesupgrades[FREEZE_WEAPON] 1 set WEAPON9_TOTALTIME 8
		else
		set WEAPON9_TOTALTIME 12
		set WEAPON9_FIREDELAY 3
		set WEAPON9_FLAGS 256
		set WEAPON9_FLASHCOLOR 0
	}

	set WEAPON11_FIREDELAY 2
	set WEAPON11_SHOOTS WESBULLET
	set	WEAPON11_SHOTSPERBURST 2
	set WEAPON11_FIRESOUND WESKAR_FIRE 
	set WEAPON11_SELECTSOUND GLOCKMAGIN
	set WEAPON11_CLIP 99999
	set WEAPON11_RELOAD 50
	set WEAPON11_RELOADSOUND1 SKARCLIPOUT
	set WEAPON11_RELOADSOUND2 SKARCLIPIN
	ifvarand wesupgrades[GROW_WEAPON] 1
	set WEAPON11_FLAGS 65536 else
	set WEAPON11_FLAGS 16384
	set WEAPON11_TOTALTIME 4
	set WEAPON11_FLASHCOLOR 24575
	smaxammo GROW_WEAPON 200
	
ends

defstate dukeweapons

	set WEAPON1_FLAGS 32768
	set WEAPON1_RELOAD 27
	set WEAPON1_TOTALTIME 5
	set WEAPON1_SHOOTS SHOTGUN
	set WEAPON1_SPAWN SHELL
	set WEAPON1_FIRESOUND FIRE1911 // NEW_PISTOL_FIRE
	set WEAPON1_RELOADSOUND1 EJECT_CLIP
	set WEAPON1_RELOADSOUND2 INSERT_CLIP
	ife LASERMODE 3 set WEAPON1_SELECTSOUND SELECT7 else
	ife LASERMODE YES set WEAPON1_SELECTSOUND SWITCHTOLASER else
	set WEAPON1_SELECTSOUND INSERT_CLIP
	set PISTOLCLIP 12
	set WEAPON1_CLIP 999
	set WEAPON1_SHOTSPERBURST 0
	
	ifvarand dukeupgrades[KNEE_WEAPON] 1 // deflect bullets
	{
		setarray weap_owned[294] YES
		setarray weap_owned[194] YES
		setarray weap_owned[94] YES
		set tempb shellyupgrades[KNEE_WEAPON]
		orvar tempb 1
		setarray shellyupgrades[KNEE_WEAPON] tempb
		set tempb wesupgrades[KNEE_WEAPON]
		orvar tempb 1
		setarray wesupgrades[KNEE_WEAPON] tempb
	}
	
	ifvarand dukeupgrades[PISTOL_WEAPON] 16 // alien pistol upgrade
	{
		setarray weap_owned[105] YES
		set tempb shellyupgrades[PISTOL_WEAPON]
		orvar tempb 16
		setarray shellyupgrades[PISTOL_WEAPON] tempb
		setarray weap_owned[5] YES
		set tempb wesupgrades[PISTOL_WEAPON]
		orvar tempb 16
		setarray wesupgrades[PISTOL_WEAPON] tempb
		setarray weap_owned[205] YES
	}
	
	ifvarand dukeupgrades[PISTOL_WEAPON] 32 // +max ammo
	{
		setarray weap_owned[106] YES
		set tempb shellyupgrades[PISTOL_WEAPON]
		orvar tempb 32
		setarray shellyupgrades[PISTOL_WEAPON] tempb
		setarray weap_owned[6] YES
		smaxammo PISTOL_WEAPON 400
	}

	ifvarand dukeupgrades[PISTOL_WEAPON] 8 // glock18
	{
		setarray weap_owned[1] YES
		set WEAPON1_SHOOTS SHOTSPARK1
		set PISTOLCLIP 33
		set WEAPON1_RELOAD 30
		set WEAPON1_FIRESOUND GLOCKFIRE
		set WEAPON1_FLAGS 98380
		
		ifvarand dukeupgrades[PISTOL_WEAPON] 4 // dual
		{
			setarray weap_owned[3] YES
			set WEAPON1_RELOAD 56
			set WEAPON1_TOTALTIME 6 // 5
			set WEAPON1_SHOTSPERBURST 2
			orvar WEAPON1_FLAGS 64
			set PISTOLCLIP 40
		}
		else
		set WEAPON1_TOTALTIME 4
		
		set WEAPON1_RELOADSOUND1 GLOCKMAGOUT
		set WEAPON1_RELOADSOUND2 GLOCKMAGIN
		set WEAPON1_SELECTSOUND GLOCKMAGIN
	}
	else
	ifvarand dukeupgrades[PISTOL_WEAPON] 4 // dual
	{
		setarray weap_owned[3] YES
		set WEAPON1_RELOAD 48
		set WEAPON1_TOTALTIME 6
	}
	ifvarand dukeupgrades[PISTOL_WEAPON] 1 // AP
	setarray weap_owned[2] YES
	
	ifvarand dukeupgrades[SHOTGUN_WEAPON] 16 // has DB shotty
	ifvarand gotDB 2
	{
		setarray weap_owned[12] YES
		set WEAPON2_FIREDELAY 4
		set WEAPON2_FLAGS 1024
		set WEAPON2_SHOOTS SHOTGUN
		set WEAPON2_CLIP 0
		set WEAPON2_SHOTSPERBURST 25
		ifvarand dukeupgrades[SHOTGUN_WEAPON] 32
		{	
			set WEAPON2_FIREDELAY 3
			set WEAPON2_TOTALTIME 40 
		}
		else
		set WEAPON2_TOTALTIME 55
		set WEAPON2_RELOAD 0
		set WEAPON2_SPAWN SHOTGUNSHELL
		set WEAPON2_SOUND2SOUND DBOPEN
		set WEAPON2_SOUND2TIME 19
		set WEAPON2_FIRESOUND DBFIRE
		set WEAPON2_SELECTSOUND DBCLOSE
	}
	else
	{
		set WEAPON2_SOUND2TIME 14 // 15
		set WEAPON2_SPAWNTIME 24
		
		set WEAPON2_RELOAD 13
		set WEAPON2_FIREDELAY 4
		set WEAPON2_TOTALTIME 30
		set WEAPON2_CLIP 0
		set WEAPON2_SHOTSPERBURST 7
		set WEAPON2_SHOOTS SHOTGUN
		set WEAPON2_FLAGS 1024
		set WEAPON2_SPAWN SHOTGUNSHELL
		
		ifvarand dukeupgrades[SHOTGUN_WEAPON] 4 // atomic shotty
		{
			setarray weap_owned[14] YES
			set WEAPON2_FIRESOUND NEWSHOTFIRE
			set WEAPON2_SOUND2SOUND NEWSHOTCOCK
			set WEAPON2_SELECTSOUND NEWSHOTCOCK
		}
		else
		{
			set WEAPON2_FIRESOUND SHOTGUN_FIRE
			set WEAPON2_SOUND2SOUND SHOTGUN_COCK
			set WEAPON2_SELECTSOUND SHOTGUN_COCK
		}
	}
	ifvarand dukeupgrades[SHOTGUN_WEAPON] 1 // explosive
	{
		setarray weap_owned[11] YES
		setarray weap_owned[111] YES
		set tempb shellyupgrades[SHOTGUN_WEAPON]
		orvar tempb 1
		setarray shellyupgrades[SHOTGUN_WEAPON] tempb
	}
	ifvarand dukeupgrades[SHOTGUN_WEAPON] 8 // rad shells
		setarray weap_owned[15] YES
	ifvarand dukeupgrades[SHOTGUN_WEAPON] 2 // burstfire
		setarray weap_owned[16] YES
	
	
	set WEAPON3_SHOTSPERBURST 0
	
	ifvarand dukeupgrades[CHAINGUN_WEAPON] 8 orvar gotshock 1 else
	{
		ifvarand gotshock 2 xorvar gotshock 2
		ifvarand gotshock 1 xorvar gotshock 1
	}
	ifvarand dukeupgrades[CHAINGUN_WEAPON] 16 // chain gang
	{
		setarray weap_owned[125] YES
		setarray weap_owned[25] YES
		set tempb shellyupgrades[CHAINGUN_WEAPON]
		orvar tempb 16
		setarray shellyupgrades[CHAINGUN_WEAPON] tempb
		set tempb wesupgrades[CHAINGUN_WEAPON]
		orvar tempb 16
		setarray wesupgrades[CHAINGUN_WEAPON] tempb
	}
	ifvarand dukeupgrades[CHAINGUN_WEAPON] 8 // EXECUTIONER
	ifvarand gotshock 2
	{
		setarray weap_owned[24] YES
		setarray weap_owned[124] YES
		setarray weap_owned[224] YES
		set WEAPON3_SHOOTS SHOCKBEAM
		set WEAPON3_FIRESOUND LIGHTNINGFIRE
		set WEAPON3_FLAGS 0
		set WEAPON3_TOTALTIME 14
		set WEAPON3_FLASHCOLOR 16744576 
		set WEAPON3_CLIP 0
		set WEAPON3_RELOAD 0
		set WEAPON3_SPAWN 0
		set WEAPON3_SPAWNTIME 0
		set WEAPON3_SELECTSOUND SWITCHTOLASER
		
	}
	else
	ifvarand dukeupgrades[CHAINGUN_WEAPON] 1 // minigun
	{
		setarray weap_owned[21] YES
		set WEAPON3_CLIP 0
		set WEAPON3_SHOOTS CHAINGUN
		set WEAPON3_FIRESOUND MINIFIRE
		set WEAPON3_RELOAD 0
		set WEAPON3_SELECTSOUND SELECT_WEAPON
		set WEAPON3_FLAGS 73804
		set WEAPON3_SPAWN SHELL
		set WEAPON3_SPAWNTIME 1
	}
	else
	{
		set WEAPON3_CLIP 0
		set WEAPON3_SHOOTS CHAINGUN
		set WEAPON3_FIRESOUND CHAINGUN_FIRE
		set WEAPON3_RELOAD 0
		set WEAPON3_SELECTSOUND SELECT_WEAPON
		set WEAPON3_FLAGS 73812
		set WEAPON3_SPAWN SHELL
		set WEAPON3_SPAWNTIME 1
	}
	
	ifvarand dukeupgrades[CHAINGUN_WEAPON] 2 // AP rounds
	{
		setarray weap_owned[22] YES
		setarray weap_owned[122] YES
		set tempb shellyupgrades[CHAINGUN_WEAPON]
		orvar tempb 2
		setarray shellyupgrades[CHAINGUN_WEAPON] tempb
		set tempb wesupgrades[CHAINGUN_WEAPON]
		orvar tempb 2
		setarray wesupgrades[CHAINGUN_WEAPON] tempb
	}
	
	ifvarand dukeupgrades[CHAINGUN_WEAPON] 4 // +max ammo
	{
		setarray weap_owned[123] YES
		set tempb shellyupgrades[CHAINGUN_WEAPON]
		orvar tempb 4
		setarray shellyupgrades[CHAINGUN_WEAPON] tempb
		setarray weap_owned[23] YES
		smaxammo CHAINGUN_WEAPON 400
	}
	
		
	ifvarand dukeupgrades[RPG_WEAPON] 1 // SMART RPG
		setarray weap_owned[31] YES
		
	ifvarand dukeupgrades[RPG_WEAPON] 2 // FAST ROCKETS
	{
		setarray weap_owned[132] YES
		setarray weap_owned[32] YES
		set tempb shellyupgrades[RPG_WEAPON]
		orvar tempb 2
		setarray shellyupgrades[RPG_WEAPON] tempb
	}
	ifvarand dukeupgrades[RPG_WEAPON] 4 // MULTI ROCKETS
	{
		setarray weap_owned[133] YES
		setarray weap_owned[33] YES
		set tempb shellyupgrades[RPG_WEAPON]
		orvar tempb 4
		setarray shellyupgrades[RPG_WEAPON] tempb
	}	
		
	ife nukeselect YES
	{
		set WEAPON4_FIRESOUND RPG_BIGSHOOT
		set WEAPON4_TOTALTIME 30
		set WEAPON4_FIREDELAY 5
	}
	else
	{
		ifvarand dukeupgrades[RPG_WEAPON] 1 set WEAPON4_FIRESOUND ROCKETFIRE2 else
		set WEAPON4_FIRESOUND RPG_SHOOT
		set WEAPON4_TOTALTIME 20
		set WEAPON4_FIREDELAY 4
	}
	set PIPEBOMB_CONTROL pipemode
	
	ifvarand wesupgrades[HANDBOMB_WEAPON] 1
	{
		set tempb dukeupgrades[HANDBOMB_WEAPON]
		orvar tempb 1
		setarray dukeupgrades[HANDBOMB_WEAPON] tempb
	}
	ifvarand wesupgrades[HANDBOMB_WEAPON] 2
	{
		set tempb dukeupgrades[HANDBOMB_WEAPON]
		orvar tempb 2
		setarray dukeupgrades[HANDBOMB_WEAPON] tempb
	}
	
	ifvarand dukeupgrades[HANDBOMB_WEAPON] 1
		setarray weap_owned[41] YES
		
	ifvarand dukeupgrades[HANDBOMB_WEAPON] 2
		setarray weap_owned[42] YES
		
	ifvarand shellyupgrades[SHRINKER_WEAPON] 1
	{
		set tempb dukeupgrades[SHRINKER_WEAPON]
		orvar tempb 1
		ifvarand shellyupgrades[SHRINKER_WEAPON] 2 { orvar tempb 2 setarray weap_owned[52] 1 }
		setarray dukeupgrades[SHRINKER_WEAPON] tempb
	}
	
	
	
	
	set WEAPON6_INITIALSOUND SHRINKER_FIRE
	set WEAPON6_FLASHCOLOR 8454016
	set WEAPON6_SELECTSOUND SWITCHTOLASER
	set WEAPON6_FLAGS 2
	smaxammo SHRINKER_WEAPON 50
	ifvarand dukeupgrades[SHRINKER_WEAPON] 1
	{
		setarray weap_owned[51] YES
		set WEAPON6_SHOOTS BMFGPROJ
		set WEAPON6_FIRESOUND -1
		set WEAPON6_FIREDELAY 30 // 14
		set WEAPON6_TOTALTIME 40 // 24
	}
	else
	{
		set WEAPON6_SHOOTS SHRINKER
		set WEAPON6_FIRESOUND 0
		set WEAPON6_FIREDELAY 10
		set WEAPON6_TOTALTIME 12
	}
	
	ifvarand dukeupgrades[DEVISTATOR_WEAPON] 1
		setarray weap_owned[61] YES
		
	ifvarand dukeupgrades[DEVISTATOR_WEAPON] 2
	{
		setarray weap_owned[62] YES
		setarray weap_owned[162] YES
		setarray weap_owned[262] YES
		set tempb shellyupgrades[DEVISTATOR_WEAPON]
		orvar tempb 2
		setarray shellyupgrades[DEVISTATOR_WEAPON] tempb
		
		set tempb wesupgrades[DEVISTATOR_WEAPON]
		orvar tempb 2
		setarray wesupgrades[DEVISTATOR_WEAPON] tempb
	}
	
	ifvarand dukeupgrades[DEVISTATOR_WEAPON] 4 // barret upgrade
		setarray weap_owned[71] YES
	
	// ifvarand gotrailgun 2 nullop else
	// {
		// set WEAPON7_FIRESOUND 0
		// set WEAPON7_INITIALSOUND CAT_FIRE
		// set WEAPON7_SHOTSPERBURST 2
		// set WEAPON7_SHOOTS RPG
		// set WEAPON7_TOTALTIME 6
		// set WEAPON7_FLAGS 72
	// }
	
	state switchrailgun
	
	ifvarand dukeupgrades[TRIPBOMB_WEAPON] 1
	{
		setarray weap_owned[81] YES
		set WEAPON8_FLAGS 16640
		set WEAPON8_SHOOTS SPIDERMINEFALLING
	}
	else
	{
		setarray weap_owned[80] YES
		set WEAPON8_WORKSLIKE 8
		set WEAPON8_FLAGS 3072
		set WEAPON8_SHOOTS HANDHOLDINGLASER
	}
	
	ifvarand dukeupgrades[TRIPBOMB_WEAPON] 2 // SPIDER MOBILITY
	{
		setarray weap_owned[182] YES
		setarray weap_owned[82] YES
		setarray weap_owned[282] YES
		set tempb shellyupgrades[TRIPBOMB_WEAPON]
		orvar tempb 2
		setarray shellyupgrades[TRIPBOMB_WEAPON] tempb
		set tempb wesupgrades[TRIPBOMB_WEAPON]
		orvar tempb 2
		setarray wesupgrades[TRIPBOMB_WEAPON] tempb
	}
		
	ifvarand dukeupgrades[TRIPBOMB_WEAPON] 4 // DEATHBEAM
	{
		setarray weap_owned[83] YES
		setarray weap_owned[183] YES
		setarray weap_owned[283] YES
		set tempb shellyupgrades[TRIPBOMB_WEAPON]
		orvar tempb 4
		setarray shellyupgrades[TRIPBOMB_WEAPON] tempb
		set tempb wesupgrades[TRIPBOMB_WEAPON]
		orvar tempb 4
		setarray wesupgrades[TRIPBOMB_WEAPON] tempb
	}
	
	ife weap_owned[153] YES setarray weap_owned[53] YES
	ife weap_owned[53] YES
	{
		set tempb dukeupgrades[FREEZE_WEAPON]
		orvar tempb 2
		setarray dukeupgrades[FREEZE_WEAPON] tempb
	}
	
	ifvarand gotplasma 2 state setplasmagun
	else
	ifvarand dukeupgrades[FREEZE_WEAPON] 1
	{
		set WEAPON9_SHOOTS ICEBEAM
		set WEAPON9_INITIALSOUND -1 // CAT_FIRE
		set WEAPON9_FIRESOUND FREEZEBOLT_FIRE
		set WEAPON9_TOTALTIME 4 // 5
		set WEAPON9_FIREDELAY 2 // 3
		set WEAPON9_FLAGS 65544
		set WEAPON9_FLASHCOLOR 16744576
	}
	else
	{
		set WEAPON9_SHOOTS FREEZEBLAST
		set WEAPON9_INITIALSOUND CAT_FIRE
		set WEAPON9_FIRESOUND CAT_FIRE
		set WEAPON9_SHOTSPERBURST 0
		set WEAPON9_TOTALTIME 5
		set WEAPON9_FIREDELAY 3
		set WEAPON9_FLAGS 65536
		set WEAPON9_FLASHCOLOR 16744576
	}

	set WEAPON11_FIREDELAY 3
	set WEAPON11_CLIP 0
	set WEAPON11_SHOOTS GROWSPARK 
	set	WEAPON11_SHOTSPERBURST 0
	set WEAPON11_SELECTSOUND SWITCHTOLASER
	set WEAPON11_FIRESOUND BAB_IMPACT 
	set WEAPON11_FLAGS 2
	set WEAPON11_TOTALTIME 5
	set WEAPON11_FLASHCOLOR 24575 
	smaxammo GROW_WEAPON 99
		
	ifvarand dukeupgrades[GROW_WEAPON] 1
	{
		setarray weap_owned[55] YES
		setarray weap_owned[155] YES
		set tempb shellyupgrades[GROW_WEAPON]
		orvar tempb 1
		setarray shellyupgrades[GROW_WEAPON] tempb
	}
	ifvarand dukeupgrades[GROW_WEAPON] 2
	{
		setarray weap_owned[56] YES
		setarray weap_owned[156] YES
		set tempb shellyupgrades[GROW_WEAPON]
		orvar tempb 2
		setarray shellyupgrades[GROW_WEAPON] tempb
	}
	

ends

defstate civlist

	switch sprite[spriteid].picnum
	case FEMCIV case FEMCIVCROUCH case FEMCIV2 case FEMCIV2CROUCH 
	case FEMCIV3 case FEMCIV3CROUCH case FEMCIV5 case FEMCIV5CROUCH
	case MALECIV1 case MALECIV1CROUCH case MALECIV2 case MALECIV2CROUCH 
	case MALECIV4 case MALECIV4CROUCH case MALECIV3 case MALECIV3CROUCH
	case MALECIV5 case MALECIV5CROUCH
	case MALECIV6 case MALECIV6CROUCH case MALECIV2SMOKING
	case GUARD case GUARDCROUCH case CRYSTAL case MAIDNPC
	case EDFSNIPER case EDFSNIPERCROUCH case EDFTROOP case ARMEDF
	case EDFDRONE
	case NAKEDBABE case NAKEDBABECROUCH case PIGSTRIPPER
	case STRIPPER case STRIPPERCROUCH case KBABE case KBABECROUCH case CHEERLEADER
	case CHEERLEADERCROUCH case HOOKER case HOOKERCROUCH case POLEDANCER
	case CAVEGIRL case CAVEGIRLCROUCH case BIKINIBABE case BIKINIBABE2
	case FATGUY1 case FATGUY2 case ALIENCIVMALE case ALIENCIVFEM
		changespritestat spriteid 1
	break
	endswitch

ends

defstate wakeupcivs
	
	headspritestat spriteid 2
	whilevarn spriteid -1
	{
		state civlist
		nextspritestat spriteid spriteid
	}
	

ends

move THROWNMOVE 512
useractor notenemy THROWNOBJECT 10

	ifmove STOPPED move 0
	
	ifmove 0
	ifn stun 1
	{
		move THROWNMOVE geth
		set z player[].horiz
		sub z 100
		mul z -32
		sub z 512
		seta[].zvel z
		
	}
	ifnotmoving ifcount 3
	{
		set spriteid sprite[].htmovflag
		add spriteid 16384
		al spriteid
		ifge spriteid 0 ifl spriteid 16384 // hit a sprite
		{
			seta[].htextra 10
			seta[].htowner spriteid
			seta[].htpicnum SHOTSPARK1
			
			seta[spriteid].htextra 10
			seta[spriteid].htowner player[].i
			seta[spriteid].htpicnum SHOTSPARK1
		}
	
		seta[].picnum mtype
		seta[].statnum savedvalue
		move 0
	}
	
	fall
	iffloordistl 2
	{
		ifcount 5
		{
			move 0
			seta[].picnum mtype
			// seta[].statnum savedvalue
			changespritestat THISACTOR savedvalue
		}
	}
	else resetcount

enda

defstate checkheldobject

	ifn PLAYERONTHEBIKE 1
	ifpdistl 1024
	ifp pfacing
	ifcansee
	ifp palive
	ife heldobject -1
	ife zombieonplayer -1
	ife onturret -1
	ife sidekick 0
	ife pipehold 0
	ife slidekick 0
	ife heldtime 0
	ife juice_pos 0
	ife player[].kickback_pic 0
	{
		set heldnear 10
		ifhitspace
		{
			set heldobject THISACTOR
			set heldcstat sprite[].cstat
			set heldtime 1
		}
	}
ends

defstate checksaberblock

	set spriteid player[].i
	
	ifg sprite[spriteid].htextra 1 ife sprite[spriteid].htowner THISACTOR
	ifn blockang 6666 seta[spriteid].htextra -1
	else ife blockang 6666
	{
		ifg saberpos 0 ifl saberpos 85 nullop else
		ifangdiffl 512 nullop else	
		ife sprite[spriteid].htowner THISACTOR
		ife player[].curr_weapon KNEE_WEAPON
		ifn gotsaber 0 ife player[].weapon_pos 0
		{
			seta[spriteid].htextra -1
			getp[].ang angvar
			getincangle blockang angvar sprite[].ang
			ifl blockang 0 set blockang -9 else set blockang 9
			flash
			
			ife pchar 2 soundonce BLADEHITMET else
			soundoncevar sabclashsnd
			
			set tempe player[].posz add tempe 1024
			espawn SPARKFALL setsprite RETURN player[].posx player[].posy tempe
			espawn SPARKFALL setsprite RETURN player[].posx player[].posy tempe
			espawn SPARKFALL setsprite RETURN player[].posx player[].posy tempe
		}
	}
ends

defstate incoming_eval

	ife sprite[myspawner].statnum 1024 { set myspawner -1 break }
	
	geta[myspawner].x x
	geta[myspawner].y y
	sub x sprite[].x
	sub y sprite[].y
	geta[].z z
	sub z 8192
	getangle angvel x y

	add angvel 512
	cos mycos angvel
	sin mysin angvel
	hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 mysector temp spriteid x y zdist 4294901809
	sub x sprite[].x
	sub y sprite[].y
	mul x x
	mul y y
	add x y
	sqrt x x
	set xydist x
	
	sub angvel 1024
	cos mycos angvel
	sin mysin angvel
	hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 mysector temp spriteid x y zdist 4294901809
	sub x sprite[].x
	sub y sprite[].y
	mul x x
	mul y y
	add x y
	sqrt x x
	
	ifl x xydist add angvel 1024
ends

defstate dmtauntcode
	ifn thiscam -1 break
	// this is run by actors who taunt the player during matches
	
	ife LEVEL 11 // opening match
	{
		ife player[].player_par 95
		{
			set cutcamtime player[].player_par
			set emp_overlay 210
			set emp_overlay_tile 15266
			set subtitle_start 696
			set subtitle_numlines 2
			set subtitle_time 210
			screensound ELITEROAM1
		}
		ife bluescore 17
		ifle redscore 15
		ife monstatus 1
		ifge sprite[].htextra sprite[].extra
		{
			set cutcamtime player[].player_par
			set emp_overlay 180
			set emp_overlay_tile 15266
			set subtitle_start 698
			set subtitle_numlines 2
			set subtitle_time 180
			screensound ELITEROAM2
		}
		
	}
	
	ife LEVEL 16 // sith boss fight
	{
		ifspritepal 10
		ife FEMKILLCOUNT 0
		{
			screensound SITHTAUNT1
			set cutcamtime player[].player_par
			set emp_overlay 120
			set emp_overlay_tile 15268
			set subtitle_start 800
			set subtitle_numlines 1
			set subtitle_time 120
			set FEMKILLCOUNT 1
		}
		ifspritepal 22
		ife monstatus 1
		ife subtitle_time 0
		ife player[].player_par 1800
		{
			globalsound SYTHTAUNT2
			set cutcamtime player[].player_par
			set emp_overlay 150
			set emp_overlay_tile 15267
			set subtitle_start 801
			set subtitle_numlines 2
			set subtitle_time 150
		}
	}
	
	// littlebigmen fight handled in their code
	
ends

defstate predamage

	ife sprite[].htextra -1
	ifn bleeding 0
	{
		ifg bleeding inithp set bleeding inithp
		ifl bleeding 0
		{
			set TMP_A bleeding, abs TMP_A
			ifg TMP_A inithp { set bleeding inithp mul bleeding -1 }
		}
		ifvarand player[].player_par 1
		{
			seta[].htextra 1
			seta[].htpicnum RADWOUND
			ifn team 1 ifn team 3
				seta[].htowner player[].i
			ifg bleeding 0
			sub bleeding 1
			else add bleeding 1
			ife bleeding 0 { ifactorsound THISACTOR RADFRY stopactorsound THISACTOR RADFRY }
			break
		}
	}
	ifn attmode NO
	ife player[].actorsqu THISACTOR
	ife player[].knee_incs 14
	{
		set temp inithp
		mul temp 2
		seta[].htextra temp
		seta[].htowner player[].i
		seta[].htpicnum BOOTS
	}
	
	ife monstatus 1
	ifl sprite[].extra 0
		strength 1
		
	ife sprite[].htextra -1 break
	
	switch sprite[].htpicnum
	
	case SHOTSPARK1
	case SABERPROJ
		
		ifg saberpos 0 ifl saberpos 85 nullop else
		ife THISACTOR player[].i
		ifg gotsaber 0 ife player[].weapon_pos 0
		ife player[].curr_weapon KNEE_WEAPON
		{
			set temp NO
			ife pchar 0 ifvarand dukeupgrades[KNEE_WEAPON] 1 set temp YES
			ife pchar 1 ifvarand shellyupgrades[KNEE_WEAPON] 1 set temp YES
			ife pchar 2 ifvarand wesupgrades[KNEE_WEAPON] 1 set temp YES
			ife temp YES
			{
				getincangle angvar sprite[].htang player[].ang
				set temp angvar
				abs temp
				ifg temp 512
				{
					seta[].htextra -1
					ifn pchar 2
					{
						ifn halfpoint 0 set halfpoint 0 else
						{
							sub gotsaber 1 
							set halfpoint 1 
						}
					}
					// set temp sprite[].htextra
					// div temp 4
					// ifl temp 1 set temp 1
					// seta[].htextra temp
					ifl blockang 0 set blockang -9 else set blockang 9
					flash
					globalsound BLASTERBOUNCE
					set tempe player[].posz add tempe 1024
					set x player[].posx
					add x 384
					rotatepoint player[].posx player[].posy x player[].posy player[].ang savx savy
					
					espawn SPARKFALL setsprite RETURN savx savy tempe
					espawn SPARKFALL setsprite RETURN savx savy tempe
					espawn SPARKFALL setsprite RETURN savx savy tempe
					espawn SPARKFALL setsprite RETURN savx savy tempe
					espawn SPARKFALL setsprite RETURN savx savy tempe
					espawn SPARKFALL setsprite RETURN savx savy tempe
					
					ifrnd 128 shoot SHOTSPARK1
					ifrnd 128 shoot SHOTSPARK1
				}
			}
		}
		
		ife pchar 2 ife sprite[].htowner player[].i
		ife player[].curr_weapon GROW_WEAPON
		ifn sprite[].pal 1 ifg sprite[].extra 1
			seta[].htpicnum FREEZEBLAST

	break
	
	// case RADIUSEXPLOSION
		// ife monstatus 1
		// ifn sprite[].htowner -1
		// ife sprite[sprite[].htowner].picnum FIREEXT
			// seta[].htpicnum FREEZEBLAST
	// break
	
	case GRENADEPROJ
	case BIGGRENADEPROJ
	case BMFGPROJ
	case COMETPROJ
	case MORTER2
	case CBPROJ
	case TANKSHELL
	case EXPBULLET
	case WESGRENADE
	case BOOBROCKET
		seta[].htpicnum RPG
	break
	
	case RPG
		ife sprite[].htowner player[].i
		ife player[].curr_weapon SHOTGUN_WEAPON
		{
			ife pchar 0 ife shotexpduke YES set temp YES
			ife pchar 1 
			{
				ifvarand gotbow 2 nullop else
				ife shotexpshelly YES set temp YES
			}
			set temp sprite[].htextra
			mul temp 3 div temp 2
			seta[].htextra temp
		}
	break
		
	case SHRINKSPARK
		ifactor SHARK
			seta[].htextra 1
		set TMP_A 500
		
		set tempb NO
		ife sprite[].htowner player[].i set tempb YES
		ife sprite[].htowner myshelly set tempb YES
		ife tempb YES
		{
			ife pchar 1
			set temp bweaplevel[6]
			else set temp dweaplevel[6]
			mul temp 180
			add TMP_A temp
			set TMP_B plevel
			mul TMP_B 50
			
			add TMP_A TMP_B
			
			ifg sprite[].extra TMP_A 
			{ 
				seta[].htpicnum SHOTSPARK1  
				set temp plevel
				ife pchar 0
				add temp dweaplevel[6]
				else
				add temp bweaplevel[6]
				mul temp 10
				add temp 20
				seta[].htextra temp
			}
		}
		else
		{
			ifg sprite[].extra TMP_A { seta[].htextra SHOTSPARK1 seta[].htpicnum SHOTSPARK1 }
		}
		
	break
	
	case BLOODBULLET
	case BLOODBOMB
		ife monstatus 1
		ifn team 1 ifn team 3 
		{
			ife sprite[].htowner myshelly add botleach 200 else
			add leach 200
		}
	break
	
	case BOMBLET
		seta[].htpicnum RPG
		seta[].htowner player[].i
	break
	
	case FREEZEBOLT
		ifl sprite[].extra 1
		ifspritepal 1
		ifrnd 64 seta[].htpicnum RPG
		else seta[].htpicnum FREEZEBLAST
	break

	case LOVEBOMB
		seta[].htpicnum GROWSPARK
		seta[].htowner player[].i
		ifg team 0
			seta[].htextra -1
		else spawn GROWSPARK
	break
	case SHOCKPROJ
		ifn sprite[].picnum APLAYER
		{
			add stun sprite[].htextra
			sub stun mlevel
			ifl stun 0 set stun 0
		}
	break
	endswitch
	
	ifg sprite[].htextra 0
	{
		ifn sprite[].htowner -1
		{
			ifvarand actorvar[sprite[].htowner].monstflags 64 // double shot power
			{
				geta[].htextra temp, 
				// shiftl temp 1, 
				mul temp 3 div temp 2
				seta[].htextra temp
			}
			ife sprite[].htpicnum SHOTSPARK1
			ifvarand actorvar[sprite[].htowner].monstflags 128 // multishot
			{
				geta[].htextra temp, 
				// shiftl temp 1, 
				mul temp 3 div temp 2
				seta[].htextra temp
			}
			ifvarand actorvar[sprite[].htowner].monstflags 256 // gigantism
			{
				geta[].htextra temp, mul temp 3, div temp 2 seta[].htextra temp
			}
			ifvarand actorvar[sprite[].htowner].monstflags 4096 // radioactive
			{
				soundonce RADFRY
				set temp sprite[].htextra
				shiftr temp 2, ifl temp 1 set temp 1
				ifg bleeding 0 mul bleeding -1
				sub bleeding temp
				espawn BIGSMOKE
				seta[RETURN].pal 76
			}
			
			ifvarand actorvar[sprite[].htowner].monstflags 16384 // vampirism
			ifn team actorvar[sprite[].htowner].team
			{
				set temp sprite[].htowner
				ife sprite[temp].htextra -1 seta[temp].htpicnum CAPTUREPLUS
				set tempb sprite[temp].extra
				add tempb sprite[].htextra
				ifg tempb 32767 set tempb 32767
				seta[temp].extra tempb
				ifn attmode 0
				{
					set tempc actorvar[temp].inithp
					mul tempc 4 div tempc 3
					ifg tempb tempc
					{
						getav[temp].mlevel tempc
						add tempc 1
						setav[temp].mlevel tempc
						setav[temp].inithp tempb
						set tempc actorvar[temp].monxp
						mul tempc 10
						div tempc 9
						setav[temp].monxp tempc
						ifl gametype 1 setav[temp].spawnprotect 70
						else setav[temp].spawnprotect 30
						screensound VRTRANSND
						ife actorvar[temp].team 0
						userquote 1251
					}
				}
			}

			ife team actorvar[sprite[].htowner].team
			{
				ife sprite[sprite[].htowner].picnum SIDEGUN
				seta[].htextra -1

				// ifwasweapon FREEZEBLAST
				ife myshelly sprite[].htowner
				{
					ife myshelly THISACTOR 
					seta[].htextra -1
					
					ifactor APLAYER 
					seta[].htextra -1
				}
				// ifwasweapon FIREBOLT
				// ife myshelly sprite[].htowner
				// {
					// ife myshelly THISACTOR 
					// seta[].htextra -1
					
					// ifactor APLAYER 
					// seta[].htextra -1
				// }
				ifvarand perks 8
				{
					ife team 1
					{
						seta[].htextra -1
						set bleeding 0
					}
				}
			}
			
			
			ife sprite[sprite[].htowner].picnum ROLLYTURRET
			{
				set temp sprite[].htowner
				ife actorvar[temp].team 1
				seta[].htowner player[].i
				set safecount ROLLYTURRET
			}
			else
			ife sprite[sprite[].htowner].picnum SIDEGUN
			{
				set temp sprite[].htowner
				ife actorvar[temp].myspawner player[].i
				seta[].htowner player[].i
				set safecount SIDEGUN
			}
			else set safecount -1

			set temp NO
			ife player[].i sprite[].htowner set temp YES
			ife myshelly sprite[].htowner set temp YES
			ife leftsidegun sprite[].htowner set temp YES
			ife rightsidegun sprite[].htowner set temp YES
			ife temp YES
			{
				ifn pdamage 100
				{
					geta[].htextra temp
					mul temp pdamage
					div temp 100
					seta[].htextra temp
				}
			}
			else // mlevel damage scaling
			// ifn attmode NO
			{
				getav[sprite[].htowner].mlevel TMP_A
				ifg TMP_A 1
				{
					sub TMP_A 1
					mul TMP_A 5
					add TMP_A 75 // 100
				
					geta[].htextra temp
					mul temp TMP_A
					div temp 100
					seta[].htextra temp
				}
			}
			
			ife myshelly sprite[].htowner
			{
				set tempb -1
				switch sprite[].htpicnum
				case SHOTSPARK1
					ife pchar 2 set tempb 1 // pistol
					else
					ife pchar 0 set tempb 3 // chaingun
					else set tempb 2  // shotgun
				break
				case KNEE
					set tempb 0 // kicks
				break
				case RPG
					set tempb 4 // RPG
				break
				case FREEZEBLAST
				case FIREBOLT
				case BURNING
					set tempb 9 // FREEZER or INCINERATOR
				break
				endswitch
				ifn tempb -1
				{
					// apply weapon level damage to bot damage
					ife pchar 0 set tempc bweaplevel[tempb] else
					ife pchar 2 set tempc wweaplevel[tempb] else
					set tempc dweaplevel[tempb]
					mul tempc 8
					add tempc 100
					ifg tempc 100
					{
						set temp sprite[].htextra
						mul temp tempc
						div temp 100
						seta[].htextra temp
					}
				}
			}
			
		}
	}
	ifn restartatt 0 break
	ifn attmode NO
	ife monstatus 1
	ifn team 1 ifn team 3
	ifg sprite[].htextra 0
	{
		geta[].htextra temp
		ifn sprite[].htowner -1
		{
			ife actorvar[sprite[].htowner].team team set temp 0
/*
			ifn sprite[].htowner player[].i
			{
				ife sprite[].htowner leftsidegun ife actorvar[leftsidegun].myspawner player[].i nullop else
				ife sprite[].htowner rightsidegun ifn actorvar[leftsidegun].myspawner player[].i nullop else
				ife sprite[].htowner player[].holoduke_on nullop else
				ife sprite[sprite[].htowner].picnum ROLLYTURRET nullop else
				div temp 2 // half xp from ally kills
			}
*/
		}
		
		set tempb -1 // this is going to be the weapon number
		ifn shrunken 0 ifl pchar 2 set tempb 6 
		else ife sprite[].htpicnum KNEE set tempb 0
		else ife safecount ROLLYTURRET set tempb 5
		else ife sprite[].htpicnum BOOTS set tempb 6
		else ifspritepal 1
		{
			ife sprite[].htpicnum FREEZEBLAST set tempb -1
			else set tempb 9
		}
		else
		{
			switch player[].curr_weapon
			case 0 // 0 kicks  // formerly 10 was chainsaw and lightsaber
				ife sprite[].htpicnum SHOTSPARK1
				ife sprite[].htowner player[].i
				{
					set tempb 0
					ifn saberpos 0 seta[].htpicnum SABERPROJ
				}
				else
				{
					ife gotsaw YES set tempb 0 else
					ifg gotsaber 0 set tempb 0 else
					set tempb 0
				}
			break
			case 1 // 1 pistol, laser pistol and comm gun
				set tempb 1
				ife sprite[].htowner player[].i 
					ife LASERMODE 3 set tempb 6 
			break
			case 2 // 2 shotgun
				set tempb 2
				ife pchar 0 ifvarand gotDB 2 set tempb 12
				ifge pchar 1 ifle pchar 2 ifvarand gotbow 2 set tempb 12
			break
			case 3 // 3 chaingun
				set tempb 3
			break
			case 4 // 4 RPG
				set tempb 4
				
			break
			case 5 // 5 pipebomb
			case 10
				set tempb 5
			break
			case 6 // 6 shrinker / BMFG
				set tempb 6
			break
			case 7 // 7 devastator / railgun
				set tempb 7
			break
			case 8 // 8 spider and tripbombs
				set tempb 8
			break
			case 9 // 9 freezer and incinerator / terminator gun
				set tempb 9
			break
			case 11 // 11 expander / shock rifle
				set tempb 11
			break
			endswitch
		}
		ifn tempb -1
		{
			// apply weapon proficiency bonuses, if any
			ife pchar 0 set TMP_A dweaplevel[tempb] 
			else ife pchar 2 set TMP_A wweaplevel[tempb]
			else set TMP_A bweaplevel[tempb]
			ifge TMP_A 3 // opening salvo perk
			ife sprite[].extra inithp
			{
				ife sprite[].htpicnum SHOTSPARK1 seta[].htpicnum RPG
				geta[].htextra tempc
				
				ife tempb 2
				{
					mul tempc 4
					div tempc 3
				}
				else
				{
					add tempc 20
					mul tempc 3, div tempc 2
				}
				
				seta[].htextra tempc
				add stun 20
				// sound
			}
			ifge TMP_A 5 // life leech perk
			ife sprite[].htowner player[].i
			ifn sprite[].picnum EBARRIER
			{
				set tempd sprite[].htextra
				ifg tempd sprite[].extra set tempd sprite[].extra
				ifg leach 500 div tempd 2
				add leach tempd
			}

			ife sprite[].htpicnum BOOTS
			{
				set tempd inithp, mul tempd 2
				ifg sprite[].htextra tempd set temp tempd
			}
			else ifg temp sprite[].extra set temp sprite[].extra
			
			ife sprite[].htpicnum HEADJIB1 add temp 50
			
			ifg temp 0
			ifg monxp 0
			// ife attmode YES
			{
				ife pchar 0 
				{
					set tempc dweapxp[tempb] 
					ife sprite[].htowner player[].i
					ifvarand comboperk 1 // ifle combotime 0 
					ifn safecount ROLLYTURRET ifn sprite[].htpicnum KNEE 
					ifn sprite[].htpicnum BURNING 
					set combotime -20
				}
				else
				ife pchar 2
				{
					set tempc wweapxp[tempb] 
					ife sprite[].htowner player[].i
					ifvarand comboperk 4 // ifle combotime 0 
					ifn safecount ROLLYTURRET ifn sprite[].htpicnum KNEE 
					ifn sprite[].htpicnum BURNING 
					set combotime -20
				}
				else 
				{
					set tempc bweapxp[tempb]
					ife sprite[].htowner player[].i
					ifvarand comboperk 2 // ifle combotime 0 
					ifn safecount ROLLYTURRET ifn sprite[].htpicnum KNEE 
					ifn sprite[].htpicnum BURNING 
					set combotime -20
				}
				ife marathon YES div temp 2
				add tempc temp // temp has now served its purpose and can be reused
				ife pchar 0 setarray dweapxp[tempb] tempc else 
				ife pchar 2 setarray wweapxp[tempb] tempc else
				setarray bweapxp[tempb] tempc
				
				ife attmode YES ife VOLUME 5 ife LEVEL 11
				{
					// setarray dweapxp[tempb] tempc setarray bweapxp[tempb] tempc
					setarray dweapxp[2] tempc 
					setarray bweapxp[2] tempc
					setarray wweapxp[2] tempc
				}
				
				ife pchar 0 set TMP_A dweaplevel[tempb] else 
				ife pchar 2 set TMP_A wweaplevel[tempb] else
				set TMP_A bweaplevel[tempb]
				add TMP_A 1
				ifg TMP_A 2 mul TMP_A 2500 else
				mul TMP_A 2000
				sub TMP_A 1000
				
				ife pchar 0 set temp dweapxp[tempb] else
				ife pchar 2 set temp wweapxp[tempb] else
				set temp bweapxp[tempb]
				
				ifge temp TMP_A
				{
					ife attmode YES
					ife VOLUME 5 ife LEVEL 11
					{
						operateactivators 2 0
						setarray dweapxp[tempb] 0
						setarray bweapxp[tempb] 0
						setarray wweapxp[tempb] 0
						set bigmsgcount 90
						set bigmsg 1137
						screensound WEAPON_UPGRADE
						screensound WEAPON_UPGRADE
						palfrom 32 63 63 63
						break
					}
					
					ife pchar 0 set temp dweaplevel[tempb] else 
					ife pchar 2 set temp wweaplevel[tempb] else
					set temp bweaplevel[tempb]
					add temp 1
					ifl temp 7 add totalxp 1000
					ife pchar 0 
					{
						setarray dweaplevel[tempb] temp 
						ifvarand comboperk 1 nullop else
						// check to see if comboperk is achieved
						{
							set TMP_A 0
							set TMP_B 0
							whilevarn TMP_A 13
							{
								ifg dweaplevel[TMP_A] 0
								add TMP_B 1
								add TMP_A 1
							}
							ifge TMP_B 11
							{
								orvar comboperk 1
								set buffermsg 1139
							}
						}
					}
					else ife pchar 2
					{
						setarray wweaplevel[tempb] temp 
						ifvarand comboperk 4 nullop else
						// check to see if comboperk is achieved
						{
							set TMP_A 0
							set TMP_B 0
							whilevarn TMP_A 13
							{
								ifg wweaplevel[TMP_A] 0
								add TMP_B 1
								add TMP_A 1
							}
							ifge TMP_B 11
							{
								orvar comboperk 4
								set buffermsg 1139
							}
						}
					}
					else 
					{
						setarray bweaplevel[tempb] temp
						ifvarand comboperk 2 nullop else
						// check to see if comboperk is achieved
						{
							set TMP_A 0
							set TMP_B 0
							whilevarn TMP_A 13
							{
								ifg bweaplevel[TMP_A] 0
								add TMP_B 1
								add TMP_A 1
							}
							ifge TMP_B 11
							{
								orvar comboperk 2
								set buffermsg 1139
							}
						}
					}
					
					ife buffermsg 0
					{
						// ife temp 1 set buffermsg 795 else 
						ife temp 3 set buffermsg 796 else ife temp 5 set buffermsg 797
					}
					ife pchar 0 set bigmsg 793 else 
					ife pchar 2 set bigmsg 1195 else set bigmsg 794
					set bigmsgcount 90
					
					ife pchar 0 set temp dweapxp[tempb] else 
					ife pchar 2 set temp wweapxp[tempb] else set temp bweapxp[tempb]
					sub temp TMP_A
					// ife pchar 0 setarray dweapxp[tempb] temp else setarray bweapxp[tempb] temp
					ife pchar 0 setarray dweapxp[tempb] 0 else 
					ife pchar 2 setarray wweapxp[tempb] 0 else setarray bweapxp[tempb] 0
					screensound WEAPON_UPGRADE
					screensound WEAPON_UPGRADE
					palfrom 32 63 63 63
					
				
				}
				
				ife pchar 0 set TMP_A dweaplevel[tempb] else 
				ife pchar 2 
				{
				 set TMP_A wweaplevel[tempb]
				 ife tempb 0 add TMP_A 2
				}
				else
				set TMP_A bweaplevel[tempb]
				ifg TMP_A 6 { sub TMP_A 6 mul TMP_A 4 add TMP_A 48 }
				else
				mul TMP_A 8
				add TMP_A 100
				geta[].htextra temp
				mul temp TMP_A
				div temp 100
				seta[].htextra temp
			}
		}
	}
	
	set temp NO
	ife attmode YES set temp YES
	ifg gametype 0 set temp YES
	ife temp YES
	ifg sprite[].htextra 0
	ifn sprite[].picnum NEWTROOPTARGET
	ifn sprite[].picnum NEWPIGTARGET
	{
		switch SKILL // userdef[].player_skill
		case 0
		case 1 // piece of cake
			geta[].htextra temp
			ife team 1
			{
				div temp 2
				ifl temp 1 set temp 1
				seta[].htextra temp
			}
			else ifn team 3
			{
				mul temp 2
				seta[].htextra temp
			}
		break
		case 2 // lets rock
			geta[].htextra temp
			ife team 1
			{
				mul temp 3 div temp 4
				ifl temp 1 set temp 1
				seta[].htextra temp
			}
			else ifn team 3
			{
				mul temp 4 div temp 3
				seta[].htextra temp
			}
		break
		case 4 // DIG
			// geta[].htextra temp
			// ife team 1
			// {
				// mul temp 5 div temp 4
				// seta[].htextra temp
			// }
			// else ifn team 3
			// {
				// mul temp 3 div temp 4
				// seta[].htextra temp
			// }
		break
		case 5 // Good Day to Die
		case 6 // THIS IS BULLSHIT
		ife gametype 0
		{
			geta[].htextra temp
			ife team 1
			{
				mul temp 5 div temp 4
				seta[].htextra temp
			}
			else ifn team 3
			{
				mul temp 3 div temp 4
				ifl temp 1 set temp 1
				seta[].htextra temp
			}
		}
		break
		endswitch
	}
ends

defstate spritebounce
	
	setvarvar temp sprite[].htmovflag
	andvar temp 49152
	ifvare temp 32768
	{
		// hit a wall
		setvarvar hitwall sprite[].htmovflag
		andvar hitwall 16383
		getwall[hitwall].point2 B
		getwall[hitwall].x x2
		getwall[hitwall].y y2
		getwall[B].x x
		getwall[B].y y
		subvarvar x2 x
		subvarvar y2 y
		getangle angvar x2 y2
		
		getactor[THISACTOR].ang tempb
		getincangle tempc angvar tempb
		subvarvar angvar tempc
		ifvarg angvar 2047 subvar angvar 2048
		ifvarl angvar 0 addvar angvar 2048
		setactor[THISACTOR].ang angvar
		set angvel angvar
	}
	else 
	{
		set spriteid sprite[].htmovflag
		addvar spriteid 16384
		ifvarl spriteid 16384 ifvarg spriteid -1 // hit a sprite
		{
			geta[spriteid].ang angvar
			getincangle temp angvar sprite[].ang
			sub angvar temp
			add angvar 1024
			seta[].ang angvar
			set angvel angvar
			ifactor SBALLACTOR count 30
			ifactor BEACHBALL count 30
		}
	}
	
ends

defstate damagepushenemy

	ifactor LIZTURRET break
	ifactor EDFTURRET break
	ifactor ROTATEGUN break
	ifactor PIGSUV break
	ifactor TANK break
	ifactor NEWTROOPTARGET break
	ifactor NEWPIGTARGET break

// blueflagval amount
// lastangvel direction

ifg sprite[].htextra 50
ife monstatus 1
// ifn mtype 1
{
	ife monstatus 1 ifg sprite[].htextra sprite[].extra break
	
	switch sprite[].htpicnum
	case SHOTSPARK1
	case RPG
	case RADIUSEXPLOSION
	case KICKIMPACT
	geta[].htextra temp
	
	shiftl temp 12
	ife sprite[].htpicnum KICKIMPACT { mul temp 3 div temp 2 }
	
	
	div temp tiledata[sprite[].picnum].xsize
	div temp sprite[].xrepeat
	
	ifg temp 1024 set temp 1024
	
	ifg temp blueflagval
	{
		seta[].xvel 0
		set lastangvel sprite[].htang
		set blueflagval temp
	}
	break
	endswitch
}

ifvarg blueflagval 0
{
	cos xvel lastangvel
	sin yvel lastangvel
	setvarvar temp blueflagval
	// ifvarg temp 1024 setvar temp 1024
	mul xvel temp
	mul yvel temp
	shiftvarr xvel 12
	shiftvarr yvel 12
	 
	movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN 
	// shiftvarr blueflagval 1
	mul blueflagval 3, div blueflagval 5
	ifn RETURN 0 
	{
		// cause damage to hit sprite
		addvar RETURN 16384
		ifvarl RETURN 16384 ifvarg RETURN -1 
		{
			ife sprite[RETURN].htextra -1
			{
				set temp blueflagval
				shiftr temp 3
				ifg temp 0
				{
					seta[RETURN].htextra temp
					seta[RETURN].htpicnum SHOTSPARK1
					seta[RETURN].htowner THISACTOR
					seta[RETURN].htang lastangvel
				}
			}
		}
		set blueflagval 0
	}
	ifvarl blueflagval 2 setvar blueflagval 0
}

ends

defstate damagepush

// dodgetime, angvel

ifg sprite[].htextra 0
{
	geta[].htextra temp
	
	mul temp 844
	ife sprite[].htpicnum KNEE mul temp 2
	
	div temp tiledata[sprite[].picnum].xsize
	ifg temp dodgetime
	{
		ifactor SBALLACTOR set B YES
		ifactor BEACHBALL set B YES
		set angvel sprite[].htang
		set dodgetime temp
		seta[].ang angvel
	}
}



ifvarg dodgetime 0
{
	cos xvel angvel
	sin yvel angvel
	setvarvar temp dodgetime
	ifvarg temp 1024 setvar temp 1024
	mulvarvar xvel temp
	mulvarvar yvel temp
	shiftvarr xvel 13
	shiftvarr yvel 13
	movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN 
	// shiftvarr dodgetime 1
	mul dodgetime 2, div dodgetime 3
	ifn RETURN 0 
	{
		// cause damage to hit sprite
		addvar RETURN 16384
		ifvarl RETURN 16384 ifvarg RETURN -1 
		{
			ife sprite[RETURN].htextra -1
			{
				set temp dodgetime
				shiftr temp 3
				ifg temp 0
				{
					seta[RETURN].htextra temp
					ifactor COVERBLOCK seta[RETURN].htpicnum RPG else
					seta[RETURN].htpicnum SHOTSPARK1
					ifactor COVERBLOCK seta[RETURN].htowner player[].i else
					seta[RETURN].htowner THISACTOR
					seta[RETURN].htang angvel
				}
			}
			set dodgetime 0
		}
		// set dodgetime 0
	}
	ifvarl dodgetime 2 setvar dodgetime 0
}

ends

defstate damagepushblock

// dodgetime, angvel

ifg sprite[].htextra 0
{
	geta[].htextra temp
	
	shiftl temp 11
	ife sprite[].htpicnum KNEE mul temp 2
	
	div temp tiledata[sprite[].picnum].xsize
	ifg temp dodgetime
	{
		set angvel sprite[].htang
		set dodgetime temp
		seta[].ang angvel
	}
}

ifvarg dodgetime 0
{
	cos xvel angvel
	sin yvel angvel
	setvarvar temp dodgetime
	ifvarg temp 8192 setvar temp 8192
	mulvarvar xvel temp
	mulvarvar yvel temp
	shiftvarr xvel 13
	shiftvarr yvel 13
	movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN 
	// shiftvarr dodgetime 1
	mul dodgetime 2, div dodgetime 3
	
	
	ifge dodgetime 4	
	{
		set TMP_B NO
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			set z sprite[].z
			sub z 16384
			ifge sprite[spriteid].z z
			ifn spriteid THISACTOR
			ife actorvar[spriteid].monstatus 1
			{
				set z sprite[].z
				add z 8192
				ifle sprite[spriteid].z z
				{
					ldist xydist THISACTOR spriteid
					ifle xydist 1024
					{
						al spriteid
						set temp dodgetime
						shiftr temp 3
						ifg temp 0
						{
							seta[spriteid].htextra temp
							seta[spriteid].htpicnum RPG 
							seta[spriteid].htowner player[].i
							seta[spriteid].htang angvel
							set TMP_B YES
						}
					}
				}
			}
			nextspritestat spriteid spriteid
		}
		
		ife TMP_B YES div dodgetime 2
	}
	ifvarl dodgetime 2 setvar dodgetime 0
	
}

ends


defstate playerpush

	ifp pstanding break
	findplayer temp
	
	ifhitspace { ifg temp 1408 break }
	else 
	{
		ifactor COVERBLOCK sub temp 512
		ifg temp 844 break
	}
	
	ife dodgetime 0
	ifcansee
	ifp palive
	{
		getp[].posx x2
		getp[].posy y2
		sub x2 sprite[].x
		sub y2 sprite[].y
		getangle angvel x2 y2
		ifhitspace { ifl temp 1024 break  } else
		add angvel 1024
		
		cos xvel angvel
		sin yvel angvel
		
		ifactor SHOPPINGCART
		{
			div xvel 96
			div yvel 96
		}
		else
		{
			shiftvarr xvel 7
			shiftvarr yvel 7
		}
		movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN 
	}

ends

defstate makespeedblur
	espawn SPEEDBLUR
	ifaction 0 setav[RETURN].mtype sprite[].picnum else
	ifaction ANULLACTION setav[RETURN].mtype sprite[].picnum else
	ife sprite[].htpicnum 0 setav[RETURN].mtype sprite[].picnum else
	setav[RETURN].mtype sprite[].htdispicnum
	seta[RETURN].xrepeat sprite[].xrepeat
	seta[RETURN].yrepeat sprite[].yrepeat
	ifg sprite[].alpha 96 seta[RETURN].alpha sprite[].alpha else
	seta[RETURN].alpha 80
	seta[RETURN].pal sprite[].pal
	seta[RETURN].mdflags 16
	seta[RETURN].pitch sprite[].pitch
ends

defstate spawnsmokeonscrap
  ifl sprite[].xrepeat 16 break
  ifge framerate 29
  ifl Numsprites 14000
  ifn sector[].lotag 2
  {
	headspritestat spriteid 5
	whilevarn spriteid -1
	{
		switch sprite[spriteid].picnum
		case SCRAP6 case 2391 case 2392 case 2393 case 2394 case 2395
		case 2396 case 2397 case 2398 case 2399 case SCRAP1 case 2401 
		case 2402 case 2403 case SCRAP2 case 2405 case 2406 case 2407
			ifn sprite[spriteid].htpicnum SECTOREFFECTOR
			{
				dist xydist THISACTOR spriteid
				ifle xydist 2048
				{
					setav[spriteid].mtype 1
					// espawn SMALLSMOKE
					// seta[RETURN].pal 4
					// seta[RETURN].cstat 130
					// setsprite RETURN sprite[spriteid].x sprite[spriteid].y sprite[spriteid].z
					// seta[RETURN].htbposx sprite[spriteid].x
					// seta[RETURN].htbposy sprite[spriteid].y
					// seta[RETURN].htbposz sprite[spriteid].z
				}
			}
		break
		endswitch
		nextspritestat spriteid spriteid
	}
  
  }
  ends

spritenoshade TRACER
move TRACEMOVE
useractor notenemy TRACER 0

ifmove 0
{
	move TRACEMOVE
	cstator 130
	sizeat 28 28
	seta[].shade -127
	ifn sprite[].pal 1
	seta[].blend 255
}
sizeto 0 0
sizeto 0 0
sizeto 0 0
ifcount 8 killit

enda

spritenoshade GLOWLIGHT1
spritenopal GLOWLIGHT1
eventloadactor GLOWLIGHT1 seta[].blend 1 geta[].lotag initsprite seta[].lotag 0 seta[].alpha initsprite cstator 2 enda
useractor notenemy GLOWLIGHT1 0 seta[].blend 1 seta[].alpha initsprite enda

spritenoshade BEAMTRAIL
useractor notenemy BEAMTRAIL 0

	ifmove 0
	{
		seta[].shade -127
		move STOPPED
		cstat 0
		ife rendmode 0 { cstator 128 ifrnd 128 cstator 4 ifrnd 128 cstator 8 }
		geta[].z z add z 512 seta[].z z
		sizeat 24 24
		seta[].pitch shotpitch		
	}

	sizeto 0 0
	ifcount 6 sizeto 0 0

	// ifcount 2 cstator 2
	// ifcount 4 cstator 512

enda

action REND0ACTION -1
spritenoshade ICEBEAMTRAIL
useractor notenemy ICEBEAMTRAIL 0

	ifmove 0
	{
		seta[].shade -127
		move STOPPED
		cstat 0
		sizeat 48 48
		ife rendmode 0 { cstator 128 ifrnd 128 cstator 4 ifrnd 128 cstator 8 action REND0ACTION sizeat 16 16 }
		geta[].z z add z 512 seta[].z z
		
		seta[].pitch shotpitch		
	}

	sizeto 0 0
	sizeto 0 0
	ifcount 4 { sizeto 0 0 sizeto 0 0 }

	ifcount 4 cstator 2
	ifcount 6 cstator 512

enda


spritenoshade TRACER2
useractor notenemy TRACER2 0

ifmove 0
{
	move TRACEMOVE
	cstat 130
	sizeat 24 20
	seta[].shade -127
	seta[].blend 255
}
sizeto 0 0
sizeto 0 0
sizeto 0 0
ifcount 8 killit

enda


spritenoshade PLASMA_EXP
action PLASMA_EXPFRAME 0 6 1 1 8
action PLASMA_EXPFRAME2 123 6 1 1 8
useractor notenemy PLASMA_EXP 0
ifaction 0
{
	ifspawnedby PLAYERPLASMA 
	{ 
		action PLASMA_EXPFRAME 
		spawn SPARKFALL
		spawn SPARKFALL
		ifrnd 64 sound LASERHIT1 else
		ifrnd 64 sound LASERHIT2
	}
	else
	ifspawnedby FIRELASER2 action PLASMA_EXPFRAME2 else
	ifspawnedby FIRELASER3 action PLASMA_EXPFRAME2 else
	ifspawnedby EDFLASER action PLASMA_EXPFRAME2 else
	ifspawnedby SHOTSPARK1 action PLASMA_EXPFRAME2 // firebolt
	else
	action PLASMA_EXPFRAME
	sizeat 26 26
	cstat 130
	seta[].blend 1
	seta[].shade -127
}
ifactioncount 6 killit
enda

spritenoshade SHOCKBALL_EXP
spritenopal SHOCKBALL_EXP
useractor notenemy SHOCKBALL_EXP 0

	ifmove 0
	{
		move STOPPED
		sizeat 2 3
		cstat 642
		seta[].blend 1
		flash
		ifspawnedby SHOCKBALL2 spritepal 49
		ifspawnedby ARCBALLPROJ2 spritepal 23
		ifspawnedby FIRELASER2 spritepal 10
		ifn mtype 0 { ifpdistl 4096 quake 20 } else
		ifpdistl 1280 quake 20
	}
	ifcount 18 
	{ 
		sizeto 0 0 sizeto 0 0 
		ifg sprite[].xrepeat sprite[].yrepeat 
			seta[].yrepeat sprite[].xrepeat
	}
	else 
	{
		ife mtype 1 { sizeto 64 64 sizeto 64 64 sizeto 64 64 }
		else ife mtype 2 { sizeto 192 192 sizeto 192 192 sizeto 192 192 sizeto 192 192 sizeto 192 192 sizeto 192 192 }
		else
		{
			sizeto 32 32 sizeto 32 32
		}
	}

	geta[].cstat B
	add countvar 1
	ifg countvar 2
	{
		set countvar 0
		ife B 642 set B 646 else
		ife B 646 set B 650 else
		ife B 650 set B 642
		seta[].cstat B
		
		ifspritepal 23
		ifl countvar 24
		ife myspawner player[].i
		{
			headspritestat myvictim 1
			whilevarn myvictim -1
			{
				ife actorvar[myvictim].monstatus 1
				{
					dist xydist THISACTOR myvictim
					ifl xydist 2560
					{
						espawn STICKYFIRE
						setav[RETURN].mtype sprite[myvictim].picnum
						setav[RETURN].myspawner myvictim
						seta[RETURN].pal 94
						setsprite RETURN sprite[myvictim].x sprite[myvictim].y sprite[myvictim].z
		
						geta[myvictim].htextra temp
						add temp 3
						seta[myvictim].htextra temp
						seta[myvictim].htpicnum RADWOUND
						seta[myvictim].htowner player[].i
					}
				}
				nextspritestat myvictim myvictim
			}
		}
	}

enda

action COMETEXPFRAMES  0  14  1  1  4
spritenoshade COMETEXP
spritenopal COMETEXP
useractor notenemy COMETEXP 0 COMETEXPFRAMES

	ifmove 0
	{
		move STOPPED
		sizeat 36 32
		cstat 642
		seta[].blend 1
		seta[].shade -100
		flash
	}
	ifactioncount 14 killit
	
	ifactioncount 9 ife mtype 0
	{
		iffloordistl 64 
		{
			espawn GROUNDSHOCK
			getzrange sprite[].x sprite[].y sprite[].z sprite[].sectnum temp temp z spriteid 192 CLIPMASK0
			seta[RETURN].z z
			seta[RETURN].htbposz z
			seta[RETURN].pal sprite[].pal
			
		}
		set mtype 1
	}
enda

action POMEXPFRAMES  0  5  1  1  6
spritenoshade POMEXP
spritenopal POMEXP
useractor notenemy POMEXP 0 POMEXPFRAMES

	ifmove 0
	{
		spritepal 12
		move STOPPED
		sizeat 40 38
		cstat 642
		seta[].blend 1
		seta[].shade -100
	}
	ifactioncount 5 killit
	
	sound SHOOTSPIKE
	set countvarb 0
	rand angvel 2047
	ife sprite[myspawner].pal 43
	{
		setprojectile[POMPROJ].range 15
		setprojectile[STICKYPROJ].xrepeat 12
		setprojectile[STICKYPROJ].yrepeat 12
	}
	
	whilevarn countvarb 12
	{
		rand zdist 10240
		sub zdist 6144
		ezshoot zdist POMPROJ
		seta[RETURN].ang angvel
		seta[RETURN].z sprite[].z
		seta[RETURN].pal 33
		seta[RETURN].owner myspawner
		
		ife sprite[myspawner].pal 43
		ifvarand countvarb 1
		{
			ezshoot zdist STICKYPROJ
			seta[RETURN].ang angvel
			seta[RETURN].z sprite[].z
			seta[RETURN].pal 33
			seta[RETURN].owner myspawner
			setav[RETURN].myspawner myspawner
		}
		
		add countvarb 1
		add angvel 170
	}
	
	ife sprite[myspawner].pal 43
	{
		setprojectile[POMPROJ].range 10
		setprojectile[STICKYPROJ].xrepeat 26
		setprojectile[STICKYPROJ].yrepeat 26
	}
		
enda

defstate trashcode

ifaction 0
{
	action ANULLACTION
	cstator 256
	ifl sprite[].xrepeat 4 sizeat 24 24
	// set monstatus 9
}
fall
ife sprite[].cstat 32768 killit
ifhitweapon 
{ 
	spawn SMALLSMOKE 
	debris SCRAP3 1
	spritepal 2 debris SCRAP3 1
	spritepal 1 debris SCRAP3 1
	spritepal 7 debris SCRAP3 1
	killit
}
ends

useractor notenemy TRASH1 10 state trashcode enda
useractor notenemy TRASH2 10 state trashcode enda
useractor notenemy TRASH3 10 state trashcode enda
useractor notenemy TRASH4 10 state trashcode enda
useractor notenemy TRASH5 10 state trashcode enda
useractor notenemy TRASH6 10 state trashcode enda
useractor notenemy TRASH7 10 state trashcode enda
useractor notenemy TRASH8 10 state trashcode enda
useractor notenemy TRASH9 10 state trashcode enda
useractor notenemy TRASH10 10 state trashcode enda

useractor notenemy SMOKER 0

add countvar 1
ifge countvar SPRITELOTAG
{
	randvarvar temp SPRITELOTAG
	mul temp 2
	ifge temp SPRITELOTAG
	{
		espawn BIGSMOKE
		rand angvar 2047
		
		set x sprite[].x
		randvarvar x2 initsprite
		add x x2
		rotatepoint sprite[].x sprite[].y x sprite[].y angvar y y2
		geta[].z z, sub z 4096
		setsprite RETURN y y2 z
		seta[RETURN].pal sprite[].pal
		seta[RETURN].shade botclip
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		seta[RETURN].htbposx y
		seta[RETURN].htbposy y2
		seta[RETURN].htbposz z
		seta[RETURN].htflags 4
		ifn mtype 0 seta[RETURN].alpha mtype
		set countvar 0
	}
}

enda

action FAKEDOORANIM	620  5  1  1  12
action FAKEDOOROPEN 624
action FAKEDOORCLOSED 618

eventloadactor FAKEDOOR

ifspritepal 4 cstat 32768
ifspritepal 33 cstat 32768
getactor[THISACTOR].hitag initsprite // must match hitag on another FAKEDOOR
setactor[THISACTOR].hitag 0
getactor[THISACTOR].lotag SPRITELOTAG // sound played (will play default sound if not set)
setactor[THISACTOR].lotag 0
ifn sprite[].extra -1 geta[].extra initflags
enda

useractor notenemy FAKEDOOR 0 FAKEDOORCLOSED

ife transition 0
{
	action FAKEDOORCLOSED
}
else
{
	
	ifaction FAKEDOORANIM
	ifactioncount 5 action FAKEDOOROPEN
	break
}
	
ife monstatus 2 killit

ifangdiffl 768 nullop else
ifspritepal 4 nullop else
ifp palive
ifcansee ifpdistl 1408
{
	ifhitspace
	{
		stopsound B_GRUNT stopsound B_GRUNT2 stopsound B_SEARCH
		stopsound DUKE_SEARCH stopsound DUKE_SEARCH2
		ifvarn SPRITELOTAG 0 soundvar SPRITELOTAG else globalsound DOOR_OPERATE2
		setvar transition 60
		action FAKEDOORANIM
		getplayer[THISACTOR].i spriteid
		setactorvar[spriteid].myspawner THISACTOR
	}
	else setvar handicon 3
}

enda


spriteflags MOVESHIPCAM 8192
eventloadactor MOVESHIPCAM

ife sprite[].pal 4
	geta[].ang shipangstart 
else
{
	geta[].lotag SPRITELOTAG
	setarray shipcams[SPRITELOTAG] THISACTOR
	seta[].lotag 0
	geta[].hitag initflags
	seta[].hitag 0
	
	geta[].extra monstflags
	geta[].xvel countvarc // shipangoff
	geta[].yvel initsprite
	seta[].yvel 0
	ife monstflags -1 set monstflags 0
	ifn SPRITELOTAG 0 cstat 32768
	// sizeat 200 200
	// cstat 0
	// ifn SPRITELOTAG 1 set initsprite 0
	geta[].x countvar
	geta[].y countvarb
	geta[].z float
	geta[].sectnum botclip
}

enda

useractor notenemy MOVESHIPCAM 0 enda

action EXPLOSION3FRAMES  0  8  1  1  10
useractor notenemy EXPLOSION3 0 EXPLOSION3FRAMES

ifactioncount 8 killit
ifl sprite[].xrepeat 8 sizeat 64 60
ifmove 0
{
	seta[].blend 1
	cstator 2
	seta[].shade -100
	move STOPPED
	iffloordistl 4 spawn EXPLOSION2BOT
}
state spawnsmokeonscrap

enda


// 0 DEFAULT
// 1 WOOD
// 2 TIN
// 3 GRATE
// 4 GRASS
// 5 TILE
// 6 CARPET
// 7 CONCRETE
// 8 SNOW
// 9 WATER
// 10 ELECTRONIC
// 11 ORGANIC

defstate tiletype

switch picnum

case 0 set TILETYPE 0 break

case 70 case 370 case 735 case 745 case 749 case 821 case 822 case 879 case 880 case 884
case 1188 case 1200 case 1201 case 4110 case 4111 case 4303 case 4428 case 1170
// DC steps
case 3684 case 3685 case 3691

case 7019 case 7035 case 7037 case 7100 case 7101 case 7102 case 7103 case 7112

// WOOD
case 11413 case 11414 case 11415 case 11465 case 11466 case 11468 case 11469
case 11805 case 11819 case 11826 case 11827 case 11838 case 11839 
case 11840 case 11841 case 11842 case 11859 case 11870 case 11888 
case 11896 case 11940 case 11950 case 11951 case 11952 case 11972
case 15747 case 15748 case 15760 case 15761 case 15768 case 15771
case 15778 case 15779 case 15780 case 16116 case 16117 case 16118
case 16119 case 16120 case 16121
case NEWTROOPTARGET case NEWPIGTARGET 
case WOODENHORSE
case HORSEONSIDE
// NUWOOD
set TILETYPE 1 break

case 150 case 151 case 152 case 153 case 154 case 155 case 156 case 157 case 158 case 159
case 182 case 195 case 196 case 211 case 216 case 218 case 220 case 221 case 222 case 223 case 224
case 226 case 227 case 231 case 232 case 242 case 243 case 244 case 257 case 258 case 259
case 278 case 283 case 284 case 285 case 286 case 287 case 288 case 289 case 290 case 291
case 292 case 294 case 295 case 296 case 300 case 302 case 303 case 309 case 311 case 312 
case 313 case 314 case 315 case 317 case 318 case 319 case 322 case 325 case 327 case 344 
case 345 case 346 case 347 case 348 case 350 case 354 case 365 case 366 case 369 case 373
case 374 case 375 case 378 
case 379 case 380 case 381 case 382 case 383 case 384 case 385 case 392 case 393 case 394 
case 395 case 396 case 397 case 399 case 400 case 407 case 408 case 409 case 410 case 411
case 412 case 413 case 418 case 419 case 420 
case 441 case 442 case 447 case 448 case 449 case 450 case 451 case 452 case 453 case 454 
case 455 case 456 case 457 case 458 case 459 case 460 case 467 case 469 case 470 case 471 
case 513 case 514 case 515 case 609 case 665 case 709 case 711 case 715 case 717 case 736 
case 737 case 738 case 739 case 754 case 755 case 756 case 767 case 795 case 797 case 798 
case 829 case 843 case 877 case 883 case 886 case 913 case 962 case 946 case 947 case 948 
case 1024 case 1097 case 1098 case 1099 case 1102 case 1103
case 1107 case 1108 case 1109 case 1110 case 1117 case 1118 
case 1119 case 1120 case 1124
case 1144 case 1173 case 1178 case 1179 case 1187 case 1190 case 4097 case 4098
case 4099 case 4105 case 4106 case 4108 case 4109 case 4117 case 4118 case 4119 case 4162
case 4163 case 4164 case 4165 case 4168 case 4201 case 4202 case 4206 case 4276 case 4277
case 4278 case 4279 case 4282 case 4283 case 4284 case 4285 case 4286 case 4287 case 4288
case 4300 case 4301 case 4302 case 4304 case 4305 case 4308 case 4309 case 4310 case 4330
case 4331 case 4334 case 4335 case 4349 case 4350
case 3693 case 3694 case 3727 case 3779
case BLUEBALLVEND case SNACKVEND case BLUEBALLBROKE case SNACKBROKE case ASIANVEND
case 6886
case 6912 case 6913 case 6914 case 6917 case 6918 case 6919 case 6921 
case 6922 case 6923 case 6929 case 6931 case 6934 case 6935 case 6936 
case 6937 case 6938 case 6939  case 6941 case 6945 case 6949 case 6951 
case 6952 case 6953
case 6960 case 6970 case 6972 case 6973 case 6974 case 6975 case 7001 
case 7002 case 7011 case 7014 case 7032 case 7039 case 7040 case 7042 
case 7043 case 7044 case 7045 case 7047 case 7048 case 7049 case 7050 
case 7054 case 7059 case 7063 case 7064 case 7066 case 7068 case 7108 
case 7109 case 7113 case 7116

case 11467 case 11854 case 11855 case 11857 case 11858 
case 11860 case 11861 case 11862 case 11863 case 11869 case 11886 
case 11916 case 11921 case 11924 case 11933 case 11937 case 11943 
case 11947 case 11948 case 12548 case 12550 case 12554 case 12555 
case 12559 case 12561 case 12562 case 12563 case 12564 case 12565 
case 12566 case 12567 case 12568 case 12571 case 12574 
case 12576 case 12577 case 12578 case 12579 
case 12580 case 12581 case 12582 case 12583 
case 12584 case 12585 case 12586 case 12587 case 12588 case 12589 
case 12590 case 12591 case 12592 case 12593 case 12594 case 12595 
case 12596 case 12597 case 12598 case 12599 case 12600 case 12603 
case 12604 case 12605 case 12606 case 12607 case 12608 case 12609 
case 12610 case 12611 case 12614 case 12615 case 12619 case 12623 
case 12624 case 12625 case 12626 case 12627 case 12628 case 12629 
case 12630 case 12631 case 12632 case 12633 case 12634 case 12635 
case 12636 case 12637 case 12638 case 12639 case 12640 case 12641 
case 12642 case 12643 case 12644 case 12645 case 12646 case 12647 
case 12648 case 12649 case 12650 case 12651 case 12652 case 12653 
case 12654 case 12655 case 12656 case 12657 case 12658 case 12659 
case 12660 case 12661 case 12662 case 12663 case 12664 case 12665 
case 12666 case 12667 case 12668 case 12669 case 12670
case 12671 case 12672 case 12673 case 12675 case 12676
case 12677 case 12678 case 12679 case 12680 case 12681 case 12682
case 12683 case 12684 case 12685 case 12686 case 12687 case 12688
case 12689 case 12690 case 12691 case 12692 case 12693  
case 12697 case 12698 case 12699 case 12700 case 15783 case 15784
case 12701 case 12702 case 12703 case 12704 case 12705 case 12706 
case 12707 case 12708 case 12709 case 12710 case 12711 case 12715
case 12716 case 12717 case 12718 case 12719 case 12720 case 12721
case 12722 case 12723 case 12724 case 12730 case 12731 case 12732 
case 12733 case 12734 case 12735 case 12736 case 12737 case 12738 
case 12739 case 12740 case 12741 case 12742 case 12743 case 12744 
case 12745 case 12746 case 12747 case 12748 case 12749 case 15782
case 12750 case 12751 case 12752 case 12753 case 12754 case 12759
case 12760 case 12761 case 12762 case 12763 case 12771 case 12772
case 12773 case 12774 case 12776 case 12777 case 12778 case 12779
case 12780 case 12781 case 12785 case 15749 case 15750 case 15769
case 15867 case 15868 case 15869 case 15870 case 15889 case 16123
case 16124 case 16125 case 16126
case 18688 case 18689 case 18690 case 18691 case 18692 case 18693
case 18694 case 18695 case 18696 case 18697 case 18698 case 18699
case 18700 case 18701 case 18702 case 18703 case 18704 case 18705
case 18706 case 18707 case 18708 case 18709 case 18710 case 18711
case 18712 case 18713 case 18714 case 18715 case 18716 case 18717
case 18718
// NUMETAL


case BOSS1STATUE case BOSS2STATUE case BOSS3STATUE case FORCEBUBBLE
case EDFDRONE case NEWSENTRY case MECHBRAIN case CANHEAD case CYCLOIDMAX case FLYINGFIST case CANHEADNOARMS case FOODCART case OSCAR
case LIZTURRET case EMPTYTURRET case EDFTURRET case EMPTYEDFTURRET
case SPIDERMINE case SPIDERWALK
case CHAIRBROKE1
case SHOPPINGCART
case COVERBLOCK case ROBOTMOUSE
case EDFTANK case EDFTANKTURRET case BLACKHAWK
case BMWM4 case COPCAR case TAXI case CRUZ case CIVIC case PORSCHE case LAMBO90
case BEETLE case HUMMER case JEEP case LIMO case PICKUP case PICKUP2 case VAN1
case VAN2 case WRECKEDCAR case DODGECAR case FORD case ROVER
case BMWM3 case NANOCOOPER case TOWTRUCK case CHEVELLE case OLDCAR 
case FLYCAR_1 case FLYCAR_2 case FLYCAR_3
case FLYCAR_PARKED1 case FLYCAR_PARKED2 case FLYCAR_PARKED3 case FLYCAR_PARKED4
case EDFTANKWRECK case MICROBUS case AUDIA
case TERMINATOR case TERMINATORDUCKING case TERMINATORCRAWLING case ROLLYTURRET
case CHEERBOT
case GEISHA1 case GEISHA2 case GEISHA3 case GEISHA4
case DRONE case TANK case TANKWRECK case ROTATEGUN 
case RECONWRECK 
case PATROLSENTRY case SPYDRONE
case SIDEGUN 
case PARKMETER case PARKMETER2 case PARKMETERBROKE
// METAL
set TILETYPE 2 break

case RECON case NEWRECON case PIGSUV 
case PSPIDER case PSPIDERJUMPING case DRPROTON case ARMEDF
case LIZBOSS case MANDOFETT case MANDOCROUCH ifrnd 128 set TILETYPE 2 break

case ARMPIG
	ifl actorvar[hitsprite].mtype 2
	set TILETYPE 2 break

case 183 case 342 case 710 case 915 case 4154 case 4155
// DC steps
case 3712 case 3732

// NEW TILES
case 6955 case 6981 case 6991 case 6992 case 6997 case 6999 case 7038 case 7067 case 7110
case 12544 case 12545 case 12546 case 12552 case 12569 case 12570 
case 12712 case 12714 case 12788
// METAL, GRATES
set TILETYPE 3 break

// GRASS or dirt
case 803 

case 11322 case 11323 case 11324
case 11798 case 11804 case 11812 case 11894 case 11935 case 11941 case 11942 case 11969 case 11984 case 11985  
// NUDIRT
set TILETYPE 4 break

case 186 case 187 case 188 case 189 case 190 case 191 case 192 case 246 case 332 case 720 
case 857 case 1205 case 4102
case 3692

// NEW TILES
case 6926 case 6927 case 6944 case 6980 case 7003
case 15756 case 15757 case 15758 case 15759
case 16115
// NUTILE
set TILETYPE 5 break

case 1219 // could be grass or carpet
gets[].floorpal temp
ifvare temp 0
ifoutside set TILETYPE 4
else set TILETYPE 6
break

case 331 
case 545 case 898 case 899 case 900 case 1218
// DC steps
case 3604 case 3612 case 3613 case 3614 case 3615 case 3616


case 7111 case 15753 case 15754 case 15755 case 16101 case 16102 case 16103
case 16104 case 16332 case 16333
// NUCARPET
set TILETYPE 6 break

case 181 case 184 case 197 case 207 case 209 case 236 case 237 
case 238 case 239 case 240 case 251 case 252
case 334 case 335 case 349 case 367 case 368 case 372 
case 376 case 377 case 414 case 417 case 429 case 430 case 431 case 432 
case 433 case 434 case 435 case 437 case 461 case 465 case 466 case 468 
case 478 case 718 case 723 case 724 case 725 case 734 case 742 
case 743 case 747 case 748 case 750 case 757 case 759 case 760 
case 761 case 763 case 764 case 770 case 772 case 773 case 775 case 780 
case 781 case 782 case 783 case 790 case 793 case 794 case 796 case 799 case 800 
case 801 case 802 case 804 case 805 case 812 case 814 case 815 case 816 
case 817 case 818 case 819 case 823 case 824 case 825 case 827 case 828 
case 852 case 853 case 859 case 876 case 887 case 893 case 894 
case 895 case 1169 case 1171 case 1182 case 1183 case 1184 case 1185 
case 1186 case 1189 case 1191 case 1193 case 1204 case 1279 case 2922 
case 3381 case 3384 case 3385 case 3386 case 3387 case 3394 case 3395 case 3396 
case 3398 case 3407 case 4112 case 4151 case 4152 case 4190 case 4208 
case 4210 case 4211 case 4212 case 4213 case 4214 case 4215 case 4216 case 4217 
case 4218 case 4219 case 4220 case 4221 case 4222 case 4223 case 4234 case 4235 
case 4236 case 4255 case 4259 case 4319 case 4320 case 4321 
case 4322 case 4323 case 4332 case 4333 case 5065 case 5066 case 5067 case 5068 
case 5069 case 5070 case 5071 case 5072 case 5073 case 5074 case 5075 case 5076 
case 5077 case 5078 case 5083

// NEW TILES
case 6916 case 6928 case 6932 case 6933 case 6940 case 6942 case 6946 case 6947 case 6948 case 6954 case 6979 case 6982 case 6983 case 6984 case 6985 case 6986 case 6987 case 6988 case 6989 case 7005 case 7008 case 7009 case 7010 case 7012 case 7015 case 7016 case 7017 case 7018 case 7022 case 7025 case 7029 case 7034 case 7086
case 7114 case 7115 case 7118 case 7119 case 7125 case 7126 case 7127 case 7130 case 7131 case 7133
case 11367 case 11449 case 11450
case 11794 case 11796 case 11797 case 11799 case 11800 case 11801 case 11802
 case 11803 case 11807 case 11808 case 11809 case 11810 
 case 11811 case 11814 case 11815 case 11816 case 11817 case 11818 
 case 11820 case 11821 case 11828 case 11829 case 11830 case 11831 
 case 11834 case 11835 case 11836 case 11837 case 11850 case 11851 
 case 11852 case 11853 case 11856 case 11867 case 11868 case 11871 
 case 11872 case 11873 case 11874 case 11875 case 11876 case 11881 
 case 11882 case 11883 case 11884 case 11885 case 11887 case 11889 
 case 11892 case 11897 case 11898 case 11899 case 11901 case 11902 
 case 11904 case 11905 case 11907 case 11908 case 11909 case 11910 
 case 11911 case 11912 case 11913 case 11914 case 11915 case 11919 
 case 11920 case 11925 case 11926 case 11927 case 11928 case 11929 
 case 11931 case 11932 case 11934 case 11936 case 11938 case 11945 
 case 11946 case 11949 case 11954 case 11955 case 11958 case 11959 
 case 11963 case 11973 case 11974 case 11975 case 11976 case 11977 
 case 11979 case 11980 case 11981 case 11982 case 11987 case 11989 
 case 12549 case 12556 case 12573 case 12575 case 12613 case 12674
 case 12694 case 12695 case 12696 case 12727 case 12728 case 12729
 case 12755 case 14068 case 14069
 case 15665 case 15666 case 15667 case 15668 case 15669 case 15670 case 15671
 case 15710 case 15711 case 15712 case 15713 case 15714 case 15715 case 15716 
 case 15717 case 15718 case 15719 case 15720 case 15767 case 15866
 case 16099 case 16100 case 16366 case 16367 case 16368 case 16369 case 16370
 case 16371 case 16372 case 16373 case 16374 case 16375 case 16376
 case 16377 case 16378 case 16379 case 16380 case 16381 case 16382 case 16383
// NUCONCRETE
set TILETYPE 7 break

case 3416
getsector[].floorpal temp
ifvare temp 0
set TILETYPE 8
else ifvare temp 6 set TILETYPE 4
else set TILETYPE 7
break

case 241
ifvare sector[].floorpal 0
ifvarl sector[].floorshade 10
ifoutside
set TILETYPE 8
// NUSNOW type 8
else ifvare temp 6 set TILETYPE 4
else set TILETYPE 7
break

case 336 case 337 case 338 case 889 case 890 case 891 case 892
case 7071 case 7092
// NUWATER 9
set TILETYPE 9 break


case 203 case 268 case 269 case 270 case 271 case 272 case 273 case 274
case W_TECHWALL1 case W_TECHWALL2 case 298 case W_TECHWALL15 case W_TECHWALL4 case W_TECHWALL16
case 357 case 358 case 359 
case 360 case 361 case 362 case 363 case 426 case 427 case 428
case 806 case 4127 case 4130 case 4131 case 4132 case 4133 case 4134
case 4135 case 4136 case 4137 case 4138 case 4139 case 4140
case 4141 case 4142 case 4143 case 4144 case 4145 case 4146 case 4147
case 4924 case 4932
case 5865 case 5866 case 5867 case 5868 case 5869 case 5870 case 5871
case 6829 case 6832 case 6835 case 6838 case 6841
case 6876 case 6877 case 6878 case 6879 case 6880 case 6881 case 6882 case 6883 
case 6884 case 6885 case 6887 case 6888 case 6889 case 6890 case PHONYBREAK

ifactor BULLETHOLE set TILETYPE 10 else
ifactor SHOTSPARK1 set TILETYPE 10 else
ifactor 1 set TILETYPE 10 else
ifactor 2 set TILETYPE 10 else
set TILETYPE 7
// NUELECTRONIC 10
break

case 1100
case 1116 case 1130 case 1131 case 1137 case 1139 case 1140 case 1141
case 5079 case 5080 case 5099 case 5102
set TILETYPE 11
// NUSQUISHY
break
default 

break
endswitch

ends

spritenopal BLOODEXP
spritenoshade BLOODEXP
action ABLOODEXPFRAMES 0  4  1  1  14
useractor notenemy BLOODEXP 0 ABLOODEXPFRAMES

	ifmove 0
	{
		move STOPPED
		cstat 128
		seta[].shade -5
		spritepal 10
		ifspawnedby BLOODBOMB
		{
			sizeat 8 8
			guts JIBS6 8
			guts JIBS3 4
			spawn BLOODPOOL2
			
			set countvar 0
			set angvel 0
			set startx sprite[].x
			
			whilevarn countvar 48
			{
				set startx sprite[].x
				add startx 512
				rand x 3072
				add startx x
				ifrnd 84 espawn BLOODSPLASH1 else ifrnd 128 espawn BLOODSPLASH2 else espawn BLOODSPLASH3
				rotatepoint sprite[].x sprite[].y startx sprite[].y angvel newx newy
				seta[RETURN].x newx
				seta[RETURN].htbposx newx
				seta[RETURN].y newy
				seta[RETURN].htbposy newy
				
				set savz sprite[].z
				sub savz 1024
				rand z 4096
				sub savz z
				seta[RETURN].z savz
				seta[RETURN].htbposz savz
				
				add countvar 1
				add angvel 43
			}
			headspritestat myspawner 1
			whilevarn myspawner -1
			{
				ife actorvar[myspawner].monstatus 1
				// ife actorvar[myspawner].team 0
				ifn actorvar[myspawner].team 1
				ifn actorvar[myspawner].team 3
				{
					dist temp THISACTOR myspawner
					ifl temp 3584
					{
						set TMP_A wweaplevel[SHRINKER_WEAPON]
						add TMP_A 1
						mul TMP_A 12
						add TMP_A 40 // damage
						
						set tempd TMP_A

						shiftl tempd 4
						add leach tempd
						al leach
						geta[myspawner].htextra tempc
						add tempc TMP_A
						seta[myspawner].htextra tempc
						seta[myspawner].htowner player[].i
						seta[myspawner].htpicnum BLOODBULLET
	
						getav[myspawner].bleeding tempc
						ifl tempc 0 mul tempc -1
						add tempc TMP_A
						setav[myspawner].bleeding tempc
						
						espawn BIGSMOKE2
						seta[RETURN].pal 10
						setsprite RETURN sprite[myspawner].x sprite[myspawner].y sprite[myspawner].z
					}
				}
				nextspritestat myspawner myspawner
			}
			
		}
		else
		{
			sizeat 4 4
			sound SQUISHED6
			guts JIBS6 2
			iffloordistl 4 ifrnd 32 spawn BLOODPOOL2
		}
	}
	ifspawnedby BLOODBOMB
	{
		sizeto 64 64
		sizeto 64 64
		sizeto 64 64
		sizeto 64 64
	}
	else
	{
		sizeto 24 24
		sizeto 24 24
		sizeto 24 24
	}
	ifactioncount 4 killit
enda


useractor notenemy EXPLOSION4 0 EXPLOSION3FRAMES

ifactioncount 8 killit
ifl sprite[].xrepeat 8 sizeat 42 40
ifmove 0
{
	seta[].blend 1
	cstator 642
	seta[].shade -100
	move STOPPED
	ifrnd 128 cstator 4
	ifrnd 128 cstator 8
	ifspawnedby BIGBOIPROJ 
	{
		spritepal 21
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			ife actorvar[spriteid].monstatus 1
			{
				dist xydist THISACTOR spriteid
				ifle xydist 1280
				{
					getav[spriteid].burning burning
					add burning 60
					setav[spriteid].burning burning
					seta[spriteid].htowner player[].i
					soundonce RADFRY
				}
			}
			nextspritestat spriteid spriteid
		}
	}
}

enda

action GROUNDSHOCKFRAMES  0  5  1  1  8
spritenoshade GROUNDSHOCK
spritenopal GROUNDSHOCK
useractor notenemy GROUNDSHOCK 0 GROUNDSHOCKFRAMES

	ifmove 0
	{
		move STOPPED
		sizeat 40 32
		cstat 514
		seta[].blend 1
		seta[].shade -100
		flash
	}
	ifactioncount 5 killit
enda

action AIRSHOCKFRAMES  0  5  1  1  8
spritenoshade AIRSHOCK
spritenopal AIRSHOCK
useractor notenemy AIRSHOCK 0 AIRSHOCKFRAMES

	ifmove 0
	{
		move STOPPED
		sizeat 40 32
		cstat 514
		seta[].blend 1
		seta[].shade -100
		ifspawnedby BIGPLASMA
			cstator 128
		else
		ifspawnedby SWIRLPROJ
			cstator 128
		else
		ifspawnedby SHOCKPROJ
			cstator 128
		else
		ifspawnedby PURPPROJ
		{
			cstator 128
			sizeat 30 24
		}
		else
		ifspawnedby LOVEBOMB
		{
			cstator 128
			sizeat 72 72
			headspritestat spriteid 1
			whilevarn spriteid -1
			{
				ife actorvar[spriteid].monstatus 1
				ife actorvar[spriteid].team 0
				ifl sprite[spriteid].htextra 100
				ifn sprite[spriteid].htpicnum GROWSPARK
				ifn sprite[spriteid].htpicnum LOVEBOMB
				{
					dist temp THISACTOR spriteid
					ifl temp 5120
					{
						seta[spriteid].htextra 100
						seta[spriteid].htowner player[].i
						seta[spriteid].htpicnum GROWSPARK
					}
				}
				nextspritestat spriteid spriteid
			}
		}
		else
		ife mtype 1
		{
			spawn BIGSMOKE
			flash
		}
		else
		ife mtype 2
		{
			ifpdistl 1024 palfrom 24 24
			cstator 128
		}
		else
		ifspawnedby RADPROJ
		{
			spritepal 76
			espawn BIGSMOKE
			seta[RETURN].pal 76
			ife team 1 seta[RETURN].pal 90
		}
		else
		flash
	}
	ifactioncount 5 killit
enda


spritenoshade ICEBEAMIMPACT
spritenopal ICEBEAMIMPACT
useractor notenemy ICEBEAMIMPACT 0

	ifmove 0
	{
		move STOPPED
		sizeat 10 8
		cstat 130
		// seta[].blend 1
		findnearactorz BURNING 844 6144 target
		ifn target -1 setav[target].monstatus 2
		findnearactorz BURNING2 844 6144 target
		ifn target -1 setav[target].monstatus 2
		findnearactorz FIRE 844 6144 target
		ifn target -1 setav[target].monstatus 2
		findnearactorz FIRE2 844 6144 target
		ifn target -1 setav[target].monstatus 2
		findnearspritez TOILETWATER 844 6144 target
		ifn target -1 
		ifg sprite[target].xrepeat 5
		{
			setav[target].monstatus 2
			geta[target].xrepeat x add x 2 seta[target].xrepeat x
			geta[target].yrepeat y add y 2 seta[target].yrepeat y
			sound NEWFREEZE
		}
		
		
	}
	ifcount 10 
	{ 
		sizeto 0 0 sizeto 0 0 
	}

	geta[].cstat B
	add countvar 1
	ifg countvar 2
	{
		set countvar 0
		ife B 130 set B 134 else
		ife B 134 set B 138 else
		ife B 138 set B 130
		seta[].cstat B
	}

enda

useractor notenemy SHOCKBALL 0 // actor version

	sizeat 24 24
	cstat 642
	ifcount 2 killit

enda

useractor notenemy SHOCKBALL2 0 // actor version

	sizeat 24 24
	cstat 642
	ifcount 2 killit

enda

useractor notenemy PADPROJ 0 // actor version

	sizeto 0 0
	ifcount 5 killit
	ifmove 0
	{
		move STOPPED
		sizeat 15 15
		seta[].shade -127
	}
	ife sprite[].cstat 642 cstat 646 else
	ife sprite[].cstat 646 cstat 650 else
	ife sprite[].cstat 650 cstat 654 else
	cstat 642

enda

action BMFGANIM1 0 17 1 1 4
action BMFGANIM2 10 1  1 1 4
action BMFGANIM3 9 8  1 1 4
action BMFGANIM4 16 1 1 1 4

spritenoshade BMFGIMPACT
spritenopal BMFGIMPACT
move BMFGACTIVE

defstate bmfgdamagestate
		
	ifn actorvar[myvictim].monstatus 1 { set myvictim -1 break }
	ife sprite[myvictim].statnum 1024 { set myvictim -1 break }
	geta[myvictim].z z
	sub z 8192
	setsprite THISACTOR sprite[myvictim].x sprite[myvictim].y z
	
	espawn STICKYFIRE
	setav[RETURN].mtype sprite[myvictim].picnum
	setav[RETURN].myspawner myvictim
	seta[RETURN].pal 46
	setsprite RETURN sprite[myvictim].x sprite[myvictim].y sprite[myvictim].z
	
	ifl sprite[myvictim].extra 1500 
	setav[myvictim].stun 3
	else
	ifrnd 12 setav[myvictim].stun 16
	
	geta[myvictim].htextra temp
	add temp 8
	seta[myvictim].htextra temp
	seta[myvictim].htpicnum RPG
	seta[myvictim].htowner player[].i
			
ends

defstate bmfgpullstate

	headspritestat spriteid 1 // 990
	whilevarn spriteid -1
	{
		ife actorvar[spriteid].monstatus 1
		ifn actorvar[spriteid].team team
		ifn actorvar[spriteid].team 3
		{
			set target spriteid // actorvar[spriteid].mysignpost
			ifn target -1
			{
				dist xydist THISACTOR target
				ifl xydist 8192
				{
					canseespr THISACTOR target temp
					ife temp YES
					{
						geta[target].x x2
						geta[target].y y2
						sub x2 sprite[].x
						sub y2 sprite[].y
						getangle angvar x2 y2
							
						add angvar 1024
						cos xvel angvar
						sin yvel angvar
						
						ife target player[].i
						{
							shiftvarl xvel 5
							shiftvarl yvel 5
							
							add xvel player[].posxv
							add yvel player[].posyv
							setplayer[].posxv xvel
							setplayer[].posyv yvel
						}
							  
						shiftvarr xvel 7
						shiftvarr yvel 7
						
						geta[].z z
						sub z sprite[target].z
						shiftr z 1
							
						ifg xydist 1024
						movesprite target xvel yvel z CLIPMASK0 RETURN
						
						setav[target].bottarget -1
						rand angvar 2047
						seta[target].ang angvar
						seta[target].xvel 0
						
						ifl xydist 3072
						ife actorvar[target].shrunken 0
						{
							ifspritepal 10 nullop else
							{
								espawn SHRINKEREXPLOSION
								setav[RETURN].myvictim target
								setsprite RETURN sprite[target].x sprite[target].y sprite[target].z
							}
							ifspritepal 10 seta[target].htpicnum RPG else
							seta[target].htpicnum SHRINKSPARK
							ife team 1 seta[target].htowner player[].i
							else seta[target].htowner THISACTOR
							ifl sprite[target].htextra 1 
							{
								seta[target].htextra 1
							}
						}
						else ifspritepal 22
						ifl xydist 1280
						ifvarand player[].player_par 1
						{
							seta[target].htpicnum RPG
							ife team 1 seta[target].htowner player[].i
							else seta[target].htowner THISACTOR
							ifl sprite[target].htextra 3
							seta[target].htextra 3
						}
						
					}
				}
			}
		}
		nextspritestat spriteid spriteid
	}

ends

defstate bmfgspawn

	headspritestat myvictim 1
	whilevarn myvictim -1
	{
		ife actorvar[myvictim].monstatus 1
		ifn actorvar[myvictim].team team
		{
			dist xydist THISACTOR myvictim
			ifl xydist 6144
			{
				ifspritepal 22 espawn SHRINKEREXPLOSION else
				ifspritepal 10 { espawn SHRINKEREXPLOSION seta[RETURN].pal 10 } else
				espawn BMFGIMPACT
				setav[RETURN].mtype 1
				setav[RETURN].myvictim myvictim
				geta[myvictim].z z 
				ifn sprite[].pal 22 sub z 8192
				setsprite RETURN sprite[myvictim].x sprite[myvictim].y z
			}
		}
		nextspritestat myvictim myvictim
	}

ends

useractor notenemy BMFGIMPACT 0 BMFGANIM1

ifmove 0
{
	flash
	ifspawnedby ARCBALLPROJ 
	{
		set initsprite ARCBALLPROJ
		spritepal 23
		geta[].z z
		sub z 8192
		seta[].z z
		ifcansee ifpdistl 6632
		{
			set spriteid player[].i
			geta[spriteid].x x2
			geta[spriteid].y y2
			sub x2 sprite[].x
			sub y2 sprite[].y
			getangle angvar x2 y2
			cos xvel angvar
			sin yvel angvar
		
			shiftvarl xvel 11
			shiftvarl yvel 11
			add xvel player[].posxv
			add yvel player[].posyv
			setplayer[].posxv xvel
			setplayer[].posyv yvel
			ifp phigher nullop else
			{
			getp[].posz z
			sub z 1024
			setp[].posz z
			setp[].poszv -4096
			}
			// push player backwards
		}
		
		set countvar 16
		set angvar sprite[].ang
		whilevarn countvar 0
		{
			shoot ARCBALLPROJ2
			add angvar 128
			seta[].ang angvar
			sub countvar 1
		}
	
	}
	seta[].shade -100
	seta[].blend 1
	cstator 2
	move STOPPED
	cstator 128
	ife mtype 1 sizeat 8 8 else
	{
		sizeat 20 20
		ifpdistl 8192 quake 15
	}
	
}

ifaction BMFGANIM1
{
	ifactioncount 4 
	ifmove STOPPED
	{
		ife mtype 0 ifn initsprite ARCBALLPROJ state bmfgspawn
		move BMFGACTIVE
		ifcansee 
		{
			findplayer xydist
			setvar xydist2 16384
			subvarvar xydist2 xydist
			ifvarg xydist2 0
			{
				shiftvarr xydist2 8
				addvar xydist2 8
				ifvarg xydist2 63 setvar xydist2 63
				ifvarvarl player[THISACTOR].pals_time xydist2
				setplayer[THISACTOR].pals_time xydist2
				
				ifspritepal 22
				{
					setplayer[THISACTOR].pals 0 8
					setplayer[THISACTOR].pals 1 63
					setplayer[THISACTOR].pals 2 12
				}
				else
				ifspritepal 10
				{
					setplayer[THISACTOR].pals 0 16
				}
				else
				{
					setplayer[THISACTOR].pals 0 57
					setplayer[THISACTOR].pals 1 57
					setplayer[THISACTOR].pals 2 63
				}
			}
		}
	}
	ifactioncount 9 
		action BMFGANIM2
}

ife mtype 1 ifn myvictim -1 state bmfgdamagestate
else ifspritepal 22 state bmfgpullstate
else ifspritepal 10 { state bmfgpullstate ifactorsound THISACTOR WARPLOOP nullop else sound WARPLOOP }

ifaction BMFGANIM2
{
	
	ifactioncount 1
	{
		ife mtype 0
		ifn sprite[].pal 22
		ifn sprite[].pal 10
		{
			flash
			hitradius 3072 6 6 6 6
		}
		resetactioncount
		ife sprite[].cstat 130 cstat 134 else
		ife sprite[].cstat 134 cstat 138 else
		ife sprite[].cstat 138 cstat 142 else
		ife sprite[].cstat 142 cstat 130
		
		ife mtype 1 ifcount 16 action BMFGANIM3
		ifcount 24 action BMFGANIM3 
		
		ife initsprite ARCBALLPROJ action BMFGANIM3
	}
}

ifaction BMFGANIM3
	ifactioncount 8 { action BMFGANIM4 cstat 642 }

ifaction BMFGANIM4
{
	ifspritepal 10 ifactorsound THISACTOR WARPLOOP stopactorsound THISACTOR WARPLOOP
	ifactioncount 1
	{
		resetactioncount
		ife sprite[].cstat 642 cstat 646 else
		ife sprite[].cstat 646 cstat 650 else
		ife sprite[].cstat 650 cstat 654 else
		ife sprite[].cstat 654 cstat 642
	}
	ifcount 1 { sizeto 0 0 resetcount }
}

enda

action PLASMEXPFRAMES 0 10 1 1 2
action PLASMSLOWFRAMES 0 10 1 1 4

spritenoshade PLASMEXPB
spritenoshade PLASMEXP
useractor notenemy PLASMEXP 0 PLASMEXPFRAMES
ifmove 0
{
	cstator 130
	seta[].blend 1
	sizeat 16 16
	move STOPPED
	ifrnd 128 cstator 4
}
ifactioncount 10 killit
enda

useractor notenemy PLASMEXPB 0
ifmove 0
{
	ifn myspawner -1
	ife pchar 2
	ifn saberpos 0
	{
		geta[myspawner].htg_t 8 hitsprite
		ifn hitsprite -1
		ifg actorvar[hitsprite].monstatus 0
		{
			geta[hitsprite].picnum picnum 
			state tiletype
			ifn TILETYPE 2
			{
				spawn AABLOOD
				killit
			}
		}
	}
	cstator 130
	seta[].shade -127
	seta[].blend 1
	ifspawnedby NEWPLASMA { sizeat 32 32 action PLASMSLOWFRAMES } else
	{ sizeat 10 10 action PLASMEXPFRAMES }
	move STOPPED
	ifrnd 128 cstator 4
	cactor PLASMEXP
	
}
enda

action PARTICLE_FRAMES 0 10 1 1 3
useractor notenemy PART_EXP 0 PARTICLE_FRAMES

ifmove 0
{
	ifrnd 128 cstator 4
	
	move STOPPED
	cstator 128
	// ifn sprite[].htpicnum WATERIMPACT
	// {
		sizeat 32 32
		geta[].z z
		sub z 2048
		seta[].z z
	// }
	ifspawnedby SHOTSPARK1 
	{
		spritepal 2
		spriteflags 68
		seta[].shade -127
		seta[].blend 255
	}
	ifspawnedby FLAKPROJ
	{
		sizeat 16 16
		spritepal 2
		spriteflags 68
		seta[].shade -127
		seta[].blend 255
	}
}
ifactioncount 10 killit

enda

useractor notenemy WATERIMPACT 0

ifmove 0
{	
	move STOPPED
	cstat 32768
	sizeat 32 32
	rand countvar 8
}
add countvar 1

ifg countvar 9 
{
	set countvar 0
	espawn BIGSMOKE2
	getactor[THISACTOR].ang angvar
	ifvare countvarb 0 
	{ addvar angvar 512 setvar countvarb 1 } 
	else
	{ subvar angvar 512 setvar countvarb 0 }
	getactor[THISACTOR].x x
	getactor[THISACTOR].y y
	setvarvar x2 x
	randvarvar temp 1024
	addvarvar x2 temp
	rotatepoint x y x2 y angvar x2 y2
	setactor[RETURN].x x2
	setactor[RETURN].y y2
	setactor[RETURN].htbposx x2
	setactor[RETURN].htbposy y2
	setactor[RETURN].pal 1
	setactor[RETURN].xrepeat 16
	setactor[RETURN].yrepeat 10
	
	// espawn PART_EXP
	// setactor[RETURN].x x2
	// setactor[RETURN].y y2
	// setactor[RETURN].htbposx x2
	// setactor[RETURN].htbposy y2
	// setactor[RETURN].pal 1
	// setactor[RETURN].xrepeat 24
	// setactor[RETURN].yrepeat 12
	// setactor[RETURN].cstat 2
	
}

enda

action ABLOCKSIT  0  1  5  1  1
useractor notenemy COVERBLOCK 10000 ABLOCKSIT

ifmove 0
{
	move STOPPED geth
	set startx 1
	ifspawnedby APLAYER 
	{
		ifgapzl 96
		sizeat 64 48 
		else
		sizeat 96 72
		cstat 257 
		set mtype 1
		set countvar 600
		seta[].alpha 220
		set savz sprite[].z
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			ife sprite[spriteid].picnum COVERBLOCK
			ifn spriteid THISACTOR
			{
				ifle sprite[spriteid].z savz
				{
					dist xydist THISACTOR spriteid
					ifl xydist 1560
					{
						set savz sprite[spriteid].z
						sub savz 24576
					}
					
				}
			}
			
			ifvarand inven_upgrades 32
			{
				set z sprite[].z
				sub z 16384
				ifge sprite[spriteid].z z
				ifn spriteid THISACTOR
				ife actorvar[spriteid].monstatus 1
				{
					set z sprite[].z
					add z 8192
					ifle sprite[spriteid].z z
					{
						ldist xydist THISACTOR spriteid
						ifle xydist 1152
						{	
							set temp plevel
							shiftl temp 5
							add temp 30
							seta[spriteid].htextra temp
							seta[spriteid].htpicnum RPG 
							seta[spriteid].htowner player[].i
							seta[spriteid].htang sprite[].ang
							
						}
					}
				}
			}

			nextspritestat spriteid spriteid
		}
		
		seta[].z savz
	}
	findnearspritez GREENSLIME 1152 10240 spriteid
	ifn spriteid -1 
	{ seta[spriteid].htextra 100 seta[spriteid].htpicnum RPG seta[spriteid].htowner player[].i }
	spriteflags 1048577
}

fall
/*
	set zdist 0
	getsector[].floorslope zdist
	getflorzofslope sprite[].sectnum sprite[].x sprite[].y z
	sub z 2048
	ifg sprite[].z z
	ifvarn zdist 0
	{
		getsector[].wallptr temp
		getwall[temp].point2 tempb
		getwall[temp].x x2
		getwall[temp].y y2
		getwall[tempb].x x
		getwall[tempb].y y
		subvarvar x2 x
		subvarvar y2 y
		getangle angvar x2 y2
	
		getincangle tempc angvar sprite[].ang
		set lastang sprite[].ang
		sub lastang 512
		getincangle tempd angvar lastang
		

		ifvarg tempc 512 { subvar tempc 1024 mulvar tempc -1 } else
		ifvarl tempc -512 { addvar tempc 1024 mulvar tempc -1 }
		
		ifvarg tempd 512 { subvar tempd 1024 mulvar tempd -1 } else
		ifvarl tempd -512 { addvar tempd 1024 mulvar tempd -1 }
		
		mulvarvar zdist tempc
		shiftvarr zdist 13
		mul zdist -1
		seta[].pitch zdist
		
		getsector[].floorslope zdist
		mulvarvar zdist tempd
		shiftvarr zdist 13
		mul zdist -1
		seta[].roll zdist

	}
	else { seta[].pitch 0 seta[].roll 0 }
*/



state playerpush

ifn sprite[].htowner player[].i ifn sprite[].htpicnum FIRELASER2 seta[].htextra -1
state predamage
ifvarand inven_upgrades 32 state damagepushblock

ifhitweapon strength 1000

ldist xydist THISACTOR player[].i
ifp phigher
{
	ifl xydist 1024
	{
		set z sprite[].z
		sub z player[].posz
		ifg z 28672
			cstat 256
		else cstat 257
	}
	else cstat 257	
}
else cstat 257

ife mtype 1 
{
	sub countvar 1
	ifle countvar 8
	{
		ifspritepal 121 getlastpal else spritepal 121
		geta[].alpha temp
		add temp 30
		seta[].alpha temp
		ife countvar 5 sound TELEPORTER
		ifle countvar 0
			killit
		
	}
	else
	ifge countvar 592
	{
		ifspritepal 121 getlastpal else spritepal 121
		geta[].alpha temp
		sub temp 30
		ifl temp 0 set temp 0
		seta[].alpha temp
	}
}

enda

useractor notenemy JUMPAD 0

ifcount 18
ifpdistl 10240
{
	resetcount
	set temp shotpitch
	mul temp 3
	div temp 2
	sub temp 1560
	ezshoot temp PADPROJ
	seta[RETURN].xvel startx
	setthisprojectile[RETURN].vel startx
	set temp starty
	add temp 13
	setthisprojectile[RETURN].range temp
}

	
	headspritestat spriteid 1
	whilevarn spriteid -1
	{
		set B 0
		ife actorvar[spriteid].padmove 0
		{
			ife actorvar[spriteid].monstatus 1 set B YES
			ife spriteid myshelly set B YES
			ife B YES
			{
				geta[].z z
				geta[spriteid].z z2
				sub z z2
				abs z
				ife sprite[spriteid].picnum EDFDRONE sub z 5120
				ife sprite[spriteid].picnum NEWSENTRY sub z 5120
				ifl z 6144 // 4096
				{
					ldist xydist THISACTOR spriteid
					ifl xydist 512
					{
						geta[].ang padang
						set padmove starty
						set jumpadxvel startx
						setav[spriteid].padmove padmove
						setav[spriteid].jumpadxvel jumpadxvel
						setav[spriteid].padang padang
						setav[spriteid].navpoint -1
						setav[spriteid].savedvalue -1
						geta[spriteid].z z
						sub z 4096
						seta[spriteid].z z
						set z2 shotpitch
						mul z2 3
						seta[spriteid].zvel z2
						soundonce JUMP_PAD
					}
				}
			}
		}
		nextspritestat spriteid spriteid
	}
	
	cstat 32768
	getplayer[].i spriteid
	ldist xydist THISACTOR spriteid
	ifl xydist 512 // 640
	ifp palive
	{
		getav[spriteid].padmove padmove
		getplayer[].falling_counter temp
		ifvarg temp 8
		{
			ifpdistg 1560 setvar temp 0
		}
		else
		{
			ifpdistl 1024 setvar temp 1
			else ifpdistl 1560 ifvarn padmove 0 setvar temp 1
			else setvar temp 0
		}
		ifn padmove 0 
		{
			getav[spriteid].padang padang
			ifn padang sprite[].ang 
				setvar temp 0 // don't reset a jump in progress
		}
				
		ifn temp 0
		{
			getp[].i spriteid
			geta[spriteid].z z
			sub z 4096
			seta[spriteid].z z
			getp[].posz z
			sub z 4096
			setp[].posz z
			setp[].jumping_counter 0
			setp[].jumping_toggle 0
			setp[].poszv shotpitch
			geta[].ang padang
			set padmove starty
			set jumpadxvel startx
			setav[spriteid].padmove padmove
			setav[spriteid].jumpadxvel jumpadxvel
			setav[spriteid].padang padang
			setp[].falling_counter 0
			set nofalldamage 1
			setp[].movement_lock 3
			soundonce JUMP_PAD
		}
	}
	
enda

move MOVECAMVEL 250

useractor notenemy MOVECAM 0
	ifn SPRITELOTAG 0
	{
		ifn sprite[].sectnum player[].cursectnum break
		set SPRITELOTAG 0
	}
	set movecam THISACTOR
	add countvar 1
	setp[].kickback_pic 0
	setp[].weapon_pos -9
	setp[].quick_kick 0
	ife player[].ftq 80 setp[].fta 0
	stopactorsound THISACTOR DUKE_GRUNT
	setp[].knuckle_incs 0
	lockplayer 10
	setp[].jumping_counter 0
	seta[player[].i].htextra -1
	setp[].jumping_counter 0
	ifmove 0
	{
		move MOVECAMVEL geth
	}
	ifmove MOVECAMVEL ifn angvel 0
		seta[].xvel angvel
	ifg countvar initflags
	{
		ifg initsprite 0
		{
			ifmove MOVECAMVEL
			{
				move STOPPED
				setp[].posx sprite[].x setp[].posy sprite[].y setp[].cursectnum sprite[].sectnum
			}
			sub initsprite 1
			set temp mtype
			sub temp 50
			mul temp 2
			add temp 100
			setp[].horiz temp
			ifg initsprite 0 break
			else { setp[].posx sprite[].x setp[].posy sprite[].y setp[].cursectnum sprite[].sectnum }
		}
		set movecam -1
		killit
	}
enda

useractor notenemy SECRETCOUNTSPRITE 0

findplayer xydist
	ifl xydist SPRITELOTAG
		ifp palive
			set secretsfound 10

enda

useractor notenemy EMPERORTALK
ife player[].cursectnum sprite[].sectnum
{
	set empactivation SPRITELOTAG
	set emptalk initflags
	set emp_frame 10902
	stopallmusic
	killit
}
enda

action AEMPNEUTRAL -12
action AEMPTALK -11
action AEMPCONFUSED -6
action AEMPSURPRISED -5
action AEMPPLEASED -4
action AEMPBORED -3
action AEMPWRATH -1
action AEMPSCREEN 0


useractor notenemy EMPERORSCREEN 0

	ife emp_frame 10901 action AEMPNEUTRAL else
	ife emp_frame 10902 action AEMPTALK else
	ife emp_frame 10907 action AEMPCONFUSED else
	ife emp_frame 10908 action AEMPSURPRISED else
	ife emp_frame 10909 action AEMPPLEASED else
	ife emp_frame 10910 action AEMPBORED else
	ife emp_frame 10912 action AEMPWRATH else
	ife emp_frame 10913 action AEMPSCREEN 

enda

defstate checkfloordist

set temp 3072
set tempb sprite[].sectnum
updatesectorz sprite[].x sprite[].y sprite[].z tempb
ifvarn tempb -1
{
	getflorzofslope tempb sprite[].x sprite[].y temp // temp is the return var
	sub temp sprite[].z
}

ends

defstate spawn_goodie

	set picnum COLA
	rand temp 19
	switch temp
	case 0 ife pchar 0 ifvarand dukeupgrades[PISTOL_WEAPON] 8 set picnum GLOCKSPRITE else
		   ife pchar 1 ifvarand shellyupgrades[PISTOL_WEAPON] 8 set picnum GLOCKSPRITE else
		   set picnum FIRSTGUNSPRITE 
		break
	case 1 ife pchar 1 ifvarand shellyupgrades[SHOTGUN_WEAPON] 4 ifvarand gotbow 2 set picnum BOWSPRITE else
		   ife pchar 2 ifvarand wesupgrades[SHOTGUN_WEAPON] 4 ifvarand gotbow 2 set picnum BOWSPRITE else
		set picnum SHOTGUNSPRITE 
		break
	case 2 set picnum CHAINGUNSPRITE break
	case 3 set picnum RPGSPRITE break
	case 4 set picnum HBOMBAMMO break
	case 5 set picnum FREEZESPRITE break
	case 6 set picnum SHRINKERSPRITE break
	case 7 set picnum TRIPBOMBSPRITE break
	case 8 set picnum DEVISTATORSPRITE break
	case 9 set picnum GROWSPRITEICON break
	case 10 set picnum COLA break
	case 11 set picnum SIXPAK break
	case 12 set picnum ATOMICHEALTH break
	case 13 ifrnd 128 { ifrnd 128 set picnum FIRSTAID else set picnum STEROIDS }
		else ifrnd 128 { ifrnd 128 set picnum HOLODUKE else set picnum HEATSENSOR }
		break
	case 14 set picnum SABERSPRITE break
	case 15 set picnum PLASMASPRITE break
	case 16 set picnum RAILGUNSPRITE break
	case 17 set picnum NUKESPRITE break
	case 18 ifrnd 128 set picnum COMMGUN else set picnum LASERPISTOL break
	case 19 set picnum SHIELD break
	endswitch
	espawnvar picnum
ends

defstate spawn_goodie2

	set picnum COLA
	rand temp 19
	switch temp
	case 0 set picnum AMMO break
	case 1 set picnum SHOTGUNAMMO break
	case 2 set picnum BATTERYAMMO break
	case 3 set picnum RPGAMMO break
	case 4 set picnum HBOMBAMMO break
	case 5 set picnum FREEZEAMMO break
	case 6 set picnum CRYSTALAMMO break
	case 7 set picnum TRIPBOMBSPRITE break
	case 8 set picnum DEVISTATORAMMO break
	case 9 set picnum GROWAMMO break
	case 10 set picnum COLA break
	case 11 set picnum SIXPAK break
	case 12 set picnum ATOMICHEALTH break
	case 13 ifrnd 128 { ifrnd 128 set picnum FIRSTAID else set picnum STEROIDS }
		else ifrnd 128 { ifrnd 128 set picnum HOLODUKE else set picnum HEATSENSOR }
		break
	
	case 14 set picnum PLASMASPRITE break
	case 15 set picnum RAILGUNAMMO break
	case 16 ife pchar 0 set picnum DBAMMO else set picnum QUIVERSPRITE break
	case 17 ife pchar 0 ifvarand perks 128 set picnum NUKESPRITE else set picnum AMMO break
	case 18 ifrnd 128 set picnum COMMGUN else set picnum LASERPISTOL break
	case 19 set picnum SHIELD break
	endswitch
	espawnvar picnum
ends

defstate rand_db_bow
    set TMP_A 0
	ifvarand startmode 1 set TMP_A 1 // include DB stuff
	ifvarand startmode 2 orvar TMP_A 2 // include bow stuff
	ifvarand startmode 4 orvar TMP_A 2 // include bow stuff
	
	ife player[].gotweapon SHOTGUN_WEAPON YES
	{
		ife TMP_A 1 spawn DBAMMO else
		ife TMP_A 2 spawn QUIVERSPRITE else
		{
			ifrnd 128 spawn DBAMMO else spawn QUIVERSPRITE 
		}
	}
	else
	{
		ife TMP_A 1 spawn DBSPRITE else
		ife TMP_A 2 spawn BOWSPRITE else
		{
			ifrnd 128 spawn DBSPRITE else spawn BOWSPRITE 
		}
	}
ends

defstate startgun_replace
	
	ifrnd 32
	{
		ifle cover_amount 300
		ifrnd 84
		{
			spawn COVERSPRITE
			break
		}
		ifle player[].holoduke_amount 1080
		ifrnd 96
		{
			espawn HOLODUKE
			setav[RETURN].initsprite YES
			break
		}
		ife es_type 0 
		{
			ife player[].shield_amount 0
			{
				espawn SHIELD
				seta[RETURN].htpicnum PIGCOP
				break
			}
		}
		else ife es_battery 0
		{
			espawn SHIELD
			seta[RETURN].htpicnum PIGCOP
			break
		}
	}
	ifrnd 128 // first bit
	{
		ifvarand startguns 1 spawn AMMO else
		ifvarand startguns 2 spawn SHOTGUNAMMO else
		ifvarand startguns 4 spawn BATTERYAMMO else
		ifvarand startguns 256 spawn FREEZEAMMO else
		ifvarand startguns 512 spawn GROWAMMO else
		ifvarand startguns 1024 spawn PLASMAAMMO else
		ifvarand startguns 32768
		{
			state rand_db_bow
		}
	}
	else
	{
		ifvarand startguns 8 spawn RPGAMMO else
		ifvarand startguns 16 spawn HBOMBAMMO else
		ifvarand startguns 32 spawn CRYSTALAMMO else
		ifvarand startguns 64 spawn DEVISTATORAMMO else
		ifvarand startguns 128 spawn TRIPBOMBSPRITE else
		ifvarand startguns 2048 { ifg gotsaber 50 state spawn_goodie2 else { espawn SABERSPRITE setav[RETURN].initsprite 10 } } else
		ifvarand startguns 16384 spawn RAILGUNAMMO
	}

ends

defstate facesprite
	geta[spriteid].x x2
	geta[spriteid].y y2
	sub x2 sprite[].x
	sub y2 sprite[].y
	getangle angvar x2 y2
	seta[].ang angvar
ends

// defstate facespriteslow

	// geta[spriteid].x x2
	// geta[spriteid].y y2
	// sub x2 sprite[].x
	// sub y2 sprite[].y
	// getangle tempb x2 y2
	
	// getincangle temp sprite[].ang tempb
	
	// ifn sprite[].ang tempb
	// {
		// set B 64
		// mul B -1
		// ifg temp B ifl temp 64
			// seta[].ang tempb
		// else
		// {
			// geta[].ang angvar
			// ifl temp 0 sub angvar 64
			// else add angvar 64
			// seta[].ang angvar
		// }
		// set lastang sprite[].ang
	// }

// ends

defstate turntotarget

	ife bottarget -1 break

	geta[bottarget].x x2
	geta[bottarget].y y2
	sub x2 sprite[].x
	sub y2 sprite[].y
	getangle tempb x2 y2
	
	getincangle temp sprite[].ang tempb
	
	ifn sprite[].ang tempb
	{
		set B MAXSHELLYTURN
		mul B -1
		ifg temp B ifl temp MAXSHELLYTURN
		{
			seta[].ang tempb
			ifactor APLAYER setp[].ang tempb
		}
		else
		{
			geta[].ang angvar
			ifl temp 0 sub angvar MAXSHELLYTURN
			else add angvar MAXSHELLYTURN
			seta[].ang angvar
			ifactor APLAYER setp[].ang angvar
		}
		set lastang sprite[].ang
	}
	abs temp

ends

defstate turnatrate

	// TMP_B set to turning rate before this state is called
	ife bottarget -1 break

	geta[bottarget].x x2
	geta[bottarget].y y2
	sub x2 sprite[].x
	sub y2 sprite[].y
	getangle tempb x2 y2
	
	getincangle temp sprite[].ang tempb
	
	ifn sprite[].ang tempb
	{
		set B TMP_B
		mul B -1
		ifg temp B ifl temp TMP_B
		{
			seta[].ang tempb
			ifactor APLAYER setp[].ang tempb
		}
		else
		{
			geta[].ang angvar
			ifl temp 0 sub angvar TMP_B
			else add angvar TMP_B
			seta[].ang angvar
			ifactor APLAYER setp[].ang angvar
		}
		set lastang sprite[].ang
	}
	abs temp

ends

defstate playerturntome

	geta[].x x
	geta[].y y
	sub x player[].posx
	sub y player[].posy
	getangle angvar x y

	getincangle B player[].ang angvar
	getp[].ang temp
	shiftr B 4
	add temp B
	setp[].ang temp

ends

defstate checksectvisited

	ife switchmode YES break

	ifl sprite[].sectnum 0 break
	
	ife psectvisited[sprite[].sectnum] YES
	{
		set botx sprite[].x
		set boty sprite[].y
		set botz sprite[].z
	}
	else ifl gametype 1
	{
		ife botx 0 ife boty 0 ife botz 0 break
		ife seeplayer YES
			nullop
		else
		setsprite THISACTOR botx boty botz
	}

ends

defstate zveltotarget
	
	
	set TMP_A tiledata[sprite[bottarget].picnum].ysize
	mul TMP_A sprite[bottarget].yrepeat
	shiftl TMP_A 1
	add TMP_A 2048
	// TMP_A is now overall z size of target; how far up from the feet to strike
	// for comparison a standard liztroop would have a TMP_A of 78*40*2+2048==8228
	
	geta[].z z2
	geta[bottarget].z z
	sub z TMP_A
	
	sub z z2
	
	ldist xydist THISACTOR bottarget
	ifg xydist 1024
	{
		mul z sprite[].xvel
		div z xydist
		seta[].zvel z
	}
ends

defstate calczdist
	geta[bottarget].z zdist
	sub zdist sprite[].z
	ldist xydist THISACTOR bottarget
	ife xydist 0 setvar xydist 1
ends

defstate lowlineofsight

set B NO
ife bottarget -1 break

// this state sets B to YES if actor can see bottarget from 2048 units off of ground

set savz sprite[].z
set z sprite[].z
sub z 3072
seta[].z z

canseespr THISACTOR bottarget B

seta[].z savz


ends

defstate sethordeval

	ife mynavsprite -1
	{
		espawn NAVSPRITE
		set mynavsprite RETURN
		changespritestat RETURN 980
		ife gametype -1 setav[RETURN].mtype 6
	}
	getp[].player_par countvar
	add countvar 1
	ife team 1
	{
		setav[mynavsprite].blueflagval 17000000
		setav[mynavsprite].blueiteration 0
		setav[mynavsprite].bluetimer countvar
		seta[mynavsprite].htpicnum BLUEFLAG
	}
	else
	{
		setav[mynavsprite].redflagval 17000000
		setav[mynavsprite].rediteration 0
		setav[mynavsprite].redtimer countvar
		seta[mynavsprite].htpicnum REDFLAG
	}
	seta[mynavsprite].htpicnum sprite[].picnum
	geta[].z savz sub savz 6144
	setsprite mynavsprite sprite[].x sprite[].y savz
	setav[mynavsprite].countvar 0

ends

defstate avoidmines

	set B NO
	switch sprite[bottarget].picnum
	case SPIDERWALK
	case SPIDERMINE
	case ZOMBIE case CRAZYLADY
	case DEANOVA
	case CYCLOIDMAX
	case FLYINGFIST
	case LIZBOSS
	case BOSS1 case NEWBOSS1
	case BOSS2
	case BOSS3
	case BOSS4
	case PIGBOSS
	case PSPIDER
	case CANHEAD
	case CANHEADNOARMS
	case NEWBATLORD
	case QUEEN
	case LARGEMAN case COMBINEDMEN
		ife dodgetime 0
		ifl targetdist 4096
		ifl navpoint 0 
			set B YES
	break
	endswitch

ends

defstate avoidboss
	
		ifg spawnprotect 30 break
		ifn actorvar[bottarget].shrunken 0 break
		
		switch sprite[bottarget].picnum
		case BOSS1
		case NEWBOSS1
		case BOSS2
		case BOSS3
		case BOSS4 case QUEEN
		case PSPIDER
		case PSPIDERJUMPING
		case DEVOURER
		case LIZBOSS
		case CANHEAD
		case CANHEADNOARMS
		case CYCLOIDMAX case FLYINGFIST
		case LARGEMAN case COMBINEDMEN
		case SITH
		case SYTH
		case DEANOVA
			ifl xydist 6144 add angvel 1024 else
			ifl xydist 8192
			ife myspawner -1 ife dodgetime 0 set myspawner bottarget
		break
		case TERMINATORCRAWLING
			ife actorvar[bottarget].countvarc YES
			{
				ifl xydist 8192
				{
					ife myspawner -1 ife dodgetime 0 set myspawner bottarget
					else add angvel 1024
				}
			}
		break
		case ARMYANT case ARMYANTCRAWL
			ife actorvar[bottarget].initsprite YES
			{
				ldist temp THISACTOR bottarget
				ifl temp 2048 add angvel 1024
			}
		break
		default
			ife dodgetime 0
			ifl xydist 4096 ifg ikicked 60 
			ifl navpoint 0 add angvel 1024
		break
		endswitch
	
ends

defstate randzshoot

	set temp zdist
	abs temp
	add temp 1280
	shiftr temp 5
	randvarvar tempb temp
	ifrnd 128 mul tempb -1
	add tempb zdist

ends

defstate randzrange

	rand z2 5120
	sub zdist z2
	add zdist 2048

ends

defstate hitscan_targetprep

	ife bottarget -1 { set zdist 0 break }
	
	geta[bottarget].z zdist
	
	switch sprite[].picnum
	case EDFSNIPER case EDFSNIPERCROUCH
	case EDFDRONE
	case NEWSENTRY
	case SPACEBULL case SPACEBULLDUCKING
	case BOSS1
	case NEWBOSS1
	case LIZMAN
	case PIGCOP case PIGCOPDIVE
	case NEWPIG case NEWPIGDIVE
	case NEWBATLORD
	case NEWRECON
	case EDFTURRET
	case TANK
		state randzrange
	break
	
	case BATBOSS
		ifn countvar 7 state randzrange
	break
	endswitch
	
	sub zdist sprite[].z 
	geta[bottarget].picnum picnum
	
	set z2 sprite[bottarget].yrepeat
	mul z2 tiledata[picnum].ysize
	// z2 is proportional to height of enemy sprite
	
	geta[].picnum picnum
	set temp sprite[].yrepeat
	mul temp tiledata[picnum].ysize
	// temp is now proportional to height of THISACTOR
	
	ifg temp z2 // aim down
	{
		sub temp z2
		
		mul temp 5
		div temp 2
		
		add zdist temp
	}
	// note there is no need to aim up at taller enemies
	shiftl zdist 8
	ldist xydist THISACTOR bottarget
	ifvare xydist 0 setvar xydist 1 
	divvarvar zdist xydist

ends

defstate rpg_targetprep

	ife bottarget -1 { set zdist 0 break }
	
	geta[bottarget].z zdist
	ifactor DUKEBOT ifge sprite[bottarget].z sprite[].z add zdist 6144 // aim near the feet
	ifactor SHELLY ifge sprite[bottarget].z sprite[].z add zdist 6144
	ifactor WESBOT ifge sprite[bottarget].z sprite[].z add zdist 6144
	sub zdist sprite[].z 
	geta[bottarget].picnum picnum
	
	set z2 tiledata[picnum].ysize
	mul z2 sprite[bottarget].yrepeat
	// z2 is proportional to height of enemy sprite
	
	geta[].picnum picnum
	set temp tiledata[picnum].ysize
	mul temp sprite[].yrepeat
	// temp is now proportional to height of THISACTOR
	
	// ifg temp z2 // aim down
	ifn temp z2
	{
		sub temp z2
		mul temp 3
		add zdist temp
	}
	
	
	mul zdist xvel
	ldist xydist THISACTOR bottarget
	ifvare xydist 0 setvar xydist 1 
	divvarvar zdist xydist

ends

defstate friendlyfirecheck

// target has been set to bottarget before this state is called
	ife target -1 break // error
	
	geta[target].x x2
	geta[target].y y2
	sub x2 sprite[].x
	sub y2 sprite[].y
	getangle angvar x2 y2
	
	headspritestat spriteid 1 // 990
	whilevarn spriteid -1
	{
		ifg actorvar[spriteid].monstatus 0
		ife team actorvar[spriteid].team
		ifn actorvar[spriteid].monstatus 2
		ifl actorvar[spriteid].monstatus 100
		ifn spriteid THISACTOR
		// ifn actorvar[spriteid].mysignpost THISACTOR
		{
			dist temp THISACTOR spriteid
			ifl temp targetdist // check for friend in the way
			{
				geta[spriteid].x tempc
				geta[spriteid].y tempd
				sub tempc sprite[].x
				sub tempd sprite[].y
				getangle B tempc tempd
				
				getincangle tempb angvar B
				abs tempb
				set tempe 524288
				div tempe temp
				ifg tempe 512 set tempe 512
				ifl tempb tempe
					set target -1
				
			}
		}
		ife spriteid player[].i set spriteid -1
		else
		{
			nextspritestat spriteid spriteid
			ife spriteid -1 set spriteid player[].i
		}
		ife target -1 set spriteid -1
	}

ends

defstate navspritevischeck

	// replaces canseespr THISACTOR spriteid temp
	// temp == YES if true, NO if false
	
	geta[spriteid].cstat bossang
	geta[spriteid].xrepeat tempxrepeat
	geta[spriteid].yrepeat tempyrepeat
	
	seta[spriteid].cstat 256
	seta[spriteid].xrepeat 128
	seta[spriteid].yrepeat 128
	
	geta[].z tempF
	set tempI tiledata[sprite[].picnum].ysize
	mul tempI sprite[].yrepeat
	shiftl tempI 1
	add tempI 2048
	sub tempF tempI
	
	geta[spriteid].z tempG
	set bossx tiledata[sprite[spriteid].picnum].ysize
	mul bossx sprite[spriteid].yrepeat
	shiftl bossx 1
	sub tempG bossx
	set bossy tempG
	sub bossy tempF

	geta[].x x
	geta[].y y
	
	geta[spriteid].x x2
	geta[spriteid].y y2
	sub x2 sprite[].x
	sub y2 sprite[].y
	getangle tempH x2 y2
	
	cos mycos tempH
	sin mysin tempH
	shiftl bossy 14

	ldist xydist3 THISACTOR spriteid
	ife xydist3 0 set xydist3 1
	div bossy xydist3

	hitscan x y tempF sprite[].sectnum mycos mysin bossy bossx bossx hitsprite x2 y2 tempI 16777281
	
	ife hitsprite spriteid set temp YES else set temp NO
	
	seta[spriteid].cstat bossang
	seta[spriteid].xrepeat tempxrepeat
	seta[spriteid].yrepeat tempyrepeat
ends

state teststate

	ifcount 3
	ifn bottarget -1
	{
		resetcount
		sound CAPT_ATTACK 
		state hitscan_targetprep
		zshoot zdist SHOTSPARK1
	}

ends


defstate targetcheck

	ifvarand sprite[target].cstat 256 nullop else { set target -1 break }
	
	
	ifg actorvar[target].spawnprotect 10 { set target -1 break }
	
	ife sprite[].htowner target 
	ifn sprite[].picnum DEANOVA
	ifg blueiteration 0 // countdown set when last hit
	{
		ife team 0
			break // automatically allow targeting of something that hit you
		ife team 1
		ifn team actorvar[sprite[].htowner].team break
		
	}
	
	dist xydist THISACTOR target
	ifg xydist MAXRANGE { ife bottarget target set bottarget -1 set target -1 break }
	
	
	
	geta[].z z
	set z2 tiledata[sprite[].picnum].ysize
	mul z2 sprite[].yrepeat
	shiftl z2 1
	add z2 2048
	sub z z2
	
	geta[target].z tempb
	set tempc tiledata[sprite[target].picnum].ysize
	mul tempc sprite[target].yrepeat
	shiftl tempc 1
	
	add tempc 2048
	
	// ***** uncomment if you want to hitscan to approximate middle of target, 
	// ***** but this has issues...
	// sub tempb tempc
	// set zdist tempb
	// sub zdist z
	
	// otherwise just do this instead
	set zdist sprite[target].z
	sub zdist sprite[].z
	
	ifl zdist -8192 ifactor ZOMBIE { set target -1 break }
	ifg zdist 8192 ife sprite[target].picnum SPIDERWALK { set target -1 break }

	ifl xydist 1024
	{
		// an unfortunate hack because the hitscans have been missing
		// when at close range!
		canseespr THISACTOR target temp
		ife temp YES break
	}
	
	geta[].x x
	geta[].y y
	rand temp 64 sub temp 32
	add x temp
	rand temp 64 sub temp 32
	add y temp
	
	// x and y can be offset by the gun position, making this more accurate
	// right side enemies:
	// lizman, boss1, newbatlord, liztroop, newtroop, pigcop, newpig, boss2
	// edfpig, armpig, terminator, armedf, lizelite, spacebull, spacebullducking
	// MANDOFETT, mandocrouch, SMALLMAN, newboss1, CYCLOIDMAX, NEWCOMM
	// left side enemies:
	// pigboss, lizboss, drproton, pspider, armyant, armyantcrawl

	switch sprite[].picnum
		
		case NEWPIG case NEWPIGDIVE
		case LIZMAN case EDFPIG case ARMPIG case TERMINATOR case TERMINATORDUCKING
		case LIZELITE case SPACEBULL case SPACEBULLDUCKING case NEWCOMM
		case NEWBATLORD case ARMEDF case MANDOFETT case MANDOCROUCH case SMALLMAN
		
			set newx x
			set temp sprite[].xrepeat
			// shiftl temp 3
			mul temp 10
			add newx temp
			set angvar sprite[].ang
			add angvar 512
			
			rotatepoint sprite[].x sprite[].y newx sprite[].y angvar x y
		break
		case BOSS2 case BOSS1 case NEWBOSS1
		case LIZTROOP case LIZTROOPDUCKING case PIGCOP case PIGCOPDIVE
			set newx x
			set temp sprite[].xrepeat
			shiftl temp 4
			add newx temp
			set angvar sprite[].ang
			add angvar 512
			
			rotatepoint sprite[].x sprite[].y newx sprite[].y angvar x y
		break
	endswitch

	
	// geta[].z z
	// sub z 8192
		
	geta[].sectnum mysector
	ife mysector -1 { set target -1 break }

	geta[target].x x2
	geta[target].y y2
	sub x2 x
	sub y2 y
	
	
	getangle angvar x2 y2
	
	ife team actorvar[player[].i].team
	{
		ldist temp THISACTOR player[].i
		ifl temp xydist // check for player in the way
		ifl temp 6144
		{
			getp[].posx tempc
			getp[].posy tempd
			sub tempc sprite[].x
			sub tempd sprite[].y
			getangle B tempc tempd
			
			getincangle tempb angvar B
			abs tempb
			ifl tempb 128
			{
				set target -1
				break
			}
		}
	}

	cos mycos angvar
	sin mysin angvar
	shiftl zdist 14
	
	ife xydist 0 set xydist 1
	div zdist xydist
	
	geta[target].xrepeat tempxrepeat
	geta[target].yrepeat tempyrepeat
	ifl tempxrepeat 64 seta[target].xrepeat 64
	ifl tempyrepeat 64 seta[target].yrepeat 64
	
	geta[].xrepeat savx
	geta[].yrepeat savy
	sizeat 1 1
	hitscan x y z mysector mycos mysin zdist tempc tempc hitsprite x2 y2 z2 4294901808
	// 4294901808
	// 16777281
		
	seta[].xrepeat savx
	seta[].yrepeat savy
	
	// al hitsprite
	// al target
	
	
	ifn hitsprite target
	{
		add z 4096
		hitscan x y z mysector mycos mysin zdist tempc tempc hitsprite x2 y2 z2 4294901808
	// 4294901808
	// 16777281
	}
	
	
	seta[target].xrepeat tempxrepeat
	seta[target].yrepeat tempyrepeat
	
	ifn hitsprite target 
		set target -1 
		
	// adjust distance for certain targets
	ifn target -1
	{
		ife sprite[target].picnum GREENSLIME shiftl xydist 2 else
		ife sprite[target].picnum EGG shiftl xydist 2 else
		ife sprite[target].picnum DRONE shiftl xydist 1
	}
ends

defstate targetsearch

	ife team 3 { set bottarget -1 break }

	ifg bluetimer 0 
	{
		sub bluetimer 1
		ifn bottarget -1
		{
			ifn actorvar[bottarget].team team
			ife actorvar[bottarget].monstatus 2 set bottarget -1
			// ifn bottarget -1
			// ifl sprite[bottarget].extra 0 set bottarget -1
			ifn bottarget -1
			{
				ife sprite[bottarget].statnum 1024 set bottarget -1
				else
				ife actorvar[spriteid].team 3 set bottarget -1
			}
		}
		break
	}
	
	set xydist2 150000
	
	ifn bottarget -1
	{
		ifl sprite[bottarget].extra 0 set bottarget -1
		ifn bottarget -1
			ife sprite[bottarget].statnum 1024 set bottarget -1
		ifn bottarget -1
		ifn actorvar[bottarget].team team
			ife actorvar[bottarget].monstatus 2 set bottarget -1
		ifn bottarget -1
		{
			geta[].z z
			sub z 8192
			seta[].z z
			canseespr THISACTOR bottarget temp
			add z 8192
			seta[].z z
			ife temp NO set bottarget -1
			else
			{
				ldist xydist2 THISACTOR bottarget
				sub xydist2 512
				set bluetimer 5
				ife actorvar[bottarget].monstatus 1
				ife team 0 ife actorvar[bottarget].team 0
				{
					ife disable_infighting YES set bottarget -1
					else
					ife seeplayer YES break // keep infighting
					else ifrnd 64 break
					set bottarget -1
				}
			}
		}
	}
	
	ife bottarget -1 set target -1
	
	
	// should select closest target with line of sight
	// also, do not select the target if the player is in the way
	
	ife team 1
	ifn sprite[].picnum APLAYER
	ifn sprite[].picnum SPIDERWALK
	{
		findnearspritez GREENSLIME 5120 20480 temp
		ifn temp -1
		{
			set target temp
			state targetcheck
			ifn target -1 
			{
				set bottarget target
				set bluetimer 6
				break
			}
		}
	}
	
	// headspritestat spriteid 990
	// whilevarn spriteid -1
	// {
		// ifn actorvar[spriteid].team team
		// ifn actorvar[spriteid].team 3
		// {
			// set target actorvar[spriteid].mysignpost
			// state targetcheck
			// ifn target -1
			// {
				// ifl xydist xydist2
				// {
					// set xydist2 xydist
					// set bottarget target
					// set bluetimer 6
				// }
			// }
		// }
		// nextspritestat spriteid spriteid
	// }
	
	headspritestat spriteid 1
	whilevarn spriteid -1
	{
		ifg actorvar[spriteid].monstatus 0
		ifn actorvar[spriteid].monstatus 2
		ifn actorvar[spriteid].team team
		ifl actorvar[spriteid].monstatus 100
		ifn actorvar[spriteid].team 3
		{
			set target spriteid
			
			state targetcheck
			ifn target -1
			{
				ife spriteid player[].i sub xydist 1024
				ife sprite[spriteid].pal 1 add xydist 2048
				ifl xydist xydist2
				{
					set xydist2 xydist
					set bottarget target
					set bluetimer 6
				}
			}
		}
		ife spriteid player[].i set spriteid -1
		else
		{
			nextspritestat spriteid spriteid
			ife spriteid -1 set spriteid player[].i
		}
	}
	
	ife bottarget -1
	{
		headspritestat spriteid 2
		whilevarn spriteid -1
		{
			ifn actorvar[spriteid].team team
			ife actorvar[spriteid].monstatus 1
			ifn actorvar[spriteid].team 3
			{
				set target spriteid
				state targetcheck
				ifn target -1
				{
					ifl xydist xydist2
					{
						set xydist2 xydist
						set bottarget target
						set bluetimer 6
					}
				}
			}
			nextspritestat spriteid spriteid	
		}
	}
	
	ife bluetimer 0
	{
		
		ife gametype 0
		{
			rand bluetimer 4
			add bluetimer 4
			ifpdistg 65536
			{
			set temp xydist2
			shiftr temp 11
			add bluetimer temp
			ife team 1 ifg bluetimer 10 set bluetimer 10
			}
			else ife target -1 rand bluetimer 2
			
		}
		else
		{
			rand bluetimer 4
			add bluetimer 4
		}
		
	}
	// set bluetimer 6

ends

defstate squish_bot

	
	ifn bottarget -1
	{
		ife bottarget myshelly ife actorvar[myshelly].monstatus 2 break
		ifl targetdist 1280
		{
			ife bottarget player[].i ife pdown YES break
			
			ifspritepal 0 set temp 50 else set temp 20
			seta[bottarget].htextra temp
			seta[bottarget].htpicnum RPG
			seta[bottarget].htowner THISACTOR
			seta[bottarget].htang sprite[].ang
		}
	}
	else
	ifn myshelly -1
	ifn team actorvar[myshelly].team
	{
		ife actorvar[myshelly].monstatus 2 break
		dist xydist THISACTOR myshelly
		ifl xydist 1280
		{
			ifspritepal 0 set temp 50 else set temp 20
			seta[bottarget].htextra temp
			seta[myshelly].htpicnum RPG
			seta[myshelly].htowner THISACTOR
			seta[myshelly].htang sprite[].ang
		}
		
	}

ends

defstate changetodecal

	// getactorvar[myspawner].droptile FLOORTEX
	// ifvare FLOORTEX -1
	// {
		// getactor[myspawner].htg_t 6 hitwall
		// ifvare hitwall -1 break
		// getwall[hitwall].picnum FLOORTEX
	// }
	
	getactor[myspawner].htg_t 6 temp
	ifvare temp -1 break
	
	getwall[temp].nextsector mysector
				
	ifn mysector -1 ifvarand sector[mysector].ceilingstat 1 
	{
		ife sector[mysector].floorz sector[mysector].ceilingz
		{
			set mtype 1024 break 
		}
	}
	
	getwall[temp].cstat tempb
	ifvarand tempb 2 // ignore this is upper half of wall
	{
		getwall[temp].nextsector B
		ife B -1 getwall[temp].picnum picnum
		else
		{
			ifg sprite[].z sector[B].ceilingz
			{
				getwall[temp].nextwall B
				ife B -1 getwall[temp].picnum picnum
				else getwall[B].picnum picnum
			}
			else getwall[temp].picnum picnum
		}
	}
	else
	getwall[temp].picnum picnum
		
	state tiletype

	set x 0
	switch TILETYPE
	case 1 set picnum WOODHOLE
	set x 4
	break
	case 2 set picnum METALHOLE
	set x 2
	break
	case 5 case 7 

	set picnum CONCRETEHOLE set x 2
	break
	case 10 
	set picnum ELECTRONICHOLE
	set x 3
	break
	case 11 set picnum ORGANICHOLE 
	set x 3
	break
	default 
		set picnum BULLETHOLE
	break
	endswitch
	ifn picnum BULLETHOLE
	{
		seta[].picnum picnum
		seta[].xrepeat x
		seta[].yrepeat x
		cstator 16
		cstator 128
		ifrnd 128 cstator 4
		changespritestat THISACTOR 1
	}
ends


defstate hitmetalsounds

	set temp 0
	ifsound METALHIT1 add temp 1
	ifsound METALHIT2 add temp 1
	ifsound METALHIT3 add temp 1
	ifsound METALHIT4 add temp 1
	ifsound METALHIT5 add temp 1
	ifsound METALHIT6 add temp 1
	
	ifg temp 3 break // don't play more than 4 at once
	
	rand tempb 5
	switch tempb
	case 0 sound METALHIT1 break
	case 1 sound METALHIT2 break
	case 2 sound METALHIT3 break
	case 3 sound METALHIT4 break
	case 4 sound METALHIT5 break
	case 5 sound METALHIT6 break
	endswitch

ends

defstate breakmetalsounds

	sound BREAK_MET3
	break
	
	set temp 0
	ifsound BREAK_MET1 add temp 1
	ifsound BREAK_MET2 add temp 1
	ifsound BREAK_MET3 add temp 1
	ifg temp 1 break
	
	rand tempb 2
	switch tempb
	case 0 sound BREAK_MET1 break
	case 1 sound BREAK_MET2 break
	case 2 sound BREAK_MET3 break
	endswitch

ends

defstate hitconcretesounds

	set temp 0
	ifsound CONCRETEHIT1 add temp 1
	ifsound CONCRETEHIT2 add temp 1
	ifsound CONCRETEHIT3 add temp 1
	ifsound CONCRETEHIT4 add temp 1
	ifsound CONCRETEHIT5 add temp 1
	ifsound CONCRETEHIT6 add temp 1
	ifsound CONCRETEHIT7 add temp 1
	
	ifg temp 3 break // don't play more than 4 at once

	rand tempb 6
	switch tempb
	case 0 sound CONCRETEHIT1 break
	case 1 sound CONCRETEHIT2 break
	case 2 sound CONCRETEHIT3 break
	case 3 sound CONCRETEHIT4 break
	case 4 sound CONCRETEHIT5 break
	case 5 sound CONCRETEHIT6 break
	case 6 sound CONCRETEHIT7 break
	
	endswitch

ends

spritenoshade NUKECOIN
spriteshadow NUKECOIN
action COINFRAMES -1 1 1 1 1

move COINVELUP 480 -32
move COINVELDOWN 480 -8

useractor notenemy NUKECOIN 0

set monstatus 100 strength 1
ifmove 0
{
	move STOPPED
	geta[].htflags temp, orvar temp 2097152, seta[].htflags temp
	ife attmode YES
	ifrnd 11 // 12
	ifg startguns 0
	{
		state startgun_replace
		killit
	}
	ifpdistg 20480 killit
	sizeat 32 32
	action COINFRAMES
}


ifvarand perks 32 // coin magnet
{
	ifpdistl 2048
	{
		ifmove STOPPED move COINVELUP faceplayer getv
	}
	else move STOPPED
}

ifcount 1500
{
   ife lastang 0 cstat 0 else
   ife lastang 1 cstat 2 else
   ife lastang 2 cstat 514 else
   ife lastang 3 cstat 32768 else
   ife lastang 4 cstat 514 else
   ife lastang 5 cstat 2
   
   add lastang 1
   ifg lastang 5 set lastang 0
   ifcount 1800 killit
}

ifp pshrunk nullop
else
  ifp palive
	ifcanseetarget
	{
		set temp NO
		ifinwater { ifpdistl 1024 set temp YES }
		else ifpdistl RETRIEVEDISTANCE set temp YES
		ife temp YES         
		{
			globalsound COINSND
			palfrom 20 63 58 0
			
			set B sprite[player[].i].extra
			mul B 100
			div B player[].max_player_health
			
			
			ife es_type 0
			{
				getp[].shield_amount temp
				ifge temp 100 add temp 5 else add temp 10
				ifg temp 150 set temp 150
				setp[].shield_amount temp
				cactor ATOMICHEALTH
				ifge B 140 nullop else
				ifge B 100 addphealth 1 else
				ifge B 70 addphealth 2 else
				ifge B 50 addphealth 3 else
				addphealth 5
			}
			else
			{
				cactor ATOMICHEALTH
				ifge B 140 nullop else
				ifge B 100 addphealth 1 else
				ifge B 70 addphealth 2 else
				ifge B 50 addphealth 3 else
				addphealth 5
				ife gametype 0 ifl es_battery es_batterymax add es_battery 10
			}
			sub o2damage 5 ifl o2damage 0 set o2damage 0
			ifinwater
			ifl player[].airleft 390
			{
				getp[].airleft temp
				add temp 150, ifg temp 390 set temp 390
				setp[].airleft temp
			}
			ife gametype 0
			// ifge SKILL 5
			{
				set TMP_A 0
				set tempb 0
				ife player[].gotweapon PISTOL_WEAPON YES 
				{
					add TMP_A player[].ammo_amount PISTOL_WEAPON
					ifl TMP_A 48 orvar tempb 1
				}
				ife player[].gotweapon SHOTGUN_WEAPON YES
				{
					set TMP_B player[].ammo_amount SHOTGUN_WEAPON
					mul TMP_B 6
					ifl TMP_B 48 orvar tempb 2
					add TMP_A TMP_B
				}
				ife player[].gotweapon CHAINGUN_WEAPON YES 
				{
					set TMP_B player[].ammo_amount CHAINGUN_WEAPON
					ifl TMP_B 48 orvar tempb 4
					add TMP_A TMP_B
				}
				ife player[].gotweapon RPG_WEAPON YES
				{
					set TMP_B player[].ammo_amount RPG_WEAPON
					mul TMP_B 20
					ifl TMP_B 60 orvar tempb 8
					add TMP_A TMP_B
				}
				ifg player[].ammo_amount HANDBOMB_WEAPON 0
				{
					set TMP_B player[].ammo_amount HANDBOMB_WEAPON
					mul TMP_B 20
					ifl TMP_B 60 orvar tempb 16
					add TMP_A TMP_B
				}
				ife player[].gotweapon SHRINKER_WEAPON YES
				{
					set TMP_B player[].ammo_amount SHRINKER_WEAPON
					mul TMP_B 10
					ifl TMP_B 50 orvar tempb 32
					add TMP_A TMP_B
				}
				ife player[].gotweapon DEVISTATOR_WEAPON YES
				{
					set TMP_B player[].ammo_amount DEVISTATOR_WEAPON
					mul TMP_B 4
					ifl TMP_B 48 orvar tempb 64
					add TMP_A TMP_B
				}
				ifg player[].ammo_amount TRIPBOMB_WEAPON 0
				{
					set TMP_B player[].ammo_amount TRIPBOMB_WEAPON
					mul TMP_B 25
					ifl TMP_B 51 orvar tempb 128
					add TMP_A TMP_B
				}
				ife player[].gotweapon FREEZE_WEAPON YES
				{
					set TMP_B player[].ammo_amount FREEZE_WEAPON
					mul TMP_B 2
					ifl TMP_B 48 orvar tempb 256
					add TMP_A TMP_B
				}
				ife player[].gotweapon GROW_WEAPON YES
				{
					set TMP_B player[].ammo_amount GROW_WEAPON
					mul TMP_B 2
					ifl TMP_B 48 orvar tempb 512
					add TMP_A TMP_B
				}
				ifvarand gotplasma 1 ifg plasmammo 0
				{
					set TMP_B plasmammo
					mul TMP_B 3
					ifl TMP_B 48 orvar tempb 1024
					add TMP_A TMP_B
				}
				ifvarand gotbow 1 ifg arrows 0
				{
					set TMP_B arrows
					mul TMP_B 4
					ifl TMP_B 48 orvar tempb 2048
					add TMP_A TMP_B
				}
				
				ifn tempb 0
				ifl TMP_A 100
				{
					rand temp 6
					switch temp
					case 0 case 1
					ife player[].gotweapon PISTOL_WEAPON YES
					ifl player[].ammo_amount PISTOL_WEAPON 48 { userquote 65 addammo PISTOL_WEAPON 12 }
					break
					
					case 2 case 3
					ife player[].gotweapon SHOTGUN_WEAPON YES
					ifl player[].ammo_amount SHOTGUN_WEAPON 8 { userquote 69 addammo SHOTGUN_WEAPON 2 }
					break
					
					case 4 case 5
					ife player[].gotweapon CHAINGUN_WEAPON YES
					ifl player[].ammo_amount CHAINGUN_WEAPON 60 { userquote 63 addammo CHAINGUN_WEAPON 15 }
					break
					
					case 6
					ife player[].gotweapon FREEZE_WEAPON YES
					ifl player[].ammo_amount FREEZE_WEAPON 32 { userquote 347 addammo FREEZE_WEAPON 8 }
					break
					
					// case 7
					// ife player[].gotweapon SHRINKER_WEAPON YES
					// ifl player[].ammo_amount SHRINKER_WEAPON 8 { userquote 347 addammo SHRINKER_WEAPON 2 }
					// break
					
					// case 8
					// ife player[].gotweapon GROW_WEAPON YES
					// ifl player[].ammo_amount GROW_WEAPON 40 { userquote 347 addammo GROW_WEAPON 10 }
					// break
					
					endswitch
					
				}
			}
			killit
		}
	}

geta[].z z fall
enda

defstate givecoin
 
  ife gametype 0 ife vendorupgrade YES 
  {
	  ifspritepal 8 { userquote 786 set B 10 } else
	  ifspritepal 1 { userquote 787 set B 25 } else
	  ifspritepal 97 { userquote 788 set B 50 } else
	  ifspritepal 10 { userquote 789 set B 100 } else
	  ifspritepal 63 { userquote 790 set B 200 } else
	  { userquote 798 set B 75 }
  }
  else
  {
	  ifspritepal 8 { userquote 273 set B 1 } else
	  ifspritepal 1 { userquote 274 set B 5 } else
	  ifspritepal 97 { userquote 275 set B 10 } else
	  ifspritepal 10 { userquote 276 set B 20 } else
	  ifspritepal 63 { userquote 277 set B 50 } else
	  set B 15
  }
  add credits B
  set lastcredits credits
  ifpdistl 1024
  palfrom 16 0 32
  sound COINPICK
  killit
ends

spritenoshade IMPCOIN
spriteshadow IMPCOIN
spritenopal IMPCOIN

useractor notenemy IMPCOIN 0

// set monstatus 100 strength 1
ifmove 0
{
	seta[].shade -80
	move STOPPED
	ifspritepal 8 sizeat 10 10 else
	ifspritepal 1 sizeat 11 11 else
	ifspritepal 97 sizeat 12 12 else
	ifspritepal 10 sizeat 14 14 else
	ifspritepal 63 sizeat 15 15 else
	sizeat 13 13
	geta[].htflags temp, orvar temp 2097152, seta[].htflags temp
	ife gametype 0 ife vendorupgrade YES nullop else
	ifpdistg 20480 killit
	
	set z sprite[].z
	sub z player[].posz
	ifg z 81920 state givecoin
}
ife gametype 0 ife vendorupgrade YES resetcount


ifvarand perks 32 // coin magnet
{
	ifpdistl 6144
	{
		ifmove STOPPED move COINVELUP faceplayer getv
	}
	else move STOPPED
}
else
{
	ifpdistl 2048
	{
		ifmove STOPPED move COINVELUP faceplayer getv
	}
	else move STOPPED
}

ifmove COINVELUP ifl sprite[].z player[].posz
move COINVELDOWN faceplayer


ifcount 300
{
   ife lastang 0 cstat 0 else
   ife lastang 1 cstat 2 else
   ife lastang 2 cstat 514 else
   ife lastang 3 cstat 32768 else
   ife lastang 4 cstat 514 else
   ife lastang 5 cstat 2
   
   add lastang 1
   ifg lastang 5 set lastang 0
   ifcount 450 killit
}

ifpdistl 896
	// ifcanseetarget
	  state givecoin
else 
ifn player[].timebeforeexit 0 state givecoin
else
iffloordistl 4
{
	switch sector[].floorpicnum
	case FLOORSLIME
	case FLOORPLASMA
	case PURPLELAVA
		state givecoin
	break
	endswitch
}
else
ifg sprite[].zvel 3500 state givecoin

ifg Numsprites 15000 state givecoin

fall
enda

defstate freezeme

	ifn shrunken 0 break
	set burning 0
	espawn ICESPRITE
	setav[RETURN].myspawner THISACTOR
	setav[RETURN].mtype sprite[].picnum
	
	espawn BIGSMOKE
	// seta[RETURN].pal 1
	seta[RETURN].xrepeat 96
	seta[RETURN].yrepeat 96
	geta[RETURN].z z
	sub z 4096
	seta[RETURN].z z
	
	ifg spawnprotect 0 { ifspritepal 33 getlastpal set spawnprotect 0 }

ends


defstate kickcheckcode
	ifge sprite[].alpha 160 
	{ 
		ife dashtarg THISACTOR set dashtarg -1  
		ife kicktarg THISACTOR set kicktarg -1
		break
	}
	ifn saberdash 0 ife dashtarg -1
	ifpdistl 6144
	ifp pfacing
		set dashtarg THISACTOR

	set temp NO
	
	ife slidehit NO
	{
		ifg slidekick 5 ifl slidekick 23
		{
			ifp pfacing
			set temp YES
		}
		else
		{
			switch sidekick
			case 0
				
				ifpdistl 2560
				ifvarand bits 4194304
				ifp pfacing
				{
					ife kicktarg -1
					{
						ifn player[].quick_kick 0
							set kicktarg THISACTOR
						else
						ifn qk_proxy 0
							set kicktarg THISACTOR
					}	
					ife player[].quick_kick 1 set sidekick 51 else
					ife qk_proxy 1 set sidekick 51
					
					ife sidekick 51
					{
						setp[].quick_kick 0
						set qk_proxy 0
						setp[].last_quick_kick 0
						set slidehit NO
					}
					
				}
			break
			case 8 case 9 case 10 case 11
			case 12 case 13 case 14 case 15
			case 40 case 41 case 42 case 43
			case 58 case 59 case 60 case 61
			ifp pfacing
			{
				set temp YES
				ife kicktarg -1
				ifpdistl 2560
					set kicktarg THISACTOR
			}
			
			break
			
			case 110 case 111 case 112 case 113
			case 114 case 115 case 116 case 117
			case 118 case 119 case 120
				ifp pfacing
				{
					set temp YES
					ife kicktarg -1
					ifpdistl 2560
						set kicktarg THISACTOR
				}
				else
				ife sprite[].htpicnum KNEE
				ifg sprite[].htextra 0 set temp YES
			
			break
			endswitch
			
		}
	}
	
	ife temp YES
	ifpdistl 1024
	{
		set slidehit YES
		
		geta[].htextra temp
		ifl temp 10 set TMP_A YES else set TMP_A NO
		set tempb SLIDEKICKSTRENGTH
		mul tempb pdamage, div tempb 100
		add temp tempb
		seta[].htpicnum KNEE
		seta[].htowner player[].i
		seta[].htang player[].ang
		seta[].htextra temp
		
		ife TMP_A YES ifn attmode NO
		ifg monxp 0
		{
			ifn sprite[].pal 1
			ifg temp sprite[].extra set temp sprite[].extra
			ifspritepal 1 set TMP_B 9 else set TMP_B 0
			ife pchar 0 set tempc dweapxp[TMP_B] else 
			ife pchar 2 set tempc wweapxp[TMP_B] else 
			set tempc bweapxp[TMP_B]
			ife marathon YES div temp 2
			add tempc temp
			ife pchar 0 setarray dweapxp[TMP_B] tempc else 
			ife pchar 2 setarray wweapxp[TMP_B] tempc else
			setarray bweapxp[TMP_B] tempc
		
			ife pchar 0 set TMP_A dweaplevel[TMP_B] else 
			ife pchar 2 set TMP_A wweaplevel[TMP_B] else
			set TMP_A bweaplevel[TMP_B]
			add TMP_A 1
			ifg TMP_A 2 mul TMP_A 2500 else
			mul TMP_A 2000
			sub TMP_A 1000
			
			ife pchar 0 set temp dweapxp[TMP_B] else 
			ife pchar 2 set temp wweapxp[TMP_B] else
			set temp bweapxp[TMP_B]
			
			ifge temp TMP_A
			{
				
				ife pchar 0 
				{
					set temp dweaplevel[TMP_B]
					add temp 1
					ifl temp 7 add totalxp 1000
					setarray dweaplevel[TMP_B] temp
					
					ifvarand comboperk 1 nullop else
					// check to see if comboperk is achieved
					{
						set tempc 0
						set tempb 0 
						whilevarn tempc 13
						{
							ifg dweaplevel[tempc] 0
							add tempb 1
							add tempc 1
						}
						ifge tempb 11
						{
							orvar comboperk 1
							set buffermsg 1139
						}
					}
					
					ife buffermsg 0
					{
						// ife temp 1 set buffermsg 795 else 
						ife temp 3 set buffermsg 796 else ife temp 5 set buffermsg 797
					}
					set bigmsg 793
					set bigmsgcount 90
					set temp dweapxp[TMP_B]
					sub temp TMP_A
					setarray dweapxp[TMP_B] 0 // temp
				}
				else
				ife pchar 2
				{
					set temp wweaplevel[TMP_B]
					add temp 1
					ifl temp 7 add totalxp 1000
					setarray wweaplevel[TMP_B] temp
					
					ifvarand comboperk 4 nullop else
					// check to see if comboperk is achieved
					{
						set tempc 0
						set tempb 0 
						whilevarn tempc 13
						{
							ifg wweaplevel[tempc] 0
							add tempb 1
							add tempc 1
						}
						ifge tempb 11
						{
							orvar comboperk 4
							set buffermsg 1139
						}
					}
					
					ife buffermsg 0
					{
						// ife temp 1 set buffermsg 795 else 
						ife temp 3 set buffermsg 796 else ife temp 5 set buffermsg 797
					}
					set bigmsg 1195
					set bigmsgcount 90
					set temp wweapxp[TMP_B]
					sub temp TMP_A
					setarray wweapxp[TMP_B] 0 // temp
				}
				else
				{
					set temp bweaplevel[TMP_B]
					add temp 1
					ifl temp 7 add totalxp 1000
					setarray bweaplevel[TMP_B] temp
					
					ifvarand comboperk 2 nullop else
					// check to see if comboperk is achieved
					{
						set tempc 0
						set tempb 0 
						whilevarn tempc 13
						{
							ifg bweaplevel[tempc] 0
							add tempb 1
							add tempc 1
						}
						ifge tempb 11
						{
							orvar comboperk 2
							set buffermsg 1139
						}
					}
					
					ife buffermsg 0
					{
						// ife temp 1 set buffermsg 795 else 
						ife temp 3 set buffermsg 796 else ife temp 5 set buffermsg 797
					}
					set bigmsg 794
					set bigmsgcount 90
					set temp bweapxp[TMP_B]
					sub temp TMP_A
					setarray bweapxp[TMP_B] 0 // temp
				}
				screensound WEAPON_UPGRADE
				screensound WEAPON_UPGRADE
				palfrom 32 63 63 63
			}
			
			ife pchar 0 set TMP_A dweaplevel[TMP_B] else 
			ife pchar 2 set TMP_A wweaplevel[TMP_B] else
			set TMP_A bweaplevel[TMP_B]
			mul TMP_A 8
			add TMP_A 100
			geta[].htextra temp
			mul temp TMP_A
			div temp 100
			seta[].htextra temp	
		}
		
		switch sprite[].picnum
		case BOSS1
		case BOSS2
		case BOSS3
		case BOSS4
		case PSPIDER
		case CYCLOIDMAX
		case NEWBATLORD
		case QUEEN
		case PIGBOSS
		case LIZBOSS
		case MEGABRAIN
		case EGG case EGGYOUNG
		case TERMINATORCRAWLING
		case TANK
		case EBARRIER
		break
		
		default
			getp[].i spriteid
			state facesprite
			set xvel -1024
			set z -2048
			ifn sidekick 0 { shiftr xvel 1 shiftr z 1 }
			seta[].xvel xvel
			seta[].zvel z
			geta[].z z
			sub z 2048
			seta[].z z
			set temp sprite[].htextra
			mul temp 5
			div temp inithp
			ifg temp 1
			add stun temp
		break
		endswitch
		
		sound KICKIMPACT
	}
	else
	ifp ponground nullop
	else
	ifpdistl 2048
	ifl sprite[player[].i].z sprite[].z
	ife jumpkickhit NO
	ifg jumpkick 0 ifl jumpkick 18
	{
		set jumpkickhit YES
		
		geta[].htextra temp
		set tempb SLIDEKICKSTRENGTH
		mul tempb pdamage, div tempb 100
		add temp tempb
		seta[].htextra temp
		
		ifstrength 90
		ifrnd 96
		seta[].htpicnum HEADJIB1
		else 
		seta[].htpicnum KNEE
		seta[].htowner player[].i
		seta[].htang player[].ang
		
		switch sprite[].picnum
		case BOSS1
		case BOSS2
		case BOSS3
		case BOSS4
		case PSPIDER
		case CYCLOIDMAX
		case NEWBATLORD
		case QUEEN
		case PIGBOSS
		case LIZBOSS
		case MEGABRAIN
		case EGG case EGGYOUNG
		case TERMINATORCRAWLING
		case TANK
		case EBARRIER
		break
		
		default
			getp[].i spriteid
			state facesprite
			seta[].xvel -1024
			seta[].zvel -2048
			geta[].z z
			sub z 3072
			seta[].z z
			set temp sprite[].htextra
			mul temp 6
			div temp inithp
			ifg temp 1
			add stun temp
		break
		endswitch
		sound KICKIMPACT
	}
ends

// used when actor vaporized
spritenoshade OUTLINE
useractor notenemy OUTLINE 0

	seta[].shade -100
	ifn sprite[].pal 4
	spritepal 33
	cstator 2
	add countvar 5
	seta[].alpha countvar
	ifg countvar 250 killit
enda

spritenopal SPEEDBLUR
action ABLURFRAME 0 1 5 1 1
useractor notenemy SPEEDBLUR 0 ABLURFRAME

	ifcount 5 killit
	geta[].alpha temp
	add temp 32
	ifg temp 255 set temp 255
	seta[].alpha temp

enda


spritenopal EBARRIER
spritenoshade EBARRIER

defstate breakbarrier

	ifn myspawner -1 { getav[myspawner].monstflags temp ifvarand temp 8 xorvar temp 8 setav[myspawner].monstflags temp }
	ife mtype APLAYER ifhitspace { killit break }
	spritepal 1
	lotsofglass 30
	ifsound SHIELDBREAK nullop else screensound SHIELDBREAK
	sound GLASS_BREAKING
	killit
	
ends

useractor notenemy EBARRIER 100

ife myspawner -1 state breakbarrier

ifmove 0
{
	move STOPPED
	cstat 338
	sizeat 12 12
	seta[].shade -50
	getav[myspawner].inithp inithp
	add inithp 200
	ifg inithp 16384 set inithp 16384
	ifspritepal 21 { mul inithp 2 div inithp 3 }
	setactor[THISACTOR].extra inithp
	set monstatus 1
	getav[myspawner].team team
	set monxp 50
	ife sprite[myspawner].picnum ROLLYTURRET ife team 1 set mtype APLAYER
}

ife sprite[myspawner].picnum MONSHADOW cstat 32768 else
ifge sprite[myspawner].alpha 160 cstat 32768 else
ifge sprite[myspawner].cstat 32768 cstat 32768 else
ife sprite[myspawner].picnum NURGLE ifn actorvar[myspawner].countvar 0 cstat 32768 else
cstat 338

getav[myspawner].team team

geta[myspawner].picnum picnum
set x tiledata[picnum].xsize
mul x sprite[myspawner].xrepeat
div x tiledata[sprite[].picnum].xsize
add x 4
seta[].xrepeat x
set y tiledata[picnum].ysize
mul y sprite[myspawner].yrepeat
div y tiledata[sprite[].picnum].ysize
ife sprite[myspawner].picnum ROTATEGUN add y 4
add y 2
seta[].yrepeat y

geta[myspawner].alpha temp, add temp 16, ifg temp 255 set temp 255
seta[].alpha temp
seta[].ang sprite[myspawner].ang
ife actorvar[myspawner].monstatus 2 state breakbarrier
ife sprite[myspawner].statnum 1024 state breakbarrier
set x sprite[myspawner].x
set x2 tiledata[sprite[myspawner].picnum.ysize
ifl x2 30 set x2 30
mul x2 sprite[myspawner].yrepeat

div x2 8

// mul x2 16
add x x2


rotatepoint sprite[myspawner].x sprite[myspawner].y x sprite[myspawner].y sprite[myspawner].ang x2 y2

set mysector sprite[myspawner].sectnum
updatesectorz x2 y2 sprite[myspawner].z mysector
ifn mysector sprite[myspawner].sectnum
{
	set x sprite[myspawner].x
	// add x 384
	set x2 sprite[myspawner].yrepeat
	mul x2 8
	add x x2
	rotatepoint sprite[myspawner].x sprite[myspawner].y x sprite[myspawner].y sprite[myspawner].ang x2 y2
}

geta[myspawner].z z
getav[myspawner].bottarget bottarget
ifn bottarget -1
{
	set z2 sprite[bottarget].z
	sub z2 z
	shiftr z2 2
	clamp z2 -4096 4096
	add z z2
}


setsprite THISACTOR x2 y2 z

ifcansee
ifl sprite[].alpha 144
	state kickcheckcode	

state predamage
ifhitweapon
{
	ifrnd 128
	soundonce HITSHIELD else
	soundonce HITSHIELD2
	ifdead state breakbarrier
	else ifn sprite[].htowner -1
	ife actorvar[myspawner].bottarget -1
	ifn team actorvar[sprite[].htowner].team
		setav[myspawner].bottarget sprite[].htowner
	
}

enda

spritenoshade RADIMPACT
spritenopal RADIMPACT
action RADEXPFRAMES 0  4  1  1  18
useractor notenemy RADIMPACT 0

ifaction 0
{
	action RADEXPFRAMES
	seta[].shade -100
	cstat 130
	ifrnd 128 cstator 4
	ifrnd 128 cstator 8
	ifn inithp 0
	{
		div inithp 12
		ifl inithp 18 set inithp 18
		ifg inithp 80 set inithp 80
		setprojectile[RADPROJ].extra inithp
	}
	set countvar 0
	geta[].ang angvel
	whilevarn countvar 16
	{
		rand zdist 2048
		sub zdist 2560
		ezshoot zdist RADPROJ
		ife myspawner player[].i seta[RETURN].owner player[].i
		add countvar 1
		add angvel 128
		seta[].ang angvel
	}
	setprojectile[RADPROJ].extra 20
}

ifactioncount 4 killit else
ifactioncount 3
{
	sizeto 0 0
	sizeto 0 0
	sizeto 0 0
}
else
ifactioncount 2
{
	sizeto 0 0
}
else
{
	sizeto 64 64
	sizeto 64 64
	sizeto 64 64
}

enda

spritenoshade RADAURA
spritenopal RADAURA

defstate radauradie
	ifn initsprite GREENSLIME
	ifn initsprite ARMYANTCRAWL
	{
		geta[].yrepeat y
		shiftl y 7
		geta[].z z
		sub z y
		seta[].z z
	}
	espawn RADIMPACT
	setav[RETURN].inithp inithp
	setav[RETURN].team 2
	sound RADEXPLOSION sound RADEXPLOSION
	geta[].xrepeat x, div x 4
	seta[RETURN].xrepeat x
	seta[RETURN].yrepeat x
	killit
ends

useractor notenemy RADAURA 0

ife myspawner -1 state radauradie
setsprite THISACTOR sprite[myspawner].x sprite[myspawner].y sprite[myspawner].z

getav[myspawner].team team
ifmove 0
{
	move STOPPED geth
	cstat 32
	cstator 2
	spritepal 6
	// seta[].blend 1
	seta[].shade -100
	set x tiledata[sprite[myspawner].picnum].xsize
	mul x sprite[myspawner].xrepeat
	getav[myspawner].inithp inithp
	ifl inithp 8 set inithp 8
	shiftr x 5
	ife sprite[myspawner].picnum GREENSLIME shiftr x 1
	ifg x 255 set x 255
	seta[].xrepeat x
	seta[].yrepeat x
	set initsprite sprite[myspawner].picnum
}
rand angvar 2047
seta[].ang angvar

seta[].alpha sprite[myspawner].alpha

ife actorvar[myspawner].monstatus 2 state radauradie
ife sprite[myspawner].statnum 1024 state radauradie
ife sprite[myspawner].picnum EGG ife actorvar[myspawner].team 3 killit

enda

defstate shockauradie

killit

ends

useractor notenemy SHOCKAURA 0

ife myspawner -1 state shockauradie
setsprite THISACTOR sprite[myspawner].x sprite[myspawner].y sprite[myspawner].z

getav[myspawner].team team
ifmove 0
{
	move STOPPED geth
	cstat 32
	cstator 2
	spritepal 16
	seta[].blend 1
	seta[].shade -100
	set x tiledata[sprite[myspawner].picnum].xsize
	mul x sprite[myspawner].xrepeat
	getav[myspawner].inithp inithp
	ifl inithp 8 set inithp 8
	// shiftr x 6
	div x 80
	ife sprite[myspawner].picnum GREENSLIME shiftr x 1
	ifg x 255 set x 255
	seta[].xrepeat x
	seta[].yrepeat x
	set initsprite sprite[myspawner].picnum
	geta[myspawner].htflags temp
	orvar temp 4
	seta[myspawner].htflags temp
	seta[myspawner].shade -60
}
rand angvar 2047
seta[].ang angvar

seta[].alpha sprite[myspawner].alpha
ife actorvar[myspawner].monstatus 2 state shockauradie
ife sprite[myspawner].statnum 1024 state shockauradie
ife sprite[myspawner].picnum EGG ife actorvar[myspawner].team 3 killit

enda

spritenoshade HEALINGAURA
spritenopal HEALINGAURA

defstate healauradie

	espawn GROUNDSHOCK
	seta[RETURN].pal 11
	sound SHIELDBREAK
	ifn myspawner -1
	{
		getav[myspawner].monstflags monstflags
		ifvarand monstflags 1024 xorvar monstflags 1024
		setav[myspawner].monstflags monstflags
	}
	killit

ends

useractor notenemy HEALINGAURA 0

ife myspawner -1 state healauradie
setsprite THISACTOR sprite[myspawner].x sprite[myspawner].y sprite[myspawner].z

getav[myspawner].team team
ifmove 0
{
	move STOPPED geth
	cstat 32
	cstator 514
	spritepal 11
	seta[].shade -100
	set x tiledata[sprite[myspawner].picnum].xsize
	mul x sprite[myspawner].xrepeat
	shiftr x 4
	ifg x 255 set x 255
	set startx x
	seta[].blend 1
	getav[myspawner].inithp inithp
	ifl inithp 500 mul inithp 2
}
rand angvar 2047
seta[].ang angvar

ife actorvar[myspawner].monstatus 2 state healauradie
ife sprite[myspawner].statnum 1024 state healauradie

set RETURN -1
set mtype NO
headspritestat spriteid 1
whilevarn spriteid -1
{
	ife actorvar[spriteid].team team
	ife actorvar[spriteid].monstatus 1
	ifl sprite[spriteid].extra actorvar[spriteid].inithp 
	{
		dist xydist THISACTOR spriteid
		set savx startx
		// shiftl savx 5
		mul savx 24
		
		ifl xydist savx
		{
			ifn spriteid THISACTOR 
			{
				seta[].xrepeat startx
				seta[].yrepeat startx
			}
			set temp player[].player_par
			modvar temp 2
			ife temp 0
			{
				geta[spriteid].extra tempb
				add tempb 1
				seta[spriteid].extra tempb
				sub inithp 1
			}
			ife mtype NO
			{
				set mtype YES
				espawn CAPTUREPLUS
				ifn RETURN -1
				{
					seta[RETURN].pal 11
					rand x2 savx
					set temp savx, div temp 2
					sub x2 temp
					add x2 sprite[].x
					seta[RETURN].x x2
					
					rand y savx
					sub y temp
					add y sprite[].y
					seta[RETURN].y y
					seta[RETURN].z sprite[].z
				}
			}
			ifactorsound THISACTOR CAPTURING nullop else sound CAPTURING
		}
	}
	nextspritestat spriteid spriteid
}
ife RETURN -1 
{
	ifactorsound THISACTOR CAPTURING stopactorsound THISACTOR CAPTURING
	set x startx, div x 3
	seta[].xrepeat x
	seta[].yrepeat x
}
ifl inithp 1 state healauradie

enda

defstate spawnradwound

	espawn RADWOUND
	ifn hitsprite -1
	{
		setav[RETURN].myvictim hitsprite
		ldist xydist THISACTOR hitsprite
		// shiftr xydist 1
		setactorvar[RETURN].mtype xydist
		
		geta[].x x2
		geta[].y y2
		geta[hitsprite].x x
		geta[hitsprite].y y
		sub x2 x
		sub y2 y
		getangle tempc x2 y2 // angle to make monster face radwound
		getincangle angvel tempc sprite[hitsprite].ang
		setav[RETURN].angvel angvel
		
		geta[hitsprite].z shotpitch
		sub shotpitch sprite[].z
		setav[RETURN].shotpitch shotpitch
	}
	setav[RETURN].myspawner player[].i
	

ends

move VERTROCKUP 0 -192
move VERTROCKDOWN 0  384

defstate select_vertlanding

	set botclip 0
	set countvar 0
	whilevarn botclip 1
	{
		rand x 20480
		add x 2560
		set x2 startx
		ifrnd 128 add x2 x else sub x2 x
		
		rand y 20480
		add y 2560
		set y2 starty
		ifrnd 128 add y2 y else sub y2 y
		
		ifn myspawner -1 set mysector sprite[myspawner].sectnum
		updatesector x2 y2 mysector
		ifn mysector -1
		ife sector[mysector].floorslope 0 
		{
			getceilzofslope mysector x2 y2 z
			getflorzofslope mysector x2 y2 z2
			set temp z2
			sub temp z
			ifge temp 65536
			{
				setsprite THISACTOR x2 y2 z
				findnearactor GROUNDTARGET 5120 spriteid
				ife spriteid -1
				{
					espawn GROUNDTARGET
					changespritestat RETURN 1
					seta[RETURN].cstat 32
					seta[RETURN].shade -100
					setav[RETURN].myspawner THISACTOR
					set myspawner RETURN
					sub z2 256
					setsprite RETURN x2 y2 z2
					set botclip 1
				}
			}
		}
		add countvar 1
		ifge countvar 644 set botclip 1
	}
	ife myspawner -1 killit else set countvar -150

ends



useractor notenemy VERTROCKET 0

ifmove 0
{
	sizeat 32 32
	move VERTROCKUP geth
	sound ROCKETFIRE2
	seta[].shade -80
	set mtype -48
	geta[].x startx
	geta[].y starty
}

movesprite THISACTOR 0 0 mtype CLIPMASK0 RETURN
sub mtype 48

getceilzofslope sprite[].sectnum sprite[].x sprite[].y z
geta[].z zdist
sub zdist z
ifl zdist 2048
ifmove VERTROCKUP
{
	geta[].z temp
	sub temp 3072
	seta[].z temp
	
	ifcount 180
	{
		cstat 32768
		move STOPPED
		state select_vertlanding
	}
}

ifmove VERTROCKUP spawn SMALLSMOKE
ifmove VERTROCKDOWN spawn SMALLSMOKE

ifn myspawner -1
{
	add countvar 1
	ifge countvar 0
	{
		ife countvar 0
		{
			cstat 8
			set mtype 0
			move VERTROCKDOWN geth getv
			geta[].z countvarb
		}
		movesprite THISACTOR 0 0 mtype CLIPMASK0 RETURN
		add mtype 48
		getflorzofslope sprite[].sectnum sprite[].x sprite[].y z
		sub z sprite[].z
		ifl z 4096
		{
			espawn NUKEEXPLOSION
			setav[RETURN].mtype 1
			setav[myspawner].monstatus 2
			killit
		}
		ifle sprite[].z countvarb { fall geta[].z z add z 1024 seta[].z z }
		geta[].z countvarb
	}
}

enda

eventloadactor ROCKETRAIN
cstat 32768
enda

useractor notenemy GROUNDTARGET
ife monstatus 2 killit
ifn myspawner -1
sizeat 128 128
state shadepulse
seta[].shade shade
enda

action SPIKEFRAME 6739
spritenoshade LOBTRAIL
useractor notenemy LOBTRAIL 0 
	
	ife pchar 0 ifvarand dukeupgrades[HANDBOMB_WEAPON] 1 action SPIKEFRAME
	ifcount 1 killit
	ife countvar 0 killit 
	sizeat 4 4
	ife player[].over_shoulder_on YES { cstator 2176 sizeat 8 8 } else
	cstator 658
	ifvarand countvar 1 cstator 4
	ifg countvar 128 spritepal 6
	
	iffloordistl 8 spritepal 6 // giving wrong result
enda

move STAKEVELS 64

useractor notenemy STAKESTUCK 0

ife myspawner -1 
{
	// ifcount 450 killit
	ifhitspace ifp palive 
	ifpdistl 1024 ifp pfacing ifcansee
	cactor STAKESPRITE
	break
}
ifvarg sprite[myspawner].statnum 2 killit
ifvarn actorvar[myspawner].monstatus 1 
ifvarn actorvar[myspawner].monstatus 3
killit

ifmove 0
{	
	cstat 0
	sizeat 10 10
	geta[].ang lastang
	geta[myspawner].ang ikicked
	move STAKEVELS geth
}

// mtype = distance
// angvel = angle offset for rotatepoint

// mtype = distance
// angvel = angle offset for rotatepoint

ifmove STAKEVELS
{
	ife sprite[myspawner].picnum NEWPIGTARGET killit
	ife sprite[myspawner].picnum NEWTROOPTARGET killit
	// move victim instead
	
	seta[].ang lastang
	
	ifn sprite[myspawner].picnum ROTATEGUN
	ifn sprite[myspawner].picnum LIZTURRET
	ifn sprite[myspawner].picnum EDFTURRET
	ifn sprite[myspawner].picnum BOSS2FLY
	{
		cos xvel lastang
		sin yvel lastang
		  
		shiftvarr xvel 4
		shiftvarr yvel 4
		seta[myspawner].clipdist 32
		movesprite myspawner xvel yvel 0 CLIPMASK0 RETURN
		ifn RETURN 0 
		{
			set initsprite 1 // STUCK TO SOMETHING!
			set startx sprite[myspawner].x
			set starty sprite[myspawner].y
			set float sprite[myspawner].z
		}
	}
	ifcount 3 move STOPPED geth
}

ife initsprite 1
{
	cos xvel lastang
	sin yvel lastang
	  
	shiftvarr xvel 4
	shiftvarr yvel 4
	
	movesprite myspawner xvel yvel 0 CLIPMASK0 RETURN
	ife RETURN 0 set initsprite 0
	
	seta[].ang lastang
	seta[myspawner].xvel 0
	seta[myspawner].zvel 0
	ifn mynaamah -1
	ife actorvar[mynaamah].myvictim THISACTOR 
	set float sprite[myspawner].z
	
	setsprite myspawner startx starty float
	set B NO
	// ifl actorvar[myspawner].inithp 600 set B YES else
	// {	
		
		set picnum sprite[myspawner].picnum
		set TMP_A tiledata[picnum].xsize
		mul TMP_A sprite[myspawner].xrepeat
		ifle TMP_A	3200 set B YES
		
	// }
	
	ife B YES
	{
		setav[myspawner].stun 10
		setav[myspawner].bottarget -1
		set angvar lastang, add angvar 1024
		seta[myspawner].ang ikicked // angvar
	}
}

getactor[myspawner].x x
getactor[myspawner].y y
getactor[myspawner].ang angvar
subvarvar angvar angvel
setvarvar x2 x
ife initsprite 1 sub x2 128
else
addvarvar x2 mtype
rotatepoint x y x2 y angvar x y
setactor[THISACTOR].x x
setactor[THISACTOR].y y

getactor[myspawner].ang angvar
subvarvar angvar botclip
setactor[THISACTOR].ang angvar
getactor[myspawner].z z
subvarvar z shotpitch
setactor[THISACTOR].z z


ifrnd 8
{
	geta[myspawner].picnum picnum
	set TILETYPE -1
	state tiletype
	ifge TILETYPE 2 ifle TILETYPE 4
	{
		cactor ARROWPROJ
		spawn SPARKFALL spawn SPARKFALL
		spawn SPARKFALL spawn SPARKFALL
		cactor STAKESTUCK
		ifn picnum ARMPIG sound SPARKING1
	}
	else
	{
		espawn JIBS6
		setactor[RETURN].zvel 0
		setactor[RETURN].xvel 0
		setactor[RETURN].xrepeat 32
		setactor[RETURN].yrepeat 32
		setactor[RETURN].pal sprite[myspawner].pal
	}
	getactor[myspawner].htextra temp
	ifvarl temp 1 setactor[myspawner].htpicnum STUCKARROW
	addvar temp 7
	setactor[myspawner].htextra temp
	setactor[myspawner].htowner player[THISACTOR].i
	// setactor[myspawner].htang sprite[THISACTOR].ang
}

ifcount 450 killit
ife sprite[myspawner].picnum DEANOVA ife actorvar[myspawner].mtype 1 ifrnd 16 killit
ife sprite[myspawner].picnum SITH ife actorvar[myspawner].mtype 1 ifrnd 16 killit
ife sprite[myspawner].picnum SYTH ife actorvar[myspawner].mtype 1 ifrnd 16 killit
enda

useractor notenemy BLADEPROJSTUCK 0

ife myspawner -1 
{
	break
}
ifvarg sprite[myspawner].statnum 2 killit
ifvarn actorvar[myspawner].monstatus 1 
ifvarn actorvar[myspawner].monstatus 3
killit

ifmove 0
{	
	cstat 0
	sizeat 10 10
	geta[].ang lastang
	move STOPPED geth
	// geta[].pitch B al B
	
	rand angvar 72
	sub angvar 36
	seta[].roll angvar
	
	getactor[myspawner].z z
	subvarvar z shotpitch
	setactor[THISACTOR].z z
	
	// espawn DRIPBLOOD
	// setav[RETURN].myspawner THISACTOR
}



// mtype = distance
// angvel = angle offset for rotatepoint

// mtype = distance
// angvel = angle offset for rotatepoint

getactor[myspawner].x x
getactor[myspawner].y y
getactor[myspawner].ang angvar
subvarvar angvar angvel
setvarvar x2 x
addvarvar x2 mtype
rotatepoint x y x2 y angvar x y
setactor[THISACTOR].x x
setactor[THISACTOR].y y

getactor[myspawner].ang angvar
subvarvar angvar botclip
setactor[THISACTOR].ang angvar
getactor[myspawner].z z
subvarvar z shotpitch
setactor[THISACTOR].z z



add countvar 1
ifge countvar 8
{
	set countvar 0
	geta[myspawner].picnum picnum
	set TILETYPE -1
	state tiletype
	ifge TILETYPE 2 ifle TILETYPE 4
	{
		cactor ARROWPROJ
		spawn SPARKFALL spawn SPARKFALL
		spawn SPARKFALL spawn SPARKFALL
		cactor BLADEPROJSTUCK
		ifn picnum ARMPIG soundonce SPARKING1
	}
	else
	{
		espawn JIBS6
		setactor[RETURN].zvel 0
		setactor[RETURN].xvel 0
		setactor[RETURN].xrepeat 32
		setactor[RETURN].yrepeat 32
		setactor[RETURN].pal sprite[myspawner].pal
	}
}
ifrnd 10
{
	getactor[myspawner].htextra temp
	ifvarl temp 1 setactor[myspawner].htpicnum STUCKARROW
	addvar temp 7
	setactor[myspawner].htextra temp
	setactor[myspawner].htowner player[THISACTOR].i

}


ifcount 300 killit
ife sprite[myspawner].picnum DEANOVA ife actorvar[myspawner].mtype 1 ifrnd 16 killit
ife sprite[myspawner].picnum SITH ife actorvar[myspawner].mtype 1 ifrnd 16 killit
ife sprite[myspawner].picnum SYTH ife actorvar[myspawner].mtype 1 ifrnd 16 killit
enda

useractor notenemy DRIPBLOOD 0

ifmove 0
{
	move STOPPED faceplayer
	cstat 1024
	ifrnd 128 cstator 4
	sizeat 8 8
	
	ifspawnedby APLAYER seta[].z player[].posz
}


ifl sprite[].yrepeat 96
{
	sizeto 20 96
	ifn myspawner -1 add shotpitch 160 else
	{
		geta[].z z
		add z 160
		seta[].z z
	}
}

ifcount 60
{
	geta[].alpha temp
	add temp 1
	seta[].alpha temp
}

ifn myspawner -1
{
	ife sprite[myspawner].statnum 1024 killit else
	ife actorvar[myspawner].shotpitch 0 killit else
	{
		getav[myspawner].z z
		add z shotpitch
		setsprite THISACTOR sprite[myspawner].x sprite[myspawner].y z
	}
}

ifcount 240 killit

enda

useractor notenemy STUCKARROW 0
ifvarg sprite[myspawner].statnum 2 killit
ifvarn actorvar[myspawner].monstatus 1 
ifvarn actorvar[myspawner].monstatus 3
killit

// mtype = distance
// angvel = angle offset for rotatepoint

getactor[myspawner].x x
getactor[myspawner].y y
getactor[myspawner].ang angvar
subvarvar angvar angvel
setvarvar x2 x
addvarvar x2 mtype
rotatepoint x y x2 y angvar x y
setactor[THISACTOR].x x
setactor[THISACTOR].y y

getactor[myspawner].ang angvar
subvarvar angvar botclip
setactor[THISACTOR].ang angvar
getactor[myspawner].z z
subvarvar z shotpitch
setactor[THISACTOR].z z

ifn sprite[myspawner].xvel 0
ifl sprite[myspawner].extra 1000
{
	geta[myspawner].xvel xvel
	mul xvel 4 div xvel 5
	seta[myspawner].xvel xvel
}
// 0 = regular pal 0; 1 = burning pal 2; 2 = explosive pal 7; 
// 3 = multi pal 12; 4 = freeze pal 1; 5 = spy pal 15; 
// 6 = electric pal 117
// 7 = blood pal 54; 8 = radioactive pal 6

ifspritepal 1
{
	// getactorvar[myspawner].burning burning
	// subvar burning 1
	// setactorvar[myspawner].burning burning
	ifrnd 24
	{
		seta[myspawner].htpicnum FREEZEBLAST
		geta[myspawner].htextra temp
		ife temp -1 set temp 3 else add temp 3
		seta[myspawner].htextra temp
		setactor[myspawner].htowner player[THISACTOR].i
		setactor[myspawner].htang sprite[THISACTOR].ang
	}
	ifcount 210 killit
}
else
ifspritepal 2
{
	getactorvar[myspawner].burning burning
	addvar burning 1
	setactorvar[myspawner].burning burning
	ifrnd 24
	{
		seta[myspawner].htpicnum FIREBOLT
		geta[myspawner].htextra temp
		ife temp -1 set temp 1 else add temp 1
		seta[myspawner].htextra temp
		setactor[myspawner].htowner player[THISACTOR].i
		setactor[myspawner].htang sprite[THISACTOR].ang
	}
	ifcount 210 killit
}
else
ifspritepal 6
{
	ifrnd 64
	{
		espawn BIGSMOKE seta[RETURN].pal 76
		soundonce RADFRY
		ifrnd 84
		{
			geta[myspawner].htextra temp
			add temp 4
			seta[myspawner].htextra temp
			
			ifle temp 5
			{
				seta[myspawner].htpicnum RADWOUND
				seta[myspawner].htowner player[].i
			}
			
			ifrnd 32
			{
				getav[myspawner].monstflags temp
				ifvarand temp 4096 nullop else
				{
					
					ife actorvar[hitsprite].monstatus 1
					ifn sprite[hitsprite].picnum APLAYER
					{
						orvar temp 4096
						setav[myspawner].monstflags temp
						espawn RADAURA
						setav[RETURN].myspawner hitsprite
						
					}
					set hitsprite myspawner
					state spawnradwound
				}
				
			}
		}
	}
	ifcount 300 killit
}
else
ifrnd 8
{
	geta[myspawner].picnum picnum
	set TILETYPE -1
	state tiletype
	ifge TILETYPE 2 ifle TILETYPE 4
	{
		cactor ARROWPROJ
		spawn SPARKFALL spawn SPARKFALL
		spawn SPARKFALL spawn SPARKFALL
		cactor STUCKARROW
		ifn picnum ARMPIG sound SPARKING1
	}
	else
	{
		espawn JIBS6
		setactor[RETURN].zvel 0
		setactor[RETURN].xvel 0
		setactor[RETURN].xrepeat 32
		setactor[RETURN].yrepeat 32
		setactor[RETURN].pal sprite[myspawner].pal
	}
	getactor[myspawner].htextra temp
	ifvarl temp 1 setactor[myspawner].htpicnum STUCKARROW
	addvar temp 4 ifg gametype 0 add temp 2
	setactor[myspawner].htextra temp
	ifspritepal 54 ifn sprite[myspawner].picnum EBARRIER 
	{
		geta[myspawner].picnum picnum
		state tiletype
		ifn TILETYPE 2
		add leach 50
	}
	setactor[myspawner].htowner player[THISACTOR].i
	setactor[myspawner].htang sprite[THISACTOR].ang
}

ifcount 450 killit
ife sprite[myspawner].picnum DEANOVA ife actorvar[myspawner].mtype 1 ifrnd 16 killit
ife sprite[myspawner].picnum SITH ife actorvar[myspawner].mtype 1 ifrnd 16 killit
ife sprite[myspawner].picnum SYTH ife actorvar[myspawner].mtype 1 ifrnd 16 killit
enda

action ASTICKYFRAME -1

defstate stickyblow

	
	ifg myvictim -1
	{
		hitradius 2176 20 27 33 40
		geta[myvictim].htextra temp
		ife myspawner player[].i add temp 60 else
		ife myvictim player[].i add temp 13 else
			add temp 40
		
		ifg mlevel 0
		{
			mul mlevel 5
			add temp mlevel
		}
		seta[myvictim].htextra temp
		seta[myvictim].htpicnum RPG
		ifn myspawner -1 seta[myvictim].htowner myspawner else
		seta[myvictim].htowner THISACTOR
		
		ifpdistl 2177 
		ifn myspawner -1
		ifn player[].i myvictim
			seta[player[].i].htowner myspawner
			
		ife myvictim myspawner seta[myvictim].htextra -1
		
		ifn myspawner -1
		{
			headspritestat spriteid 1
			whilevarn spriteid -1
			{
				ifn actorvar[spriteid].monstatus 0
				{
					dist temp THISACTOR spriteid
					ifle temp 2176 seta[spriteid].htowner myspawner
				}
				nextspritestat spriteid spriteid
			}
		}
			
	}
	else ife myspawner player[].i 
	{
		hitradius 2176 25 30 38 50 
		ifvarand perks 8 ifpdistl 2180
		{
			getp[].i spriteid
			ife sprite[spriteid].htpicnum RADIUSEXPLOSION
				seta[spriteid].htextra -1
		}
	}
	else
	{
		hitradius 2176 20 27 33 40
		ifn myspawner -1
		{
			dist xydist THISACTOR myspawner
			ifle xydist 2176 seta[myspawner].htextra -1
		}
	}
	espawn EXPLOSION3
	seta[RETURN].xrepeat 20 seta[RETURN].yrepeat 20
	sound SMALLEXP1
	spawn SPARKFALL spawn SPARKFALL spawn SPARKFALL spawn SPARKFALL spawn SPARKFALL spawn SPARKFALL 
	killit

ends

useractor notenemy STICKYBOMB 0 ASTICKYFRAME

ifmove 0
{
	sound MAGLOCK
	move STOPPED
	// sound stickon
	cstator 128
	ifn myvictim -1
	{
		ife sprite[myspawner].picnum CHEERBOT ife actorvar[myspawner].team actorvar[myvictim].team
		set myvictim -1
	}
	ife myvictim -1 iffloordistl 4 cstat 0
	ifspritepal 33 sizeat 12 12 else
	sizeat 26 26
	
	getflorzofslope sprite[].sectnum sprite[].x sprite[].y z
	ifg sprite[].z z seta[].z z
	ifn myspawner -1
	ife actorvar[myspawner].team 0
		set mlevel actorvar[myspawner].mlevel
}

ifg myvictim -1
{
	// mtype = distance
	// angvel = angle offset for rotatepoint
	ife actorvar[myvictim].monstatus 2 { set myvictim -2 break }
	ifn myvictim player[].i ifg sprite[myvictim].statnum 2 { set myvictim -2 break }
	getactor[myvictim].x x
	getactor[myvictim].y y
	getactor[myvictim].ang angvar
	subvarvar angvar angvel
	setvarvar x2 x
	addvarvar x2 mtype
	rotatepoint x y x2 y angvar x y
	setactor[].x x
	setactor[].y y
	
	getactor[myvictim].z z
	subvarvar z shotpitch
	setactor[].z z
}
else ife myvictim -2 fall

ifvarand extbits 64 
ife myspawner player[].i
{
	ifvarand gametips 64 { xorvar gametips 64 savegamevar gametips }
	rand temp 5
	ife temp 0 count 75 else
	ife temp 1 count 76 else
	ife temp 2 count 77 else
	ife temp 3 count 78 else
	ife temp 4 count 79 else
	count 80
}

ifcount 40
{
	ifspritepal 121 spritepal 0 else spritepal 121
	ifcount 80 state stickyblow
}

enda

defstate AActivation

	set spriteid 0
	whilevarn spriteid 16384 // Numsprites
	{
		ife sprite[spriteid].picnum FANACTIVATE
		{
			ife actorvar[spriteid].SPRITELOTAG SPRITELOTAG
			{
				ife actorvar[spriteid].mtype 0 setav[spriteid].mtype 1 else
				setav[spriteid].mtype 0
			}
		}
		ife sprite[spriteid].picnum UPDRAFT_SPAWNER
		{
			ife actorvar[spriteid].SPRITELOTAG SPRITELOTAG
			{
				setav[spriteid].SPRITELOTAG 0
				setav[spriteid].initsprite SPRITELOTAG
				setav[spriteid].countvar 60
			}
			else
			ife actorvar[spriteid].initsprite SPRITELOTAG
			{
				setav[spriteid].SPRITELOTAG SPRITELOTAG
				setav[spriteid].initsprite 0
			}
		}
		
		ife sprite[spriteid].picnum MULTIPLATE
		ife actorvar[spriteid].mtype 2
		ife actorvar[spriteid].SPRITELOTAG SPRITELOTAG
		{
			setav[spriteid].droptile YES
		}
		
		ifge sprite[spriteid].picnum 18719
		ifle sprite[spriteid].picnum 18721
		{
			// al spriteid
			ife SPRITELOTAG actorvar[spriteid].SPRITELOTAG
			ife actorvar[spriteid].countvar 0 // not currently active
			{
				setav[spriteid].countvar 1
				// al SPRITELOTAG
				
				ife actorvar[spriteid].countvarb 0 // in starting position
					setav[spriteid].countvarc 1 // start animation forward
				else
					setav[spriteid].countvarc -1 // start animation backward
			}
		}
		ife sprite[spriteid].picnum MOVESHIPCAM
		{
			ife SPRITELOTAG actorvar[spriteid].initsprite
			setav[spriteid].initsprite -1
			
			ife SPRITELOTAG actorvar[spriteid].initflags
			ife actorvar[spriteid].SPRITELOTAG 1
			setav[spriteid].initflags 0
		}
		
		ife sprite[spriteid].picnum LASERWALL
		{
			ife SPRITELOTAG actorvar[spriteid].SPRITELOTAG
			{
				// mtype 1 == deactivated
				ife actorvar[spriteid].mtype 0 setav[spriteid].mtype 1 else
				setav[spriteid].mtype 0
			}
		}
		ife sprite[spriteid].picnum NEWLASERLINE
		{
			ife SPRITELOTAG actorvar[spriteid].SPRITELOTAG
			{
				ife sprite[spriteid].cstat actorvar[spriteid].initflags
					seta[spriteid].cstat 32768
				else
					seta[spriteid].cstat actorvar[spriteid].initflags
			}
		}
		
		ife sprite[spriteid].picnum DIALOGBUB
		ife SPRITELOTAG actorvar[spriteid].startx
		ife actorvar[spriteid].initflags -1
		{
			setav[spriteid].monstatus 2
			seta[spriteid].cstat 32768
		}
			
		ife sprite[spriteid].picnum NOCNITSA
		ife SPRITELOTAG actorvar[spriteid].SPRITELOTAG
			setav[spriteid].monstatus 2
		
		ife sprite[spriteid].picnum BLACKHAWK
		ife actorvar[spriteid].SPRITELOTAG SPRITELOTAG
			setav[spriteid].SPRITELOTAG 0
			
		ife sprite[spriteid].picnum COFFIN
		ife actorvar[spriteid].SPRITELOTAG SPRITELOTAG
		ife actorvar[spriteid].initsprite NO
			setav[spriteid].initsprite YES
			
		ife sprite[spriteid].picnum MESSAGER
		ife actorvar[spriteid].mtype SPRITELOTAG
			setav[spriteid].monstatus 2

		add spriteid 1
	}
ends

defstate se17activation

	headspritesect spriteid sprite[].sectnum
	whilevarn spriteid -1
	{
		ife sprite[spriteid].picnum SECTOREFFECTOR
		ife sprite[spriteid].lotag 17
			operatesectors sprite[].sectnum player[].i
		
		nextspritesect spriteid spriteid
	}

ends
	
defstate activatechannel

	operateactivators SPRITELOTAG 0
	operatemasterswitches SPRITELOTAG
	operaterespawns SPRITELOTAG
	
	state AActivation
	
	set SPRITELOTAG 0

ends

// defstate spawnmysignpost

	// espawn TEAM_TARGET
	// setav[RETURN].team team
	// setav[RETURN].mysignpost THISACTOR
	// seta[RETURN].cstat 32768
	// set mysignpost RETURN
	// seta[RETURN].xrepeat 32
	// seta[RETURN].yrepeat 32
	// seta[RETURN].z player[].posz
	// changespritestat RETURN 990

// ends

defstate wavesettings
	// if timebeforeexxit is set, that means spawnsleft and monleft must be set later for next match
	switch wave
	case 1
		set spawnsleft 30
		set monleft 30
		set gametime 10800
	break
	case 2
		set spawnsleft 2
		set monleft 2
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			ife actorvar[spriteid].monstatus 1
				setav[spriteid].teamspawned -1
			ife sprite[spriteid].picnum TEAMSPAWNER
			{
				setav[spriteid].myspawner -1
				setav[spriteid].countvar 60
			}
			nextspritestat spriteid spriteid
		}
	break
	
	case 3
		set spawnsleft 0
		set monleft 0
		
		ife pdown NO
		ifp palive
		{
			set survivor_winner YES
			al survivor_winner
			setp[].movement_lock 0
			setp[].dead_flag 0
			setp[].newowner -1
			ifl sprite[player[].i].extra 100 seta[player[].i].extra 100
			setp[].wackedbyactor -1
			set pdown NO
			
		}
		setp[].timebeforeexit 210
		set endgametime gametime
		set gametime -1
		
		
	break
	case 7
		set spawnsleft 24 //34
		set monleft 24 // 34
	break
	case 8
		operateactivators 1 0
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			ife actorvar[spriteid].monstatus 1
			ifn sprite[spriteid].picnum SITH
			ifn sprite[spriteid].picnum SYTH
				setav[spriteid].teamspawned -1
			nextspritestat spriteid spriteid
		}
		// set spawnsleft 2
		set monleft 2
		// this is a special case
	break
	// case 9 end of sith match, use default
	// case 10 // MICKY'S CTF
	
	case 11  // second arena survival match
		set spawnsleft 30
		set monleft 30
	break
	case 12
		set spawnsleft 3
		set monleft 3
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			ife actorvar[spriteid].monstatus 1
				setav[spriteid].teamspawned -1
			ife sprite[spriteid].picnum TEAMSPAWNER
			{
				setav[spriteid].myspawner -1
				setav[spriteid].countvar 60
			}
			nextspritestat spriteid spriteid
		}
	break
	
	case 21 // zombies
	case 24 // drones
	case 22 // liztroop
		set spawnsleft 50
		set monleft 50
	break
	
	case 28 // army ant
	case 33 // terminator
	case 23 // lizman
	case 25 // pigcop, armpig, tank
	case 26 // octabrain, megabrain
	case 27 // newbeast, cyberbeast
	case 30 // lizranger
	case 32 // spacebull
		set spawnsleft 30
		set monleft 30
	break
	
	case 29 // commander
	case 31 // mechbrain
	case 34 // lizelite
		set spawnsleft 18
		set monleft 18
	break
	
	case 35 // lizboss and boss3 pal
		set spawnsleft 14
		set monleft 14
	break
	
	case 39
	break
	
	case 40 // first cycloidmax wave
		set spawnsleft 12
		set monleft 12
	break
	
	case 41
	break
	
	case 42
		set spawnsleft 16
		set monleft 16
	break
	
	case 43
	break
	
	default
	setp[].timebeforeexit 180
	
	ife pdown NO
	ife gametype SURVIVAL
	ife monleft 0
	ife spawnsleft 0
	{
		set survivor_winner YES 
		al survivor_winner
	}
	break
	endswitch

ends

// WAVE MASTER LIST
// wave 0 first DM to start game
// wave 1 first survival wave in arena
// wave 2 boss survival wave in arena
// wave 3 end of 1st survival contest
// wave 4 got new shotgun from ogus
// wave 5 JCTF
// wave 6 arctic control
// wave 7 survival wave in sith battle
// wave 8 boss wave in sith battle
// wave 9 end of sith battle
// wave 10 Micky's sausage CTF
// wave 11,12 regular and boss waves in arena 2
// wave 13 arena 2 finished
// wave 14 dungeon CTF
// wave 15 confeud control
// wave 16 big boi boss fight in altar.map
// wave 17 DM vs bubafett in ironwill
// wave 18 sewers CTF
// wave 19 factory control
// wave 20 space command CTF
// wave 21 survive in edelheim



defstate mandoconcedesounds

	ife bluescore 1 
	{ stopallsounds globalsound MANDO_EVENTUALLY 
		set subtitle_time 120 set subtitle_numlines 1 set subtitle_start 580 
		set cutcamtime player[].player_par
		set emp_overlay 120
		set emp_overlay_tile 15270
		} 
	else
	ife bluescore 2 
	{ stopallsounds globalsound MANDO_GOODSHOT 
		set subtitle_time 120 set subtitle_numlines 1 set subtitle_start 581 
		set cutcamtime player[].player_par
		set emp_overlay 120
		set emp_overlay_tile 15270
		} 
	else
	ife bluescore 4 
	{ stopallsounds globalsound MANDO_UDONTSUCK 
		set subtitle_time 150 set subtitle_numlines 1 set subtitle_start 582 
		set cutcamtime player[].player_par
		set emp_overlay 150
		set emp_overlay_tile 15270
		} 
	else
	ife bluescore 6 
	{ stopallsounds globalsound MANDO_UHAVESKILL 
		set subtitle_time 150 set subtitle_numlines 2 set subtitle_start 583 
		set cutcamtime player[].player_par
		set emp_overlay 150
		set emp_overlay_tile 15270
		}
	else
	ifg bluescore 7 ifg bluescore redscore
	{
		set temp bluescore
		modvar temp 2
		ife temp 0
		{ stopallsounds globalsound MANDO_UNDERESTIMATED 
			set subtitle_time 150 set subtitle_numlines 1 set subtitle_start 585
			set cutcamtime player[].player_par
			set emp_overlay 150
			set emp_overlay_tile 15270
		}
	}
	
ends

defstate deathmatchscore

	ife teamspawned 99999 break
	
	ife gametime -1 break // match already over
	set value 1
	
	geta[].htowner spriteid
	ifwasweapon BURNING
	{
		ife pchar 1 set spriteid player[].i else
		ifn myshelly -1 set spriteid myshelly
	}
	ife spriteid player[].i
	{
		ife pchar 0 add duke_kills 1
		ife pchar 1 add shelly_kills 1
		ife pchar 2 add wes_kills 1
	}
	else ifn myshelly -1 ife spriteid myshelly
	{
		ife sprite[myshelly].picnum SHELLY add shelly_kills 1 else
		ife sprite[myshelly].picnum SHELLYCROUCH add shelly_kills 1 else
		ife sprite[myshelly].picnum DUKEBOT add duke_kills 1 else
		ife sprite[myshelly].picnum DUKEBOTCROUCH add duke_kills 1 else
		ife sprite[myshelly].picnum WESBOT add wes_kills 1 else
		ife sprite[myshelly].picnum WESBOTCROUCH add wes_kills 1
	}
	else
	{
		ifn spriteid -1
		{
			ife team actorvar[spriteid].team
			{
				ifactor MANDOFETT { sub enemy1_kills 1 sub redscore 1 } else
				ifactor MANDOCROUCH { sub enemy1_kills 1 sub redscore 1 } else
				ife sprite[spriteid].pal 12 { sub enemy1_kills 1 sub redscore 1 } else
				ife sprite[spriteid].pal 10 { sub enemy2_kills 1 sub redscore 1 }
				
				ifl enemy1_kills 0 set enemy1_kills 0
				ifl enemy2_kills 0 set enemy2_kills 0
				ifl redscore 0 set redscore 0
			}
		}
		else
		{
			ife pchar 0 add duke_kills 1
			ife pchar 1 add shelly_kills 1
			ife pchar 2 add wes_kills 1
		}
	}
	
	ife team 0 ifl bluescore scorelimit add bluescore value
	ife team 1 ifl redscore scorelimit add redscore value
	
	ifactor MANDOFETT { add enemy1_deaths 1 state mandoconcedesounds } else
	ifactor MANDOCROUCH { add enemy1_deaths 1 state mandoconcedesounds } else
	ifspritepal 12 add enemy1_deaths 1 else
	ifspritepal 10 add enemy2_deaths 1

	ifge bluescore scorelimit ifg bluescore redscore { setp[].timebeforeexit 180 set endgametime gametime set gametime -1 }
	ifge redscore scorelimit ifg redscore bluescore { setp[].timebeforeexit 180 set endgametime gametime set gametime -1 }
	
	ife gametime 0 ifn bluescore redscore { setp[].timebeforeexit 180 set endgametime gametime set gametime -1 }

ends

defstate spawnoutline

	espawn OUTLINE
	ifvarand monstflags 32768 seta[RETURN].pal 4
	seta[RETURN].mdflags 16
	setav[RETURN].initsprite sprite[].htdispicnum
	seta[RETURN].xrepeat sprite[].xrepeat
	seta[RETURN].yrepeat sprite[].yrepeat

ends

move NUMBERUP 0 -16
move NUMBERUPFAST 0 -32

defstate numberstate
	set shrunken 0
	ifvare mtype 0 break
	spriteflags 68
	ifmove 0
	{
		ife mtype 1 move NUMBERUPFAST geth getv
		else
		move NUMBERUP geth	
		sizeat 40 40
		cstator 80
		spritepal 21
		seta[].shade -127
	}

	geta[].alpha temp
	add temp 3
	seta[].alpha temp 
	ifcount 84 killit

ends

useractor notenemy 12821 0 state numberstate enda

useractor notenemy 12822 0 state numberstate enda

useractor notenemy 12823 0 state numberstate enda

useractor notenemy 12824 0 state numberstate enda

useractor notenemy 12825 0 state numberstate enda

useractor notenemy 12826 0 state numberstate enda

useractor notenemy 12827 0 state numberstate enda

useractor notenemy 12828 0 state numberstate enda

useractor notenemy 12829 0 state numberstate enda

useractor notenemy 12830 0 state numberstate enda

defstate moveitleft
getactor[THISACTOR].ang angvar
addvar angvar 512
getactor[RETURN].x x
getactor[RETURN].y y
setvarvar x2 x
addvar x2 128
rotatepoint x y x2 y angvar x2 y2
setactor[RETURN].x x2
setactor[RETURN].y y2
ends

defstate moveitright
getactor[THISACTOR].ang angvar
subvar angvar 512
getactor[RETURN].x x
getactor[RETURN].y y
setvarvar x2 x
addvar x2 128
rotatepoint x y x2 y angvar x2 y2
setactor[RETURN].x x2
setactor[RETURN].y y2
ends

defstate spawnimpcoins
	// spawn coins
	ifactor NEWTROOPTARGET break
	ifactor NEWPIGTARGET break
	whilevarn value 0
	{ 
	  randvar angvar 2047
	  seta[].ang angvar
	  randvar z 4096
	  mulvar z -1
	  ezshoot z IMPCOINPROJ
	  ifn RETURN -1
	  {
		  ifrnd 160 { seta[RETURN].pal 8 set savx 10 } else
		  ifrnd 160 { seta[RETURN].pal 1 set savx 11 } else
		  ifrnd 160 { seta[RETURN].pal 12 set savx 13 } else
		  ifrnd 160 { seta[RETURN].pal 97 set savx 12 } else
		  ifrnd 160 { seta[RETURN].pal 10 set savx 14 } else
		  { seta[RETURN].pal 63 set savx 15 }
		  seta[RETURN].xrepeat savx
		  seta[RETURN].yrepeat savx
	  }
	  ife monstatus 1 ifg value 10 sub value 1
	  subvar value 1
	}
ends

defstate parkmetercode

	ifaction 0
	{
		action ANULLACTION
		cstator 257
	}
	
	ifhitweapon
	{
		ifdead
		{
			set value 8
			state spawnimpcoins
			debris SCRAP1 3
			debris SCRAP6 2
			sound VENT_BUST
			cactor PARKMETERBROKE
		}
	}

ends

useractor notenemy PARKMETER 40 state parkmetercode enda
useractor notenemy PARKMETER2 40 state parkmetercode enda

defstate spawn_number
setvarvar tempb TMP_A
addvar tempb NEWNUMSTART
espawnvar tempb
setav[RETURN].mtype monstatus
setav[RETURN].myspawner THISACTOR

set zdist tiledata[].ysize
mul zdist sprite[].yrepeat
add zdist 3072
mul zdist 2
getactor[].z z, sub z zdist
seta[RETURN].z z

setactor[RETURN].ang sprite[THISACTOR].ang
ends

defstate showpoints

getactor[THISACTOR].ang savx
getplayer[THISACTOR].posx x2
getplayer[THISACTOR].posy y2
getactor[THISACTOR].x x
getactor[THISACTOR].y y
subvarvar x2 x
subvarvar y2 y
getangle angvar x2 y2
setactor[THISACTOR].ang angvar

setvarvar tempd monxp

switch SKILL // userdef[].player_skill
case 0 case 1 div tempd 4 break
case 2 div tempd 2 break
case 4 mul tempd 3 div tempd 2 break
case 5 case 6 mul tempd 2 break
endswitch

setvarvar tempI tempd

ifvarg tempd 9999
{
	setvarvar TMP_A tempI
	divvar TMP_A 10000
	state spawn_number
	mulvar TMP_A 10000
	subvarvar tempI TMP_A // tempI is now the number that is left over
	state moveitleft
	state moveitleft
	state moveitleft
}
ifvarg tempd 999
{
	setvarvar TMP_A tempI
	divvar TMP_A 1000
	state spawn_number
	mulvar TMP_A 1000
	subvarvar tempI TMP_A // tempI is now the number that is left over
	state moveitleft
	state moveitleft
}
ifvarg tempd 99
{
	setvarvar TMP_A tempI
	divvar TMP_A 100
	state spawn_number
	mulvar TMP_A 100
	subvarvar tempI TMP_A
	state moveitleft
}
ifvarg tempd 9
{
	setvarvar TMP_A tempI
	divvar TMP_A 10
	state spawn_number
	mulvar TMP_A 10
	subvarvar tempI TMP_A
}
setvarvar TMP_A tempI
state spawn_number
state moveitright

setactor[THISACTOR].ang savx

ends


defstate enemy_death

  ife DAMAGEFLASH YES ife sawfleshtime 0 
  ife sprite[].htowner player[].i
  set damflash player[].player_par
  
  set spriteid sprite[].htowner
  ife spriteid -1 set spriteid player[].i
  ife spriteid player[].i
  ifrnd SWEARFREQUENCY
  {
      ifwasweapon ARROWPROJ
	  ife pchar 1
	  {
		ifrnd 84 globalsound B_SHAFT else
		ifrnd 128 globalsound B_GOTTHEPOINT else
		globalsound B_AMAZONDELIVERY
	  }
	  else
	  {
		switch sprite[].picnum
		case PIGCOP case PIGCOPDIVE case NEWPIG case NEWPIGDIVE
		ifl pchar 2
		{
			ifg burning 0 ifwasweapon BURNING
			{
			  ifrnd 96
			  {
				ife pchar 0 globalsound MAKINBACON else
				ife pchar 1 globalsound B_MAKINBACON
			  }
			}
			else ifwasweapon SHOTSPARK1
			{
			  ifrnd 96
			  {
				ife pchar 0 globalsound SQUEALPIGGY else
				ife pchar 1 globalsound B_SQUEALPIGGY
			  }
			}
			else ifwasweapon RPG
			{
			  ifrnd 32
			  {
				ife pchar 0 globalsound MAKINBACON else
				ife pchar 1 globalsound B_MAKINBACON
			  }
			}
		}
		break
		case OCTABRAIN
		ifrnd 48
		ifl pchar 2
		{
		  ife pchar 0 globalsound TENTACLES else
		  ife pchar 1 globalsound B_TENTACLES
		}
		break
		case COMMANDER
		case NEWCOMM
		ifrnd 64
		ifl pchar 2
		{
		  ife pchar 0 globalsound JIBBED_ACTOR12
		  ife pchar 1 { ifrnd 160 globalsound B_FATFUCK else globalsound B_SUCKIT }
		}
		break
		case BOSS1 case BOSS2 case BOSS3 case BOSS4
		case PIGBOSS case LIZBOSS case CANHEADNOARMS
		case CYCLOIDMAX case BATBOSS
		ifrnd 96
		{
			ife pchar 0 globalsound BIGBLEED else
			ife pchar 2 globalsound WESSTAYDOWN else
			globalsound B_BIGBLEED
		}
		break
		endswitch
	  }

  }
  set burning 0
  set bleeding 0
  ifvarand monstflags 2048 seta[].alpha 0 // ghostly
  // seta[].mdflags 0
  ife targetlock[0] THISACTOR setarray targetlock[0] -1
  ife targetlock[1] THISACTOR setarray targetlock[1] -1
  ife targetlock[2] THISACTOR setarray targetlock[2] -1
  
  ifn team 1
  ife restartatt 0
  ifn monstatus 2
  {
      ife team 0 ifvarand perks 1
	  ifn gametype -1
	  {
		ifl leftsidegun -1 add leftsidegun 1
		ifl rightsidegun -1 add rightsidegun 1
	  }
	  ifvarand perks 64 ifl rescuecharge RESCUEAMOUNT add rescuecharge 1
	  set safecount monxp
	  // mul safecount 3
	  // div safecount 11
	  // sqrt safecount safecount
	  
	  add safecount 50
	  div safecount 5
	  sqrt safecount safecount
	  
	  // div safecount 50
	  
	  ifl safecount 1 set safecount 1
	  
	  set temp NO
	  ifg gametype 0 set temp YES else
	  // ife vendorupgrade YES 
	  ife vrtrip 0 set temp YES
	  ife temp YES
	  {
		
		set value safecount
		ifn gametype 0 shiftr value 1
		shiftr safecount 1, sub safecount 1, ifl safecount 0 set safecount 0
		ife marathon YES div value 2
		
		state spawnimpcoins
	  
	  }
	   
	  div safecount 4
	  ife gametype DM set safecount 0
	  ifg safecount 4 set safecount 4
	  
	  
	  // ifn attmode NO
	  ife pdown NO
	  {
		set temp healthbuff
		div temp 2
		ifl sprite[player[].i].extra temp
		{
			abs temp
			div temp 50
			ifrnd 128 add temp 1
			add safecount temp
		}
		else
		ifrnd 16
	    ifg startguns 0
	    state startgun_replace
	  }
	  ifg safecount 6 set safecount 6

	  whilevarn safecount 0
	  {
		  randvar angvar 2047
		  seta[].ang angvar
		  randvar z 4096
		  mulvar z -1
		  zshoot z COINPROJ
		  subvar safecount 1
	  }
	ifn attmode NO
	{
		set temp monxp
		ifn gameover YES
		{
			switch SKILL // userdef[].player_skill
			case 0 case 1 div temp 4 add totalxp temp break
			case 2 div temp 2 add totalxp temp break
			case 3 add totalxp monxp break
			case 4 mul temp 3 div temp 2 add totalxp temp break
			case 5 case 6 mul temp 2 add totalxp temp break
			endswitch
		}
		ife marathon YES div monxp 2
		ifg monxp 0 ife SHOWPOINTS YES state showpoints
		add playerxp monxp
		ifge playerxp nextplevel
		ifp palive
		ife pdown NO
		{
			ife attmode YES ife VOLUME 5 ife LEVEL 11 
			{
				operateactivators 3 0
				set playerxp 0
				screensound LEVELUP
				screensound LEVELUP
				screensound LEVELUP
				palfrom 50 63 63 63
				addphealth 100
				set bigmsg 1138
				set bigmsgcount 90
				break
			}
			sub playerxp nextplevel
			add plevel 1
			set spriteid player[].i
			setav[spriteid].spawnprotect 90
			ifg plevel 7 { mul nextplevel 6, div nextplevel 5 } else
			{ mul nextplevel 5, div nextplevel 4 }
			
			ifl plevel 10
			{
				set temp 8192
				set tempb plevel
				mul tempb 644
				sub temp tempb
				add nextplevel temp
			}

			screensound LEVELUP
			screensound LEVELUP
			screensound LEVELUP
			palfrom 50 63 63 63
			add pdamage 5
			add healthbuff 10
			addphealth 100
			setp[].max_player_health healthbuff
			ifn bigmsgcount 0 { ife buffermsg 0 set buffermsg 792 } else
			{
				set bigmsg 792
				set bigmsgcount 90
			}
			ife checkpoints NO
			state autosave
		}
	}
	set monxp 0
	
	ifvarand monstflags 1048576 // electric explosion	
	{
		sound RADEXPLOSION
		set safecount 0
		whilevarn safecount 64
		{
			geta[].ang angvar
			add angvar 32
			seta[].ang angvar
			add safecount 1
			eshoot SHOCKPROJ
		}
		xorvar monstflags 1048576
		ife pchar 2 ifrnd 32 globalsound WESSHOCKING
	}
	
  }
  set monstatus 2
  ifvarand monstflags 2 xorvar monstflags 2
  ife bluecarrier THISACTOR set bluecarrier -1
  ife redcarrier THISACTOR set redcarrier -1
  ifwasweapon BLOODBULLET
  ifvarand wesupgrades[SHRINKER_WEAPON] 1
  {
	spawn BLOODEXP
	espawn ZOMBIE
	setav[RETURN].team 1
	seta[RETURN].pal 2
	setav[RETURN].FEMKILLCOUNT 1800
	setav[RETURN].mlevel plevel
	setav[RETURN].teamspawned 99999
	seta[RETURN].xrepeat 28
	seta[RETURN].yrepeat 26
	setav[RETURN].monstflags 80 // speedy plus double damage
  }
  ifvarand monstflags 32768
  {
	espawn BMFGIMPACT
	seta[RETURN].pal 10
	setav[RETURN].team team
	geta[RETURN].z zdist
	sub zdist 10240
	seta[RETURN].z zdist
  }
  ifn droptile 0 { espawnvar droptile set droptile 0 }
  
  ife gametype SURVIVAL
  ifn teamspawned -1 ifn teamspawned 99999 ifn actorvar[teamspawned].mtype 0
  {
	sub monleft 1
	ifl monleft 1 
	{
		add wave 1
		globalsound BIGCHEER
		state wavesettings
		// ifg player[].timebeforeexit 0 ife pdown NO { set bluescore 500 set redscore 0 }
		
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			ife actorvar[spriteid].monstatus 2
			ifn actorvar[spriteid].teamspawned -1
			ifn sprite[spriteid].picnum TEAMSPAWNER
			ifg sprite[spriteid].htg_t 0 30 // move count >30
			{
				seta[spriteid].picnum BIGSMOKE // turn body into smoke
				seta[spriteid].xrepeat 0
				seta[spriteid].yrepeat 0
			}
			
			setav[spriteid].teamspawned -1 // safety
			
			ife player[].timebeforeexit 0
			ife sprite[spriteid].picnum TEAMSPAWNER
			ifn actorvar[spriteid].mtype 0
			{
				ifg actorvar[spriteid].countvar 90
					setav[spriteid].countvar 90
				
				setav[spriteid].myspawner -1
			}
			nextspritestat spriteid spriteid
		}
		getp[].player_par curr_tick
		add curr_tick 1
		headspritestat spriteid 980
		whilevarn spriteid -1
		{
			setav[spriteid].redflagval 0
			setav[spriteid].rediteration 99999
			setav[spriteid].redtimer curr_tick
			nextspritestat spriteid spriteid
		}
		
	}
  }
  // ifvarand monstflags 256
  // {
	// set upscaled NO
	// mul init_xrepeat 2
	// div init_xrepeat 3
	
	// seta[].xrepeat init_xrepeat
	// mul init_yrepeat 2
	// div init_yrepeat 3
	// seta[].yrepeat init_yrepeat
	// state spawnoutline
  // }
  ifactor PIGSUV break // safety
  ifg SPRITELOTAG 9
  {
    state activatechannel
  }
  ifg gametype 0
  {
    set value 1
	
	switch sprite[].picnum
	case ZOMBIE case CRAZYLADY case CRONEN case EGG case EGGYOUNG case LIZTROOP case NEWTROOP 
	case PIGCOP case PIGCOPDIVE case NEWPIG case NEWPIGDIVE
	set value 0 break
	case TANK case COMMANDER case NEWCOMM case NEWBEAST case CYBERBEAST case TERMINATOR case TERMINATORCRAWLING
	case EDFPIG case ARMPIG case PIGSUV case ARMEDF case MEGABRAIN case MECHBRAIN
	case NURGLE case BATBOSS
	case CHEERBOT
	add value 1 break
	case EDFTROOP ifspritepal 19 add value 1 break
	case PIGBOSS case BOSS1 case BOSS2 case BOSS3 case BOSS4 case LIZBOSS case CANHEADNOARMS case CYCLOIDMAX ifspritepal 0 add value 9 else add value 3 break
	case LIZELITE case LIZELITECROUCH case MANDOFETT case MANDOCROUCH add value 2 break
	endswitch
	ife gametype DM state deathmatchscore
	else ifn gametime -1
	{
		ife team 0 add bluescore value
		ife team 1 add redscore value
		
		ifn gametype SURVIVAL
		{
			ifge bluescore scorelimit ifg bluescore redscore { setp[].timebeforeexit 180 set endgametime gametime set gametime -1 }
			ifge redscore scorelimit ifg redscore bluescore { setp[].timebeforeexit 180 set endgametime gametime set gametime -1 }
			
			ife gametime 0
			ifn redscore bluescore
			{
				setp[].timebeforeexit 180 set endgametime gametime set gametime -1
			}
		}
	}
	
  }

ends


defstate playerpainsounds // dukepainsounds

	set temp player[].max_player_health
	div temp 2
	ifg temp 80 set temp 80
	
	ifl sprite[].extra temp
	// ifphealthl YELLHURTSOUNDSTRENGTHMP
	{
	  ife pchar 1
	  {
		ifactorsound THISACTOR SHELLYPAIN2 break
		ifactorsound THISACTOR SHELLYPAIN3 break
		ifrnd 128 
		{
			ifrnd 128 sound SHELLYPAIN2 else
			sound SHELLYPAIN3
		}
		else
		{
			ifrnd 128 sound SHELLYDIE2
			else sound B_DIE
		}
	  }
	  else ife pchar 2
	  {
		ifrnd 84
			sound WESPAIN5
		else ifrnd 128
			sound WESPAIN4
		else sound WESDEATH2
	  }
	  else
	  {
		  ifrnd 64
			sound DUKE_LONGTERM_PAIN2
		  else
			ifrnd 64
			  sound DUKE_LONGTERM_PAIN3
		  else
			ifrnd 64
			  sound DUKE_LONGTERM_PAIN4
		  else
			sound DUKE_DEAD
	  }
	}
	else
	{
	  ife pchar 1
	  {
		ifactorsound THISACTOR SHELLYPAIN1 break
		ifactorsound THISACTOR SHELLYPAIN4 break
		ifrnd 128 
		{
			ifrnd 128 sound B_OW 
			else sound SHELLYPAIN5
		}
		else
		{
			ifrnd 128 sound SHELLYPAIN1 else
			sound SHELLYPAIN4
		}
	  }
	  else ife pchar 2
	  {
		ifrnd 84
			sound WESPAIN1
		else ifrnd 128
			sound WESPAIN2
		else sound WESPAIN3
	  }
	  else
	  {
		  ifrnd 64
			sound DUKE_LONGTERM_PAIN5
		  else ifrnd 64
			sound DUKE_LONGTERM_PAIN6
		  else ifrnd 64
			sound DUKE_LONGTERM_PAIN7
		  else
			sound DUKE_LONGTERM_PAIN8
	  }
	}
ends

defstate recontilt

 // tilt code thanks to Hunter_Rus for initial version
  getactor[].ang angvar
  getincangle temp angvar countvarb
  
  set countvarb angvar
  shiftvarl temp 20
  divvar temp 18768
  ifvarg temp  256 set temp  256 else
  ifvarl temp -256 set temp -256 
  // added this code to make it smoother 
  getactor[].roll mtype
  ifvarvarg temp mtype 
  {
	  addvar mtype 24
	  ifvarvarg mtype temp set mtype temp
  }
  else ifvarvarl temp mtype
  {
	  subvar mtype 24
	  ifvarvarl mtype temp set mtype temp
  }
  setactor[].roll mtype
  
ends

defstate teleportnearplayer

	ifl gametype 1 { set spawnprotect 0 break }
	
	add spawnprotect 1
	{
		resetcount
		resetactioncount
		ife spawnprotect -30 // teleport
		{
			ifspritepal 33 getlastpal
			
			
			set value 0
			set TMP_A -1
			headspritestat spriteid 980
			whilevarn spriteid -1
			{
				ifn spriteid mynavsprite
				ifg actorvar[spriteid].blueflagval value
				{
					set value actorvar[spriteid].blueflagval
					set TMP_A spriteid
				}
				nextspritestat spriteid spriteid
			}
			ifn TMP_A -1
			{
				setsprite THISACTOR sprite[TMP_A].x sprite[TMP_A].y sprite[TMP_A].z
				sound BOSSPORT
				ife initsprite 1996
				{
					geta[].z savz
					set z savz
					sub z 32768
					seta[].z z
					espawn SHOCKBALL_EXP
					seta[].z savz
					setav[RETURN].mtype 2
					seta[RETURN].pal 12
					
				}
			}
		}
		else ifg spawnprotect -30 // after teleporting
		{
			ife initsprite 1996
			{
				ife spawnprotect -27
				ifpdistl 4560
				{
					sound LIGHTNING_SLAP
					hitradius 5120 10 20 30 40
					// seta[].htextra -1
					set spriteid player[].i
					geta[spriteid].x x2
					geta[spriteid].y y2
					sub x2 sprite[].x
					sub y2 sprite[].y
					getangle angvar x2 y2
					cos xvel angvar
					sin yvel angvar
				
					shiftvarl xvel 10
					shiftvarl yvel 10
					add xvel player[].posxv
					add yvel player[].posyv
					setplayer[].posxv xvel
					setplayer[].posyv yvel
					
					getp[].posz z
					sub z 1024
					setp[].posz z
					setp[].poszv -3072
				}
				ife spawnprotect 0 { ifspritepal 33 getlastpal } else
				{
					ifspritepal 33 getlastpal else spritepal 33
				}
			}
				
			
		}
		else
		{
			ifspritepal 33 getlastpal else spritepal 33
			ife spawnprotect -44 sound BOSSPORT
			ife spawnprotect -35 ife initsprite 1996
			{
				geta[].z savz
				set z savz
				sub z 32768
				seta[].z z
				espawn SHOCKBALL_EXP
				seta[].z savz
				setav[RETURN].mtype 2
				seta[RETURN].pal 12
			}
		}
	}

ends

defstate spawnprotectcode

	ifvarand monstflags 131072 nullop else
	ifl gametype 1 ifg spawnprotect 0 ifle spawnprotect 40 
	{
		set spawnprotect 0
		ifspritepal 33 getlastpal
	}
	
	ifg spawnprotect 0
	{
		ifactor APLAYER ife pdown YES addphealth 1
		sub spawnprotect 1
		ifspritepal 33 getlastpal else ifg spawnprotect 0 spritepal 33
		seta[].htextra -1	
	}
	ifl spawnprotect 0 state teleportnearplayer

ends


defstate imonfire

	ifinwater { set burning 0 break }
	geta[].mdflags temp
	orvar temp 16
	seta[].mdflags temp

	sub burning 1
	ifg burning 2048 set burning 2048
	

	ifonwater iffloordistl 16 ifg burning 1 subvar burning 1
	
	ifvarand initflags 4 nullop else
	ifvarand player[].player_par 1
	{
		ifactor APLAYER
		{
			quote 108
			palfrom 26 63 20 20
			ifg burning 300 set burning 300
			getp[].boot_amount temp
			ifg temp 0
			{
				subvar temp 1
				setp[].boot_amount temp
				subvar burning 3
				ifvarl burning 0 set burning 0
			}
			soundonce FIRE_CRACKLE
			ifrnd 16 state playerpainsounds
			ifphealthl 50 subvar burning 1
		}
		set temp burning
		shiftvarr temp 6
		ifg temp 8 set temp 8
		ifactor APLAYER ifg temp 4 set temp 4
		ifvarl temp 1 set temp 1
		sub burning temp
		ifvarl burning 0 set burning 0
		ifg temp 0
		{
			geta[].htextra tempb
			ife tempb -1 set tempb 0
			add temp tempb
			ifl temp 1 set temp 1
			seta[].htextra temp
			ifn sprite[].htpicnum RPG
			ifn sprite[].htpicnum RADIUSEXPLOSION
			seta[].htpicnum BURNING
			// seta[].htowner player[].i
			add temp 1
			ifvarvarl sprite[].extra temp
			{
				geta[].htflags temp
				orvar temp 4
				seta[].htflags temp
				getsector[].floorshade tempb
				add tempb 12 ifg tempb 30 set tempb 30
				seta[].shade tempb
			}
		}
		
	}

	espawn STICKYFIRE
	setav[RETURN].mtype sprite[].picnum
	setav[RETURN].myspawner THISACTOR

	ifg burning 260
	{
		espawn STICKYFIRE
		setav[RETURN].botclip sprite[].picnum
		setav[RETURN].myspawner THISACTOR
	}
	ifvarn monstatus 0
	{
		ifvarand initflags 4 soundonce FIRE_CRACKLE
		else
		soundonce COOKINGDEEPFRIER
	}
	ifn sprite[].picnum APLAYER
	ifrnd 16
	{
		espawn BIGSMOKE 
		geta[RETURN].z z
		sub z 4096
		seta[RETURN].z z
		seta[RETURN].htpicnum BURNING
	}
	
ends

defstate avoidwater

ife gametype SURVIVAL
iffloordistl 8 ifonwater
ifl navpoint 0
{
	ifn teamspawned -1
		setsprite THISACTOR sprite[teamspawned].x sprite[teamspawned].y sprite[teamspawned].z
	else ife team 1
	{
		setsprite THISACTOR loadx[LEVEL] loady[LEVEL] loadz[LEVEL]
	}
	break
}

// ifg gametype 0 break

ifn team 0
ifg navpoint -1 break
ifactornotstayput nullop else break
// ifonwater break
ifinwater break // too late
ife sector[].floorpicnum PURPLELAVA break

switch sprite[].picnum

case LIZTROOP
case NEWTROOP
case SHARK
case ROTATEGUN
case SIDEGUN
case COMMANDER 
case NEWCOMM
case OCTABRAIN
case MEGABRAIN
case DRONE case EDFDRONE case NEWSENTRY
case BOSS2FLY
case BOSS4
case RECON case NEWRECON
case SCUBATROOP
case NAAMAH case DEVOURER
case MANDOFETT case MANDOCROUCH
break

default
	ifonwater
	{
		geta[].htflags temp
		orvar temp 134217728
		orvar temp 16
		seta[].htflags temp
	}
	// neartag <x> <y> <z> <sect> <ang> <nearTagSector> <nearTagWall> <nearTagSprite> <nearTagHitDist> <nearTagRange> <tagSearch>
	else
	{
		ifvarand monstflags YES set angvar angvel else set angvar sprite[].ang
		ifl sprite[].xvel -16 add angvar 1024
		
		set temp -1
		neartag sprite[].x sprite[].y sprite[].z sprite[].sectnum angvar temp tempb spriteid xydist 512 1
		
		ifn temp -1
		ife sector[temp].lotag 1
		{
		
		/*
		geta[].ang angvar
		ifvarand monstflags YES set angvar angvel
		// ifl sprite[].xvel -16 { add angvar 1024 set x2 -1 } // moving backwards
		
		set x2 sprite[].x
		add x2 512 // 384
		rotatepoint sprite[].x sprite[].y x2 sprite[].y angvar xvel z
		set mysector sprite[].sectnum
		updatesectorz xvel z sprite[].z mysector
		set tempc 0
		ifn mysector -1
		{
			gets[mysector].lotag tempc
			ife sector[mysector].floorpicnum PURPLELAVA set tempc 1
		}
		ife tempc 0
		{
			sub angvar 160
			rotatepoint sprite[].x sprite[].y x2 sprite[].y angvar xvel z
			updatesectorz xvel z sprite[].z mysector
			ifn mysector -1
			{
				gets[mysector].lotag tempc
				ifn sector[].floorpicnum PURPLELAVA
				ife sector[mysector].floorpicnum PURPLELAVA set tempc 1
			}
			ife tempc 0
			{
				add angvar 320
				rotatepoint sprite[].x sprite[].y x2 sprite[].y angvar xvel z
				updatesectorz xvel z sprite[].z mysector
				ifn mysector -1
				{
					gets[mysector].lotag tempc
					ifn sector[].floorpicnum PURPLELAVA
					ife sector[mysector].floorpicnum PURPLELAVA set tempc 1
				}
			}
		}
		
		ife tempc 1 // water sector ahead
		{
		*/
			set tempd NO
			ife team 3 set tempd YES
			ifvarand monstflags YES set tempd YES
			ife tempd YES
			{
				geta[].ang angvar
				add angvar 768
				rand temp 512
				add angvar temp
				seta[].ang angvar
				set dodgetime 10
			}
			else ifg sprite[].xvel 0 iffloordistl 16
			{
				ifrnd 8
				{
					geta[].ang angvar
					add angvar 768
					rand temp 512
					add angvar temp
					seta[].ang angvar
					seta[].xvel 0
					set crumbwait 10
					resetcount
				}
				else
				{
					// ife x2 0 seta[].xvel -128 else seta[].xvel 128
					seta[].xvel -128
				}
			}
			
		}
	}
	
break
endswitch

ends

defstate avoidcliffs

ifn sprite[].htactorstayput -1 break
ifvarand monstflags 1 break
ifn navpoint -1 break

getactor[].x x
getactor[].ang angvar
ifvarl sprite[].xvel -16 addvar angvar 1024 // moving backwards
setvarvar x2 sprite[].x
addvar x2 768

rotatepoint sprite[].x sprite[].y x2 sprite[].y angvar x2 y2
set mysector sprite[].sectnum
updatesector x2 y2 mysector
ifvarn mysector -1
ifvarvarn mysector sprite[].sectnum
{
	getflorzofslope mysector x2 y2 temp
	getflorzofslope sprite[].sectnum sprite[].x sprite[].y tempb
	subvarvar temp tempb
	ifvarand sector[mysector].floorstat 1 set temp 100000
	ifvarg temp 65536 // 20480
	{
		addvar angvar 768
		randvar temp 512
		addvarvar angvar temp
		ifvarl sprite[].xvel -16 // moving backwards
		{
			getactor[].xvel xvel
			mulvar xvel -1
			setactor[].xvel xvel
		}
		
		setactor[].ang angvar
	}
}

ends

defstate setfarang
	rand angle2 2047
	set xydist 3072
	set bossang -6666
	set B 0
	whilevarn B 16
	{
		add B 1
		geta[].z z
		sub z 5120
		add angle2 128
		cos mycos angle2
		sin mysin angle2
		hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 hitsector hitwall hitsprite hitx hity hitz clipmask
		
		set newx sprite[].x
		sub newx hitx
		mul newx newx
		set y2 sprite[].y
		sub y2 hity
		mul y2 y2
		add newx y2
		sqrt newx newx
		
		ifg newx xydist { set xydist newx set bossang angle2 }
		
	}
	ifn bossang -6666 { seta[].ang bossang set crumbwait 15 }
ends

defstate crumbcode

	ifn sprite[].htactorstayput -1 break
	ifg navpoint -1 break
	ifg crumbwait 0 { sub crumbwait 1 break }
	ifvarand monstflags YES nullop else
	ifn bottarget -1 break
	
	ifvarand monstflags 262144
	ife team 0
	{
		ifpdistl 16384 
		{
			state setfarang
			break
		}
	}
	sleeptime 100

	ife seeplayer YES ifawayfromwall set xydist2 4096
	else set xydist2 2048

	set B -1 // reset crumb and search from scratch
	// linked list of sprites already in order from most recent to oldest
	headspritestat spriteid 999
	whilevarn spriteid -1
	{
		ldist xydist THISACTOR spriteid
		ifg xydist 384 ifl xydist xydist2
		ifge actorvar[spriteid].mtype lastcrumb
		{
			canseespr THISACTOR spriteid temp
			ife temp YES
			{ set B spriteid getav[B].mtype lastcrumb }
		}
		
		nextspritestat spriteid spriteid
		ifn B -1 set spriteid -1
	}

	ife B -1 // longer distance check
	{
		mul xydist2 2
		headspritestat spriteid 999
		whilevarn spriteid -1
		{
			ldist xydist THISACTOR spriteid
			ifg xydist 384 ifl xydist xydist2 
			ifge actorvar[spriteid].mtype lastcrumb
			{
				canseespr THISACTOR spriteid temp
				ife temp YES
				{ set B spriteid getav[B].mtype lastcrumb }
			}
			nextspritestat spriteid spriteid
			ifn B -1 set spriteid -1
		}
	}

	ifn B -1 // face crumb
	{
		// ifn bottarget -1
		// ife seemytarget YES
			// break
		
		ifactor GUARD ifmove GUARDWALKVEL
		move GUARDFOLLOWVEL geth
		geta[B].x x
		geta[B].y y
		sub x sprite[].x
		sub y sprite[].y
		getangle angvar x y
		ifvarand monstflags YES set angvel angvar else
		seta[].ang angvar
		ifactor EDFDRONE ifl sprite[B].z sprite[].z
			movesprite THISACTOR 0 0 -2048 CLIPMASK0 RETURN
		ifactor NEWSENTRY ifl sprite[B].z sprite[].z
			movesprite THISACTOR 0 0 -2048 CLIPMASK0 RETURN
		ifnotmoving
		{
			set crumbwait 20
			geta[].z z
			geta[B].z temp
			sub z temp
			ifg z 10240
			ifg sprite[].zvel -1
			{
				set crumbwait 22 // jump trigger
				ifactor LIZMAN ifrnd 160 break
				ifactor NEWBEAST ifrnd 160 break
				ifactor LIZTROOP ifrnd 160 break
			}
			
			sub angvar 384
			rand temp 768
			add angvar temp
			ifvarand monstflags YES set angvel angvar
			else
			seta[].ang angvar
		}
	}

ends

defstate moveatangvar

	ifvarand monstflags YES nullop else
	ife sprite[].xvel 0 break

	cos xvel angvar
	sin yvel angvar
	shiftr xvel 8
	shiftr yvel 8
	ife team 3 { shiftr xvel 1 shiftr yvel 1 }
	movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN

ends


defstate strafecheck
	
	ifvarand monstflags YES set angvar angvel else
	geta[].ang angvar
	sub angvar 480
	geta[].z z
	sub z 6144 // 8192
	cos mycos angvar
	sin mysin angvar
	hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 hitsector hitwall hitsprite hitx hity hitz 16777281
	
	set xydist sprite[].x
	sub xydist hitx
	mul xydist xydist
	set y2 sprite[].y
	sub y2 hity
	mul y2 y2
	add xydist y2
	sqrt xydist xydist
	
	ifn hitsprite -1 ifl xydist 384
	ifn actorvar[hitsprite].monstatus 0
	break
	
	add angvar 960
	cos mycos angvar
	sin mysin angvar
	hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 hitsector hitwall hitsprite hitx hity hitz 16777281
	set xydist2 sprite[].x
	sub xydist2 hitx
	mul xydist2 xydist
	set y2 sprite[].y
	sub y2 hity
	mul y2 y2
	add xydist2 y2
	sqrt xydist2 xydist2
	
	ifl xydist2 xydist ifl xydist2 384
	{
		ifvarand monstflags YES set angvar angvel else
		set angvar sprite[].ang
		sub angvar 512
		state moveatangvar
	}
	else
	{
		ifle xydist xydist2 ifl xydist 384
		{
			ifvarand monstflags YES set angvar angvel else
			set angvar sprite[].ang
			add angvar 512
			state moveatangvar
		}
	}

ends

defstate strafechecklong
	
	ifvarand monstflags YES set angvar angvel else
	geta[].ang angvar
	sub angvar 256
	geta[].z z
	sub z 6144 // 8192
	cos mycos angvar
	sin mysin angvar
	hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 hitsector hitwall hitsprite hitx hity hitz 16777281
	
	set xydist sprite[].x
	sub xydist hitx
	mul xydist xydist
	set y2 sprite[].y
	sub y2 hity
	mul y2 y2
	add xydist y2
	sqrt xydist xydist
	
	add angvar 512
	cos mycos angvar
	sin mysin angvar
	hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 hitsector hitwall hitsprite hitx hity hitz 16777281
	set xydist2 sprite[].x
	sub xydist2 hitx
	mul xydist2 xydist
	set y2 sprite[].y
	sub y2 hity
	mul y2 y2
	add xydist2 y2
	sqrt xydist2 xydist2
	
	ifl xydist2 xydist ifl xydist2 1024
	{
		ifvarand monstflags YES set angvar angvel else
		set angvar sprite[].ang
		sub angvar 512
		state moveatangvar
	}
	else
	{
		ifle xydist xydist2 ifl xydist 1024
		{
			ifvarand monstflags YES set angvar angvel else
			set angvar sprite[].ang
			add angvar 512
			state moveatangvar
		}
	}

ends


defstate stayincontrol
// the current node being checked has been validated
// invalidate the node if it leads to leaving the control sector prematurely
ife temp YES 
{
	ifg actorvar[spriteid].SPRITELOTAG 999
	{
		ife sprite[].sectnum sprite[A_ID].sectnum
		{
			ifn redbasestat LOCKDOWN ifn redbasestat REDLOCKDOWN set temp NO
		}
		else
		ife sprite[].sectnum sprite[B_ID].sectnum
		{
			ifn bluebasestat LOCKDOWN ifn bluebasestat REDLOCKDOWN set temp NO
		}
		else
		ife sprite[].sectnum sprite[C_ID].sectnum
		{
			ifn thirdbasestat LOCKDOWN ifn thirdbasestat REDLOCKDOWN set temp NO
		}
	}
}

ends

defstate valuetranslate
	
	ife gametype CONTROL // control
	{
		// redbasestat used for CONTROL_A
		// bluebasestat used for CONTROL_B
		// thirdbasestat used for CONTROL_C
		// negative numbers mean red influence, le REDLOCKDOWN means red lockdown
		// positive numbers mean blue influence, LOCKDOWN means blue lockdown
		ife team 1
		{
			ifl redbasestat LOCKDOWN getav[spriteid].redbaseval value
			ifl bluebasestat LOCKDOWN ifg actorvar[spriteid].bluebaseval value getav[spriteid].bluebaseval value
			ifl thirdbasestat LOCKDOWN ifg actorvar[spriteid].thirdbaseval value getav[spriteid].thirdbaseval value
		}
		else
		ife team 0
		{
			ifg redbasestat REDLOCKDOWN getav[spriteid].redbaseval value
			ifg bluebasestat REDLOCKDOWN ifg actorvar[spriteid].bluebaseval value getav[spriteid].bluebaseval value
			ifg thirdbasestat REDLOCKDOWN ifg actorvar[spriteid].thirdbaseval value getav[spriteid].thirdbaseval value
		}
		
	}
	else
	ife gametype DM
	{
		ife team 1 
		{

			ifg actorvar[spriteid].redflagval value
				set value actorvar[spriteid].redflagval
			
			ifg actorvar[spriteid].redbaseval value
				set value actorvar[spriteid].redbaseval
		}
		else
		ife team 0 
		{	

			ifg actorvar[spriteid].blueflagval value
				set value actorvar[spriteid].blueflagval
			
			ifg actorvar[spriteid].bluebaseval value
				set value actorvar[spriteid].bluebaseval
		}
	}
	else
	ife gametype -1 // tour guide
	{
		ifg tourgoal 7
		{
			ifg actorvar[spriteid].redflagval value
				set value actorvar[spriteid].redflagval
				
			ifactor GUIDEDRONE break
			
			ifg actorvar[spriteid].redbaseval value
				set value actorvar[spriteid].redbaseval
		}
		else
		ifcansee ifpdistl 8192
		{
			ifg actorvar[spriteid].redflagval value
				set value actorvar[spriteid].redflagval
			
			ifg actorvar[spriteid].redbaseval value
				set value actorvar[spriteid].redbaseval
		}
		else
		{
			set initflags YES // flag for player-following
			ifg actorvar[spriteid].blueflagval value
				set value actorvar[spriteid].blueflagval
			
			ifg actorvar[spriteid].bluebaseval value
				set value actorvar[spriteid].bluebaseval
		}
	}
	else
	ife gametype SURVIVAL
	{
		ife team 1 
		{
			ifg actorvar[spriteid].redflagval value
				set value actorvar[spriteid].redflagval
			
			ifg actorvar[spriteid].redbaseval value
				set value actorvar[spriteid].redbaseval
				
			ife pdown YES // ife myshelly THISACTOR
			{
				set value 0
				ifn spriteid mynavsprite
				ifg actorvar[spriteid].blueflagval value
				set value actorvar[spriteid].blueflagval
			
				ifg actorvar[spriteid].bluebaseval value
					set value actorvar[spriteid].bluebaseval
			}
			else ifle value 0
			{
				ifg actorvar[spriteid].blueflagval value
				set value actorvar[spriteid].blueflagval
			}
		}
		else
		ife team 0 
		{

			ifg actorvar[spriteid].blueflagval value
				set value actorvar[spriteid].blueflagval
			
			ifg actorvar[spriteid].bluebaseval value
				set value actorvar[spriteid].bluebaseval
		}
		else
		ife team 3 
		{
			ifg actorvar[spriteid].redflagval value
				set value actorvar[spriteid].redflagval
		}
	}
	else // CTF
	{
		
		ife team 1
		{
			ife redcarrier THISACTOR
			{
				getav[spriteid].bluebaseval value
				ife bluecarrier -1
				ifg actorvar[spriteid].blueflagval value
				set value actorvar[spriteid].blueflagval
			}
			else
			{
				getav[spriteid].blueflagval value
		
				ife redcarrier -1
				{
					ifg actorvar[spriteid].redflagval value
						set value actorvar[spriteid].redflagval
					else
					ifg actorvar[spriteid].redbaseval value
						set value actorvar[spriteid].redbaseval
				}
				else ife value 0
				{
					ifg actorvar[spriteid].redbaseval value
						set value actorvar[spriteid].redbaseval
				}
					
				ifvarand monstflags YES ife bluecarrier -1
				ifg actorvar[spriteid].blueflagval 1000
					getav[spriteid].blueflagval value
			}
		}
		else
		ife team 0 
		{
			ife bluecarrier THISACTOR
			{
				getav[spriteid].redbaseval value
				ife redcarrier -1
				ifg actorvar[spriteid].redflagval value
				set value actorvar[spriteid].redflagval
			}
			else
			{
				getav[spriteid].redflagval value
				
				ife bluecarrier -1
				{
					ifg actorvar[spriteid].blueflagval value
						set value actorvar[spriteid].blueflagval
					else
					ifg actorvar[spriteid].bluebaseval value
						set value actorvar[spriteid].bluebaseval
				}
				else ife value 0
				{
					ifg actorvar[spriteid].bluebaseval value
						set value actorvar[spriteid].bluebaseval
				}
					
				ifvarand monstflags YES ife redcarrier -1
				ifg actorvar[spriteid].redflagval 1000
					getav[spriteid].redflagval value
			}
		}
	}
	
	
	
	ifg actorvar[spriteid].SPRITELOTAG 999
	ifn sprite[spriteid].pal 0
	ifg actorvar[spriteid].initflags 0
	{
		// adjust value
		headspritestat TMP_A 980
		whilevarn TMP_A -1
		{
			ife actorvar[spriteid].initflags actorvar[TMP_A].initflags
			ifn TMP_A spriteid
			{
				ife value actorvar[spriteid].bluebaseval getav[TMP_A].bluebaseval TMP_B else
				ife value actorvar[spriteid].redbaseval getav[TMP_A].redbaseval TMP_B else
				ife value actorvar[spriteid].thirdbaseval getav[TMP_A].thirdbaseval TMP_B else
				ife value actorvar[spriteid].blueflagval getav[TMP_A].blueflagval TMP_B else
				getav[TMP_A].redflagval TMP_B
				add value TMP_B
				div value 2
				set TMP_A -1
			}
			ifn TMP_A -1
			nextspritestat TMP_A TMP_A
		}
	}
ends

defstate navforcedpath
	
	set B NO
	headspritestat spriteid 980
	whilevarn spriteid -1
	{
		ldist xydist THISACTOR spriteid
		ifl xydist MAXNAVDIST
		ifn spriteid navpoint
		{
			set temp YES
			getav[spriteid].SPRITELOTAG tempb
			sub tempb actorvar[navpoint].SPRITELOTAG
			
			ifn tempb direction set temp NO
			
			ife temp YES
			{
				// geta[].z z
				// subvar z 6144
				// seta[].z z
				// canseespr THISACTOR spriteid temp
				// add z 6144 // 8192
				// seta[].z z
				// ifn padmove 0 set temp YES
				
				set temp YES // we are going to force accessibility as an experiment
				ife temp YES // found it!!
				{
					set B YES
					ifvarand monstflags YES
					{
						geta[spriteid].x x2
						geta[spriteid].y y2
						sub x2 sprite[].x
						sub y2 sprite[].y
						getangle angvel x2 y2
					}
					else
					state facesprite
					set value 0
					state valuetranslate
					set savedvalue value

					set navpoint spriteid
					// note DO NOT change direction here!!
					set spriteid -1
				}
				
			}
		}
		ifn spriteid -1
		nextspritestat spriteid spriteid
	}
	ife B NO
	ifg navpoint 0
	{
		// add navpoint 16384
		// mul navpoint -1
		set navpoint -1
		set direction 0
	}

ends

defstate tanknavcode

ifg navpoint -1
{
	set spriteid navpoint
	
	geta[navpoint].x x2
	geta[navpoint].y y2
	sub x2 sprite[].x
	sub y2 sprite[].y
	getangle tempb x2 y2
	
	getincangle temp sprite[].ang tempb
	
	ifn sprite[].ang tempb
	{
		set B MAXTANKTURN
		mul B -1
		ifg temp B ifl temp MAXTANKTURN
			seta[].ang tempb
		else
		{
			geta[].ang angvar
			ifl temp 0 sub angvar MAXTANKTURN
			else add angvar MAXTANKTURN
			seta[].ang angvar
		}
	}
	
	ldist xydist THISACTOR navpoint
	ifl xydist 384
	{
		ifg actorvar[navpoint].SPRITELOTAG 999
		{
			state navforcedpath
			break
		}
		// find new point, but only
		set tempd 0 // current element in tmpar1
		set tempc 0 // current element in tmpar2
		headspritestat spriteid 980
		whilevarn spriteid -1
		{
			ifn spriteid navpoint
			ifn spriteid mynavsprite
			{
				geta[].z z
				subvar z 6144 // 8192
				geta[spriteid].z z2
				sub z2 z
				abs z2
				
				set temp YES
				ifn actorvar[navpoint].SPRITELOTAG 0
				{
					ifn actorvar[navpoint].SPRITELOTAG actorvar[spriteid].initflags
					set temp NO
					
					ifg actorvar[spriteid].SPRITELOTAG 999
					{
						ife sprite[spriteid].pal 0 set temp NO
						ifl navpoint 0
						ifn sprite[spriteid].sectnum sprite[].sectnum
							set temp NO
					}
				}

				ife temp YES // if lotag nonzero must match next node's hitag
				ifl z2 MAXHEIGHTDIFF // no big height difference allowed
				{
					geta[].z z
					subvar z 6144 // 8192
					seta[].z z
					canseespr THISACTOR spriteid temp
					add z 6144 // 8192
					seta[].z z
					
					ifg navpoint -1
					ifg actorvar[navpoint].initsprite -1
					ife actorvar[navpoint].initsprite actorvar[spriteid].initsprite
						set temp YES
					
					ife temp YES
					{
						geta[spriteid].x x2
						geta[spriteid].y y2
						sub x2 sprite[].x
						sub y2 sprite[].y
						getangle B x2 y2
						
						getincangle tempb sprite[].ang B
						abs tempb
						ifn bottarget -1 set tempb 0
						ifl tempb 640
						{
							dist xydist THISACTOR spriteid
							
							ife sprite[spriteid].pal 8 set TMP_A HALFNAVDIST else set TMP_A MAXNAVDIST		
							
							ifl xydist TMP_A
							{
								setarray tmpar1[tempd] spriteid
								add tempd 1
							}
							else ifl xydist 16384 // long distance points
							{
								setarray tmpar2[tempc] spriteid
								add tempc 1
							}
						}
					}
				
				}
			}
			nextspritestat spriteid spriteid
			ife tempd MAXELEMENTS set spriteid -1
			ife tempc MAXELEMENTS set spriteid -1
		}
		// choose randomly from tmpar1
		// or choose closest to target
		
		ifg tempd 0
		{
			sub tempd 1
			ife tempd 0 set navpoint tmpar1[tempd]
			else
			{
				ifn bottarget -1
				{
					set tempG 99999
					whilevarn tempd -1
					{
						dist tempH tmpar1[tempd] bottarget
						ifl tempH tempG
						{
							set tempG tempH
							set navpoint tmpar1[tempd]
						}
						sub tempd 1
					}
				}
				else
				{
					randvarvar temp tempd
					set navpoint tmpar1[temp]
				}
			}
		}
		else ifg tempc 0
		{
			sub tempc 1
			ife tempc 0 set navpoint tmpar2[tempc]
			else
			{
				ifn bottarget -1
				{
					set tempG 99999
					whilevarn tempc -1
					{
						dist tempH tmpar2[tempc] bottarget
						ifl tempH tempG
						{
							set tempG tempH
							set navpoint tmpar2[tempc]
						}
						sub tempc 1
					}
				}
				else
				{
					randvarvar temp tempc
					set navpoint tmpar2[temp]
				}
			}
		}
		else
		{
			add navpoint 16384
			mul navpoint -1
		}
	}
	
}
ends

defstate defaultwandercode
	
	ifg navpoint -1
	{
		set spriteid navpoint
		ifvarand monstflags YES
		{
			geta[spriteid].x x2
			geta[spriteid].y y2
			sub x2 sprite[].x
			sub y2 sprite[].y
			getangle angvel x2 y2
		}
		else
		ifn sprite[].xvel 0
		state facesprite
		
		ldist xydist THISACTOR navpoint
		ifl xydist 384
		{
			ifg actorvar[navpoint].SPRITELOTAG 999
			{
				state navforcedpath
				break
			}
			// find new point, but only in front
			set tempd 0 // current element in tmpar1
			set tempc 0 // current element in tmpar2
			headspritestat spriteid 980
			whilevarn spriteid -1
			{
				ifn spriteid navpoint
				ifn spriteid mynavsprite
				{
					geta[].z z
					subvar z 6144 // 8192
					geta[spriteid].z z2
					sub z2 z
					abs z2
					
					set temp YES
					ifn actorvar[navpoint].SPRITELOTAG 0
					{
						ifn actorvar[navpoint].SPRITELOTAG actorvar[spriteid].initflags
						set temp NO
						
						ifg actorvar[spriteid].SPRITELOTAG 999
						{
							ife sprite[spriteid].pal 0 set temp NO
							ifl navpoint 0
							ifn sprite[spriteid].sectnum sprite[].sectnum
								set temp NO
						}
					}
					// hack to prevent actors from leaving control sector prematurely via forced path
					ife gametype CONTROL // control
					state stayincontrol
					
					ifactor DUMCIV ife actorvar[spriteid].mtype 6 set temp NO
					
					ife temp YES // if lotag nonzero must match next node's hitag
					ifl z2 MAXHEIGHTDIFF // no big height difference allowed
					{
						geta[].z z
						subvar z 6144 // 8192
						seta[].z z
						canseespr THISACTOR spriteid temp
						add z 6144 // 8192
						seta[].z z
						
						ifg navpoint -1
						ifg actorvar[navpoint].initsprite -1
						ife actorvar[navpoint].initsprite actorvar[spriteid].initsprite
							set temp YES
						
						ife temp YES
						{
							geta[spriteid].x x2
							geta[spriteid].y y2
							sub x2 sprite[].x
							sub y2 sprite[].y
							getangle B x2 y2
							
							ifvarand monstflags YES getincangle tempb angvel B else
							getincangle tempb sprite[].ang B
							abs tempb
							ifl tempb 640
							{
								dist xydist THISACTOR spriteid
								
								ife sprite[spriteid].pal 8 set TMP_A HALFNAVDIST else set TMP_A MAXNAVDIST		
								
								ifl xydist TMP_A // 6144
								{
									setarray tmpar1[tempd] spriteid
									add tempd 1
								}
								else ifl xydist 16384 // long distance points
								{
									setarray tmpar2[tempc] spriteid
									add tempc 1
								}
							}
						}
					
					}
				}
				nextspritestat spriteid spriteid
				ife tempd MAXELEMENTS set spriteid -1
				ife tempc MAXELEMENTS set spriteid -1
			}
			// choose randomly from tmpar1
			
			ifg tempd 0
			{
				sub tempd 1
				ife tempd 0 set navpoint tmpar1[tempd]
				else
				{
					randvarvar temp tempd
					set navpoint tmpar1[temp]
				}
			}
			else ifg tempc 0
			{
				sub tempc 1
				ife tempc 0 set navpoint tmpar2[tempc]
				else
				{
					randvarvar temp tempc
					set navpoint tmpar2[temp]
				}
			}
			else 
			{
				add navpoint 16384
				mul navpoint -1
			}
			
			ifg navpoint 0
			{
				set spriteid navpoint
				ifvarand monstflags YES
				{
					geta[spriteid].x x2
					geta[spriteid].y y2
					sub x2 sprite[].x
					sub y2 sprite[].y
					getangle angvel x2 y2
				}
				else
				state facesprite
			}
		}
		else 
		{
			ifvarand monstflags YES nullop else
			{
				geta[].htmovflag temp
				ifn temp 0
				{
					// bumping something
					add temp 16384
					ifl temp 16384 ifg temp -1 // bumping a sprite
					{
						set B NO
						ife actorvar[temp].monstatus 1
						ife actorvar[temp].team team set B YES
						ifn gametype 0 ifvarand sprite[temp].cstat 16 set B YES
						ife gametype CTF ife actorvar[temp].monstatus 0 set B YES
						ife B YES
						{
							set x2 sprite[].x
							add x2 256
							rotatepoint sprite[].x sprite[].y x2 sprite[].y sprite[].ang x y
							setsprite THISACTOR x y sprite[].z
							seta[].htmovflag 0
						}
					}
				}
			}
		}
		
	}
ends

defstate getaflagnode

	set value 0 // should be initialized first
	ifg navpoint 0
		ifg actorvar[navpoint].SPRITELOTAG 999
	{
		state navforcedpath
		break
	}
	set tempd 0
	set B savedvalue
	
	ifl navpoint -1
	{
		set tempe navpoint
		mul tempe -1
		sub tempe 16384
	}
	else set tempe -1
	
	headspritestat spriteid 980
	whilevarn spriteid -1
	{
		set value 0 // should be initialized first
		state valuetranslate
		
		ldist xydist THISACTOR spriteid
		ife sprite[spriteid].pal 8 set TMP_A HALFNAVDIST else set TMP_A MAXNAVDIST
		ifl xydist TMP_A
		ifn spriteid navpoint
		ifn spriteid tempe
		ifg value B
		{
			geta[].z z
			subvar z 6144 // 8192
			geta[spriteid].z z2
			sub z2 z
			abs z2
			
			set temp YES
			
			ifg navpoint -1
			{
				ifn actorvar[navpoint].SPRITELOTAG 0
				{
					ifn actorvar[navpoint].SPRITELOTAG actorvar[spriteid].initflags
					set temp NO
				}
				
				ifg actorvar[spriteid].SPRITELOTAG 999
				ife sprite[spriteid].pal 0 set temp NO
			}
			else
			{
				ifn actorvar[spriteid].SPRITELOTAG 0
				{
					ifn sprite[spriteid].sectnum sprite[].sectnum
					set temp NO
				}
			}
			// hack to prevent actors from leaving control sector prematurely via forced path
			ife gametype CONTROL // control
				state stayincontrol
				
			ifactor COMMANDER set z2 0
			ifactor NEWCOMM set z2 0
			ifactor BOSS2FLY set z2 0
			ifactor OCTABRAIN set z2 0
			
			ife temp YES
			ifl z2 MAXHEIGHTDIFF // no big height difference allowed
			{
				geta[].z z
				subvar z 6144 // 8192
				seta[].z z
				ife navpoint -1 state navspritevischeck
				else canseespr THISACTOR spriteid temp
				
				add z 6144 // 8192
				seta[].z z
				
				ifg navpoint -1
				ifg actorvar[navpoint].initsprite -1
				ife actorvar[navpoint].initsprite actorvar[spriteid].initsprite
					set temp YES
				
				ife temp YES
				{
					setarray tmpar1[tempd] spriteid
					add tempd 1
					ifvarand monstflags YES set tempG YES else set tempG NO
					
					ife navpoint -1 set B value else
					ife tempG NO set B value else
					ifg navpoint -1
					set B value
				}
			
			}
		}
		nextspritestat spriteid spriteid
		ife tempd MAXELEMENTS set spriteid -1
	}
	
	ifg tempd 0
	{
		sub tempd 1
		ife tempd 0 
		{
			set navpoint tmpar1[tempd]
		}
		else
		{
			set tempc NO
			ife savedvalue -1
			ifrnd 128 set tempc YES
			else
			ife gametype -1 set tempc YES else
			ife gametype SURVIVAL set tempc YES
			
			ife tempc YES // take high value
			{
				set value 0 // should be initialized first
				whilevarn tempd -1
				{
					set spriteid tmpar1[tempd]
					state valuetranslate
					ifg value savedvalue { set navpoint spriteid set savedvalue value }
					sub tempd 1
				}
			}
			else
			{
				randvarvar temp tempd
				set navpoint tmpar1[temp]
			}
		}
		ifg actorvar[navpoint].SPRITELOTAG 999
		{
			ife sprite[navpoint].pal 1 set direction 1
			else
			ife sprite[navpoint].pal 2 set direction -1
		}
		
		set spriteid navpoint
		set value 0 // should be initialized first
		state valuetranslate
		set savedvalue value
		
	}
	else 
	{
		set savedvalue -1 // reset value if failed to find new node
		state defaultwandercode
		break
	}
	
	ifg navpoint 0
	{
		set spriteid navpoint
		ifvarand monstflags YES
		{
			geta[spriteid].x x2
			geta[spriteid].y y2
			sub x2 sprite[].x
			sub y2 sprite[].y
			getangle angvel x2 y2
		}
		else
		state facesprite
	}

ends

// write this state only if the CTF code proves to be inadequate
// state hordepursuitcode ends

defstate getanode

	ifg navpoint -1
	{
		// remember statnum 1 means it is not a navsprite
		ife sprite[navpoint].statnum 1
		// ife actorvar[navpoint].SPRITELOTAG 0
		{
			dist xydist THISACTOR navpoint
			ifl xydist 4096 // 1560
			{
				// geta[].z z
				// subvar z 6144
				// seta[].z z
				// canseespr THISACTOR navpoint temp
				// add z 6144
				// seta[].z z
				// ife temp YES
				// {
					geta[].z z
					geta[navpoint].z z2
					sub z z2
					abs z
					ifg z MAXHEIGHTDIFF
						set navpoint -1
				// }
				// else set navpoint -1
			}
			else set navpoint -1
			
		}
		else
		ife sprite[navpoint].statnum 1024 set navpoint -1
	}
	
	ifl navpoint 0
	{
		ifl navpoint -1
		{
			set tempe navpoint
			mul tempe -1
			sub tempe 16384
		}
		else set tempe -1
		
		ife crumbwait 0
		{
			ife navmode 2
			{
				state getaflagnode
				ifg navpoint -1 
				break
			}
			set xydist2 99999
			set target -1
			headspritestat spriteid 980
			whilevarn spriteid -1
			{
				ifn spriteid tempe
				ifn spriteid mynavsprite
				{
					geta[].z z
					subvar z 6144 // 8192
					seta[].z z
					ife navpoint -1 state navspritevischeck
					else canseespr THISACTOR spriteid temp
					add z 6144 // 8192
					seta[].z z
					
					ifactor DUMCIV ife actorvar[spriteid].mtype 6 set temp NO
					
					ifn actorvar[spriteid].SPRITELOTAG 0
					{
						ifg actorvar[spriteid].SPRITELOTAG 999
						{
							ife sprite[spriteid].pal 0
								set temp NO
							ifl navpoint 0
							ifn sprite[spriteid].sectnum sprite[].sectnum
								set temp NO
						}
						else
						ifn sprite[spriteid].sectnum sprite[].sectnum
						set temp NO
					}
					ife gametype CONTROL // control
						state stayincontrol
					ife temp YES
					{
						dist xydist THISACTOR spriteid
						ifl xydist xydist2
						{
							set target spriteid
							set xydist2 xydist
						}
					}
				}
				nextspritestat spriteid spriteid
			}
			ifn target -1 
			{
				set navpoint target
				ifg actorvar[navpoint].SPRITELOTAG 999
				{
					ife sprite[navpoint].pal 1 set direction 1
					else
					ife sprite[navpoint].pal 2 set direction -1
				}
			}
		}
	}

ends

defstate getflagcode

	ifg navpoint -1
	{
		set spriteid navpoint
		ifvarand monstflags YES
		{
			geta[spriteid].x x2
			geta[spriteid].y y2
			sub x2 sprite[].x
			sub y2 sprite[].y
			getangle angvel x2 y2
		}
		else
		state facesprite
		ldist xydist THISACTOR navpoint
		ife sprite[navpoint].picnum NAVSPRITE
		{
			ifvarand monstflags YES set tempG YES else set tempG NO
			ifl xydist 384
				state getaflagnode
			else
			ife tempG NO
			{
				geta[].htmovflag temp
				ifn temp 0
				{
					// bumping something
					add temp 16384
					ifl temp 16384 ifg temp -1 // bumping a sprite
					{
						set B NO
						ife actorvar[temp].monstatus 1
						ife actorvar[temp].team team set B YES
						ifn gametype 0 ifvarand sprite[temp].cstat 16 set B YES
						ife B YES
						{
							set x2 sprite[].x
							add x2 256
							rotatepoint sprite[].x sprite[].y x2 sprite[].y sprite[].ang x y
							setsprite THISACTOR x y sprite[].z
							seta[].htmovflag 0
						}
					}
				}
			}
		}
		else
		{
			ifl xydist 256
				state getaflagnode
			else
			ifnotmoving ifg xydist 1560
				set navpoint -1
				
		}
	}
ends



defstate navigationsmart

// this version is for actors who can move in one direction while firing in another
	ifg gametype 0
	{
		ife bonus_screen 1 killit
		sleeptime -1
		set navmode 2
		ife gametype CTF ifg sprite[].xvel 40 ifl sprite[].xvel 160 seta[].xvel 160
	}
	else
	ifn bottarget -1
	{
		ife navmode 3 { set navpoint -1 break }
	}
	ifg crumbwait 0 sub crumbwait 1
	ife navmode 0 break

	ifg redtimer 0 sub redtimer 1
	
	ifg navpoint 0
	{
		geta[].z z
		sub z 4096
		cos mycos angvel
		sin mysin angvel
		hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 hitsector hitwall hitsprite hitx hity hitz 16777281
		
		ifn actorvar[navpoint].initsprite -1
		ifn gametype -1
		{
			set x sprite[].x
			sub x hitx
			mul x x
			set y2 sprite[].y
			sub y2 hity
			mul y2 y2
			add x y2
			sqrt x x
			ife redtimer 0
			ifl actorvar[navpoint].initsprite 10
			{
				ifn hitwall -1
				{
					ifl x 1560 
					{
						getw[hitwall].nextsector temp
						ifn temp -1
						{
							operatesectors temp THISACTOR 
							set redtimer 30 
						}
					}
				}
			}
			
			ifn redtimer 30
			ifnotmoving ifrnd 8 operate
		}
		else
		ifnotmoving 
		iffloordistl 8
		{
			geta[].htmovflag temp
			ifn temp 0
			{
				// hit something
				add temp 16384
				ifl temp 16384 ifg temp -1 
				{
					ifn actorvar[temp].monstatus 1
					{
						set navpoint -1
						set crumbwait 8
					}
				}
				else
				{
					ifn navpoint -1
					ifl actorvar[navpoint].SPRITELOTAG 999
					{
						set navpoint -1
						set crumbwait 8
					}
				}
			}
		}
		
		ifn hitsprite -1
		ifg sprite[].xvel 0
		ife actorvar[hitsprite].monstatus 1
		ife actorvar[hitsprite].team team
		{
			getincangle temp sprite[hitsprite].ang angvel
			abs temp
			ifg temp 768
			{
				// ifn navpoint actorvar[hitsprite].navpoint
				// {
					set angvar angvel
					add angvar 512
					state moveatangvar
				// }
			}
		}
		ifg sprite[].xvel 0
			state strafecheck
	}
	
	ife navmode 4 // pursue player but also use navpoints
	{
		ifg gametype 0 set navmode 2
		else
		{
			set savedvalue navpoint
			set navpoint -1
			set B -1
			ife seeplayer YES { ifpdistg 8192 state crumbcode }
			else
			state crumbcode
			
			ife B -1
			{
				set navpoint savedvalue
				state getanode
				state defaultwandercode
			}
			
			
		}
	}
	else
	ife navmode 3 // random wander mode
	{
		state getanode
		state defaultwandercode
		
		ifl gametype 1
		ifl navpoint 0
		ifactornotstayput
		{
			ife seeplayer YES { iffloordistl 32 ifpdistg 8192 state crumbcode }
			else
			state crumbcode
			
		}
		
		
	}
	else
	ife navmode 2 // goal seeking mode
	{
		ife gametype CONTROL // control
		{
			state getanode
			state getflagcode
		}
		else
		ife gametype DM
		{
			state getanode
			state getflagcode
		}
		else
		ife gametype SURVIVAL // horde arena mode
		{
			state getanode
			// state hordepursuitcode
			state getflagcode
			// edge cases of flag code should work for horde mode navigation
		}
		else
		ife gametype CTF // capture the flag
		{
			state getanode
			state getflagcode
		}
		else // default code
		{
			state getanode
			ifn team 0 ife gametype -1 ife botclip 10 state getflagcode
			else
			state defaultwandercode
		}
	}

ends

defstate navigation

	ifg gametype 0
	{
		ife bonus_screen 1 killit
		sleeptime -1
		set navmode 2
	}
		
	ifg crumbwait 0 sub crumbwait 1
	ife navmode 0 break
	
	ife botclip 10 ife initflags 2 break // hack for arena guide

	// coming into this code, the actor may have a combat target (bottarget)
	// rules of engagement:
	// if your navpoint is your own flag or base, then drop your target
	// if wandering, fight instead
	// if playing CTF:
	// if enemy is in front of you on your path, fight
	// if enemy is not in front of you and has a different target, ignore
	// if enemy is far away ignore

	ifg navpoint -1 ifn sprite[navpoint].picnum NAVSPRITE 
	ife actorvar[navpoint].team team
		set bottarget -1
	
	ifn bottarget -1
	{
		ife navmode 3 { set navpoint -1 break } else
		ife gametype CONTROL { set navpoint -1 break } else
		ife gametype SURVIVAL { set navpoint -1 break } else
		ife gametype DM { set navpoint -1 break } else
		ife navmode 2
		{
			// references to flag carriers in non-CTF are harmless
			ldist xydist THISACTOR bottarget
			ife redcarrier THISACTOR ifg xydist 4096 set bottarget -1 else
			ife bluecarrier THISACTOR ifg xydist 4096 set bottarget -1
			
			ifn bottarget -1
			ifn bottarget redcarrier ifn bottarget bluecarrier
			{
				// is enemy directly in my path?
				geta[bottarget].x x2
				geta[bottarget].y y2

				sub x2 sprite[].x
				sub y2 sprite[].y
				getangle angvar x2 y2
				
				ifg navpoint -1 
				{
					geta[navpoint].x x
					geta[navpoint].y y
					sub x sprite[].x
					sub y sprite[].y
					getangle temp x y
				}
				else set temp sprite[].ang
				
				getincangle tempb angvar temp
				abs tempb			
				set tempe 1048576
				ife xydist 0 set xydist 1
				div tempe xydist
				ifg tempe 512 set tempe 512
				ifg tempb tempe
				{
					// possibly drop target
					ifg xydist 6144 set bottarget -1 else
					ifn actorvar[bottarget].bottarget -1
						ifn actorvar[bottarget].bottarget THISACTOR
							set bottarget -1
				}
			}
		}
	}
	ifn bottarget -1 ifn navmode 1
	break
	
	ifg redtimer 0 sub redtimer 1
	ifg navpoint 0
	ifn navmode 1
	{
		geta[].z z
		sub z 4096
		cos mycos sprite[].ang
		sin mysin sprite[].ang
		hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 hitsector hitwall hitsprite hitx hity hitz 16777281
		
		ifn actorvar[navpoint].initsprite -1
		ifn gametype -1
		{
			set x sprite[].x
			sub x hitx
			mul x x
			set y2 sprite[].y
			sub y2 hity
			mul y2 y2
			add x y2
			sqrt x x
			ife redtimer 0
			// ifl actorvar[navpoint].initsprite 10
			ifn actorvar[navpoint].initsprite 20
			{		
				ifn hitwall -1
				{
					ifl x 1560 
					{
						getw[hitwall].nextsector temp
						ifn temp -1
						{
							operatesectors temp THISACTOR 
							set redtimer 30 
						}
					}
				}
			}
			ifn redtimer 30
			{
			ifnotmoving 
			{ 
				ifrnd 16 operate 
				ifrnd 4 { set navpoint -1 set crumbwait 8 } 
			}
			else ifg sprite[].xvel 0 ifl x 1280 ifn hitwall -1 { ifrnd 32 operate ifg sprite[].xvel 32 seta[].xvel 32 }
			}
		}
		else
		ifnotmoving 
		iffloordistl 8
		{
			geta[].htmovflag temp
			// hit something
			add temp 16384
			
			ifl temp 16384 ifg temp -1
			{
				ife actorvar[temp].monstatus 1
				ife actorvar[temp].team team
				ifn team 3
				{
					set x2 sprite[].x
					add x2 128
					rotatepoint sprite[].x sprite[].y x2 sprite[].y sprite[].ang x y
					setsprite THISACTOR x y sprite[].z
					seta[].htmovflag 0
				}
			}
			else
			ifrnd 10
			{
				set navpoint -1
				set crumbwait 8
			}
		}
		
		ifn hitsprite -1
		ifg sprite[].xvel 0
		ife actorvar[hitsprite].monstatus 1
		ife actorvar[hitsprite].team team
		{
			getincangle temp sprite[hitsprite].ang sprite[].ang
			abs temp
			ifg temp 768
			{
				// ifn navpoint actorvar[hitsprite].navpoint
				// {
					geta[].ang angvar
					add angvar 512
					state moveatangvar
				// }
			}
		}
		
		ifg sprite[].xvel 0
			state strafecheck
	}
	
	ife navmode 3 // random wander mode
	{
		state getanode
		state defaultwandercode
		
		ifl navpoint 0
		ifactornotstayput
		{
			ifg sprite[].xvel 0
			{
				ife seeplayer YES { iffloordistl 32 ifpdistg 8192 state crumbcode }
				else
				state crumbcode
			}
		}	
	}
	else
	ife navmode 2 // goal seeking mode
	{
		ife gametype CONTROL // control
		{
			state getanode
			state getflagcode
		}
		else
		ife gametype DM 
		{
			state getanode
			state getflagcode
		}
		else
		ife gametype SURVIVAL // horde arena
		{
			state getanode
			// state hordepursuitcode
			state getflagcode
			// edge cases of flag code should work for horde mode navigation
		}
		else
		ife gametype CTF // capture the flag
		{
			state getanode
			state getflagcode
		}
		else // default code
		{
			state getanode
			ifn team 0 ife gametype -1 ife botclip 10 state getflagcode
			else
			state defaultwandercode
		}
	}
	else
	ife navmode 1 // directed wander mode
	{
		state getanode
		state tanknavcode
	}

ends

defstate summondespawn

	ifg FEMKILLCOUNT 0
	ife bottarget -1
	{
		sub FEMKILLCOUNT 1
		ife FEMKILLCOUNT 0
		{
			sound TELEPORTER
			spawn GLARESTAR
			state spawnoutline
			killit
		}
	}

ends

defstate jumppadmove

	set FEMFALLDMG 0
	cos xvel padang
    sin yvel padang
    
	mul xvel jumpadxvel
	mul yvel jumpadxvel
	
	seta[].xvel 0
	div xvel 15000
	div yvel 15000
	// shiftr xvel 14
	// shiftr yvel 14
	
	geta[].zvel z
	sub z 32
	seta[].zvel z // gravity difference compensation

	movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN
	
	
	sub padmove 1
	iffloordistl 8 nullop else ife padmove 0 set padmove 1
	
	ife padmove 0 set navpoint -1
	
ends

defstate spawn_crushed
	set RETURN 0
	switch sprite[].picnum
	case LIZTROOP case LIZTROOPDUCKING
	case NEWTROOP case NEWTROOPDUCKING
		espawn CRUSHLIZTROOP
	break
	case PIGCOP case PIGCOPDIVE
	case NEWPIG case NEWPIGDIVE
		espawn CRUSHPIGCOP
	break
	case ARMPIG case EDFPIG
		espawn CRUSHARMPIG
	break
	case LIZELITE case LIZELITECROUCH
		espawn CRUSHLIZELITE
	break
	case NEWBEAST case NEWBEASTCROUCH
	case CYBERBEAST
		espawn CRUSHNEWBEAST
	break
	case MECHBRAIN
		espawn CRUSHMECHBRAIN
	break
	case LIZMAN
		espawn CRUSHLIZMAN
	break
	case LIZDOG
		espawn CRUSHLIZDOG
	break
	case COMMANDER case NEWCOMM
		espawn CRUSHCOMMANDER
	break
	case OCTABRAIN case MEGABRAIN
		espawn CRUSHOCTABRAIN
	break
	case LIZRANGER case LIZRANGERDUCKING
		espawn CRUSHLIZRANGER
	break
	case SPACEBULL case SPACEBULLDUCKING
		espawn CRUSHSPACEBULL
	break
	case ARMYANT case ARMYANTCRAWL
		espawn CRUSHANT
	break
	case ZOMBIE
		espawn CRUSHZOMBIE
	break
	case CRAZYLADY
		spritepal 2
		espawn CRUSHZOMBIE
		getlastpal
	break
	case BOSS1 case NEWBATLORD
		espawn CRUSHBATLORD
	break
	
	endswitch
	ifn RETURN 0 
	{
		setav[RETURN].myspawner THISACTOR
		seta[RETURN].pal sprite[].pal
	}
ends

defstate alphapulse
	ifactor SIDEGUN break
	set temp player[].player_par
	add temp monxp
	// add temp sprite[].picnum
	shiftvarl temp 3
	
	sin tempb temp
	ifl tempb 0 mul tempb -1
	shiftr tempb 6
	ifg tempb 255 set tempb 255
	seta[].alpha tempb

ends

defstate shellyperkcheck

	set savz NO
	ife pchar 1 ife sprite[].htowner player[].i set savz YES else
	ife sprite[].htowner myshelly
	{
		ife sprite[myshelly].picnum SHELLY set savz YES else
		ife sprite[myshelly].picnum SHELLYCROUCH set savz YES
	}
	
	ife savz YES
	{
		set savz sprite[].htextra
		mul savz 100
		div savz inithp
		add stun savz
	}

ends

defstate wesperkcheck

	set savz NO
	ife pchar 2 ife sprite[].htowner player[].i set savz YES else
	ife sprite[].htowner myshelly
	{
		ife sprite[myshelly].picnum WESBOT set savz 2 else
		ife sprite[myshelly].picnum WESBOTCROUCH set savz 2
	}
	
	ifn savz NO
	{
		switch sprite[].picnum
		case ZOMBIE case ZOMBIEGIDUP case CORRUPT
		case CRONEN case CRAZYLADY
		case OCTABRAIN case MEGABRAIN
		case BATBOSS
			set temp sprite[].htextra
			mul temp 2
			seta[].htextra temp
			ife savz YES add leach temp else
			ife savz 2 add botleach temp
		break
		endswitch
	}

ends

defstate addfriendflag

rand temp 8
	switch temp
	case 0 orvar monstflags 16 break // speedy
	case 1 orvar monstflags 128 break // multishot
	case 2 orvar monstflags 1024 break // healing aura
	case 3 orvar monstflags 2 break // rapid ROF
	case 4 orvar monstflags 8 break // energy barrier
	case 5 orvar monstflags 512 break // sideguns
	case 6 orvar monstflags 16384 break // vampirism
	case 7 orvar monstflags 2048 break // ghostly
	case 8 orvar monstflags 64 break // double damage
	endswitch
ends

defstate addmonstflag

	ifrnd 64
	ifn sprite[].picnum LIZTURRET
	ifn sprite[].picnum EDFTURRET
	ifn sprite[].picnum ROTATEGUN
	orvar monstflags 32 // strafes when moving forward
			
	rand temp 100

	ifl temp 10
		ifn sprite[].picnum ROTATEGUN
		ifn sprite[].picnum LIZTURRET
		ifn gametype 1
		{
			ifvarand monstflags 16 nullop else { mul monxp 5 div monxp 4 }
			orvar monstflags 16 // speedy
			
			ife initflags 0
			ifspritepal 0 spritepal 36
		}
	else ifl temp 15
		ifn sprite[].picnum ROTATEGUN
		ifn sprite[].picnum ZOMBIE
		{
			ifvarand monstflags 4096 nullop else { mul monxp 5 div monxp 4 }
			orvar monstflags 4096 // radioactive
			ife initflags 0
			spritepal 76
		}
	else ifl temp 25
		ifn sprite[].picnum ZOMBIE
		ifn sprite[].picnum SHARK
		{
			ifvarand monstflags 128 nullop else { mul monxp 4 div monxp 3 }
			orvar monstflags 128 // multishot
			ife initflags 0 spritepal 64
		}
	else ifl temp 30
		ifn sprite[].picnum NEWRECON
		{
			ifvarand monstflags 1024 nullop else { mul monxp 5 div monxp 3 }
			orvar monstflags 1024 // healing aura
			ife initflags 0
			spritepal 22
		}
	else ifl temp 35
		ifn sprite[].picnum NEWBEAST ifn sprite[].picnum DRONE ifn sprite[].picnum ROTATEGUN ifn sprite[].picnum DEANOVA
		ifn sprite[].picnum SITH ifn sprite[].picnum SYTH ifn sprite[].picnum CORRUPT
		ifn sprite[].picnum LIZTURRET ifn sprite[].picnum EDFTURRET ifn sprite[].picnum SCUBATROOP 
		ifn sprite[].picnum COMBINEDMEN ifn sprite[].picnum SMALLMAN ifn sprite[].picnum LARGEMAN 
		ifn sprite[].picnum SHARK
		{
			ifvarand monstflags 2 nullop else { mul monxp 4 div monxp 3 }
			orvar monstflags 2 // rapid ROF
		}
	else ifl temp 45	
		ifn sprite[].picnum SHARK
		{
			ifvarand monstflags 8 nullop else { mul monxp 5 div monxp 4 }
			orvar monstflags 8  // energy barrier
		}
	
	else ifl temp 55
		{
			ifvarand monstflags 16384 nullop else { mul monxp 5 div monxp 4 }
			orvar monstflags 16384  // vampirism
		}
	else ifl temp 60
		{
			ifvarand monstflags 1048576 nullop else { mul monxp 4 div monxp 3 }
			orvar monstflags 1048576 // electric aura
		}
	else ifl temp 70
	ifn gametype 1 ifn gametype 3
		{
			ifvarand monstflags 256 nullop else { mul monxp 4 div monxp 3 }
			orvar monstflags 256  // gigantism
		}
	else ifl temp 80
		{
			ifvarand monstflags 512 nullop else { mul monxp 4 div monxp 3 }
			orvar monstflags 512 // sideguns
			ife initflags 0
			ifspritepal 0 spritepal 14
		}
	else ifl temp 85
	ifn sprite[].picnum ROTATEGUN
	ifn sprite[].picnum LIZTURRET
	ifn gametype 2
		{
			ifvarand monstflags 32768 nullop else { mul monxp 3 div monxp 2 }
			orvar monstflags 32768 // darkness
			geta[].htflags temp, orvar temp 4, seta[].htflags temp
		}
	else ifl temp 95
		{
			ifvarand monstflags 64 nullop else { mul monxp 4 div monxp 3 }
			orvar monstflags 64  // double damage
			ife initflags 0
			spritepal 49
		}
	else
	ife gametype 0
		{	
			ifvarand monstflags 2048 nullop else { mul monxp 3 div monxp 2 }
			orvar monstflags 2048 // ghostly
			ife initflags 0
			spritepal 15
		}

ends

defstate monsterai

ifl monstatus 1
{
  ifvarand monstflags 131072
	nullop
  else
  {
	seta[].yvel 200
	rand bluetimer 6
	switch sprite[].picnum
	
	case PIGCOP case PIGCOPDIVE case NEWPIG case NEWPIGDIVE
	case PIGCOPSTAYPUT case NEWPIGSTAYPUT
	set monxp 200
	ifspritepal 21 { orvar initflags 32 addstrength PIGCOPSTRENGTH sound PIGWARN add monxp 150 }
	break
	
	case OCTABRAIN
	case OCTABRAINSTAYPUT
		set monxp 200
		ifspritepal 17 { orvar initflags 16 addstrength 100 sizeat 36 32 add monxp 100 }
	break
	
	case RECON
	set monxp 300
	break
	
	case LIZRANGER case LIZRANGERDUCKING
	set monxp 200 break
	
	case MECHBRAIN
		set monxp 400
		ifspritepal 14 { orvar initflags 2 add monxp 150 }
		ifspritepal 21 { orvar initflags 2 add monxp 150 }
	break
	
	case COMMANDER case EDFPIG
	case CYBERBEAST case NEWRECON
		set monxp 400 
		ifspritepal 24 { add monxp 200 orvar initflags 2 }
	break
	case NEWCOMM
		set monxp 500 
		ifspritepal 24 { add monxp 200 orvar initflags 2 }
	break
	
	case LIZELITE case LIZELITECROUCH
		set monxp 600 
	break
	case SITH case SYTH
	case MEGABRAIN case PIGSUV
	set monxp 650 break
	
	case CHEERBOT
		ifspritepal 43 set monxp 1000 else
		set monxp 600 
	break
		
	case MANDOFETT case MANDOCROUCH
		orvar initflags 2
		set monxp 800
	break
	
	case DEANOVA 
		orvar initflags 2
		set monxp 800
	break
	
	case TANK
		set monxp 800
	break
	
	case NURGLE
		set monxp 1000
	break
	
	case LIZDOG
		ifspritepal 104 { orvar initflags 32 set monxp 800 } else
		ifspritepal 17 set monxp 200 else
		set monxp 150
	break
	
	case LIZMAN
		set monxp 250
		ifspritepal 20 { orvar initflags 32 addstrength LIZSTRENGTH add monxp 200 }
		ifspritepal 42 { orvar initflags 8 addstrength LIZSTRENGTH add monxp 200 } 
	break
		
	case LIZTROOP case LIZTROOPDUCKING
		set monxp 100
		ifspritepal 16 { orvar initflags 16 addstrength 50 add monxp 100 }
	break
	
	case NEWTROOP case NEWTROOPDUCKING
		set monxp 150
		ifspritepal 16 { orvar initflags 16 addstrength 50 add monxp 100 }
		ifspritepal 24 { orvar initflags 2 add monxp 150 }
		ifspritepal 21 { orvar initflags 2 add monxp 50 }
	break
	
	case NEWBEAST
		set monxp 300
		ifspritepal 21 orvar initflags 4
		ifvarand initflags 4 { addstrength 100 add monxp 100 }
	break
	
	case TERMINATOR case TERMINATORDUCKING
		set monxp 350
		ifvarand initflags 32 { add monxp 200 addstrength 150 }
	break
	
	case TERMINATORCRAWLING
		set monxp 100
	break
	
	case ARMPIG
		ife mtype 2 set monxp 400 else set monxp 550
		ifspritepal 21 { orvar initflags 32 add monxp 200 addstrength 200 }
	break
	
	case LIZTURRET
	case SPACEBULL case SPACEBULLDUCKING
	case NEWSENTRY
		set monxp 300 
	break
	
	case ARMYANT case ARMYANTCRAWL case ARMYANTJUMP
	case SCUBATROOP
	case CRAZYLADY
		set monxp 150 break
	
	case DRONE
		set monxp 100
		ifspritepal 19 { orvar initflags 8 addstrength 50 add monxp 100 }
		ife mtype 1 { strength 40 set monxp 0 }
	break
	
	case ROTATEGUN
	case CORRUPT
		set monxp 100
	break
	
	case SHARK
	case ZOMBIE
	case ZOMBIEGIDUP
	case SIDEGUN
		set monxp 75 break
	case EGG case EGGYOUNG set monxp 30 break
		
	case BOSS1 case BOSS2 case BOSS3 case BOSS4
	case DRPROTON case PSPIDER
	ifspritepal 0 { set monxp 2000 orvar initflags 2 }
	else set monxp 1000
	break
	
	case NEWBOSS1 case QUEEN
	ifspritepal 0 { set monxp 2500 orvar initflags 2 }
	else set monxp 1250
	break
	
	case PIGBOSS
	ifspritepal 0 { orvar initflags 2 set monxp 2500 } else 
	ifspritepal 42 { orvar initflags 2 set monxp 3000 } else 
	set monxp 1250
	break
	
	case NEWBATLORD 
	ifspritepal 0 { set monxp 2500 orvar initflags 2 } else ifspritepal 42 set monxp 1500 else set monxp 1250
	break
	
	case LIZBOSS 
	ifspritepal 60 { set monxp 2500 orvar initflags 2 } else
	ifspritepal 0 { set monxp 2500 orvar initflags 2 } else ifspritepal 20 { orvar initflags 2 set monxp 1500 } else set monxp 1250
	break
	
	case LARGEMAN case SMALLMAN
	case COMBINEDMEN
		set monxp 1250
	break
	
	case CANHEAD
		ifspritepal 0 { set monxp 2000 orvar initflags 2 } else set monxp 1500
	break
	
	case BOSS2FLY set monxp 2000
	break
	
	case CRONEN
		set monxp 150
		ifvarand initflags 32 add monxp 200
	break
	
	case DEVOURER
		ifspritepal 0
		{ orvar initflags 2 set monxp 3000 }
		else ifspritepal 19 set monxp 400 else set monxp 200
	break
	
	case BATBOSS
		ifspritepal 21 { orvar initflags 2 set monxp 4000 } else set monxp 1000
	break
	
	case CYCLOIDMAX
		ifspritepal 0 { orvar initflags 2 set monxp 5000 } else set monxp 2500
	break
	
	default set monxp 100 break
	
	endswitch
	
	ifge monstflags 2
	ifge SKILL 4 set savedvalue YES
	
	ifn attmode NO
	// ife team 0
	ifn team 1
	ifn team 3
	ifl monstflags 2 // don't add more if they are set in the map
	{
		ifg plevel 1
		{
			set TMP_A plevel
			mul TMP_A 2
			set B plevel, add B 5, ifg TMP_A B set TMP_A B
			set TMP_B plevel
			div TMP_B 2, ifl TMP_B 1 set TMP_B 1
			rand mlevel TMP_A
			ifl mlevel TMP_B set mlevel TMP_B
		}
		ife challenge YES add mlevel 1
		// add monstflags based on plevel here
		
		ifg plevel 1
		ifn sprite[].picnum SIDEGUN
		ifn sprite[].picnum SHARK
		ifn sprite[].picnum DOPEFISH
		ifn sprite[].picnum EGGYOUNG
		ifn sprite[].picnum FLYINGFIST
		{
			ifrnd 84 ifn sprite[].picnum EGG 
			
			ifn sprite[].picnum ROTATEGUN
			ifn sprite[].picnum LIZTURRET
			ifn sprite[].picnum EDFTURRET
			orvar monstflags 32 // strafes when moving forward
			
			set TMP_A plevel
			ife SKILL 4 add TMP_A 1
			ife SKILL 5 add TMP_A 2
			ife SKILL 6 add TMP_A 2
			
			set tempI TMP_A
			
/*
			rand TMP_B 100
			ifl TMP_B TMP_A
			ifn sprite[].picnum EGG
			{
				orvar monstflags 2 // increased HP
				mul monxp 4 div monxp 3
				ifn sprite[].picnum BOSS1 ifn sprite[].picnum BOSS2 ifn sprite[].picnum BOSS3 ifn sprite[].picnum BOSS4
				ifn sprite[].picnum NEWBATLORD ifn sprite[].picnum QUEEN
				ifn sprite[].picnum DEANOVA
				ifspritepal 0 spritepal 12
			}
*/		
			rand TMP_B 100
			ifl TMP_B TMP_A
			ifn sprite[].picnum EGG
			ifn sprite[].picnum ROTATEGUN
			ifn sprite[].picnum LIZTURRET
			{
				orvar monstflags 16 // speedy
				mul monxp 5 div monxp 4
				ife initflags 0
				ifspritepal 0 spritepal 36
				sub TMP_A 1
			}
			
			rand TMP_B 110
			ifl TMP_B TMP_A
			ifn sprite[].picnum EGG
			{
				orvar monstflags 8  // energy barrier
				mul monxp 5 div monxp 4
				sub TMP_A 1
			}
			
			sub TMP_A 1 // ***START TIER 2***
			
			rand TMP_B 100
			
			ifl TMP_B TMP_A
			ifn sprite[].picnum EGG
			ifn sprite[].picnum ZOMBIE
			{
				orvar monstflags 128 // multishot
				mul monxp 5 div monxp 4
				ife initflags 0
				spritepal 64
				sub TMP_A 1
			}
			
			rand TMP_B 110
			ifg attbeaten 0
			ifl TMP_B TMP_A
			ifn sprite[].picnum EGG
			{
				orvar monstflags 16384  // vampirism
				mul monxp 5 div monxp 4
				sub TMP_A 1
			}
			
			rand TMP_B 140
			ifge SKILL 4
			ifl TMP_B TMP_A
			{
				orvar monstflags 1048576 // electric aura
				mul monxp 4 div monxp 3
				sub TMP_A 1
			}
			
			sub TMP_A 1  // ***START TIER 3***
			
			rand TMP_B 140
			ifl TMP_B TMP_A
			{
				orvar monstflags 256  // gigantism
				mul monxp 4 div monxp 3
				sub TMP_A 1
			}
			
			rand TMP_B 120
			ifl TMP_B TMP_A
			ifn sprite[].picnum NEWRECON
			{
				orvar monstflags 1024 // healing aura
				mul monxp 4 div monxp 3
				ife initflags 0
				spritepal 22
				sub TMP_A 1
			}
			
			rand TMP_B 120
			ifl TMP_B TMP_A
			ifn sprite[].picnum ROTATEGUN
			ifn sprite[].picnum ZOMBIE
			{
				orvar monstflags 4096 // radioactive
				mul monxp 5 div monxp 4
				ife initflags 0
				spritepal 76
				sub TMP_A 1
			}
			
			
			sub TMP_A 1  // ***START TIER 4***
			
			rand TMP_B 100
			ifl TMP_B TMP_A
			ifn sprite[].picnum EGG
			{
				orvar monstflags 512 // sideguns
				mul monxp 4 div monxp 3
				ife initflags 0
				ifspritepal 0 spritepal 14
				sub TMP_A 1
			}
/*
			rand TMP_B 95
			ifl TMP_B TMP_A
			ifn sprite[].picnum EGG
			{
				orvar monstflags 4 // double HP
				mul monxp 4 div monxp 3
				ife initflags 0
				ifspritepal 0 spritepal 35
			}
*/	
			
			rand TMP_B 95
			ifvarand monstflags 128 nullop else
			ifl TMP_B TMP_A
			ifn sprite[].picnum NEWBEAST ifn sprite[].picnum DRONE ifn sprite[].picnum ROTATEGUN ifn sprite[].picnum DEANOVA
			ifn sprite[].picnum SITH ifn sprite[].picnum SYTH ifn sprite[].picnum CORRUPT
			ifn sprite[].picnum LIZTURRET ifn sprite[].picnum EDFTURRET ifn sprite[].picnum SCUBATROOP 
			ifn sprite[].picnum COMBINEDMEN ifn sprite[].picnum SMALLMAN ifn sprite[].picnum LARGEMAN 
			ifn sprite[].picnum EGG
			ife initflags 0
			{
				orvar monstflags 2 // rapid ROF
				mul monxp 4 div monxp 3
				sub TMP_A 1
			}
			
			
			ifge attbeaten 4
			ifge plevel 4
			ifn sprite[].htpicnum RESPAWN
			ifn sprite[].picnum ROTATEGUN
			ifn sprite[].picnum EGG
			ifn sprite[].picnum LIZTURRET
			ifn sprite[].picnum DRONE
			ifn sprite[].picnum NEWBATLORD
			ifn sprite[].picnum CANHEAD
			ifn sprite[].picnum BOSS2
			ifn sprite[].picnum BOSS3
			ifn sprite[].picnum LIZBOSS
			ifn sprite[].picnum PIGBOSS
			ifn sprite[].picnum NURGLE
			ifn sprite[].picnum DEANOVA
			ifn sprite[].picnum BATBOSS
			ife sprite[].htactorstayput -1
			ifl monxp 2000
			{
				rand TMP_B 150
				ifl TMP_B TMP_A
				{
					orvar monstflags 131072 // mimic
					ifvarand monstflags 2 xorvar monstflags 2
					set inithp plevel
					set mlevel plevel
					mul inithp 100
					add inithp 200
					set bluebaseval inithp
					set monxp inithp
					seta[].extra inithp
					set spawnprotect 0
				}
			}
			
			sub TMP_A 1  // ***START TIER 5***
			rand TMP_B 90
			ifvarand monstflags 128 nullop else
			ifvarand monstflags 2 nullop else
			ifl TMP_B TMP_A
			ifn sprite[].picnum EGG
			{
				orvar monstflags 64  // double damage
				mul monxp 4 div monxp 3
				ife initflags 0
				spritepal 49
				sub TMP_A 1
			}
			
			rand TMP_B 120
			ifl TMP_B TMP_A
			ifg attbeaten 1
			{
				orvar monstflags 32768 // darkness
				mul monxp 4 div monxp 3
				geta[].htflags temp, orvar temp 4, seta[].htflags temp
				sub TMP_A 1
			}
			
			rand TMP_B 100
			ife attmode 2 ifge monxp 1000 set TMP_B 100
			ife attmode 1 ifge monxp 2000 set TMP_B 100
			ifl TMP_B TMP_A
			{
				ifvarand monstflags 1024 // don't add ghostly if has healing aura
				{
					orvar initflags 32
					orvar monstflags 512
				}
				else
				orvar monstflags 2048 // ghostly
				mul monxp 4 div monxp 3
				ife initflags 0
				spritepal 15
				sub TMP_A 1
			}
			
			ifvarand monstflags 131072 nullop else
			ifg ppowcount 60
			ifg monxp 100 ifl monxp 1900
			ifg plevel 3
			ifn sprite[].picnum SCUBATROOP
			ife attmode YES
			ifn challenge YES
			{
				set ppowcount -60
				orvar monstflags 4
				ifrnd 128 orvar monstflags 128 else orvar monstflags 16
				ifrnd 128 orvar monstflags 512 else orvar monstflags 64
				ifrnd 128 orvar monstflags 1024 else orvar monstflags 4096
				ifg plevel 10 { ifrnd 128 orvar monstflags 2048 else orvar monstflags 256 }
				ifrnd 128 orvar initflags 32
				orvar monstflags 32
				orvar monstflags 65536
				spritepal 92
				add monxp 500
			}
			
			ifge monxp 1000
			ifle monstflags 1
			ifge plevel 5
			{
				ifrnd 84 { orvar monstflags 256 mul monxp 4 div monxp 3 } else
				ifrnd 128 { orvar monstflags 16 mul monxp 5 div monxp 4 } else
				{ orvar monstflags 64 mul monxp 4 div monxp 3 }
				ifn sprite[].pal 0 spritepal 49
			}
			
		}
		
	}
	else 
	{
		set mlevel plevel
		ife marathon YES 
		{
			add mlevel mlevel_bonus
			ife attmode NO
			ifg mlevel 1
			{
				set TMP_A mlevel
				sub TMP_A 1
				set B TMP_A
				mul B 5
				add inithp B
				mul TMP_A 10
				add TMP_A 100
				mul inithp TMP_A
				div inithp 100
			}
		}
		ife team 1
		ifg FEMKILLCOUNT 0
		ifge plevel 5 state addfriendflag
	}
	ifge SKILL 5 ifn sprite[].picnum EGG
	ifn sprite[].picnum SIDEGUN 
	ifn gametype -1
	{
		ife team 0 
		ifl monstflags 2
		{
			// ife SKILL 5 { ifrnd 32 state addmonstflag } else
			state addmonstflag
		}
		else ife team 1 ifn gametype 0 state addmonstflag
	}
	geta[].extra inithp
	// apply some flag settings
	
  }
	geta[].htflags temp, orvar temp 8192, seta[].htflags temp
    set monstatus 1
	ifrnd 96 orvar monstflags 262144
	ifvarand monstflags 8 // energy barrier
	{
		espawn EBARRIER
		setav[RETURN].myspawner THISACTOR
		ifrnd 128 seta[RETURN].pal 21
		ife gametype DM setav[RETURN].teamspawned 99999
	}
	ifvarand monstflags 4 { add inithp 150 mul inithp 3 div inithp 2 }
	ifvarand monstflags 64 { add inithp 50 mul inithp 4 div inithp 3 }
	ifvarand monstflags 128 { add inithp 50 mul inithp 4 div inithp 3 }
	ifvarand monstflags 256 
	{
		add inithp 100
		mul inithp 2
		set upscaled NO
	}
	ifvarand monstflags 512 // side guns
	{
		espawn SIDEGUN
		setav[RETURN].myspawner THISACTOR
		setav[RETURN].botclip -384
		rand safecount 5
		setav[RETURN].mtype safecount
		espawn SIDEGUN
		setav[RETURN].myspawner THISACTOR
		setav[RETURN].botclip 384
		setav[RETURN].mtype safecount
		ife gametype DM setav[RETURN].teamspawned 99999
		
		ifvarand monstflags 256 nullop else
		ifvarand monstflags 4 nullop else
		{
			mul inithp 4 div inithp 3
		}
	}
	ifvarand monstflags 1024 // healing aura
	{
		espawn HEALINGAURA
		setav[RETURN].myspawner THISACTOR
		add inithp 100
		ifvarand monstflags 256 nullop else
		{
			mul inithp 4 div inithp 3
		}
	}
	ifvarand monstflags 4096 // radiation aura
	{
		espawn RADAURA
		setav[RETURN].myspawner THISACTOR
		// seta[RETURN].pal 22
	}
	ifvarand monstflags 1048576
	{
		espawn SHOCKAURA
		setav[RETURN].myspawner THISACTOR
	}
	ifvarand monstflags 2 // rapid ROF
	{
		add inithp 50
		mul inithp 5 div inithp 4
	}
	ifvarand monstflags 32768 // darkness
	{
		sound FLAMEDRAWIN
		add inithp 100
		state spawnoutline
	}
	
	// ifg mlevel 1
	ife savedvalue YES
	{
		add mlevel 2
		ifge SKILL 5 add mlevel 2
		set savedvalue -1
	}
	ifn attmode NO
	{
		ifvarand monstflags 131072 nullop else
		ifn THISACTOR mynaamah
		{
			ifl SKILL 5
			{
				mul inithp 3
				div inithp 4
			}
			div monxp 2
			
			
			set TMP_A mlevel
			sub TMP_A 1
			set B TMP_A
			mul B 5
			add inithp B
			mul TMP_A 10
			add TMP_A 100
			mul inithp TMP_A
			div inithp 100
			
			set TMP_A mlevel
			sub TMP_A 1
			mul TMP_A 15
			add TMP_A 100
			mul monxp TMP_A
			div monxp 100
		}
	}
	ifg inithp 32767 set inithp 32767
	ifvarand monstflags 131072 
	{
		set inithp bluebaseval
		ifn redflagval 0
		seta[].extra redflagval
	}
	else
	seta[].extra inithp
	set blueiteration 0
	
	ifg gametype 0 set spawnprotect 40
}

ife player[].actorsqu THISACTOR
  ife player[].knee_incs 14
		state spawn_crushed

ife upscaled YES // ensures that upscaled monsters don't get too big
{
	ifg sprite[].xrepeat init_xrepeat ifg init_xrepeat 4 seta[].xrepeat init_xrepeat
	ifg sprite[].yrepeat init_yrepeat ifg init_yrepeat 4 seta[].yrepeat init_yrepeat
}
else
ifvarand monstflags 256
{
	ifmove 0 nullop else
	{
		set upscaled YES
		
		ife init_xrepeat 0 set temp YES else set temp NO
		
		ife init_xrepeat 0
		geta[].xrepeat x
		else set x init_xrepeat
		
		mul x 3, div x 2, ifg x 255 set x 255
		seta[].xrepeat x
		set init_xrepeat x
		al x
		ife init_yrepeat 0
		geta[].yrepeat y
		else set y init_yrepeat
		
		mul y 3, div y 2, ifg y 255 set y 255
		seta[].yrepeat y
		set init_yrepeat y
		al y
		
		ife temp YES
		{
			state spawnoutline
			spawn GLARESTAR
			sound ACTOR_GROWING
		}
		
	}
}

ifcansee set seeplayer YES else set seeplayer NO

// ifn team 3
// ifn monstatus 2 ife mysignpost -1 
// ifn sprite[].picnum EGG // to prevent bots blowing up nearby civilians
// ifn sprite[].picnum EGGYOUNG
// state spawnmysignpost

	// ifonwater
	// {
		// geta[].picnum picnum
		// switch picnum
		// case LIZTROOP case ZOMBIETROOP
		// case PIGCOP case PIGCOPDIVE
		// case LIZMAN case NEWBEAST
		// case BOSS1 case BOSS2 case BOSS3
		// geta[].htflags temp
		// orvar temp 16
		// seta[].htflags temp
		// seta[].mdflags 16
		// set float YES
		// break
		// endswitch
	// }
	// else seta[].mdflags 0

ifg stun 0 
{
	sub stun 1
	ifge SKILL 4 sub stun 1
	set temp inithp
	ifg inithp 800
	{
		div temp 800
		ifg temp 7 set temp 7
		sub stun temp
	}
	ifl stun 0 set stun 0
}


ifg dodgetime 0 sub dodgetime 1

ifg thirdbasetimer 0 
{
	sub thirdbasetimer 1 // countdown until saber ammo can be spent on this enemy
	ifg thirdbasetimer 99 seta[].htpicnum HEADJIB1 // hack to make headshots work with lightsaber
}

// SPECIAL KICK CHECKING CODE

ifge sidekick 100
ife kicktarg -1
ife monstatus 1
ifl sprite[].alpha 128
{
	ife seeplayer YES
	ifpdistl 3072
	{
		set angvar initkickang
		add angvar 1024
		getincangle temp sprite[].ang angvar
		abs temp
		ifl temp 128 set kicktarg THISACTOR
	}
}

ife monstatus 1
	ife seeplayer YES
	ifl sprite[].alpha 128
{
	ifn sprite[].picnum RECON
	// ifn sprite[].picnum PIGSUV
	ifn sprite[].picnum ROTATEGUN
	// ifn sprite[].picnum SIDEGUN
	{
		state kickcheckcode	
	}
	
	set temp NO
	ife pchar 0 ifvarand dukeupgrades[RPG_WEAPON] 4 set temp YES // MULTI ROCKETS
	ife pchar 1 ifvarand shellyupgrades[RPG_WEAPON] 4 set temp YES // MULTI ROCKETS
	
	ife temp YES
	ife zoomin YES
	ife player[].curr_weapon RPG_WEAPON
	ifg player[].ammo_amount RPG_WEAPON 0
	ife player[].kickback_pic 0
	ife player[].weapon_pos 0
	ife targetwait 0
	// ifn THISACTOR targetlock[0]
	// ifn THISACTOR targetlock[1]
	// ifn THISACTOR targetlock[2]
	ifn actorvar[player[].i].team team
	{
		geta[].x x2
		geta[].y y2
		sub x2 player[].posx
		sub y2 player[].posy
		getangle angvar x2 y2
		
		getincangle temp angvar player[].ang
		abs temp
		ifl temp 16
		{
			ife targetlock[0] -1
			{
				set targetwait 10
				sound TARGETLOCK
				setarray targetlock[0] THISACTOR
				geta[THISACTOR].mdflags temp
				orvar temp 16
				seta[THISACTOR].mdflags temp
			}
			else
			ife targetlock[1] -1
			ifg player[].ammo_amount RPG_WEAPON 1
			{
				set targetwait 10
				sound TARGETLOCK
				setarray targetlock[1] THISACTOR
				geta[THISACTOR].mdflags temp
				orvar temp 16
				seta[THISACTOR].mdflags temp
			}
			else
			// ife targetlock[2] -1
			ifg player[].ammo_amount RPG_WEAPON 2
			{
				set B NO
				
				ife targetlock[0] targetlock[1]
				ifn targetlock[0] THISACTOR
				{
					setarray targetlock[1] THISACTOR
					set B YES
				}
				else
				ife targetlock[1] targetlock[2]
				ifn targetlock[1] THISACTOR
				{
					setarray targetlock[2] THISACTOR
					set B YES
				}
				else
				ife targetlock[0] targetlock[2]
				ifn targetlock[0] THISACTOR
				{
					setarray targetlock[2] THISACTOR
					set B YES
				}
				else
				ife targetlock[2] -1 { setarray targetlock[2] THISACTOR set B YES }
				
				ife B YES
				{
					set targetwait 10
					sound TARGETLOCK
					geta[THISACTOR].mdflags temp
					orvar temp 16
					seta[THISACTOR].mdflags temp
				}
			}
		}
	}
}

	state spawnprotectcode
	
ifg padmove 0 state jumppadmove
else ifvarand monstflags 16 // super speed
{
	ifmove STOPPED nullop else
	ifmove STOPPEDFORPLAYER nullop else
	{
		geta[].xvel xvel
		ifg xvel 32
		{
			// ifg xvel 32 
			ifl xvel 768 add xvel 64
			// ifl xvel -32 ifg xvel -256 sub xvel 32
			seta[].xvel xvel
			ifvarand sprite[].cstat 32768 nullop else
			ife team 0
			state makespeedblur
		}
	}
}

ifg monstflags 0
{
	ifvarand monstflags 16384 // vampirism
	{
		ifwasweapon CAPTUREPLUS
		{
			seta[].htpicnum SHOTSPARK1
			
			set safecount 0
			whilevarn safecount 8
			{
				espawn CAPTUREPLUS
				ifn RETURN -1
				{
					seta[RETURN].pal 21
					
					rand x2 1024
					sub x2 512
					add x2 sprite[].x
					seta[RETURN].x x2
					seta[RETURN].htbposx x2
					
					rand x2 1024
					sub x2 512
					add x2 sprite[].y
					seta[RETURN].y x2
					seta[RETURN].htbposy x2
					
				}
				add safecount 1
			}
		}
	}

	ifvarand monstflags 32768 // darkness
	{
		geta[].htflags temp, orvar temp 4, seta[].htflags temp
		ife monstatus 1
		{
			seta[].shade 35 
			set temp player[].player_par
			add temp THISACTOR
			modvar temp 30
			ife temp 0
			{
				espawn BIGSMOKE2
				seta[RETURN].htflags 4
				seta[RETURN].shade 28
			}
			// retaliate with dark projectiles
			ifg sprite[].htextra sprite[].extra // 5
			ifn sprite[].htowner -1
			ifn actorvar[sprite[].htowner].team team
			{
				setprojectile[RADPROJ].workslike 69634
				setprojectile[RADPROJ].vel 412
				
				set safecount inithp // sprite[].htextra
				div safecount 2
				sqrt safecount safecount
				ifg safecount 64 set safecount 64
				ifl safecount 3 set safecount 3
				
				whilevarn safecount 0
				{
					// set temp sprite[].htextra
					// ifg sprite[].htextra inithp set temp inithp
					// div temp 5, ifl temp 5 set temp 5
					// ifg temp 25 set temp 25
					setprojectile[RADPROJ].extra 10
					eshoot RADPROJ
					sound RADHIT
					setav[RETURN].bottarget sprite[].htowner
					setav[RETURN].mtype 1
					seta[RETURN].pal 10
					seta[RETURN].blend 0
					seta[RETURN].cstat 128
					rand angvar 2048 sub angvar 1024 add angvar sprite[].ang
					seta[RETURN].ang angvar
					rand z 1024
					sub z 1024
					seta[RETURN].zvel z
					sub safecount 1
				}
				
				setprojectile[RADPROJ].workslike 69890
				setprojectile[RADPROJ].extra 20
				setprojectile[RADPROJ].vel 512
			}
			
			ifrnd 1
			ifn zombieonplayer THISACTOR
			// iffloordistl 4
			ife sprite[].htextra -1
			ife shrunken 0
			ifn redcarrier THISACTOR
			ifn bluecarrier THISACTOR
			{
				set mysignpost sprite[].picnum
				sound FLAMEDRAWIN
				cactor MONSHADOW
				geta[].yrepeat damflash
				geta[].mdflags temp
				orvar temp 16
				seta[].mdflags temp
				randvar angvar 2047
				seta[].ang angvar
				break
			}
		}
		else
		seta[].shade 20
		
	}

	ifvarand monstflags 2
	ife monstatus 1
	{
		ifle sprite[].xvel 64
		ifge sprite[].xvel -64
		{
			set temp player[].player_par
			modvar temp 3
			ife temp 0
			{
				set tempb sprite[].htg_t 2
				add tempb 1
				seta[].htg_t 2 tempb
			}
		}
	}

	ifvarand monstflags 2048 // ghostly
	{
		ife monstatus 2 
		{
			seta[].alpha 0
			xorvar monstflags 2048
		}
		else
		{
			state alphapulse
			geta[].cstat temp
			ifg sprite[].alpha 164 // 128
			{
				ifvarand temp 256 xorvar temp 256
				
				ifn zombieonplayer THISACTOR
					seta[].htextra -1
				
			}
			else
			{
				ifvarand temp 32768 nullop else
				orvar temp 256
			}
			seta[].cstat temp
			ifspritepal 1 // frozen
			{
				cstator 257
				seta[].alpha 0
				xorvar monstflags 2048
			}
		}
	}

	ifvarand monstflags 8192 // suicide bomber
	{
		ife spawnprotect 0
		{
			ifspritepal 6 getlastpal
			
			set temp player[].player_par
			modvar temp 5
			ife temp 0 spritepal 6
		}
		
		set temp NO
		
		ifn bottarget -1
		ifn actorvar[bottarget].team team
		ife seemytarget YES
		ifl targetdist 1024
		set temp YES
		
		ifn sprite[].htowner -1
		ifn actorvar[sprite[].htowner].team team
		ifge sprite[].htextra sprite[].extra
		set temp YES
		
		ife temp YES
		{
			xorvar monstflags 8192
			ifspritepal 6 getlastpal
			hitradius 2048 30 45 60 75
			
			ifn bottarget -1
			{
				set temp inithp
				ifg temp 150 set temp 150
				ife pchar 0 set tempc dweaplevel[GROW_WEAPON] else 
				ife pchar 2 set tempc wweaplevel[GROW_WEAPON] else
				set tempc bweaplevel[GROW_WEAPON]
				add tempc 6
				mul tempc 10
				add temp tempc
				geta[bottarget].htextra tempb
				add tempb temp
				seta[bottarget].htextra tempb
				seta[bottarget].htpicnum RPG
				ife team 1
				seta[bottarget].htowner player[].i else
				seta[bottarget].htowner THISACTOR
				seta[bottarget].htang sprite[].ang
			}
			
			strength 1
			seta[].htextra 100
			seta[].htpicnum RPG
			seta[].htowner THISACTOR
			
			ifrnd 128
			sound PIPEBOMB_EXPLODE
			else
			sound ROBOT_EXPLODE
			spawn EXPLOSION3
			
		}
	}

	ifmove STOPPED nullop else
	ifn monstatus 2
	ifg sprite[].extra 0
	{
		ifvarand monstflags 32
		{
			ife targetalive YES
			ife seemytarget YES
			ifn bottarget -1
			ifl targetdist 12288
			ifg sprite[].xvel 31
			{
				set temp player[].player_par
				add temp THISACTOR
				shiftl temp 5
				sin tempb temp

				shiftr tempb 5
				
				ifinwater shiftr tempb 1
				
				geta[bottarget].x x2
				geta[bottarget].y y2
				sub x2 sprite[].x
				sub y2 sprite[].y
				getangle angvar x2 y2
				
				ifvarand THISACTOR 1
				add angvar 512
				else
				sub angvar 512
				
				cos xvel angvar
				sin yvel angvar
					  
				shiftr xvel 5
				shiftr yvel 5
				
				mul xvel tempb
				mul yvel tempb
				
				shiftr xvel 5
				shiftr yvel 5
			
				mul xvel sprite[].xvel
				mul yvel sprite[].xvel
				
				// shiftr xvel 14
				// shiftr yvel 14
				div xvel 12288
				div yvel 12288
				movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN
			}
		}
		ifvarand monstflags 65536
		{
			ifg ppowcount 0 set ppowcount 0
			ife seeplayer YES ifpdistl 16384 
			{
				ifle prating 800
				ifrnd 2
				{
					spawn GLARESTAR
					sound TELEPORTER
					killit
				}
			}
			else
			ifrnd 2
			ife bottarget -1
			{
				set B -1
				headspritestat spriteid 999
				whilevarn spriteid -1
				{
					ldist tempc player[].i spriteid
					ifg tempc 2560 
					{
						canseespr spriteid player[].i temp
						ife temp YES
						set B spriteid
					}
					
					nextspritestat spriteid spriteid
					ifn B -1 set spriteid -1
				}
				ifn B -1
				{
					spawn GLARESTAR
					setsprite THISACTOR sprite[B].x sprite[B].y sprite[B].z
					spawn GLARESTAR
					sound TELEPORTER
					seta[].htactorstayput -1
				}
			}
		}
	}
}

state predamage

ifg sprite[].htextra 0
{
	ife sprite[].htowner THISACTOR 
	{
		ifn sprite[].htpicnum SHOTSPARK1
			seta[].htextra -1
	}
	else
	{
		geta[].htowner spriteid
		ifn spriteid -1 
		{
			ife team actorvar[spriteid].team
			ifn actorvar[spriteid].monstatus 0
			{
				set temp sprite[].htextra
				ife gametype DM set temp -1
				else { mul temp 2 div temp 3 }
				ifl temp 1 set temp 1
				seta[].htextra temp
			}
			else
			ifvarand monstflags 1048576
			ife monstatus 1
			ifn sprite[].htpicnum STUCKARROW
			ifn sprite[].htpicnum RADWOUND 
			ifn sprite[].htpicnum BURNING
			{
				geta[].ang safecount
				state facesprite
				set xvel 768
				geta[spriteid].z zdist
				sub zdist sprite[].z 
				mul zdist xvel
				ldist xydist THISACTOR spriteid
				ifvare xydist 0 setvar xydist 1 
				divvarvar zdist xydist
				ezshoot zdist SHOCKPROJ
				rand angvar 4
				sub angvar 2
				add safecount angvar
				seta[].ang safecount
			}
		}
	}
	
}

ifg sprite[].htextra -1
{
	set temp sprite[].htextra
	ife sprite[].htowner player[].i
	{
		set TMP_A NO
		// ifg combotime 0 set TMP_A YES
		ifg switchboost 0 set TMP_A YES
		ife TMP_A YES
		{
			
			mul temp 3
			div temp 2
			seta[].htextra temp
			ifn sprite[].htpicnum BURNING
			ifn sprite[].htpicnum FREEZEBLAST
			ifn sprite[].htpicnum KNEE
			ifn sprite[].htpicnum SHRINKSPARK
			ifn sprite[].htpicnum GROWSPARK
			{
				seta[].htpicnum RPG
				sound AMPHIT
			}
		}
		else ife switchboost 0 add damagecount temp
	}
	ife DAMAGEFLASH YES
	ifg sprite[].extra 3
	ife sawfleshtime 0
	ife sprite[].htowner player[].i
	{
		geta[].mdflags tempb
		orvar tempb 16
		seta[].mdflags tempb
		set tempc player[].player_par
		sub tempc 1
		ifn tempc damflash
		ifn sprite[].htpicnum STUCKARROW
		ifn sprite[].htpicnum RADWOUND 
		ifn sprite[].htpicnum FORCECHOKE
		set damflash player[].player_par
	}
	
	
	set blueiteration 90 // this is a countdown timer

	switch sprite[].htpicnum
	
	case RPG
		ifvarand shellyupgrades[RPG_WEAPON] 1 nullop else
		{
			ife pchar 1
			ife player[].curr_weapon RPG_WEAPON
			ife sprite[].htowner player[].i
			{
				ife rpgtype 1 { ifl burning 60  seta[].htpicnum FREEZEBLAST }
				else ife rpgtype 0
				{
					geta[].htextra temp
					shiftl temp 1
					add burning temp
					shiftr temp 2
					seta[].htextra temp
				}
			
			}
		}
		
		ifn sprite[].picnum BOSS1
		ifn sprite[].picnum BOSS2
		ifn sprite[].picnum BOSS3
		ifn sprite[].picnum BOSS4
		ifn sprite[].picnum DEVOURER
		ifn sprite[].picnum RECON
		ifn sprite[].picnum NEWRECON
		{
			geta[].xvel xvel
			mulvar xvel -1
			seta[].xvel xvel	
		}
		ifvarand perks 256 state shellyperkcheck
	break
	
	case RADIUSEXPLOSION
		
		ifn sprite[].picnum BOSS1
		ifn sprite[].picnum BOSS2
		ifn sprite[].picnum BOSS3
		ifn sprite[].picnum BOSS4
		ifn sprite[].picnum DEVOURER
		ifn sprite[].picnum RECON
		ifn sprite[].picnum NEWRECON
		{
			geta[].xvel xvel
			mulvar xvel -1
			seta[].xvel xvel	
		}
		ifvarand perks 256 state shellyperkcheck
	break
	
	case KNEE
	
		ifn shrunken 0
		{
			geta[].htextra temp
			shiftl temp 4
			seta[].htpicnum RPG
		}
		geta[].htowner spriteid
		set B NO
		ife sprite[spriteid].picnum DUKEBOT set B YES
		ife sprite[spriteid].picnum SHELLY set B YES
		ife B YES
		{
			ifn team 1
			ife monstatus 1
			{
				geta[].htextra temp
				add temp KNEE_WEAPON_STRENGTH
				seta[].htextra temp
				
				// ifn sprite[].picnum BOSS1
				// ifn sprite[].picnum BOSS2
				// ifn sprite[].picnum BOSS3
				// ifn sprite[].picnum BOSS4
				// ifn sprite[].picnum PSPIDER
				// ifn sprite[].picnum CYCLOIDMAX
				// ifn sprite[].picnum NEWBATLORD
				// ifn sprite[].picnum QUEEN
				// ifn sprite[].picnum PIGBOSS
				// ifn sprite[].picnum LIZBOSS
				// ifn sprite[].picnum TERMINATORCRAWLING
				// ifn sprite[].picnum EGG
				// ifn sprite[].picnum EGGYOUNG
				// ifn sprite[].picnum ROTATEGUN
				// ifn sprite[].picnum SIDEGUN
				// ifn sprite[].picnum RECON
				// ifn sprite[].picnum NEWRECON
				// ifn sprite[].picnum PIGSUV
				// ifn sprite[].picnum TANK
				// {
					
					set temp sprite[].htextra
					div temp 5
					add stun temp
				// }

			}
		}
		else
		ife sprite[].htowner player[].i
		{
			ife kneecharge FULLKNEE 
			ife slidekick 0
			ife slidehit NO
			ife monstatus 1
			ife sidekick 0
			{
				ifn sprite[].picnum BOSS1
				ifn sprite[].picnum BOSS2
				ifn sprite[].picnum BOSS3
				ifn sprite[].picnum BOSS4
				ifn sprite[].picnum PSPIDER
				ifn sprite[].picnum CYCLOIDMAX
				ifn sprite[].picnum NEWBATLORD
				ifn sprite[].picnum QUEEN
				ifn sprite[].picnum PIGBOSS
				ifn sprite[].picnum LIZBOSS
				ifn sprite[].picnum TERMINATORCRAWLING
				ifn sprite[].picnum EGG
				ifn sprite[].picnum EGGYOUNG
				ifn sprite[].picnum ROTATEGUN
				ifn sprite[].picnum SIDEGUN
				ifn sprite[].picnum RECON
				ifn sprite[].picnum NEWRECON
				ifn sprite[].picnum PIGSUV
				ifn sprite[].picnum TANK
				{
					seta[].xvel -512 // -1024
					seta[].zvel -1024 // -2048
					geta[].z z
					sub z 1536 // 3072
					seta[].z z
				}
				geta[].htextra temp
				add temp KNEE_WEAPON_STRENGTH
				seta[].htextra temp
				set kneecharge 0
			}
		}
	break
	
	case FREEZEBLAST
		set tempc sprite[].htextra
		set temp tempc
		mul temp 3 div temp 4 
		ifl temp 1 set temp 1
		seta[].htextra temp
		ifl tempc 2 set tempc 2
		shiftl tempc 2
		sub burning tempc
	break
	
	case SHOTSPARK1
	case SABERPROJ
	case SAWPROJ
		findplayer xydist
		geta[].htowner spriteid
		// ife sprite[spriteid].picnum APLAYER
		ife spriteid player[].i
		ife player[].curr_weapon KNEE_WEAPON
		ifl xydist 1408
		{
			ife gotsaw YES
			ifn pchar 2
			{
				sub sawammo 1
				ifl sawammo 0 set sawammo 0
				ife sawammo 0
					state sawoff
				
				set TMP_A sprite[].htextra
				mul TMP_A 10
				div TMP_A inithp
				add stun TMP_A
				ifg stun 15 set stun 15
			}
			else
			{
				set saberdash 0
				
				ifg sprite[].htextra sprite[].extra
				ifrnd 64
				ifn sprite[].htpicnum HEADJIB1
				{
					seta[].htpicnum HEADJIB1
					ifg gotsaber 0 ifn pchar 2 
					{
						sub gotsaber 1
						set thirdbasetimer 6
					}
				}
				else
				ife thirdbasetimer 0 
				{ 
					ifg gotsaber 0 ifn pchar 2
					{
						sub gotsaber 1 
						set thirdbasetimer 6 // saber ammo usage timer
					}
				}
			}
		}
	break
	
	endswitch
	
	geta[].htowner spriteid
	ifn spriteid -1
	ifn monstatus 2
	ifn sprite[spriteid].picnum NAAMAH
	{
		ife team actorvar[spriteid].team 
		{
			setav[spriteid].myvictim -2
			// geta[].htextra temp ifg temp 1 { shiftr temp 1 seta[].htextra temp }
		}
		else
		setav[spriteid].myvictim THISACTOR
	}
	ifg sprite[].htextra 0 ifvarand perks 512 state wesperkcheck
}
else ifg blueiteration 0 sub blueiteration 1


state damagepushenemy

ifg burning 0 state imonfire
else ifl burning 0
{
	set temp sprite[].extra
	mul temp -1
	ifl burning temp
	{
		geta[].mdflags temp
		orvar temp 16
		seta[].mdflags temp
		changespritestat THISACTOR 2
		sleeptime 32767
	}
	add burning 1
	ifl burning -150 add burning 1
	ifge burning 0 { changespritestat THISACTOR 1 sleeptime 100 }
}

ifvarand monstflags 131072 // mimic
ifn monstatus 2
{
	add redbaseval 2
	
	ifactor SITH ife mtype 1 nullop else
	ifactor SYTH ife mtype 1 nullop else
	add redbaseval sprite[].htextra
	
	set tempb bluebaseval
	div tempb 3
	ifge redbaseval tempb
	ifn sprite[].pal 1
	ifl sprite[].htextra sprite[].extra
	ifg redbaseval 150
	{
		set picnum -1
		set B NO
		// ifp phigher set B YES
		iffloordistl 32 nullop else set B YES
		ife B NO
		{
			rand temp 37
			switch temp
			case 0 set picnum NEWTROOP break
			case 1 set picnum NEWPIG break
			case 2 set picnum LIZMAN break
			case 3 set picnum COMMANDER break
			case 4 set picnum NEWCOMM break
			case 5 set picnum SPACEBULL break
			case 6 set picnum NEWBEAST break
			case 7 set picnum LIZBOSS break
			case 8 set picnum PIGBOSS break
			case 9 set picnum OCTABRAIN break
			case 10 set picnum MEGABRAIN break
			case 11 set picnum TANK break
			case 12 set picnum NEWTROOPJETPACK break
			case 13 set picnum LIZRANGER break
			case 14 set picnum SYTH break
			case 15 set picnum SITH break
			case 16 set picnum NEWPIG break
			case 17 set picnum BOSS3 break
			case 18 set picnum QUEEN break
			case 19 set picnum ZOMBIE break
			case 20 set picnum ARMPIG break
			case 21 set picnum NEWSENTRY break
			case 22 set picnum CANHEAD break
			case 23 set picnum PSPIDER break
			case 24 set picnum ARMYANT break
			case 25 set picnum MANDOFETT break
			case 26 set picnum CYBERBEAST break
			case 27 set picnum TERMINATOR break
			case 28 set picnum SMALLMAN break
			case 29 set picnum NEWTROOP break
			case 30 set picnum LIZMAN break
			case 31 set picnum NEWBATLORD break
			case 32 set picnum LARGEMAN break
			case 33 set picnum MECHBRAIN break
			case 34 set picnum EDFPIG break
			case 35 set picnum DUKEBOT break
			case 36 set picnum SHELLY break
			case 37 set picnum CHEERBOT break
			endswitch
		}
		else
		{
			rand temp 10
			switch temp
			case 0 set picnum COMMANDER break
			case 1 set picnum NEWCOMM break
			case 2 set picnum LIZBOSS break
			case 3 set picnum OCTABRAIN break
			case 4 set picnum MEGABRAIN break
			case 5 set picnum NEWTROOPJETPACK break
			case 6 set picnum NEWSENTRY break
			case 7 set picnum MANDOFETT break
			case 8 set picnum ARMYANTJUMP break
			case 9 set picnum DUKEBOT break
			case 10 set picnum SHELLY break
			endswitch
		}
		ifactorsound THISACTOR SABERIDLE stopactorsound THISACTOR SABERIDLE
		set mid_spawn YES
		espawnvar picnum
		set mid_spawn NO
		setav[RETURN].spawnprotect 10
		setav[RETURN].initflags initflags
		setav[RETURN].monstflags monstflags
		setav[RETURN].mlevel plevel
		rand pal 17
		add pal 7
		seta[RETURN].pal pal
		ifg sprite[].htextra 0
		{
			set temp sprite[].extra
			sub temp sprite[].htextra
			seta[].extra temp
		}
		setav[RETURN].bluebaseval bluebaseval
		setav[RETURN].monxp monxp
		seta[RETURN].extra sprite[].extra
		setav[RETURN].redflagval sprite[].extra
		seta[RETURN].cstat 257
		setav[RETURN].monstatus -1
		seta[RETURN].statnum 1
		seta[RETURN].zvel sprite[].zvel
		setav[RETURN].burning burning
		set monstatus 2
		spawn AIRSHOCK
		killit
	}
	ifawayfromwall nullop else
	ifgapzl 128 ifnotmoving ifg sprite[].xrepeat 24
	{
		sizeto 24 24
		spawn FRAMEEFFECT1
	}
}

ife monstatus 1
ifp pfacing
ifl sprite[].cstat 32768
{
	ife scannedsprite THISACTOR
	{ set monid THISACTOR set monidtime 8 } 
	else
	{
		ife seeplayer YES
		ife seemytarget YES
		ifn team 3
		{
			ife monid -1 { set monid THISACTOR set monidtime 8 }
		}
	}
}

ifactor PIGSUV break
ifactor DUKEBOT break
ifactor DUKEBOTCROUCH break
ifactor SHELLY break
ifactor SHELLYCROUCH break
ifactor WESBOT break
ifactor WESBOTCROUCH break

ifn shrunken 0
{
  ife shrunken 10
  { 
	geta[].extra temp 
	div temp 3
	seta[].extra temp 
	geta[].mdflags temp, orvar temp 16, seta[].mdflags temp
  }
  ifg shrunken 31
  {
    ifl shrunken SHRUNKCOUNT
	{
		ifg sprite[].z player[].posz
		{
			ifpdistl SQUISHABLEDISTANCE
			ifn team 1 ifn team 3
			{
				ifactor DRONE { ife player[].knee_incs 0 setp[].knee_incs 1 setp[].actorsqu THISACTOR }
				else
				ifactor TANK { ife player[].knee_incs 0 setp[].knee_incs 1 setp[].actorsqu THISACTOR }
				else
				ifactor TERMINATOR { ife player[].knee_incs 0 setp[].knee_incs 1 setp[].actorsqu THISACTOR }
				else
				ifactor TERMINATORCRAWLING { ife player[].knee_incs 0 setp[].knee_incs 1 setp[].actorsqu THISACTOR }
				else
				ifactor CHEERBOT { ife player[].knee_incs 0 setp[].knee_incs 1 setp[].actorsqu THISACTOR }
				pstomp
			}
		}
		
		ife team 0 ife monstatus 1
		ifn myshelly -1 ifg sprite[myshelly].xrepeat 12
		{
			findnearactorz SHELLY 644 6144 spriteid
			ifn spriteid -1 { seta[].htpicnum RPG seta[].htextra 1000 seta[].htowner spriteid state spawn_crushed }
			else
			findnearactorz DUKEBOT 644 6144 spriteid
			ifn spriteid -1 { seta[].htpicnum RPG seta[].htextra 1000 seta[].htowner spriteid state spawn_crushed }
			else
			findnearactorz WESBOT 644 6144 spriteid
			ifn spriteid -1 { seta[].htpicnum RPG seta[].htextra 1000 seta[].htowner spriteid state spawn_crushed }
		}
		
		ifg sprite[].htextra 0 ifn sprite[].htpicnum FREEZEBLAST
		ifn sprite[].htpicnum SHRINKSPARK ifrnd 80 seta[].htpicnum RPG
	}
  }
  else
  {
    ifg sprite[].xrepeat 64 { sizeto MINXSTRETCH MINYSTRETCH }
	ifg sprite[].xrepeat 38 { sizeto MINXSTRETCH MINYSTRETCH }
	
	set temp tiledata[sprite[].picnum].ysize
	
    // ife upscaled YES
	ifg temp 95
	{
		ifg sprite[].xrepeat MINXUPSTRETCH spawn FRAMEEFFECT1
		sizeto MINXUPSTRETCH MINYUPSTRETCH
	}
	else
	{
		sizeto MINXSTRETCH MINYSTRETCH
		spawn FRAMEEFFECT1
	}
  }
  add shrunken 1
  ife shrunken SHRUNKCOUNT
  {
	geta[].extra temp
	mul temp 3
	seta[].extra temp
	sound UNSHRINK
  }
  ifg shrunken SHRUNKCOUNT
  {
    switch sprite[].picnum
	case OCTABRAIN ifvarand initflags 16 sizeto 36 32 else sizeto 24 22 break
	case PIGCOP sizeto 40 40 break
	case CHEERBOT
	case COMMANDER
	case NEWCOMM sizeto 30 28 break
	case ARMPIG case EDFPIG sizeto 26 24 break
	case FEMCIV case FEMCIVCROUCH case FEMCIV2 case FEMCIV2CROUCH case FEMCIV3 case FEMCIV3CROUCH
	case FEMCIV5 case FEMCIV5CROUCH
	case MALECIV1 case MALECIV1CROUCH case MALECIV2 case MALECIV2CROUCH 
	case MALECIV4 case MALECIV4CROUCH case MALECIV5 case MALECIV5CROUCH
	case MALECIV6 case MALECIV6CROUCH
	case NAKEDBABE case NAKEDBABECROUCH case SHOWERGIRL case GUARD case GUARDCROUCH
	case STRIPPER case STRIPPERCROUCH case KBABE case KBABECROUCH case CHEERLEADER
	case CAVEGIRL case CAVEGIRLCROUCH case BIKINIBABE case BIKINIBABE2
	case CRYSTAL case CHEERLEADERCROUCH case HOOKER case HOOKERCROUCH case POLEDANCER sizeto 28 26 break
	case TERMINATOR case TERMINATORDUCKING ifspritepal 57 sizeto 36 32 else sizeto 28 24 break
	case POLESTRIPPER case BLUEHANGBABE case NEWSLIMEBABE case NEWSLIMEBABE2 case SCUBAGIRL
	case LARRY case GARFIELD case ORCHID case CHUNLI case FEM12 case FEM13 case FEM14
	case FEM16 case FEM17 case FEM18 case FEM19 case FEM20 case FEM21 case BETTY
	case SLAVE1 case SLAVE2 case SLAVE3 case HELLONURSE
	sizeto 28 26 break
	case FEM11 sizeto 28 28 break
	case MECHBRAIN sizeto 40 38 break
	case SPACEBULL case SPACEBULLDUCKING sizeto 26 26 break
	case TANK { sizeto 60 60 sizeto 60 60 } break
	case RECON case NEWRECON case ARMYANT case ARMYANTCRAWL sizeto 24 24 break
	case SHARK sizeto 40 40 break
	case BOSS2 ifspritepal 0 { sizeto 80 64 sizeto 80 64 } else sizeto 40 32 break
	case BOSS1 case BOSS3 case BOSS4
	ifspritepal 0 { sizeto 128 128 sizeto 128 128 } else sizeto 40 40
	break
	case LIZRANGER case LIZRANGERDUCKING sizeto 30 28 break
	case LIZBOSS
		ifspritepal 0 sizeto 64 56 else sizeto 32 28 break
	case PIGBOSS ifspritepal 0 sizeto 66 60 else ifspritepal 42 sizeto 66 60 
		else sizeto 33 30
		break
	case EDFTROOP sizeto 25 22 break
	case EDFSNIPER case ZOMBIE case CRAZYLADY sizeto 28 26 break
	case CYBERBEAST sizeto 32 28 break
	case LIZELITE case LIZELITECROUCH sizeto 23 23 break
	case NEWTROOP case NEWTROOPDUCKING 
		sizeto 24 22
	break
	
	case NEWPIG case NEWPIGDIVE
		sizeto 28 26
	break
	
	case LIZMAN case ARMEDF case CORRUPT
		sizeto 28 26
	break
	case LIZDOG case MANDOFETT case MANDOCROUCH
		sizeto 26 24
	break
	case BATBOSS sizeto 32 30 break
	case NURGLE sizeto 32 28 break
	case NEWBATLORD ifspritepal 0 sizeto 96 80 else sizeto 48 40 break
	case QUEEN ifspritepal 0 sizeto 96 80 else sizeto 42 40 break
	case DEVOURER ifspritepal 19 sizeto 30 28 else sizeto 18 16 break
	default sizeto 40 40 break
	endswitch

	ifg shrunken SHRUNKDONECOUNT 
	{
		set shrunken 0 
		seta[].htpicnum SHOTSPARK1 
		ife upscaled YES
		{
			seta[].xrepeat init_xrepeat
			seta[].yrepeat init_yrepeat
		}
	}
  }
  geta[].xrepeat x mul x 3
  ifg sprite[].xvel x seta[].xvel x
  mul x -1
  ifl sprite[].xvel x seta[].xvel x
  ifl sprite[].zvel -64 seta[].zvel -64
}

ifactor NEWTROOPTARGET break
ifactor NEWPIGTARGET break
ifactor RECON break
// ifactor SHARK break
ifactor NEWRECON break
ifactor SITH ife mtype 1 break // blocking
ifactor SYTH ife mtype 1 break
ifactor DEANOVA ife mtype 1 break

set tempb YES
getp[].cursectnum temp
ifn temp -1
ife sector[temp].lotag 2
{
	set tempb NO
	ifinwater set tempb YES
}
ife monstatus 2 set tempb NO
ife monstatus 3 set tempb NO
ife team 3 set tempb NO
ife tempb YES
ife navmode 0
ifl bluetimer 30
{
	ife shrunken 0
	ife stun 0 ifl sprite[].htextra 1
	// ife player[].holoduke_on -1
	ifactornotstayput
	{
		ifg sprite[].xvel 0
		{
			ife seeplayer YES { iffloordistl 32 ifpdistg 8192 state crumbcode }
			else
			state crumbcode
		}
		else
		ifvarand monstflags YES
		{
			ife seeplayer YES { iffloordistl 32 ifpdistg 8192 state crumbcode }
			else
			state crumbcode
		}
	}
}

// ifn shellyinmap 0
// ife crumbwait 0
ife monstatus 1
ifn sprite[].picnum DRPROTON
ifn sprite[].picnum PSPIDER
ifn sprite[].picnum PSPIDERJUMPING
{

	// infighting trigger
	ife team 0 ifg sprite[].htextra 0
	ife gametype 0
	ifn sprite[].htowner -1
	{
		ifn sprite[sprite[].htowner].picnum TANK
		ife actorvar[sprite[].htowner].team 0
		{
			set temp NO
			ifge SKILL 4 { ifrnd 16 set temp YES } else { ifrnd 32 set temp YES }
			ife disable_infighting YES set temp NO
			ife temp YES
			{
				set bottarget sprite[].htowner
				set bluetimer 6
			}
		}
		else ifn bottarget -1
		ife team actorvar[bottarget].team
			set bottarget -1
	}
	
	state targetsearch
	ifactornotstayput 
	ife dodgetime 0
	ife padmove 0
	ifn sprite[].picnum ROTATEGUN
	ifn sprite[].picnum LIZTURRET ifn sprite[].picnum EDFTURRET
	ifn sprite[].picnum SIDEGUN
	{
		ifvarand monstflags YES
		state navigationsmart
		else
		state navigation
	}
	
	ifn bottarget -1
	{
		// distance management
		// ifmove STOPPED set dodgetime 0
		
		set temp NO
		ifl targetdist 512 set temp YES
		else
		ife targethigher YES
		{
			ldist tempb THISACTOR bottarget
			ifl tempb 844 set temp YES
		}
		ifvarand monstflags 1 set temp NO
		// ife team 0
		ife temp YES
		{
			ifmove STOPPED ifn bottarget player[].i 
			seta[].xvel -128
			// move BACKUP geth
		}
		// else
		// ifg targetdist 844 ifmove BACKUP move STOPPED geth
		
		ife dodgetime 0
		{
			// if an actor uses commands such as faceplayer, seekplayer, then
			// do NOT make them face a player target this way
			
			set temp YES
			
			ife bottarget player[].i 
			{
				set ptargeted 10
				switch sprite[].picnum
				case EDFTROOP case EDFTROOPCROUCH
				case EDFDRONE case NEWSENTRY case SIDEGUN
				case ARMEDF
				case SPACEBULL case SPACEBULLDUCKING
				case EDFSNIPER case EDFSNIPERCROUCH
				case LIZELITE case LIZELITECROUCH
				case MANDOFETT case MANDOCROUCH
				case NEWBOSS1
				case QUEEN
				case CYCLOIDMAX case FLYINGFIST
				// case LARGEMAN 
				case SMALLMAN	
				// case COMBINEDMEN
				case SCHOOLGIRL
					set temp YES
				break
				default 
					set temp NO
				break
				endswitch
			}
				
			ife temp YES
			{
				switch sprite[].picnum
				case EDFDRONE
				case NEWSENTRY
				// case SIDEGUN
				case COMBINEDMEN
				case LARGEMAN
				case NEWBOSS1
				case CYCLOIDMAX
				case FLYINGFIST 
				case QUEEN
					state turntotarget 
				break
				case EDFTANK case EDFTANKTURRET
				case BLACKHAWK
				break
				default
					geta[bottarget].x x
					geta[bottarget].y y
					sub x sprite[].x
					sub y sprite[].y
					getangle angvar x y
					seta[].ang angvar
				break
				endswitch
			}
		}
		
	}
	
}

	// ifmove BACKUP ifcount 20 move STOPPED geth

	ifn player[].holoduke_on -1
	ife monstatus 1
	ifn team actorvar[player[].i].team
	ifstrength 2000
	ifn gametype CTF ifn gametype CONTROL
	ifg sprite[].yvel 0
	{
		ifn bottarget -1 dist temp THISACTOR bottarget
		else dist temp THISACTOR player[].i
		dist tempc THISACTOR player[].holoduke_on
		ifvarvarl tempc temp
		{
			getp[].holoduke_on spriteid
			geta[].z z
			subvar z 8192
			seta[].z z
			geta[spriteid].z tempb
			subvar tempb 8192
			seta[spriteid].z tempb
			canseespr THISACTOR spriteid temp
			add z 8192
			seta[].z z
			add tempb 8192
			seta[spriteid].z tempb
			ife temp 1
			{
				ifl tempc 1024 ifg sprite[].xvel 0 seta[].xvel -40
				ifg tempc 512
				{
					geta[spriteid].x x
					geta[spriteid].y y
					sub x sprite[].x
					sub y sprite[].y
					getangle angvar x y
					seta[].ang angvar
					set bottarget player[].holoduke_on
					setav[player[].holoduke_on].monstatus 1
				}
				else seta[].ang lastang
				
			}
		}
		geta[].yvel temp, sub temp 1, ifl temp 0 set temp 0, seta[].yvel temp
		ife temp 0 ife bottarget player[].holoduke_on set bottarget -1
	}
	
	ifn bottarget -1
	{
		ifn bottarget player[].i
		{
			geta[].z z
			subvar z 8192
			
			
			ifle sprite[bottarget].z z set targethigher YES else set targethigher NO
			
			set seemytarget YES set shootmytarget YES
			dist targetdist THISACTOR bottarget
			ifn actorvar[bottarget].monstatus 2 set targetalive YES
			else set targetalive NO
		}
		else // player is target
		{
			geta[].z z
			subvar z 8192
			ifle sprite[player[].i].z z set targethigher YES else set targethigher NO
			
			// ifp phigher set targethigher YES else set targethigher NO
			
			// ife team actorvar[player[].i].team // player ally
			// {
				// set seemytarget NO
				// set shootmytarget NO
				// set targetdist 99999
				// set targetalive NO
			// }
			// else
			// ife actorvar[player[].i].team 3 // neutral team
			// {
				// set seemytarget NO
				// set shootmytarget NO
				// set targetdist 99999
				// set targetalive NO
			// }
			// else
			// {
				// ifcansee 
				set seemytarget YES 
				// ifcanshoottarget 
				set shootmytarget YES
				findplayer targetdist
				ifp pshrunk set targetalive YES else ifp palive set targetalive YES
				else set targetalive NO
			// }
		}
	}

	else
	{
		getav[player[].i].team tempc

		ife team tempc
		{
			set seemytarget NO
			set shootmytarget NO
			set targetdist 99999
			set targetalive NO
		}
		else
		{
			ifvarand monstflags YES set temp YES else set temp NO
			
			ifg navpoint -1
			ife temp NO
			{
				// don't force player as target if the actor is using a navigation point
				set seemytarget NO
				set shootmytarget NO
				set targetdist 99999
				set targetalive NO
			}
			else
			{
				findplayer targetdist
				// ife seeplayer YES ifcanshoottarget ifl targetdist MAXRANGE
				// {
					// ifp phigher set targethigher YES else set targethigher NO
					// set seemytarget YES 
					// set shootmytarget YES
					// ifp pshrunk set targetalive YES else
					// ifp palive set targetalive YES else set targetalive NO
					// ife targetalive YES set bottarget player[].i
				// }
				// else
				// {
					set seemytarget NO
					set shootmytarget NO
					// set targetdist 999999
					// set targetalive NO
					ifp palive set targetalive YES else set targetalive NO
				// }
				ifge sprite[].picnum BOSS2 ifle sprite[].picnum BOSS3
				ife seeplayer YES ifcanshoottarget ifl targetdist MAXRANGE
				{
					ifp phigher set targethigher YES else set targethigher NO
					set seemytarget YES 
					set shootmytarget YES
					ifp pshrunk set targetalive YES
					ife targetalive YES set bottarget player[].i
				}
			}
		}

	}

	ifn monstatus 2
	state avoidwater
	
	geta[].ang lastang

ends

defstate jib_sounds
  set spriteid sprite[].htowner
  ife spriteid -1 set spriteid player[].i
  ife spriteid player[].i
  ifrnd SWEARFREQUENCY
  {
    ife pchar 1
	{
		ife VOLUME 6 ifl LEVEL 11 rand temp 18
		else
		rand temp 15
		add temp 1
		ife temp 1 globalsound B_JIB1
		ife temp 2 globalsound B_JIB2
		ife temp 3 globalsound B_JIB3
		ife temp 4 globalsound B_JIB4
		ife temp 5 globalsound B_JIB5
		ife temp 6 globalsound B_JIB6
		ife temp 7 globalsound B_JIB7
		ife temp 8 globalsound B_JIB8
		ife temp 9 globalsound B_JIB9
		ife temp 10 globalsound B_IMGOOD
		ife temp 11 globalsound B_SUCKIT
		ife temp 12 globalsound B_NEVERGETSOLD
		ife temp 13 globalsound B_RIP
		ife temp 14 globalsound B_WHOSENEXT
		ife temp 15 globalsound B_SURGERY
		ife temp 16 globalsound B_SUCKA
		// VACA JIBS
		ife temp 17 globalsound B_BAIT
		ife temp 18 globalsound B_FISHFOOD
		ife temp 19 globalsound B_ONTHEHOUSE
	}
	else
	ife pchar 2
	{
		rand temp 14
		ife temp 0 globalsound WESSTAYDOWN
		ife temp 1 globalsound WESGETTINGFUN
		ife temp 2 globalsound WESARMYOFME
		ife temp 3 globalsound WESAWWYEAH
		ife temp 4 globalsound WESBEATDOWN
		ife temp 5 globalsound WESBIOHAZARD
		ife temp 6 globalsound WESDOTHISALLDAY
		ife temp 7 globalsound WESFOOLS
		ife temp 8 globalsound WESHOLYSHIT
		ife temp 9 globalsound WESMADEPOINT
		ife temp 10 globalsound WESMESSY
		ife temp 11 globalsound WESWANTSOMEOFME
		ife temp 12 globalsound WESYEAHBITCH
		ife temp 13 globalsound WESOHSMACK
		ife temp 14 globalsound WESIMONFIRE
	}
	else
	{
		ife VOLUME 6 ifl LEVEL 11 rand temp 18
		else
		rand temp 15
		add temp 1
		ife temp 1 globalsound JIBBED_ACTOR12
		ife temp 2 globalsound JIBBED_ACTOR1
		ife temp 3 globalsound JIBBED_ACTOR9
		ife temp 4 globalsound JIBBED_ACTOR14
		ife temp 5 globalsound SMACKED
		ife temp 6 globalsound JIBBED_ACTOR2
		ife temp 7 globalsound MDEVSPEECH
		ife temp 8 globalsound JIBBED_ACTOR5
		ife temp 9 globalsound JIBBED_ACTOR11
		ife temp 10 globalsound JIBBED_ACTOR13
		ife temp 11 globalsound JIBBED_ACTOR3
		ife temp 12 globalsound JIBBED_ACTOR8
		ife temp 13 globalsound JIBBED_ACTOR6
		ife temp 14 globalsound JIBBED_ACTOR4
		ife temp 14 globalsound JIBBED_ACTOR10
		ife temp 15 globalsound JIBBED_ACTOR15
		ife temp 16 globalsound JIBBED_ACTOR7
		// DUKE VACA JIBS
		ife temp 17 globalsound D_BAIT
		ife temp 18 globalsound D_FISHFOOD
		ife temp 19 globalsound D_ONTHEHOUSE
	}
  }

	
ends

defstate troop_body_jibs

	ifl sprite[].yrepeat 12 break

	ifspritepal 1
    guts HEADJIB1 1
	else
	{
	  rand zdist 1024
	  sub zdist 3500
	  ife upscaled YES 
	  { 
		  setprojectile[TROOPHEADPROJ].xrepeat init_xrepeat 
		  setprojectile[TROOPHEADPROJ].yrepeat init_yrepeat 
	  }
	  ifactor NEWTROOP ezshoot zdist NEWTROOPHEADPROJ
	  else
	  ezshoot zdist TROOPHEADPROJ
	  ife upscaled YES { seta[RETURN].xrepeat init_xrepeat seta[RETURN].yrepeat init_yrepeat }
	  rand angvar 512
	  sub angvar 256
	  add angvar sprite[].htang
	  seta[RETURN].ang angvar
	  seta[RETURN].pal sprite[].pal
	}

    guts LEGJIB1 2

    guts ARMJIB1 1
  ifrnd 48
  ife shrunken 0
  {
    ifspritepal 1 spawn BLOODPOOL else
    spawn BLOODPOOL2
  }
ends

defstate liz_body_jibs

	ifl sprite[].yrepeat 12 break

	ifspritepal 1
    guts LIZMANHEAD1 1
	else
	{
	  rand zdist 1024
	  sub zdist 3500
	  ezshoot zdist LIZHEADPROJ
	  ife upscaled YES { seta[RETURN].xrepeat init_xrepeat seta[RETURN].yrepeat init_yrepeat }
	  rand angvar 512
	  sub angvar 256
	  add angvar sprite[].htang
	  seta[RETURN].ang angvar
	  seta[RETURN].pal sprite[].pal
	}

    guts LIZMANLEG1 2

    guts LIZMANARM1 1
  ifrnd 48
  ife shrunken 0
  {
    ifspritepal 1 spawn BLOODPOOL else
    spawn BLOODPOOL2
  }
ends

defstate ranger_body_jibs


	ifl sprite[].yrepeat 12 break

	rand zdist 1024
	sub zdist 3500
	ezshoot zdist RANGERHEADPROJ
	rand angvar 512
	sub angvar 256
	add angvar sprite[].htang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist RANGERLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist RANGERARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist RANGERARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132

ends

defstate comm_body_jibs

	ifl sprite[].yrepeat 12 break
	
	rand zdist 1024
	sub zdist 3500
	ifactor NEWCOMM ezshoot zdist NEWCOMMHEADPROJ
	else
	ezshoot zdist COMMHEADPROJ
	rand angvar 512
	sub angvar 256
	add angvar sprite[].htang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist COMMARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist COMMARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132
ends

defstate pig_body_jibs

	ifl sprite[].yrepeat 12 break
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist PIGHEADPROJ
	rand angvar 512
	sub angvar 256
	add angvar sprite[].htang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist PIGLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist PIGLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist PIGARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist PIGARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132

ends

defstate armpig_body_jibs

	ifl sprite[].yrepeat 12 break

	ife B YES
	{
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist PIGHEADPROJ
	rand angvar 512
	sub angvar 256
	add angvar sprite[].htang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	}
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist ARMPIGFOOTPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist ARMPIGLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist ARMPIGARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	ifn mtype 987
	{
		rand zdist 1024
		sub zdist 3500
		ezshoot zdist ARMPIGARMPROJ
		rand angvar 2047
		seta[RETURN].ang angvar
		seta[RETURN].pal sprite[].pal
		seta[RETURN].cstat 132
	}

ends

defstate bull_body_jibs

	ifl sprite[].yrepeat 12 break

	ife B YES
	{
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BULLHEADPROJ
	rand angvar 512
	sub angvar 256
	add angvar sprite[].htang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	}
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BULLARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BULLLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BULLLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	

ends

defstate bigboi_body_jibs

	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BBHEADJIBPROJ
	rand angvar 512
	sub angvar 256
	add angvar sprite[].htang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal

	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BBARMJIBPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BBARMJIBPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BBLEGJIBPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BBLEGJIBPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal

ends

defstate beast_armslegs

	ifl sprite[].yrepeat 12 break

	rand angvar 512
	sub angvar 256
	add angvar sprite[].htang
	seta[RETURN].ang angvar
	ifactor CYBERBEAST ifspritepal 24 seta[RETURN].pal 21 else
	ifspritepal 0 seta[RETURN].pal 15 else
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BEASTLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	ifactor CYBERBEAST ifspritepal 24 seta[RETURN].pal 21 else
	ifspritepal 0 seta[RETURN].pal 15 else
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BEASTLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	ifactor CYBERBEAST ifspritepal 24 seta[RETURN].pal 21 else
	ifspritepal 0 seta[RETURN].pal 15 else
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BEASTARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	ifactor CYBERBEAST ifspritepal 24 seta[RETURN].pal 21 else
	ifspritepal 0 seta[RETURN].pal 15 else
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BEASTARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	ifactor CYBERBEAST ifspritepal 24 seta[RETURN].pal 21 else
	ifspritepal 0 seta[RETURN].pal 15 else
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132

ends

defstate beast_body_jibs

	ifl sprite[].yrepeat 12 break

	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BEASTHEADPROJ
	ifactor NEWBEAST
	ifspritepal 0 seta[RETURN].pal 15 else
	seta[RETURN].pal sprite[].pal
	state beast_armslegs

ends

defstate arrow_bits

	rand zdist 1024
	sub zdist 3072
	ezshoot zdist ARROWBIT1
	rand angvar 1024
	add angvar 512
	add angvar sprite[].ang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3072
	ezshoot zdist ARROWBIT2
	rand angvar 1024
	add angvar 512
	add angvar sprite[].ang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3072
	ezshoot zdist ARROWBIT3
	rand angvar 1024
	add angvar 512
	add angvar sprite[].ang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal

ends

defstate sawblade_bits

	rand zdist 1024
	sub zdist 3072
	ezshoot zdist ARROWBIT1
	rand angvar 1024
	add angvar 512
	add angvar sprite[].ang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3072
	ezshoot zdist ARROWBIT1
	rand angvar 1024
	add angvar 512
	add angvar sprite[].ang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	debris SCRAP6 4

ends

defstate randgetweapsnds
  ife VOLUME 6 ifl LEVEL 11 rand temp 18
  else
  rand temp 12
  switch temp
  case 0 globalsound BIGGUNS break
  case 1 case 2 globalsound DUKE_GETWEAPON2 break
  case 3 case 4 globalsound DUKE_GETWEAPON3 break
  case 5 case 6 globalsound DUKE_GETWEAPON4 break
  case 7 case 8 globalsound DUKE_GETWEAPON5 break
  case 9 case 10 globalsound DUKE_GETWEAPON1 break
  case 11 case 12 globalsound DUKE_GETWEAPON6 break
  case 13 case 14 globalsound VACA_GETWEAP1 break
  case 15 case 16 globalsound VACA_GETWEAP2 break
  case 17 case 18 globalsound VACA_GETWEAP3 break
  endswitch
ends

defstate standard_jibs

  ife padang 1337 { state spawnoutline break }

  guts JIBS2 1
  guts JIBS3 2
  guts JIBS4 3
  guts JIBS5 2
  guts JIBS6 3
  ifrnd 6
  {
    guts JIBS1 1
    ifspritepal 1 spawn BLOODPOOL else
    spawn BLOODPOOL2
  
  }         // a badly drawn spine

  ifn team 3
  ifn team 1
  state jib_sounds
ends

defstate lite_jibs

  ife padang 1337 { state spawnoutline break }

  guts JIBS2 1
  guts JIBS3 1
  guts JIBS4 2
  guts JIBS5 1
  guts JIBS6 2
  ifrnd 6
  {
    guts JIBS1 1
    ifspritepal 1 spawn BLOODPOOL else
    spawn BLOODPOOL2
  }

  state jib_sounds
ends

defstate standard_pjibs
  guts JIBS1 1
  guts JIBS3 2
  guts JIBS4 1
  guts JIBS5 1
  guts JIBS6 2
  guts DUKETORSO 1
  guts DUKELEG 2
  guts DUKEGUN 1
  ife gametype 0 ifrnd 16 money 1
ends

defstate tech_debris

	rand zdist 844
	sub zdist 2560
	ezshoot zdist MECHDEBRIS1
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	
	set zdist sprite[].xrepeat
	set temp tiledata[sprite[].picnum].xsize
	add temp tiledata[sprite[].picnum].ysize
	mul zdist temp
	shiftr zdist 8
	sub zdist 4
	ifl zdist 9 set zdist 9, ifg zdist 255 set zdist 255
	seta[RETURN].xrepeat zdist
	seta[RETURN].yrepeat zdist
	
	rand zdist 844
	sub zdist 2560
	ezshoot zdist MECHDEBRIS2
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	
	set zdist sprite[].xrepeat
	set temp  tiledata[sprite[].picnum].xsize
	add temp tiledata[sprite[].picnum].ysize
	mul zdist temp
	shiftr zdist 8
	sub zdist 4
	ifl zdist 9 set zdist 9, ifg zdist 255 set zdist 255
	seta[RETURN].xrepeat zdist
	seta[RETURN].yrepeat zdist
	
	rand zdist 644
	sub zdist 768
	ezshoot zdist MECHDEBRIS3
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	
	set zdist sprite[].xrepeat
	set temp  tiledata[sprite[].picnum].xsize
	add temp tiledata[sprite[].picnum].ysize
	mul zdist temp
	shiftr zdist 9
	sub zdist 2
	ifl zdist 7 set zdist 7, ifg zdist 255 set zdist 255
	seta[RETURN].xrepeat zdist
	seta[RETURN].yrepeat zdist
	
	rand zdist 644
	sub zdist 768
	ezshoot zdist MECHDEBRIS3
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	
	set zdist sprite[].xrepeat
	set temp tiledata[sprite[].picnum].xsize
	add temp tiledata[sprite[].picnum].ysize
	mul zdist temp
	// shiftr zdist 9
	div zdist 768
	sub zdist 2
	ifl zdist 7 set zdist 7, ifg zdist 255 set zdist 255
	seta[RETURN].xrepeat zdist
	seta[RETURN].yrepeat zdist
ends

defstate wood_debris

	rand zdist 844
	sub zdist 2560
	ezshoot zdist WOODDEBRIS
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	
	rand zdist 844
	sub zdist 2560
	ezshoot zdist WOODDEBRIS
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	
	rand zdist 844
	sub zdist 2560
	ezshoot zdist WOODDEBRIS
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	
	rand zdist 844
	sub zdist 2560
	ezshoot zdist WOODDEBRIS
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140

ends

defstate pottery_debris

	rand zdist 844
	sub zdist 2560
	ezshoot zdist POTDEBRIS1
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	seta[RETURN].pal sprite[].pal
	seta[RETURN].alpha sprite[].alpha
	
	rand zdist 844
	sub zdist 2560
	ezshoot zdist POTDEBRIS2
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	seta[RETURN].pal sprite[].pal
	seta[RETURN].alpha sprite[].alpha
	
	rand zdist 844
	sub zdist 2560
	ezshoot zdist POTDEBRIS3
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	seta[RETURN].pal sprite[].pal
	seta[RETURN].alpha sprite[].alpha
	
	rand zdist 844
	sub zdist 2560
	ezshoot zdist POTDEBRIS4
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	seta[RETURN].pal sprite[].pal
	seta[RETURN].alpha sprite[].alpha
	
	rand zdist 844
	sub zdist 2048
	ezshoot zdist POTDEBRIS1
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	seta[RETURN].pal sprite[].pal
	seta[RETURN].alpha sprite[].alpha
	
	rand zdist 844
	sub zdist 2048
	ezshoot zdist POTDEBRIS2
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	seta[RETURN].pal sprite[].pal
	seta[RETURN].alpha sprite[].alpha
	
	rand zdist 844
	sub zdist 2048
	ezshoot zdist POTDEBRIS3
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	seta[RETURN].pal sprite[].pal
	seta[RETURN].alpha sprite[].alpha
	
	rand zdist 844
	sub zdist 2048
	ezshoot zdist POTDEBRIS4
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	seta[RETURN].pal sprite[].pal
	seta[RETURN].alpha sprite[].alpha

ends

defstate splatcode
	ifmove 0
	{
		geta[].ang angvar
		add angvar 1024
		seta[].ang angvar
		move STOPPED
		ifactor CRUSHANT sizeat 6 6 else
		ifactor CRUSHOCTABRAIN sizeat 2 2 else
		ifactor CRUSHLIZDOG sizeat 5 5 else
		ifactor CRUSHMECHBRAIN sizeat 5 5 else
		sizeat 4 4
		cstat 32
		cstator 256
		strength 10
		ifn sector[].floorslope 0 killit
	}
	fall
	ifhitweapon
	{
		ifdead { guts JIBS6 6 screensound SQUISHED killit }
		else guts JIBS6 2
		
	}
	ifcount 2 ifn myspawner -1 ife sprite[myspawner].statnum 1
	ife actorvar[myspawner].monstatus 1 killit
ends

// ARCBTRAILFRAMES is just -1

useractor notenemy FANACTIVATE 0 ANULLACTION

	ife mtype 1
	{
		ifaction ANULLACTION action ARCBTRAILFRAMES
		ifactorsound THISACTOR FANSOUND nullop else sound FANSOUND
	}
	else
	{
		ifaction ARCBTRAILFRAMES action ANULLACTION
		ifactorsound THISACTOR FANSOUND stopactorsound THISACTOR FANSOUND
	}

enda

useractor notenemy ICESPRITE 0

ifvarn myspawner -1
{
	ifvarn sprite[myspawner].pal 1 spritepal 1
	ifvarvarn sprite[myspawner].picnum mtype spritepal 1
	ife actorvar[myspawner].monstatus 2 spritepal 1
	ife sprite[myspawner].statnum 1024 spritepal 1
	ifspritepal 1
	{
		sound GLASS_BREAKING
		lotsofglass 10
		seta[].alpha 64
		state pottery_debris
		state pottery_debris
		state pottery_debris
		killit
	}
	ife initsprite 0
	{
		seta[].mdflags 16
		cstat 514
		ifrnd 128 cstator 4
		ifvarand sprite[myspawner].cstat 128 cstator 128
		set initsprite 1
		
		set y tiledata[mtype].yoffset
		seta[].yoffset y
		
		set x tiledata[mtype].ysize
		mul x sprite[myspawner].yrepeat
		div x 96
		seta[].yrepeat x
		
		set x tiledata[mtype].xsize
		mul x sprite[myspawner].xrepeat
		div x 96
		add x 4
		seta[].xrepeat x
		// switch mtype
		// case LIZTROOP sizeat 26 32 break
		// case NEWPIG case NEWPIGDIVE
		// case PIGCOP case PIGCOPDIVE case LIZMAN sizeat 28 32
		// case COMMANDER case NEWCOMM case ARMPIG case SPACEBULL sizeat 36 32 break
		// case MEGABRAIN case DRPROTON sizeat 40 48 break
		// case MECHBRAIN sizeat 40 38 break
		// case BOSS1 case BOSS2 case BOSS3 case BOSS4 case PIGBOSS case LIZBOSS sizeat 42 40 break
		// case PSPIDER sizeat 72 40 break
		// case GARFIELD sizeat 22 16 break
		// default sizeat 26 32 break
		// endswitch

	}
	geta[myspawner].z z
	add z 1024
	ife sprite[myspawner].picnum MEGABRAIN sub z 1024
	seta[].z z
}
enda

useractor notenemy CRUSHARMPIG 20 state splatcode enda
useractor notenemy CRUSHLIZELITE 20 state splatcode enda
useractor notenemy CRUSHNEWBEAST 20 state splatcode enda
useractor notenemy CRUSHMECHBRAIN 20 state splatcode enda
useractor notenemy CRUSHLIZMAN 20 state splatcode enda
useractor notenemy CRUSHCOMMANDER 20 state splatcode enda
useractor notenemy CRUSHOCTABRAIN 20 state splatcode enda
useractor notenemy CRUSHLIZRANGER 20 state splatcode enda
useractor notenemy CRUSHSPACEBULL 20 state splatcode enda
useractor notenemy CRUSHPIGCOP 20 state splatcode enda
useractor notenemy CRUSHLIZTROOP 20 state splatcode enda
useractor notenemy CRUSHANT 20 state splatcode enda
useractor notenemy CRUSHZOMBIE 20 state splatcode enda
useractor notenemy CRUSHBATLORD 20 state splatcode enda
useractor notenemy CRUSHLIZDOG 20 state splatcode enda

action ASABDETH1	 0  1  1  1  50
action ASABDETH2_6	 1  6  1  1  18
action ASABDETH2_5   1  5  1  1  18
action ASABDED_6  	 6  1  1  1  10
action ASABDED_5  	 5  1  1  1  10

state sabdethcode

	fall
	ifmove 0
	{
		move STOPPED
		cstator 256
		seta[].htflags 8388611
		getp[].max_actors_killed temp
		sub temp 1
		setp[].max_actors_killed temp
	}
	set temp NO
	ifaction ASABDED_6 set temp YES
	ifaction ASABDED_5 set temp YES
	ife temp YES
	{
		state predamage
		ifhitweapon
		{
			strength 0
			set temp NO
			ifwasweapon RADIUSEXPLOSION set temp YES
			ifwasweapon RPG set temp YES
			ife temp YES
			{
				sound SQUISHED
				state standard_jibs
				killit
			}	
		}
		break
	}
	ifaction ASABDETH1
	{
		ifactioncount 1
		{
			ife countvar 6 action ASABDETH2_6 else
			ife countvar 5 action ASABDETH2_5
			ifhitweapon { } strength 0
		}
		break
	}
	ifaction ASABDETH2_5 ifactioncount 5 { sound THUD action ASABDED_5 } else
	ifaction ASABDETH2_6 ifactioncount 6 { sound THUD action ASABDED_6 }

ends

useractor enemy NEWTSABERDEATH 0 ASABDETH1 set countvar 6 state sabdethcode enda
useractor enemy LIZMANSABERDEATH 0 ASABDETH1 set countvar 6 state sabdethcode enda
useractor enemy NEWPIGSABERDEATH 0 ASABDETH1 set countvar 6 state sabdethcode enda
useractor enemy DEASABERDEATH 0 ASABDETH1 set countvar 5 state sabdethcode enda
useractor enemy MANDOSABERDEATH 0 ASABDETH1 set countvar 5 state sabdethcode enda
useractor enemy SYTHSABERDEATH 0 ASABDETH1 set countvar 5 state sabdethcode enda
useractor enemy SITHSABERDEATH 0 ASABDETH1 set countvar 5 state sabdethcode enda

defstate genericshrunkcode

  
  ifcount SHRUNKMINUSONE sound UNSHRINK
  ifcount 32
  {
    ifpdistl SQUISHABLEDISTANCE
	{
		ifn team 1 ifn team 3
		{
			pstomp
			ifactor STRIPPER
			ifn initsprite 0
			{
				seta[].hitag initsprite
				respawnhitag
				set initsprite 0
			}
			ifactor HOOKER
			ifn initsprite 0
			{
				seta[].hitag initsprite
				respawnhitag
				set initsprite 0
			}
			ifactor KBABE
			ifn initsprite 0
			{
				seta[].hitag initsprite
				respawnhitag
				set initsprite 0
			}
			ifactor CAVEGIRL
			ifn initsprite 0
			{
				seta[].hitag initsprite
				respawnhitag
				set initsprite 0
			}
			ifactor POLEDANCER
			ifn initsprite 0
			{
				seta[].hitag initsprite
				respawnhitag
				set initsprite 0
			}
			ifactor NAKEDBABE
			ifn initsprite 0
			{
				seta[].hitag initsprite
				respawnhitag
				set initsprite 0
			}
		}
	}
	else ife team 0 ife monstatus 1
	{
		findnearactorz SHELLY 644 6144 spriteid
		ifn spriteid -1 ifg sprite[spriteid].xrepeat 12 { seta[].htpicnum RPG seta[].htextra 1000 seta[].htowner spriteid }
		else
		findnearactorz DUKEBOT 644 6144 spriteid
		ifn spriteid -1 ifg sprite[spriteid].xrepeat 12 { seta[].htpicnum RPG seta[].htextra 1000 seta[].htowner spriteid }
		else
		findnearactorz DEANOVA 644 6144 spriteid
		ifn spriteid -1 ifg sprite[spriteid].xrepeat 12 { seta[].htpicnum RPG seta[].htextra 1000 seta[].htowner spriteid }
		else
		findnearactorz WESBOT 644 6144 spriteid
		ifn spriteid -1 ifg sprite[spriteid].xrepeat 12 { seta[].htpicnum RPG seta[].htextra 1000 seta[].htowner spriteid }
	}
  }
  else
  {
    ifg sprite[].xrepeat 64 { sizeto MINXSTRETCH MINYSTRETCH }
	ifg sprite[].xrepeat 40 { sizeto MINXSTRETCH MINYSTRETCH }
	
	ife upscaled YES
	{
		sizeto MINXUPSTRETCH MINYUPSTRETCH
	}
	else
    sizeto MINXSTRETCH MINYSTRETCH
    spawn FRAMEEFFECT1
  }
ends

defstate spawnbabe
	globalsound NEWBABE
	espawn TRANSPORTERSTAR 
	seta[RETURN].cstat 32768 
	seta[RETURN].pal 91
	rand B 24
	switch B
	case 0 set B FEMCIV break
	case 1 set B FEMCIV2 break
	case 2 set B STRIPPER break
	case 3 case 4 set B KBABE break
	// case 4 set B HOOKER break
	case 5 set B CHEERLEADER break
	case 6 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B MALECIV1
	break
	case 7 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B MALECIV2 
	break
	case 8 set B CAVEGIRL break
	case 9 set B BIKINIBABE break
	case 10 set B BIKINIBABE2 break
	case 11 case 12 set B NAKEDBABE break
	case 13 set B CRYSTAL break
	case 14 set B FEMCIV3 break
	case 15 set B SCHOOLGIRL break
	case 16 set B FEMCIV4 break
	case 17 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B ALIENCIVFEM break
	case 18 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B ALIENCIVMALE break
	case 19 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B MALECIV3 break
	case 20 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B GUARD break
	case 21 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B HOOKER2 break
	case 22 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B MALECIV4 break
	case 23 set B FEMCIV5 break
	case 24 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B MALECIV5 break
	endswitch
	
	ifactor ARMYANT set B ANT
	ifactor ARMYANTCRAWL set B ANT
	espawnvar B
	ife B ANT espawn MALECIV3
	rand pal 13
	add pal 10
	ife pal 17 set pal 0 else
	ife pal 19 set pal 0 else
	ife pal 20 set pal 0
	set temp NO
	ife pchar 0 ifvarand dukeupgrades[GROW_WEAPON] 1 set temp YES
	ife pchar 1 ifvarand shellyupgrades[GROW_WEAPON] 1 set temp YES
	ife temp YES
	{
		set pal 49
		setav[RETURN].monstflags 8192
		setav[RETURN].inithp 100
	}
	seta[RETURN].pal pal
	setav[RETURN].teamspawned 99999
ends

defstate makeally

	ife gametype 0
	{
	globalsound NEWBABE
	espawn TRANSPORTERSTAR 
	seta[RETURN].cstat 32768 
	seta[RETURN].pal 91
	
	ai 0
	move 0
	action 0
	cstator 256
	getlastpal
	spritepal 85
	set monxp 0
	seta[].extra inithp
	set monstatus 1
	set team 1
	set botclip 0
	set countvar 0
	set countvarb 0
	set countvarc 0
	set myspawner -1
	set myvictim -1
	set bottarget -1
	set initsprite 0
	set stun 0
	set burning 0
	set bleeding 0
	set bluetimer 0
	set FEMKILLCOUNT 2400
	ifactor SITH set mtype 0
	ifactor SYTH set mtype 0
	ifactor EGG sizeat 40 40
	ifactor RECON sizeat 24 24
	ifactor COMMANDER sizeat 30 28
	set startx 0
	set shotpitch 0
	ifvarand monstflags 131072 xorvar monstflags 131072
	}
	else
	{
		sound NUKESOUND
		setactorsoundpitch THISACTOR NUKESOUND 512
		
		hitradius 5120 50 80 110 150
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			dist temp THISACTOR spriteid
			ifle temp 5120 seta[spriteid].htowner player[].i
			nextspritestat spriteid spriteid
		}
		espawn EXPLOSION2
		setav[RETURN].mtype BOMBSECTOR
		killit
	}
	

ends

defstate genericgrowcode

  ifl burning 0 set burning 0
  ifcount 32
  {
    guts JIBS4 2
    guts JIBS6 4
	//state standard_jibs
	//ifactor LIZTROOP state troop_body_jibs
	//ifactor LIZMAN state liz_body_jibs
	//ifactor NEWBEAST state liz_body_jibs
	ifn team 1 ifn team 3
		addkills 1 
	state enemy_death
	
    sound SQUISHED
    // sound PIPEBOMB_EXPLODE
    hitradius 2048 30 35 40 45
	headspritestat spriteid 1
	whilevarn spriteid -1
	{
		ife actorvar[spriteid].team 3
		{
			dist xydist THISACTOR spriteid
			ifle xydist 2048 seta[spriteid].htextra -1
		}
		ife sprite[spriteid].picnum SCHOOLGIRL seta[spriteid].htextra -1
		nextspritestat spriteid spriteid
	}
	set temp NO
	ife pchar 0 ifvarand dukeupgrades[GROW_WEAPON] 2 set temp YES else
	ife pchar 1 ifvarand shellyupgrades[GROW_WEAPON] 2 set temp YES
	ife temp YES ifn team 1 ifn team 3 state makeally else
	{
		state spawnbabe
		killit
	}
  }
  else
  {
    ifcount 3 nullop else ifcount 2 
	{ 
		espawn GROUNDSHOCK 
		seta[RETURN].pal 49
	}
    ifspritepal 91 getlastpal else
	spritepal 91
	
    ifactor COMMANDER
	{
	  // ife upscaled YES sizeto 80 50 else
      sizeto 160 100
	}
    else
      ifactor SHARK
	{
	  // ife upscaled YES sizeto 42 42 else
        sizeto 84 84
	}
    else
	{
	  // ife upscaled YES sizeto 64 64 else
	  sizeto 128 MAXYSTRETCH
      // sizeto MAXXSTRETCH MAXYSTRETCH
	}
	geta[].xrepeat init_xrepeat
	geta[].yrepeat init_yrepeat
  }
ends

useractor notenemy MONSHADOW 0

	set temp player[].player_par
	add temp THISACTOR
	modvar temp 30
	ife temp 0
	{
		espawn BIGSMOKE2
		seta[RETURN].htflags 4
		seta[RETURN].shade 28
	}
	ife damflash 4 ife player[].heat_on YES cstat 258 else
	{ cstat 2 seta[].htextra -1 }

	ifg damflash 4 sub damflash 1
	
	cos xvel sprite[].ang
	sin yvel sprite[].ang
		  
	shiftr xvel 6
	shiftr yvel 6
	
	espawn SPEEDBLUR
	setav[RETURN].mtype sprite[].htdispicnum
	seta[RETURN].xrepeat sprite[].xrepeat
	seta[RETURN].yrepeat 4
	seta[RETURN].pal 4
	seta[RETURN].alpha 160
	seta[RETURN].mdflags 16
		 
	ifactornotstayput
	{
		movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN
		ifn RETURN 0 { rand angvar 2047 seta[].ang angvar }
		else ifrnd 4 { rand angvar 2047 seta[].ang angvar }
	}
	ife damflash 4
	{
		ifrnd 2
		{
			sound FLAMEDRAWIN
			seta[].picnum mysignpost
			cstat 257
		}
		else ifpdistl 2048
		ifrnd 6
		{
			sound FLAMEDRAWIN
			seta[].picnum mysignpost
			cstat 257
		}
		else ifhitweapon
		{
			sound FLAMEDRAWIN
			seta[].picnum mysignpost
			cstat 257
		}
	}

enda

action ASHARKCRUZING 0 8 5 1 24
action ASHARKFLEE  0 8 5 1 10
action ASHARKATACK   0 8 5 1 6
action ASHARKSHRUNK  0 8 5 1 24
action ASHARKGROW  0 8 5 1 24
action ASHARKFROZEN  0 1 5 1 24

action ASHARKDYING 7866 4 1 1 24
action ASHARKDEAD 7869  1  1  1  1
move SHARKVELS 24
move SHARKFASTVELS 72
move SHARKFLEEVELS 40

actor SHARK SHARKSTRENGTH ASHARKCRUZING SHARKVELS randomangle geth
  ifaction 0 { action ASHARKCRUZING sizeat 40 40 }
  ifinwater
  {
	  ife initsprite NO 
	  {
		geta[].x startx
		geta[].y starty
		set initsprite YES
	  }
  }
  else
  {
	ife initsprite YES
	{
		setsprite THISACTOR startx starty sprite[].z
	}
  }
  ifaction ASHARKDYING
  {
	ifactioncount 3 { action ASHARKDEAD cstat 256 ifrnd 128 cstator 8 strength 0 }
	break
  }
  ifaction ASHARKDEAD
  {
	ifhitweapon { state lite_jibs killit }
	break
  }
  state monsterai
  ifaction ASHARKSHRUNK
  {
    ifcount SHRUNKDONECOUNT
      action ASHARKCRUZING
    else ifcount SHRUNKCOUNT
      sizeto 40 40
	
    else
      state genericshrunkcode
    break
  }
  else
    ifaction ASHARKGROW
      state genericgrowcode
  else
    ifaction ASHARKFROZEN
  {
    // fall

    ifp pfacing
      ifpdistl FROZENQUICKKICKDIST
        state pkick_check

    ifcount THAWTIME
    {
      action ASHARKFLEE
	  move SHARKFLEEVELS fleeenemy
      getlastpal
      break
    }
    else
      ifcount FROZENDRIPTIME
        ifactioncount 26
          resetactioncount

    ifhitweapon
    {
      ifwasweapon FREEZEBLAST
      { resetcount resetactioncount break }

	  lotsofglass 10
      state standard_jibs
      sound GLASS_BREAKING
      addkills 1 state enemy_death
      killit
    }
    break
  }
  else
    ifaction ASHARKFLEE
  {
    ifcount 16
      ifrnd 48
    {
      action ASHARKCRUZING
      move SHARKVELS randomangle geth
    }
  }
  else
    ifaction ASHARKCRUZING
  {
    // ifcansee
      ifcount 48
        ifrnd 2
          // ifcanshoottarget
	ife seemytarget YES
	ifn bottarget -1
    {
      action ASHARKATACK
      move SHARKFASTVELS faceplayerslow getv break
    }
    ifcount 32
      ifnotmoving
    {
      ifrnd 128
        move SHARKVELS randomangle geth
      else
        move SHARKFASTVELS randomangle geth
    }
  }
  else
    ifaction ASHARKATACK
  {
    ifcount 4
    {
      // ifpdistl 1280
	  ifn bottarget -1
	  ifl targetdist 1280
      {
        // ifp palive ifcanshoottarget
		ife sector[].lotag sector[player[].cursectnum].lotag
        {
		  ife bottarget player[].i
		  {
			  ife pchar 1 sound B_GRUNT else
			  ife pchar 2 sound WESPAIN2 else
			   sound DUKE_GRUNT
			  palfrom 32 32
		  }
		  // getp[].i spriteid
		  seta[bottarget].htpicnum FIRELASER
		  seta[bottarget].htowner THISACTOR
		  set temp SHARKBITESTRENGTH
		  mul temp -1
		  seta[bottarget].htextra temp
		  seta[bottarget].htang sprite[].ang
        }
        action ASHARKFLEE
        move SHARKFLEEVELS fleeenemy
      }
    }
    else
      ifnotmoving
    {
      ifcount 32
      {
        action ASHARKCRUZING
        move SHARKVELS randomangle geth
      }
    }
    else
      ifcount 48
        ifrnd 2
    {
      action ASHARKCRUZING
      move SHARKFASTVELS randomangle geth
    }
  }
 
  ifhitweapon
  {
    ifdead
    {
      ifwasweapon GROWSPARK
      {
        move 0
        cstat 0
        action ASHARKGROW
        sound ACTOR_GROWING
        break
      }
      else
        ifwasweapon FREEZEBLAST
      {
        spritepal 1
        strength 0
        action ASHARKFROZEN
		move STOPPED
        sound NEWFREEZE
		state freezeme
      }
      else
      {
	    sound SQUISHED
		guts JIBS6 5
		addkills 1 
		state enemy_death
		ifn sprite[].htpicnum RPG ifn sprite[].htpicnum RADIUSEXPLOSION
		{
			action ASHARKDYING	
			sizeat 60 60 
			move STOPPED
		}
		else
			killit
      }
    }
    else
    {
      ifwasweapon SHRINKSPARK
      {
        // action ASHARKSHRUNK
        sound ACTOR_SHRINKING
		set shrunken 1
		seta[].htpicnum SHOTSPARK1
        // move 0
        break
      }
      else
        ifwasweapon GROWSPARK
          sound SPARKLESOUND

      move SHARKVELS randomangle geth
    }
  }
enda

action ADOPEFISHCRUZING  0  4  5  1  24
action ADOPEFISHFLEE 	 0  4  5  1  10
action ADOPEFISHATACK 	 0  4  5  1  6
action ADOPEFISHSHRUNK  0 4 5 1 24
action ADOPEFISHGROW  0 4 5 1 24
action ADOPEFISHFROZEN  0 1 5 1 24

useractor enemy DOPEFISH SHARKSTRENGTH ADOPEFISHCRUZING SHARKVELS randomangle geth

  ifinwater
  {
	  ife initsprite NO 
	  {
		geta[].x startx
		geta[].y starty
		set initsprite YES
	  }
  }
  else
  {
	ife initsprite YES
	{
		setsprite THISACTOR startx starty sprite[].z
	}
  }
  seta[].shade -100
  ifaction ASHARKCRUZING action ADOPEFISHCRUZING
  state monsterai
  ifaction ADOPEFISHSHRUNK
  {
    ifcount SHRUNKDONECOUNT
      action ADOPEFISHCRUZING
    else ifcount SHRUNKCOUNT
      sizeto 60 60
	
    else
      state genericshrunkcode
    break
  }
  else
    ifaction ADOPEFISHGROW
      state genericgrowcode
  else
    ifaction ADOPEFISHFROZEN
  {
    // fall

    ifp pfacing
      ifpdistl FROZENQUICKKICKDIST
        state pkick_check

    ifcount THAWTIME
    {
      action ADOPEFISHFLEE
	  move SHARKFLEEVELS fleeenemy
      getlastpal
      break
    }
    else
      ifcount FROZENDRIPTIME
        ifactioncount 26
          resetactioncount

    ifhitweapon
    {
      ifwasweapon FREEZEBLAST
      { resetcount resetactioncount break }
	  spritepal 6
	  lotsofglass 30
      state standard_jibs
      sound GLASS_BREAKING
      addkills 1 state enemy_death
	  rand countvar 2
		add countvar 1
		whilevarn countvar 0
		{
			state spawn_goodie2
			rand x 1400
			sub x 700
			add x sprite[].x
			seta[RETURN].x x
			rand y 1400
			sub y 700
			add y sprite[].y
			seta[RETURN].y y
			sub countvar 1
		}
      killit
    }
    break
  }
  else
    ifaction ADOPEFISHFLEE
  {
    ifcount 16
      ifrnd 48
    {
      action ADOPEFISHCRUZING
      move SHARKVELS randomangle geth
    }
  }
  else
    ifaction ADOPEFISHCRUZING
  {
    ifcansee
      ifcount 48
        ifrnd 2
          ifcanshoottarget
    {
      action ADOPEFISHATACK
      move SHARKFASTVELS faceplayerslow getv break
    }
    ifcount 32
      ifnotmoving
    {
      ifrnd 128
        move SHARKVELS randomangle geth
      else
        move SHARKFASTVELS randomangle geth
    }
  }
  else
    ifaction ADOPEFISHATACK
  {
    ifcount 4
    {
      ifpdistl 1280
      {
        ifp palive ifcanshoottarget
        {
          ife pchar 1 sound B_GRUNT else
		  ife pchar 2 sound WESPAIN2 else
           sound DUKE_GRUNT
          palfrom 32 32
		  getp[].i spriteid
		  seta[spriteid].htpicnum FIRELASER
		  seta[spriteid].htowner THISACTOR
		  set temp SHARKBITESTRENGTH
		  mul temp -1
		  seta[spriteid].htextra temp
		  seta[spriteid].htang sprite[].ang
        }
        action ADOPEFISHFLEE
        move SHARKFLEEVELS fleeenemy
      }
    }
    else
      ifnotmoving
    {
      ifcount 32
      {
        action ADOPEFISHCRUZING
        move SHARKVELS randomangle geth
      }
    }
    else
      ifcount 48
        ifrnd 2
    {
      action ADOPEFISHCRUZING
      move SHARKFASTVELS randomangle geth
    }
  }
 
  ifhitweapon
  {
    ifdead
    {
      ifwasweapon GROWSPARK
      {
        move 0
        cstat 0
        action ADOPEFISHGROW
        sound ACTOR_GROWING
        break
      }
      else
        ifwasweapon FREEZEBLAST
      {
        spritepal 1
        strength 0
        action ADOPEFISHFROZEN
		move STOPPED
        sound NEWFREEZE
		state freezeme
      }
      else
      {
	    sound SQUISHED
		spritepal 6
		guts JIBS6 5
		state lite_jibs
		addkills 1 
		state enemy_death
		rand countvar 2
		add countvar 4
		whilevarn countvar 0
		{
			state spawn_goodie2
			rand x 1024
			sub x 512
			add x sprite[].x
			seta[RETURN].x x
			rand y 1024
			sub y 512
			add y sprite[].y
			seta[RETURN].y y
			sub countvar 1
		}
		killit
      }
    }
    else
    {
      ifwasweapon SHRINKSPARK
      {
        // action ADOPEFISHSHRUNK
        sound ACTOR_SHRINKING
		set shrunken 1
		seta[].htpicnum SHOTSPARK1
        // move 0
        break
      }
      else
        ifwasweapon GROWSPARK
          sound SPARKLESOUND

      move SHARKVELS randomangle geth
    }
  }

enda

useractor notenemy SHOOT_THIS 20

// ife mysignpost -1 state spawnmysignpost
ifmove 0
{
	move STOPPED
	cstator 256
	set monstatus 1
}
ifhitweapon
{
	ifdead
	{
	set monstatus 2
	shoot SHRUNKBULLET
	killit
	}
}

enda

state headhitstate

// Unrem the following line to invoke screen tilting during
// low player hitpoint damage.

// wackplayer

ends


action BURNING_FLAME  0   12   1   1   2
move BURNING_VELS 

state burningstate

  ife monstatus 2
  {
	cactor BIGSMOKE
	action 0
	move 0
  }
  ifspawnedby FIREBEAM
  {
	fall
	ifinwater killit
	iffloordistl 64 nullop else killit
	ifrnd 128 cactor BURNING2
  }
  ifspawnedby PLASMA_EXP
  {
	fall
	ifinwater killit
	iffloordistl 64 nullop else killit
  }
  ifspawnedby BURNING
  {
    ifgapzl 16
      break
  }
  else
    ifspawnedby BURNING2
  {
    ifgapzl 16
      break
  }

  ifcount 128
  {
    ifspawnedby TIRE
    {
      ifactioncount 512
        killit
      ifrnd 8 
        sizeto 64 48
    }
    else
    {
      sizeto 8 8
      sizeto 8 8
      ifcount 192
        killit
    }
  }
  else
  {
    ifmove 0
	{
      move BURNING_VELS
	  cstator 2
	  seta[].blend 1
	}
    sizeto 52 52

    ifp palive
      ifpdistl 844
        // ifrnd 32
          ifcansee
		    ifn sprite[].pal 1
				ife team 0
    {
      ifg player[].boot_amount 0
	  {
		ifvarand player[].player_par 1
		{
		  getp[].boot_amount temp
		  sub temp 1
		  setp[].boot_amount temp
		}
	  }
	  else
	  {
		  getp[].i spriteid
		  getav[spriteid].burning temp
		  ifl temp 60 add temp 1
		  setav[spriteid].burning temp
		  palfrom 32 16
	  }
    }
	
	ifn sprite[].pal 1
	{
		headspritesect spriteid sprite[].sectnum
		whilevarn spriteid -1
		{
			ife sprite[spriteid].statnum 1
			ife actorvar[spriteid].monstatus 1
			{
				dist xydist THISACTOR spriteid
				ifl xydist 844
				ife team actorvar[spriteid].team
				{
					getav[spriteid].burning temp
					ifl temp 100
					{
					ifrnd 128 add temp 2
					}
					// add temp 2
					setav[spriteid].burning temp
				}
			}
			nextspritesect spriteid spriteid
		}
	}
	
  }

ends

actor BURNING WEAK BURNING_FLAME
  state burningstate
enda

actor BURNING2 WEAK BURNING_FLAME
  state burningstate
enda

// action QUICK_FLAME  -2   12   1   1   2

state quickflamestate

  sleeptime 300
  ifcount 50
  {
      sizeto 8 8
	  sizeto 8 8
      ifcount 90
	  {
	    spawn BIGSMOKE
        killit
	  }
  }
  else
  {
    ifmove 0
	{
      move BURNING_VELS
	  cstator 128
	  ifrnd 128 cstator 4
	  ifrnd 128 cstator 8
	  seta[].shade -127
	}

    sizeto 52 52
	

    ifp palive
      ifpdistl 844
        // ifrnd 32
          ifcansee
    {
	   ifg player[].boot_amount 0
	  {
		ifvarand player[].player_par 1
		{
		  getp[].boot_amount temp
		  sub temp 1
		  setp[].boot_amount temp
		}
	  }
	  else
	  {
		  getp[].i spriteid
		  getav[spriteid].burning temp
		  ifl temp 60 add temp 4
		  setav[spriteid].burning temp
		  palfrom 32 16
	  }
	  killit
    }
	
	headspritesect spriteid sprite[].sectnum
	whilevarn spriteid -1
	{
		ife sprite[spriteid].statnum 1
		ife actorvar[spriteid].monstatus 1
		{
			dist xydist THISACTOR spriteid
			ifl xydist 844
			{
				getav[spriteid].burning temp
				ifl temp 180
				{
					add temp 20
					rand tempb 20
					add temp tempb
				}
				
				setav[spriteid].burning temp
				count 51
			}
		}
		nextspritesect spriteid spriteid
	}
	
  }

ends

useractor notenemy QUICKFLAME 0 // QUICK_FLAME
  state quickflamestate
enda

action TOILETWATERFRAMES 0 4 1 1 1
actor TOILETWATER 0 TOILETWATERFRAMES
  ife monstatus 2
  {
	ifaction ANULLACTION nullop else { resetcount action ANULLACTION stopactorsound THISACTOR WATER_GURGLE }
	cstator 259
	// ifhitweapon { spritepal 1 sound GLASS_BREAKING lotsofglass 30 spawn BIGSMOKE killit }
	ifcount 600 { set monstatus 0 cstat 0 action TOILETWATERFRAMES }
	break
  }
  ifpdistl 8192
  {
    soundonce WATER_GURGLE
    ifspawnedby TOILET
      sizeto 34 34
    else
    {
      ifspawnedby WATERFOUNTAINBROKE
        sizeto 6 15
      else
        ifspawnedby TOILETWATER
          nullop
      else
        sizeto 24 32
    }

    ifp palive
      ifpdistl RETRIEVEDISTANCE
        ifp pfacing
          ifactioncount 32
            ifphealthl MAXPLAYERHEALTH
              ifhitspace
                ifcansee
    {
      addphealth 1
      globalsound DUKE_DRINKING
      resetactioncount
    }
  }
enda

state steamcode
  ifpdistl 6144
    soundonce STEAM_HISSING

  ifcount 20
    {
      resetcount
      ifp palive
        ifpdistl 1024
      {
        addphealth -1
        palfrom 16 16
      }
    }
  else
  {
    ifspawnedby STEAM
      break
    else
      ifspawnedby CEILINGSTEAM
        break

    sizeto 24 24
  }
ends

action STEAMFRAMES    0     5     1     1     1
actor STEAM 0 STEAMFRAMES
  state steamcode
enda

actor CEILINGSTEAM 0 STEAMFRAMES
  state steamcode
enda

actor WATERBUBBLEMAKER 0 0 randomangle
  ifpdistl 3084
    ifrnd 24
      spawn WATERBUBBLE
enda

action BUBBLE
action CRACKEDBUBBLE  1
move BUBMOVE       -10 -36
move BUBMOVEFAST     -10 -52

actor WATERBUBBLE 0 BUBBLE BUBMOVE getv geth randomangle

  ifaction CRACKEDBUBBLE
  {
    ifinwater
      ifrnd 192
        killit
    ifactioncount 7
      killit
  }
  else
  {
    ifcount 4
    {
      ifrnd 192
        move BUBMOVE getv geth randomangle
      else
        move BUBMOVEFAST getv geth randomangle
      resetcount

      ifrnd 84
        sizeat 8 10
      else
        ifrnd 84
          sizeat 10 8
      else
        sizeat 9 9
    }

    ifonwater
    {
      iffloordistl 8
        action CRACKEDBUBBLE
    }
    else
      ifactioncount 40
        action CRACKEDBUBBLE
  }
enda

eventloadactor MESSAGER
cstat 32768
geta[].lotag SPRITELOTAG
seta[].lotag 0
geta[].hitag initsprite
ife initsprite 0 set initsprite 1
seta[].hitag 0
geta[].extra mtype
ife mtype -1 set mtype 0

enda

useractor notenemy MESSAGER

	ifp palive
	ifpdistl 1280
	ifl subtitle_time 3
	{
		set subtitle_time 6
		set subtitle_start SPRITELOTAG
		set subtitle_numlines initsprite
	}
	
	ifn mtype 0
	{
		checkactivatormotion mtype
		ife RETURN 1 killit
	}
	ife monstatus 2 killit

enda

eventloadactor UPDRAFT_SPAWNER
cstat 32768
geta[].lotag SPRITELOTAG
seta[].lotag 0

enda

useractor notenemy UPDRAFT_SPAWNER 0

ifspritepal 2
{
	headspritesect spriteid sprite[].sectnum
	whilevarn spriteid -1
	{
		ife sprite[spriteid].picnum UPDRAFT_SPAWNER
		ifn spriteid THISACTOR
		ifg sprite[spriteid].z sprite[].z
		{
			geta[].z float
			setav[spriteid].float float
			seta[spriteid].pal 4
		}
		nextspritesect spriteid spriteid
	}
	killit
}

ifp ponground set mtype NO

ife SPRITELOTAG 0
ife sprite[].sectnum player[].cursectnum
ifp phigher
{
	set temp YES
	ifspritepal 4 ifl player[].posz float set temp NO
	ldist xydist THISACTOR player[].i
	ife temp YES
	ifl xydist 2816 // 2304
	{
		setp[].jumping_toggle 1
		
		ife pchar 2 
		{
			set glidetime GLIDEMAX
			set glideboost 0
		}
		ife mtype NO { set mtype YES setp[].poszv -5120 screensound GLIDEUP } else
		ifg player[].poszv -2048
		{
			getp[].poszv zdist
			sub zdist 512
			ifl zdist -2048 set zdist -2048
			setp[].poszv zdist
		}
	}
}

ife SPRITELOTAG 0
add countvar 1
ifge countvar 60
{
	espawn UPDRAFT_SPRITE
	setav[RETURN].myspawner THISACTOR
	ifspritepal 4 setav[RETURN].float float
	set countvar 0
}
enda

spritenoshade UPDRAFT_SPRITE
spritenopal UPDRAFT_SPRITE
move UPDRAFTVEL 0 -128
useractor notenemy UPDRAFT_SPRITE 0

ifmove 0
{
	seta[].shade -100
	seta[].alpha 96
	seta[].blend 1
	sizeat 40 38
	move UPDRAFTVEL geth getv
	cstat 514
}

ifn float 0 ifl sprite[].z float killit
ifn actorvar[myspawner].SPRITELOTAG 0 killit
ifnotmoving killit
ifceilingdistl 8 killit

enda

eventloadactor AIRBUBBLEMAKER
cstat 32768
geta[].lotag countvar
seta[].lotag 0
ife countvar 0 set countvar 240
enda

spritenoshade AIRBUBBLE

state killbubble
	set countvarb 0
	geta[].x x
	geta[].y y
	geta[].z z
	whilevarn countvarb 12
	{
		espawn WATERBUBBLE
		rand temp 1024
		sub temp 512
		add temp x
		seta[RETURN].x temp
		rand temp 1024
		sub temp 512
		add temp y
		seta[RETURN].y temp
		rand temp 8192
		sub temp 4096
		add temp z
		seta[RETURN].z temp
		add countvarb 1
	}
	killit
ends

useractor notenemy AIRBUBBLE 0 BUBBLE

	ifmove 0 
	{
		seta[].shade -50
		move BUBMOVEFAST getv geth randomangle
		sizeat 48 8
		cstat 898
		geta[].z z
		sub z 8192
		seta[].z z
		ifrnd 128 set mtype 1
		ifrnd 128 cstator 4
		ifrnd 128 cstator 8
	}
	
	// vertical movement insurance policy
	geta[].z z
	sub z 128
	seta[].z z
	
	getceilzofslope sprite[].sectnum sprite[].x sprite[].y z
	geta[].z zdist
	sub zdist z

	ifl zdist 6144
	{
		sizeto 48 18
		ifl sprite[].yrepeat 20
			state killbubble
	}
	else sizeto 48 42
	
	set temp player[].player_par
	shiftl temp 4
	sin tempb temp
	shiftr tempb 8
	ife mtype 1
	{
		geta[].y y
		sub y tempb
		seta[].y y
	}
	else
	{
		geta[].x x
		sub x tempb
		seta[].x x
	}
	
	ifinwater nullop else
		state killbubble
		
	ifhitweapon
		state killbubble
		
	ifpdistl 1024
	{
		ifinwater
		ifl player[].airleft 390
		ifp palive
		{
			globalsound AIRBURST
			sound DUKE_TAKEPILLS
			palfrom 48 0 0 60
			setp[].airleft 390
			set lastbubble 150
			ifg o2damage 0
			ifl sprite[player[].i].extra player[].max_player_health
			{
				geta[player[].i].extra temp
				add temp o2damage
				ifg temp player[].max_player_health set temp player[].max_player_health
				seta[player[].i].extra temp
			}
			set o2damage 0
		}
		state killbubble
	}
	

enda

useractor notenemy AIRBUBBLEMAKER 0

ifmove 0
{
	move STOPPED
	cstat 32768
	set countvarb 0
	ife countvar 0 set countvar 240
}
add countvarb 1
ifg countvarb countvar
{
	set countvarb 0
	spawn AIRBUBBLE
}

enda

action ABIGSMOKEFRAMES 0 15 1 1 6
action ABIGSMOKEFAST 0 15 1 1 3
action ABIGSMOKESLOW 0 15 1 1 10
move BIGSMOKEVEL
move PLAYERSMOKEVEL 0 -8
move SMOKERVEL 32 -32
move TIRESMOKEVEL 64 -10
move BURNSMOKEVEL 96 -64
move BURN2SMOKEVEL 48 -32
move COPTER_DUST 192

useractor notenemy BIGSMOKE 0

ifspawnedby TEAMSPAWNER
{
	move 0
	action 0
	resetcount
	resetactioncount
	sizeat 40 40
	seta[].htpicnum BIGSMOKE
}

ifmove 0
{
	move BIGSMOKEVEL
	ifspritepal 76 
	{
		geta[].z z, sub z 5120, seta[].z z
		move BURN2SMOKEVEL geth getv
		cstator 2
		rand angvar 64
		sub angvar 32
		add angvar sprite[].ang
		seta[].ang angvar
	}
	ifspritepal 90 
	{
		sound STEAMRELEASE
		geta[].z z, sub z 5120, seta[].z z
		move BURN2SMOKEVEL geth getv
		cstator 2
		sizeat 96 96
		rand angvar 64
		sub angvar 32
		add angvar sprite[].ang
		seta[].ang angvar
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			ife actorvar[spriteid].monstatus 1
			ife actorvar[spriteid].team 0
			{
				dist xydist THISACTOR spriteid
				ifl xydist 2048
				{
					set B actorvar[spriteid].inithp
					set temp 1024
					mul temp plevel
					div temp B
					set TMP_A temp
					ifg temp 0
					{
						getav[spriteid].stun tempb
						add tempb temp
						setav[spriteid].stun tempb
						shiftl temp 1
						getav[spriteid].bleeding tempb
						ifg tempb 0 mul tempb -1
						sub tempb TMP_A
						setav[spriteid].bleeding tempb
						geta[spriteid].mdflags temp
						orvar temp 16
						seta[spriteid].mdflags temp
					}
				}
			}
			nextspritestat spriteid spriteid
		}
	}
	action ABIGSMOKEFRAMES
	
	ifl sprite[].xrepeat 8 sizeat 40 40
	else ifg sprite[].xrepeat 64 action ABIGSMOKESLOW
	cstat 128
	ifrnd 128 cstator 4
	ifrnd 128 cstator 8
	seta[].blend 1
	geta[].htflags temp
	orvar temp 8192
	seta[].htflags temp
	switch sprite[].htpicnum
	case SHELLY sizeat 24 24 break
	case APLAYER
		move PLAYERSMOKEVEL geth getv
		seta[].alpha 64
	break
	case RPG  
		seta[].blend 254
		cstator 2 sizeat 20 20 
		action ABIGSMOKEFAST 
		ifpdistl 1560 killit 
		seta[].alpha 116
	break
	case SMOKER
		spriteflags 4
		move SMOKERVEL randomangle getv
		action ABIGSMOKESLOW
	break
	case PIGSUV 
		ifspritepal 4
		{
			spritepal 0
			spriteflags 4
			seta[].shade 20
			move BURNSMOKEVEL randomangle getv 
		}
		else
		move TIRESMOKEVEL geth getv randomangle 
		cstator 2 
	break
	case RECONWRECK
	case TANKWRECK
		spriteflags 4
		seta[].shade 20
		move BURNSMOKEVEL randomangle getv 
	break

	case BURNING
	
		spriteflags 4
		seta[].shade 20
		move BURN2SMOKEVEL randomangle getv 
	break
	case NUKEEXPLOSION
		sizeat 64 64
		spriteflags 4
		seta[].shade 18
		ifrnd 128 debris SCRAP2 1
		ifrnd 128 debris SCRAP3 1
		ifrnd 128 debris SCRAP4 1
		ifrnd 128 debris SCRAP5 1
		ifrnd 48 { ifrnd 128 spawn BURNING else spawn BURNING2 }
	break
	case SCUBATROOP
	
		seta[].blend 0
		sizeat 32 32
		cstator 514
		geta[].z z
		sub z 4096
		seta[].z z
	break
	case BLACKHAWK
		move COPTER_DUST geth
		sizeat 18 14
		seta[].blend 0
		cstator 514
	break
	endswitch
	ife mtype 1
	{
		cstat 130
		sizeat 128 128
		spritepal 89
		seta[].shade -64
		action ABIGSMOKESLOW
	}
}
ifnotmoving killit
ifactioncount 15 killit

enda

action BIGSMOKE2FRAMES 0 20 1 1 6

useractor notenemy BIGSMOKE2 0 BIGSMOKE2FRAMES

ifmove 0
{	
	cstat 0
	ifspritepal 0 spritepal 12
	move STOPPED
	ifspawnedby WATERIMPACT cstat 514
	else ifspawnedby BLOODEXP sizeat 48 48
	else
	{
		sizeat 40 40
		cstat 2
	}
	ifrnd 128 cstator 4
}

ifactioncount 20 killit

enda

move SMOKEVEL 8 -16
move ENGINE_SMOKE 64 -64
move RAD_SMOKE 32 -36
move RAD_SMOKE2 38 -16
move SMOKESHOOTOUT -192
action SMOKEFRAMES 0 4 1 1 10
actor SMALLSMOKE 0 SMOKEFRAMES

  ifspawnedby SHOTSPARK1
  {
	  ifonwater
	  iffloordistl 4 killit
	  
	  geta[].owner spriteid
	  ifn spriteid -1
	  {
		ifn sprite[spriteid].htg_t 8 -1
		killit
	  }
  }
  
  ifmove 0
  {
	switch sprite[].htpicnum
	case CARXPLODE
	case TERMLEGPART1
	case TERMLEGPART2
	case TERMLEGPART3
		sizeat 42 42 spriteflags 4 seta[].shade 20 cstator 2
		move SMOKEVEL geth getv faceplayer
		seta[].alpha 128
	break
	case MECHDEBRIS1
	case MECHDEBRIS2
		sizeat 42 42 spriteflags 4 seta[].shade 20 cstator 2
		seta[].alpha 172
		move SMOKEVEL geth getv faceplayer
	break
	case RECON
		move SMOKESHOOTOUT geth
	break
	case SECTOREFFECTOR
		 move ENGINE_SMOKE geth getv
	break
	case RADWOUND
		ifrnd 128
	    move RAD_SMOKE randomangle getv
		else
		move RAD_SMOKE2 randomangle getv
		cstator 2
	break
	
	default
		 move SMOKEVEL geth getv faceplayer
	break
	endswitch
	
	ifspritepal 4 { spritepal 0 spriteflags 4 seta[].shade 20 }
    ifrnd 128 cstator 4
	ifrnd 128 cstator 8
    
    ifspawnedby RPG
	{
	  espawn BIGSMOKE
	  seta[RETURN].htpicnum RPG
	  killit
	}
	  
  }
  
  ifpdistl 1596
    ifspawnedby RPG
      killit
  ifactioncount 4
    killit
enda

state random_ooz
  ifrnd 128
    spawn OOZ2
  else
    spawn OOZ
ends

// action SHRINKERFRAMES 0 4 1 1 10
action SHRINKERFRAMES 15164 8 1 1 8
actor SHRINKEREXPLOSION 0 SHRINKERFRAMES

  ifmove 0
  {
      move STOPPED
	  ifspritepal 0 spritepal 11
	  seta[].blend 1
	  cstator 2
	  geta[].yrepeat y, div y 2, seta[].yrepeat y
	  geta[].xrepeat x, div x 2, seta[].xrepeat x
  }
  ifn myvictim -1
  {
	set x tiledata[sprite[myvictim].picnum].ysize
	mul x sprite[myvictim].yrepeat
	shiftr x 6 // 5
	clamp x 8 255
	seta[].yrepeat x
	seta[].xrepeat x
	
	ife actorvar[myvictim].shrunken 0
	{
		ifspritepal 10 seta[myvictim].htpicnum SHOTSPARK1 else
		seta[myvictim].htpicnum SHRINKSPARK
		seta[myvictim].htowner player[].i
		ifl sprite[myvictim].htextra 1 seta[myvictim].htextra 1
	}
  }
  ifactioncount 8
    killit
enda

action EXPLOSION5FRAMES  0  36  1  1  4

useractor notenemy EXPLOSION5 0 EXPLOSION5FRAMES

ifmove 0
{
	move STOPPED
	seta[].blend 1
	cstator 2
	seta[].shade -127
	ifl sprite[].xrepeat 4
	sizeat 18 16
	ifspawnedby FLAMEPROJ 
	{
		cstator 128
		stopsound PISTOL_BODYHIT
		ifrnd 32
		{
			ifspritepal 1
			{
				spawn BIGSMOKE
			}
			else
			{
				ifrnd 128 spawn BURNING else
				spawn BURNING2
			}
		}
	}
}
state spawnsmokeonscrap

ifactioncount 35 killit

enda

action EXPLOSION6FRAMES  0  30  1  1  4

useractor notenemy EXPLOSION6 0 EXPLOSION5FRAMES

ifmove 0
{
	move STOPPED
	seta[].blend 1
	cstator 2
	seta[].shade -127
	ifl sprite[].xrepeat 4
	sizeat 18 16
}
state spawnsmokeonscrap

ifactioncount 30 killit

enda

action NUKEFRAMES2  8440  21  1  1  16
action NUKEFRAMES3  13694 64  1  1  4
action NUKEFRAMES4  13694 64  1  1  4

action EXPLOSION_FRAMES 0 20 1 1  4
action EXPLOSIONB_FRAMES 6558 17 1 1 6
actor EXPLOSION2 1 EXPLOSION_FRAMES
ifmove 0
{
	seta[].blend 1
	// cstator 2
	// seta[].alpha 32
	ifspawnedby FIREEXT
	{
		seta[].blend 0
		seta[].alpha 80
		spritepal 26
		cstator 514
		espawn PART_EXP
		seta[RETURN].pal 12
		espawn PART_EXP
		seta[RETURN].pal 12
		spritepal 33
		debris SCRAP3 8
		getlastpal
	}
	
	ifspawnedby NUKEEXPLOSION
	{
		ife rendmode 0
		{
		action NUKEFRAMES2
		sizeat 255 224
		spritepal 76
		}
		else
		{
		action NUKEFRAMES3
		sizeat 196 160
		getflorzofslope sprite[].sectnum sprite[].x sprite[].y z
		getceilzofslope sprite[].sectnum sprite[].x sprite[].y z2
		sub z z2
		abs z
		shiftr z 11
		ifg z 255 set z 255
		ifl z 64 set z 64
		seta[].yrepeat z
		mul z 4 div z 3
		ifg z 255 set z 255
		seta[].xrepeat z
		}
		ifrnd 128 cstat 0 else cstat 4
		// cstator 2
		move STOPPED
		break
	}
	ifspawnedby BOMBSECTOR
	{
		action NUKEFRAMES4
		sizeat 96 72
		move STOPPED
		cstat 0
		break
	}
	ife mtype BOMBSECTOR
	{
		action NUKEFRAMES4
		sizeat 72 60
		move STOPPED
		cstat 0
		break
	}
	ifspawnedby ARROWPROJ
	{
		action EXPLOSIONB_FRAMES
		geta[].xrepeat x
		add x 12
		geta[].yrepeat y
		add y 12
		seta[].xrepeat x
		seta[].yrepeat y
		move STOPPED
		break
	}
	ifspawnedby STICKYBOMB
	{
		action EXPLOSIONB_FRAMES
		sizeat 32 32
		move STOPPED
		break
	}
	ifspawnedby SHOTSPARK1
	ife pchar 2
	ife player[].curr_weapon DEVISTATOR_WEAPON
	{
		// hitradius 1280 1 4 8 12
		headspritestat spriteid 5
		whilevarn spriteid -1
		{
			ifl sprite[spriteid].htextra 1
			{
				dist xydist THISACTOR spriteid
				ifle xydist 1280
				{
					seta[spriteid].htextra 4
					seta[spriteid].htpicnum RADIUSEXPLOSION
					seta[spriteid].htowner player[].i
				}
			}
			nextspritestat spriteid spriteid
		}
		headspritestat spriteid 6
		whilevarn spriteid -1
		{
			ifl sprite[spriteid].htextra 1
			{
				dist xydist THISACTOR spriteid
				ifle xydist 1280
				{
					seta[spriteid].htextra 4
					seta[spriteid].htpicnum RADIUSEXPLOSION
					seta[spriteid].htowner player[].i
				}
			}
			nextspritestat spriteid spriteid
		}
	}
	ifg shrunken 10 ifl shrunken SHRUNKCOUNT
	{
		geta[].xrepeat x div x 2 seta[].xrepeat x
		geta[].yrepeat y div y 2 seta[].yrepeat y
	}
	ife mtype 2 killit
	ifspawnedby BOMBLET sizeat 20 20
	ifinwater ifspritepal 0
	ifn mtype WESBOT
	{
		ifl sprite[].xrepeat 10 set mtype 1
		geta[].xrepeat temp
		mul temp 3 div temp 2
		seta[].xrepeat temp
		geta[].yrepeat temp
		geta[].z z
		mul temp 160
		add z temp
		seta[].z z
		espawn EXPLOSION2
		ifn RETURN -1
		{
			seta[RETURN].pal 1
			seta[RETURN].xrepeat sprite[].xrepeat
			seta[RETURN].yrepeat sprite[].yrepeat
			seta[RETURN].cstat 2
			geta[RETURN].yrepeat temp
			geta[RETURN].z z
			mul temp 160
			add z temp
			seta[RETURN].z z
			setav[RETURN].mtype mtype
		}
		spritepal 1
		cstator 138
		iffloordistl 8 killit
	
	}
	// else iffloordistl 32 nullop else
	// ifrnd 128 
	// {
		// action EXPLOSIONB_FRAMES
		// geta[].xrepeat x
		// add x 6
		// geta[].yrepeat y
		// add y 6
		// seta[].xrepeat x
		// seta[].yrepeat y
	// }
	ifspawnedby SHOTSPARK1 
	{
		action EXPLOSIONB_FRAMES
		geta[].x x
		geta[].y y
		ifg player[].posx sprite[].x add x 256
		else sub x 256
		ifg player[].posy sprite[].y add y 256
		else sub y 256
		seta[].x x
		seta[].y y
	}
	move STOPPED
	ifg sprite[].xrepeat 24
	{
		ifpdistl 4096 quake 20
	}
	ifaction EXPLOSION_FRAMES
	ifspritepal 0
	{
		ifspawnedby WESBOMB
		{
			spritepal 1
			cstat 0
		}
		iffloordistl 4
		{
			cactor EXPLOSION6
			action EXPLOSION6FRAMES
			cstat 2
			ifrnd 128 cstator 4
		}
		else
		{
			cactor EXPLOSION5
			action EXPLOSION5FRAMES
		}
		cstator 2
		seta[].shade -127
		geta[].xrepeat x, mul x 2, div x 3
		
		geta[].yrepeat y, mul y 2, ifg y 20 sub y 2, div y 3
		ife mtype WESBOT { mul x 3 mul y 3 }
		seta[].xrepeat x
		seta[].yrepeat y
		
		ife mtype WESBOT 
		{
			flash
			espawn FIRERING
			setav[RETURN].mtype 2
			stopsound ROCKETLOOP
			ifpdistl 10240 quake 50
			
			
			sound NUKESOUND
			setactorsoundpitch THISACTOR NUKESOUND 768
			
			set x2 5120
			ifspawnedby TERMINATORCRAWLING sub x2 512
			headspritestat spriteid 1
			whilevarn spriteid -1
			{

				geta[spriteid].z z
				sub z sprite[].z
				abs z
				ifl z 131072 // 65536
				{
					ldist xydist THISACTOR spriteid
					ifl xydist x2
					{
						set xydist2 400000
						ife xydist 0 set xydist 1
						div xydist2 xydist
						ifg xydist2 644 set xydist2 644
						
						geta[spriteid].htextra B
						add B xydist2
						seta[spriteid].htextra B
						seta[spriteid].htpicnum RPG
						// setav[spriteid].padang 1337
						ifspawnedby TERMINATORCRAWLING seta[spriteid].htowner sprite[].owner else
						seta[spriteid].htowner player[].i
						seta[spriteid].htang sprite[].ang
						
						getav[spriteid].stun tempb
						add tempb 55
						setav[spriteid].stun tempb
					}
					
				}
				ife spriteid player[].i set spriteid -1 else
				{
					nextspritestat spriteid spriteid
					ife spriteid -1 ifcansee { ifspawnedby TERMINATORCRAWLING set spriteid player[].i }
				}
			}
			set countvar 0
			whilevarn countvar 20
			{
				add countvar 1
				espawn BIGSMOKE
				rand x2 8192
				sub x2 4096
				add x2 sprite[].x
				seta[RETURN].x x2
				rand x2 8192
				sub x2 4096
				add x2 sprite[].y
				seta[RETURN].y x2
			}
			
		}
		
		changespritestat THISACTOR 1
		break
	}
	
}
  ifaction NUKEFRAMES4
  {
	ifactioncount 64 killit
	break
  }
  ifaction NUKEFRAMES3
  {
	ifactioncount 64 killit
	break
  }
  ifaction NUKEFRAMES2
  {
    ifactioncount 21 killit
    break
  }
  ifspritepal 1 ifactioncount 9 // under water
  ife mtype 0
  {
	sizeto 255 255
	geta[].xrepeat temp
	mul temp 32 div temp 33
	seta[].xrepeat temp
	geta[].z z
	geta[].yrepeat temp
	mul temp 14
	add z temp
	seta[].z z
	cstator 512
	ifactioncount 19 killit
  }
  
  state spawnsmokeonscrap

  ifaction EXPLOSIONB_FRAMES
	ifactioncount 17
		killit
  ifactioncount 20
    killit
enda

actor EXPLOSION2BOT 1 EXPLOSION_FRAMES
  
  seta[].blend 1
  cstator 2
  ifinwater spritepal 1
  else ifspawnedby EXPLOSION2 killit
  else ifspawnedby RPG killit
  ifactioncount 20
    killit
enda

action FFLAME_FR 0 16 1 1 1
action FFLAME 0 1 1 1 1

actor FLOORFLAME 0 FFLAME_FR
  ifaction FFLAME_FR
  {
    ifpdistl 1024
      hitradius 1024 WEAKEST WEAKEST WEAKEST WEAKEST
    ifactioncount 16
      action FFLAME
  }
  ifaction FFLAME
    ifrnd 4
  {
    action FFLAME_FR
    sound CAT_FIRE
    resetactioncount
  }
enda


useractor notenemy HEALTHBOX 100
ife myspawner -1 break
ifg sprite[myspawner].statnum 2 killit
ife actorvar[myspawner].monstatus 2 killit
ifg sprite[].htextra 0
{
	changespritestat myspawner 1
	geta[].htextra temp
	geta[myspawner].htextra tempb
	ife tempb -1 set tempb 0
	add tempb temp
	seta[myspawner].htextra tempb
	seta[myspawner].htowner sprite[].htowner
	seta[myspawner].htang sprite[].htang
	seta[myspawner].htpicnum sprite[].htpicnum
	ifhitweapon strength 100
}
enda

action ASATNSPIN     0 5 1 1 4
action ASATSHOOTING   -10 3 5 1 40
action ASATSHOOTLEFT  -10 1 5 1 18
action ASATSHOOTRIGHT -5  1 5 1 18
action ASATWAIT      0 1 5 1 1
action ASATWAITSHOOT 0  1  5  1  20
move TURRVEL

actor ROTATEGUN ROTTURRETSTRENGTH
// ASATSHOOTING TURRVEL faceplayer

 ifn myspawner -1
 {
	  seta[].cstat sprite[myspawner].cstat
	  seta[].alpha sprite[myspawner].alpha
	  cstator 8
	  set tempb 0
	  geta[myspawner].statnum temp
	  ife temp 1024 set tempb 1
	  ifn sprite[myspawner].picnum DRONE set tempb 1 
	  ifl sprite[myspawner].xrepeat 20 set tempb 1
	  ife tempb 1
	  {
		  strength 0
		  seta[].htextra 10
		  seta[].htpicnum RADIUSEXPLOSION
	  }
	  else
	  {
		  geta[myspawner].x x
		  geta[myspawner].y y
		  geta[myspawner].z z
		  add z 1024
		  seta[].x x
		  seta[].y y
		  seta[].z z
		  geta[myspawner].sectnum temp
		  ifn temp sprite[].sectnum ifvarn temp -1
		  changespritesect THISACTOR temp
	  }
 }
  
  // this looks redundant but protects against code changes in mid saved game
  ifmove TURRVEL nullop else move TURRVEL faceplayer
  ifaction 0
  {
    cstator 256
    ife NEWENEMIES YES ifrnd 32 { addstrength 30 orvar initflags 32 } else
    ifspritepal 42 { addstrength 30 orvar initflags 32 }
	
    // action ASATSHOOTING
	action ASATSHOOTLEFT
    move TURRVEL faceplayer
	// ife myspawner -1
	// {
		// espawn HEALTHBOX
		// seta[RETURN].cstat 33024
		// seta[RETURN].xrepeat 64
		// seta[RETURN].yrepeat 64
		// setav[RETURN].myspawner THISACTOR
	// }
	ifvarand initflags 32
	{
		sound PISTOLFIRE2
		shoot CHAINGUN
	}
	else
	{
		sound PRED_ATTACK
		shoot FIRELASER
	}
  }
  else
    ifaction ASATNSPIN
  {
    geta[].ang angvar
    ifvarand THISACTOR 1 add angvar countvar else sub angvar countvar
	seta[].ang angvar
	sub countvar 6
    ifactioncount 32
    {
      action ASATWAIT
      move TURRVEL faceplayer
    }
  }
  else ifaction ASATSHOOTLEFT
  {
	 ifactioncount 1
		action ASATWAITSHOOT
  }
  else ifaction ASATWAITSHOOT
  {
	ifactioncount 1
	{
		ifvarand initflags 32
		{
			sound PISTOLFIRE2
			shoot SHOTSPARK1
			shoot SHOTSPARK1
		}
		else
		{
			sound PRED_ATTACK
			shoot SHOTSPARK1
			shoot SHOTSPARK1
		}
		action ASATSHOOTRIGHT
	}
  }
  else ifaction ASATSHOOTRIGHT
  {
	ifactioncount 1
	{
		action ASATWAIT
		move TURRVEL faceplayer
	}
  }
  else
    ifaction ASATWAIT
  {
	set temp NO
	ifge SKILL 4 { ifactioncount 32 set temp YES }
	else
    ifactioncount 64 set temp YES
	
	
	ife temp YES
      ifrnd 32
	    ife targetalive YES
			ife seemytarget YES
    {
      // action ASATSHOOTING
	  action ASATSHOOTLEFT
      move TURRVEL faceplayer
	  ifvarand initflags 32
	  {
		sound PISTOLFIRE2
		shoot CHAINGUN
	  }
	  else
	  {
		sound PRED_ATTACK
		shoot FIRELASER
	  }
    }
  }
  seta[].xvel 0
  state monsterai ife monstatus -1 break
  ifhitweapon
  {
    ifdead
    {
	  ifvarn myspawner -1 setav[myspawner].myspawner -1
      addkills 1 state enemy_death
      sound LASERTRIP_EXPLODE
      debris SCRAP1 4
	  state tech_debris
      spawn EXPLOSION2
      killit
    }
    else
    {
      action ASATNSPIN
      debris SCRAP1 4
	  set countvar 264
    }
    move 0
  }
enda

action RIP_F 0 8 1 1 1
actor FORCERIPPLE 0 RIP_F
  ifactioncount 8
    killit
enda

// action TRANSFOWARD 0  6  1  1  2
// action TRANSBACK   5  6  1 -1  2
// actor TRANSPORTERSTAR 0 TRANSFOWARD
  // ifaction TRANSFOWARD
  // {
    // ifactioncount 6
      // action TRANSBACK
  // }
  // else
    // ifactioncount 6
      // killit
// enda

useractor notenemy PHONEDROP 0

ifmove 0
{
	cstat 32
	sizeat 32 32
}

fall

enda

spritenoshade TRANSPORTERSTAR

action TRANSFOWARD 0  6  1  1  2
action TRANSBACK   5  6  1 -1  2
actor TRANSPORTERSTAR 0 TRANSFOWARD
seta[].shade -127
seta[].alpha 128
seta[].blend 1

ifvare mtype 3 killit

ifvare mtype 1
{
	sizeat 3 3
	cstat 2
	
}
else ifvare mtype 0
{
	ifspawnedby PLAYERPLASMA { set mtype 2 spritepal 77 cstator 2 break }
	ifspawnedby PLASMAPROJ { set mtype 2 spritepal 77 cstator 2 break }
	ifspawnedby FREEZEBLAST { set mtype 2 break }
	ifspawnedby FIRELASER { set mtype 2 spritepal 2 break }
	ifspawnedby FIRELASER2 { set mtype 2 spritepal 2 break }
	ifspawnedby FIRELASER3 { set mtype 2 spritepal 2 break }
	ifspawnedby EDFLASER { set mtype 2 spritepal 2 break }
	ifspawnedby DRWILY { move STOPPED faceplayer cstat 530 set mtype 2 spritepal 1 sizeat 16 32 break }
	// cstat 32768
	// addvar initsprite 1
	// set lastang 0
	// whilevarn lastang 8
	// {
		// espawn TRANSPORTERSTAR
		// setav[RETURN].initsprite initsprite
		// randvar x 192
		// randvar y 256
		// randvar z 6144
		// ifrnd 128 mulvar z -1
		// ifrnd 128 mulvar x -1
		// ifrnd 128 mulvar y -1
		// getactor[].x temp
		// add temp x
		// seta[RETURN].x temp
		// getactor[].y temp
		// add temp y
		// seta[RETURN].y temp
		// getactor[].z temp
		// add temp z
		// seta[RETURN].z temp
		// setav[RETURN].mtype 1
		// seta[RETURN].cstat 32768
		// ifspritepal 91 seta[RETURN].pal 91
		// else
		// {
			// ifrnd 128 seta[RETURN].pal 2 else seta[RETURN].pal 7
		// }
		// addvar lastang 1
		
	// }
	// ifvare initsprite 30 killit
	ife mtype 0 { spawn GLARESTAR killit }
}

  ifaction TRANSFOWARD
  {
    ifactioncount 6
      action TRANSBACK
  }
  else
    ifactioncount 6
      killit
enda

action BEAMFOWARD  0  4  1  1  9
actor TRANSPORTERBEAM 0 BEAMFOWARD
  sizeto 32 64
  sizeto 32 64
  sizeto 32 64
  ifactioncount 4
    killit
enda

move TARGETSPIN
defstate targetcode
	
	ifmove 0
	{
		ifspawnedby APLAYER
		{
			// state spawnmysignpost
			set monstatus 1
			sizeat 30 30
			cstator 256
			strength 15000
		}
		geta[].pal countvar
		move STOPPED
		spriteflags 1056769
		geta[].ang angvel
		ifn starty 0
		{
			set SPRITELOTAG startx
			set mtype 9
			set botclip 25
		}
	}
	state monsterai
	
	ifn starty 0
	{
		set monstatus 2
		set monxp 0
		ifmove STOPPED
		{
			set target reconpoints[SPRITELOTAG]
			geta[target].x x2
			geta[target].y y2
			geta[].x x
			geta[].y y
			sub x2 x
			sub y2 y
			getangle angvar x2 y2
			
			ldist xydist THISACTOR target
		
			ifvarl xydist 512
			{
				add SPRITELOTAG 1
				ifg SPRITELOTAG highrecon set SPRITELOTAG 0
			}
			else
			{
				cos xvel angvar
				sin yvel angvar
					  
				shiftr xvel mtype
				shiftr yvel mtype
				
				geta[].z z
				sub z sprite[target].z
				shiftr z 1
						 
				movesprite THISACTOR xvel yvel z CLIPMASK0 RETURN
			}
		}
	}
	
	ife attmode YES ife VOLUME 5 ife LEVEL 11
	ife starty 0
	{
		ife bigmsg 1137 ifg bigmsgcount 0 
		ifn SPRITELOTAG 0
		{
			strength 0
			seta[].htextra 10
			seta[].htpicnum STUCKARROW
		}
	}

	ifhitweapon 
	{
		ifn sprite[].htpicnum STUCKARROW 
		{
			sound CONCRETEHIT1
			move TARGETSPIN spin
			cstat 16
		}
		
		ifstrength 10 
		ife starty 0
		{
			ifn SPRITELOTAG 0 
			state activatechannel
			set SPRITELOTAG 0
		}
		
		ifn starty 0 
		{
			ifg mtype 4 sub mtype 1	
			set monxp botclip
			set monstatus 1
			state enemy_death
			set monstatus 1
			// add botclip 50
			mul botclip 2
			ifg botclip 300 set botclip 300
			ifl mtype 5
			{
				debris SCRAP3 3
				spritepal 2
				debris SCRAP3 3
				spritepal 8
				debris SCRAP3 3
				spritepal 4
				debris SCRAP3 4
				killit
			}
		}
	}
	
	ifmove TARGETSPIN 
	{
		ifangdiffl 512 spritepal 4 else seta[].pal countvar
		geta[].ang angvar
		add angvar 128
		seta[].ang angvar
		ifcount 15 
		{
			seta[].pal countvar
			move STOPPED geth
			seta[].ang angvel
			cstat 272
		}
	}

ends

eventloadactor NEWTROOPTARGET 
geta[].lotag SPRITELOTAG seta[].lotag 0 
geta[].extra startx // initial pigsuvpoint lotag target
ife startx -1 set startx 0
geta[].hitag starty // moving type
seta[].hitag 0
enda

eventloadactor NEWPIGTARGET 
geta[].lotag SPRITELOTAG seta[].lotag 0 
geta[].extra startx // initial pigsuvpoint lotag target
ife startx -1 set startx 0
geta[].hitag starty // moving type
seta[].hitag 0
enda

useractor notenemy NEWTROOPTARGET 900 0 state targetcode enda
useractor notenemy NEWPIGTARGET 900 0 state targetcode enda

spritenoshade RADWOUND
useractor notenemy RADWOUND 0

	ifmove 0
	{
		move STOPPED
		sizeat 8 8
		ifspawnedby BIGBOIPROJ sizeat 24 24
		seta[].shade -100
		rand countvar 6
		add countvar 4
	}
	cstat 128
	ifrnd 128 cstator 4
	ifrnd 128 cstator 8
	// ifspritepal 0 ifrnd 64 spritepal 6 else spritepal 0

	ifn myvictim -1
	{

		ifg sprite[myvictim].statnum 2 { set myvictim -1 break }
		ife actorvar[myvictim].monstatus 2 { set myvictim -1 break }
		getactor[myvictim].x x
		getactor[myvictim].y y
		getactor[myvictim].ang angvar
		subvarvar angvar angvel
		// sub angvar 512
		setvarvar x2 x
		addvarvar x2 mtype
		rotatepoint x y x2 y angvar x y

		setactor[].x x
		setactor[].y y
		
		getactor[myvictim].z z
		
		subvarvar z shotpitch
		setactor[].z z
		
		ifrnd 64
		{
			espawn SMALLSMOKE seta[RETURN].pal 8
			ifrnd 84
			{
				geta[myvictim].htextra temp
				ifl temp 1 set temp 1 else
				add temp 1
				ife sprite[].xrepeat 24 { add temp 2 ife temp 3 seta[myvictim].htpicnum RADWOUND }
				seta[myvictim].htextra temp
				seta[myvictim].htowner player[].i
				ife temp 1
				seta[myvictim].htpicnum RADWOUND
				ife sprite[myvictim].htpicnum RADWOUND seta[myvictim].htowner player[].i
				sub countvar 1
			}
		}
		
		
		ifl countvar 1 set myvictim -1
	}
	else ifcount 20 sizeto 0 0


enda


state random_wall_jibs
  ifrnd 96
    shoot BLOODSPLAT1
  ifrnd 96
    shoot BLOODSPLAT2
  ifrnd 96
    shoot BLOODSPLAT3
  ifrnd 96
    shoot BLOODSPLAT4
  ifrnd 96
    shoot BLOODSPLAT1
ends

spritenoshade WOUNDSPRITE
useractor notenemy WOUNDSPRITE 0

	ifmove 0
	{
		move STOPPED
		sizeat 16 14
		cstator 128
		ifrnd 128 cstator 4
		ifrnd 128 cstator 8
		spawn AABLOOD
	}
	ifcount 4 cstator 2
	ifcount 6 cstator 512
	ifcount 8 killit

enda

action ABLOODSPLASH  0  4  1  1  20

defstate bloodsplashcode

cstat 128

ifspawnedby SHOTSPARK1
{	
	sizeto 20 24 sizeto 20 24
	ifactioncount 3 cstator 2
	ifactioncount 4 killit
	break
}
sizeto 72 72 sizeto 72 72
ifactioncount 4 
{
	state random_wall_jibs
	killit
}
ends

useractor notenemy BLOODSPLASH1 0 ABLOODSPLASH state bloodsplashcode enda
useractor notenemy BLOODSPLASH2 0 ABLOODSPLASH state bloodsplashcode enda
useractor notenemy BLOODSPLASH3 0 ABLOODSPLASH state bloodsplashcode enda

action AABLOODFRAMES  1  4  1  1  15
useractor notenemy AABLOOD 0 AABLOODFRAMES

cstat 128
sizeto 72 72 sizeto 72 72
ifactioncount 4 killit

enda

action FIRE_FRAMES   -1 14 1 1 1
move FIREVELS

state firestate

  ife monstatus 2
  {
	cactor BIGSMOKE
	action 0
	move 0
  }
  ifaction 0
    ifrnd 16
    {
      action FIRE_FRAMES
      cstator 128
    }

  sleeptime 300         // Never let it fall to sleep

  ifspawnedby FIRE
  {
    ifgapzl 16
      break
  }
  else
    ifspawnedby FIRE2
  {
    ifgapzl 16
      break
  }

  ifinwater
    killit

  ifp palive
    ifpdistl 844
      ifrnd 32
        ifcansee
  {
    // soundonce DUKE_LONGTERM_PAIN
    // addphealth -1
	getp[].i spriteid
	  getav[spriteid].burning temp
	  add temp 1
	  setav[spriteid].burning temp
    palfrom 32 32
  }

  ifactor FIRE
  {
    ifspawnedby FIRE
      break
  }
  else
    ifactor FIRE2
      ifspawnedby FIRE2
        break

  iffloordistl 128
  {
    ifrnd 128
    {
      ifcount 84
        killit
                // This line(and the else below)
                // is not necessary, since actors
                // with zero x-size are automatically
                // deleted anyway!
      else
        ifcount 42
          sizeto 0 0
      else
        sizeto 32 32
    }
  }
  else
    killit

ends

useractor notenemy FIRE WEAK 0 FIREVELS state firestate enda
useractor notenemy FIRE2 WEAK 0 FIREVELS state firestate enda

eventloadactor FECES sizeat 12 12 enda
actor FECES
  ifcount 24
  {
    ifpdistl RETRIEVEDISTANCE
    {
      ifrnd SWEARFREQUENCY
        soundonce DUKE_STEPONFECES

      sound STEPNIT

      spawn BLOODPOOL   // Will be brown
      killit
    }
  }
  else
    sizeto 12 12
enda

defstate drop_ammo
  ifg gametype 0 break
  
  ifvarand charsel 4
  {
	ifvarand wesupgrades[PISTOL_WEAPON] 4 nullop else
	{
		ifrnd 80 { spawn FIRSTGUNSPRITE break }
	}
  }
  ife player[].gotweapon PISTOL_WEAPON NO
  {
    ifrnd SPAWNAMMOODDS { spawn FIRSTGUNSPRITE break }
  }
  ifrnd 24
  {
	state rand_db_bow
	break
  }
  ifrnd SPAWNAMMOODDS
    spawn AMMO
  else
  ifvarand initflags 16
    spawn AMMO
	
ifvarand inven_upgrades 32
  ifle cover_amount 200
	ifrnd 64
		spawn COVERSPRITE
ends

state drop_battery
  ifg gametype 0 break
  ifrnd SPAWNAMMOODDS
    spawn BATTERYAMMO
ends
state drop_sgshells
  ifg gametype 0 break
  ifrnd SPAWNAMMOODDS
    spawn SHOTGUNAMMO
ends
state drop_shotgun
  ifg gametype 0 break
  ifrnd SPAWNAMMOODDS
  {
    ifrnd 48
	{
		state rand_db_bow
	}
	else
	{
		espawn SHOTGUNSPRITE
		setav[RETURN].droptile PIGCOP
	}
	sound ENDSEQVOL2SND1
  }
  else ifvarand initflags 8
  {
	espawn SHOTGUNSPRITE
	setav[RETURN].droptile PIGCOP
	sound ENDSEQVOL2SND1
  }
ends
state drop_chaingun
  ifg gametype 0 break
  ifrnd SPAWNAMMOODDS
  {
    ifactor LIZMAN ifvarand initflags 8 { espawn GROWSPRITEICON break }
    ifrnd 32
	{
      spawn CHAINGUNSPRITE
	  sound ENDSEQVOL2SND1
	}
    else
	ifrnd 32
	{
		state rand_db_bow
	}
	else 
      spawn BATTERYAMMO
  }
ends


state toughgalspeech
  ifrnd 64
  {
    ifnosounds
      soundonce TOUGHGALSND1
  }
  else
    ifrnd 64
  {
    ifnosounds
      soundonce TOUGHGALSND2
  }
  else
    ifrnd 64
  {
    ifnosounds
      soundonce TOUGHGALSND3
  }
  else
    ifnosounds
      soundonce TOUGHGALSND4
ends

action FEMSHRUNK
action FEMFROZEN1 1
action FEMGROW
action FEMFROZEN2
action FEMDANCE1 19 1 1 1 16
action FEMDANCE3 19 1 1 1 26
action FEMDANCE2 20 2 1 1 10
action FEMDANCE4 5  1 1 1 30
action FEMDANCE5 6  1 1 1 10
action FEMDANCE6 7  1 1 1 20
action FEMDANCE7 11 1 1 1 20
action FEMDANCE8 5  1 1 1 30
action FEMDANCE9 1  1 1 1 30
action FEMDANCE10  2 1 1 1 30
action FEMDANCE11A 2 1 1 1 30
action FEMDANCE11B 3 1 1 1 60
action FEMDANCE11C 2 1 1 1 30
action FEMDANCE12 223 1 1 1 30
action NURSEHEAL1 1 1 1 1 30
action NURSEHEAL2 2 1 1 1 60

action FEMANIMATESLOW 0 2 1 1 100
action TOUGHGALANIM   0 5 1 1 25
action FEMANIMATE 0 1 1 1 1
action FEMNEW1 4262 3 1 1 100
action FEMNEW2 4257 0 1 1 1
action FEMNEW3 4985 3 1 1 100

defstate femcode
  set team 3 // noncombatant
  ife monstatus 0 set monstatus 1
  set spawnprotect 0
  state monsterai
  ife gametype -1 seta[].htextra -1
  
  ifactor NAKED1 nullop
  else
    ifactor FEM6 nullop
  else
    ifactor NEWHANGBABE nullop else
	ifactor NEWSLIMEBABE nullop else
	ifactor NEWSLIMEBABE2 nullop else
	ifactor BLUEHANGBABE nullop else
	ifactor SCUBAGIRL nullop else
    {
      fall
	  switch sprite[].picnum
	  case BLOODYPOLE
	  case BLOODYPOLE2
	  case BLOODYPOLE3
	  case BLOODYPOLE4
        ifhitweapon
          ifdead
      {
		set monstatus 2
		spritepal 6
		debris SCRAP3 12
		getlastpal
        state lite_jibs
        killit
      }
	  break
	  endswitch
    }

  ifaction FEMSHRUNK
  {
    ifcount SHRUNKDONECOUNT
    {
      action FEMANIMATE
      cstat 257
    }
    else
      ifcount SHRUNKCOUNT
	  {
	    switch sprite[].picnum
		case POLESTRIPPER case BLUEHANGBABE case NEWSLIMEBABE case NEWSLIMEBABE2 case SCUBAGIRL
		case LARRY case GARFIELD case ORCHID case CHUNLI case FEM12 case FEM13 case FEM14
		sizeto 30 28 break
		case FEM11 sizeto 28 28 break
		default sizeto 40 40 break
		endswitch
	  }
    else
      state genericshrunkcode
  }
  else ifaction FEMGROW
  {
    ifcount 32
    {
      respawnhitag
      guts JIBS4 20
      guts JIBS6 20
      spritepal 6
	
	  ifactor GARFIELD nullop else
	  ifactor LARRY soundonce MC_DEATH else
	  ifactor TUBEGUY soundonce MC_DEATH else
	  ifactor ROSHI soundonce MC_DEATH else
	  ifactor TEXTINGNPC1 soundonce MC_DEATH else
	  ifactor TEXTINGNPC3 soundonce MC_DEATH else
	  ifactor FLASHER4 soundonce MC_DEATH else
	  ifactor FLASHER3 soundonce PIG_DYING else
	  ifactor FROGMASCOT 
	  {
		soundonce MC_DEATH 
		spritepal 32
		debris SCRAP3 18
	  }
	  else
	  ifactor CHUNLI soundonce CHUNLIDIES
	  else
      soundonce LADY_SCREAM
      ifactor NAKED1
        debris SCRAP3 4
      else
        ifactor PODFEM1
          debris SCRAP3 4
      sound SQUISHED
	  set monstatus 2
	  state spawnbabe
      killit
    }
    else
      sizeto MAXXSTRETCH MAXYSTRETCH
  }

  else
    ifaction FEMDANCE1
  {
    ifactioncount 2
      action FEMDANCE2
  }
  else
    ifaction FEMDANCE2
  {
    ifactioncount 8
      action FEMDANCE3
  }
  else
    ifaction FEMDANCE3
  {
    ifactioncount 2
    action FEMANIMATE
  }
  else
    ifaction FEMDANCE4
  {
    ifactioncount 1
	action FEMDANCE5
  }
  else
    ifaction FEMDANCE5
  {
    ifactioncount 8
	action FEMANIMATE
  }
  else
    ifaction FEMDANCE6
  {
    ifactioncount 16
	action FEMANIMATE
  }
  else
    ifaction FEMDANCE7
  {
	ifactioncount 12
	action FEMANIMATE
  }
  else
    ifaction FEMDANCE9
  {
    ifactioncount 8
	action FEMANIMATE
  }
  else
    ifaction FEMDANCE10
  {
    ifactioncount 4
	action FEMANIMATE
  }
  else
    ifaction FEMDANCE11A
  {
    ifactioncount 1 action FEMDANCE11B
  }
  else
  ifaction FEMDANCE11B
  {
    ifactioncount 1 action FEMDANCE11C
  }
  else
  ifaction FEMDANCE11C
  {
    ifactioncount 1 action FEMANIMATE
  }
  else
  ifaction FEMDANCE12
  {
    ifactioncount 6 action FEMANIMATE
  }
  else
  ifaction NURSEHEAL1
  {
	ifactioncount 1
	{
		ifpdistl 1280
		{
			sound AIRBURST
			action NURSEHEAL2
		}
		else action FEMANIMATE
	}
  }
  else
  ifaction NURSEHEAL2
  {
    ifl sprite[player[].i].extra player[].max_player_health { cactor ATOMICHEALTH add mtype 1 addphealth 1 cactor HELLONURSE }
	ifactioncount 1 action FEMANIMATE
  }
  else
    ifaction FEMFROZEN1
  {
    ifcount THAWTIME
    {
      action FEMANIMATE
      getlastpal
    }
    else
      ifcount FROZENDRIPTIME
    {
      ifactioncount 26
      {
        spawn WATERDRIP
        resetactioncount
      }
    }
	ifvarand sprite[].cstat 512 seta[].htextra -1
    ifhitweapon
    {
      ifwasweapon FREEZEBLAST
      {
	    resetcount resetactioncount
        strength 0
        break
      }
	  lotsofglass 10
      state standard_jibs
      sound GLASS_BREAKING
      respawnhitag
      ifrnd 84
        spawn BLOODPOOL
      set monstatus 2
      killit
    }
    else
      ifp pfacing
        ifpdistl FROZENQUICKKICKDIST
          state pkick_check
    break
  }
  else ifaction FEMFROZEN2
  {
    ifcount THAWTIME
    {
      ifactor TOUGHGAL
        action TOUGHGALANIM
      else
        ifactor FEM10
          action FEMANIMATESLOW
	  else
		ifactor SISTERS
		  action ANULLACTION
      else
        action FEMANIMATE

      getlastpal
    }
    else
      ifcount FROZENDRIPTIME
    {
      ifactioncount 26
      {
        spawn WATERDRIP
        resetactioncount
      }
    }
	ifvarand sprite[].cstat 512 seta[].htextra -1
    ifhitweapon
    {
      ifwasweapon FREEZEBLAST
      {
	    resetcount resetactioncount
        strength 0
          break
      }

      state standard_jibs
	  lotsofglass 10
      sound GLASS_BREAKING
      ifrnd 84
        spawn BLOODPOOL
      respawnhitag
	  set monstatus 2
      ifrnd 128
        sound DUKE_HIT_STRIPPER1
      else
        sound DUKE_HIT_STRIPPER2

      killit
    }
    else
      ifp pfacing
        ifpdistl FROZENQUICKKICKDIST
          state pkick_check
    break
  }

  ifactor FEM13
  {
	ifaction FEMDANCE8
	{
		ifcount 150 
		{
			action FEMANIMATE
			resetcount
		}
	}
	else
	ifaction FEMANIMATE
	{
		ifcount 150 
		{
			action FEMDANCE8
			resetcount
		}
	}
  }
  ifvarand sprite[].cstat 512 seta[].htextra -1
  ifhitweapon
  {
    ifdead
    {
      ifwasweapon GROWSPARK
      {
        cstat 0
        move 0
        sound ACTOR_GROWING
        action FEMGROW
        break
      }
      else ifwasweapon FREEZEBLAST
      {
        ifaction FEMSHRUNK
          break

        ifactor NAKED1
          action FEMFROZEN2
        else
          ifactor FEM5
            action FEMFROZEN2
        else
          ifactor FEM6
            action FEMFROZEN2
        else
          ifactor FEM8
            action FEMFROZEN2
        else
          ifactor FEM9
            action FEMFROZEN2
        else
          ifactor FEM10
            action FEMFROZEN2
        else
          ifactor TOUGHGAL
            action FEMFROZEN2
        else
          ifactor PODFEM1
            action FEMFROZEN2
	    else
		  ifactor SISTERS
		    action FEMFROZEN2
		else
		  ifactor BLUEHANGBABE
		    action FEMFROZEN2
        else
		  ifactor FEM15
		    action FEMFROZEN2
		else
		  ifactor ELFGIRL
			action FEMFROZEN2
		else
		  ifactor BOOTHBABE
			action FEMFROZEN2
		else
          action FEMFROZEN1

        move 0
        spritepal 1
        strength 0

        sound NEWFREEZE
		state freezeme
        break
      }
      set monstatus 2
      ifrnd 128
        sound DUKE_HIT_STRIPPER1
      else
        sound DUKE_HIT_STRIPPER2

      respawnhitag
      state standard_jibs
      state random_wall_jibs
      spawn BLOODPOOL

      ifactor FEM1
        money 5
      else
        ifactor FEM2
      {
        money 7
		action 0
        cactor BARBROKE
        cstat 0
      }
      else
        ifactor FEM3
          money 4
      else
        ifactor FEM7
          money 8

      ifactor FEM5
      {
        strength TOUGH
		action FEMANIMATE
        cactor BLOODYPOLE
      }
      else ifactor FEM6
      {
        cstat 0
        cactor FEM6PAD
		action FEMANIMATE
      }
      else
        ifactor FEM8
      {
        strength TOUGH
        cactor BLOODYPOLE
      }
	  else
	    ifactor NEWSLIMEBABE2
	  {
	    strength TOUGH
		cactor BLOODYPOLE
		soundonce LADY_SCREAM
	  }
	  else
	   ifactor FEM12
	  {
	    strength TOUGH
		cactor BLOODYPOLE
		soundonce LADY_SCREAM
	  }
      else
      {
        spritepal 6
		ifactor GARFIELD nullop else
		ifactor LARRY soundonce MC_DEATH else
		ifactor TUBEGUY soundonce MC_DEATH else
		ifactor ROSHI soundonce MC_DEATH else
		ifactor TEXTINGNPC1 soundonce MC_DEATH else
		ifactor TEXTINGNPC3 soundonce MC_DEATH else
		ifactor FLASHER4 soundonce MC_DEATH else
		ifactor FLASHER3 soundonce PIG_DYING else
		ifactor CHUNLI soundonce CHUNLIDIES else
        soundonce LADY_SCREAM
		
        ifactor NAKED1
          debris SCRAP3 18
        else
          ifactor PODFEM1
            debris SCRAP3 18
		else
		  ifactor FEM11
		    debris SCRAP3 18
	    else
		  ifactor NEWSLIMEBABE
		    debris SCRAP3 18
		else
		  ifactor NEWSLIMEBABE2
		    debris SCRAP3 18
	    else
		  ifactor FEM12
		    debris SCRAP3 18
		else
		  ifactor BLUEHANGBABE
		    debris SCRAP3 10
		else
		  ifactor FROGMASCOT
		  {
		    soundonce MC_DEATH
			spritepal 32
			debris SCRAP3 18
		  }
        killit
      }
    }
    else
    {
      ifwasweapon SHRINKSPARK
      {
        sound ACTOR_SHRINKING
		set shrunken 1
        // move 0
        // action FEMSHRUNK
        // cstat 0
        break
      }
      else
        ifwasweapon GROWSPARK
          sound SPARKLESOUND
      ifactor FEM8
        break

      ifactor TOUGHGAL
          state toughgalspeech
      else sound SQUISHED

      guts JIBS6 1
    }
  }
ends

state killme
  ifinwater nullop
  else
    ifp pfacing
      ifpdistl 1280
        ifhitspace
          soundonce KILLME
ends

defstate giftcheck
	ife pchar 0
	ifvarand perks 128
	ife botclip 0
	{
		set botclip YES
		quote 1359
		
		ifrnd 128
		{
			ifrnd 128 espawn AMMO else
			espawn COLA
		}
		else
		{
			state spawn_goodie2
			geta[RETURN].z z, sub z 8192, seta[RETURN].z z
			espawn TRANSPORTERSTAR
			geta[RETURN].z z, sub z 8192, seta[RETURN].z z
		}
	}
ends

defstate tipme
  ifspritepal 1 break
  ifaction FEMDANCE11B break
  ifp pfacing
    ifpdistl 1280
      ifhitspace
  {
    ifactor HELLONURSE
	{
		ifaction FEMANIMATE
		ifl mtype 100
			action NURSEHEAL1
	}
	else
	{
		tip
		ifrnd 128
		  soundonce DUKE_TIP1
		else
		  soundonce DUKE_TIP2
		  
		state giftcheck
		
	} 
    ifactor FEM1
      action FEMDANCE1
	else
	ifactor ORCHID
	  action FEMDANCE4
	else
	ifactor FEM13
	  action FEMDANCE7
	else
	ifactor FEM14
	  action FEMDANCE12
	ifactor CHUNLI
	{
	  action FEMDANCE6
	  soundonce CHUNLIHAPPY
	}
	else
	ifactor FEM15
	{
	  ifaction FEMANIMATE
	  {
		add mtype 1
		ifg mtype 3 set mtype 0
		  action FEMDANCE9
		ife mtype 0 soundonce BATHCOMM1
		ife mtype 1 soundonce BATHCOMM2
		ife mtype 2 soundonce BATHCOMM3
		ife mtype 3 soundonce BATHCOMM4
	  }
	}
	else
	ifactor FEM17
	  action FEMDANCE10
	ifactor BETTY
	  action FEMDANCE10
	else
	ifactor FEM18
	  action FEMDANCE11A
	
  }
ends

state toughgaltalk
  ifp pfacing
    ifpdistl 1280
      ifhitspace
        state toughgalspeech
ends

actor FEM1 TOUGH FEMANIMATE
  state tipme
  state femcode
enda
actor FEM2 TOUGH FEMANIMATE
  state tipme
  state femcode
enda
actor FEM3 TOUGH FEMANIMATE
  state tipme
  state femcode
enda
actor FEM4 TOUGH FEMANIMATE
  state femcode
enda
// actor FEM5 TOUGH FEMNEW1
  // state killme
  // state femcode
// enda


// actor FEM6 TOUGH FEMNEW2
  // state killme
  // state femcode
// enda

action ANEWFEMANG5  0  2  5  1  50
action ANEWFEMANG8  0  2  8  1  50
action ANEWANG5FRO  0  1  8  1  10
action ANEWANG8FRO  0  1  8  1  10

state newfemcode
  ifmove 0
  {
	  move STOPPED geth
	  set team 3 // noncombatant
	  set monstatus 1
	  set spawnprotect 0
  }
  state monsterai
  ife gametype -1 seta[].htextra -1
  
  ifaction FEMSHRUNK
  {
    ifcount SHRUNKDONECOUNT
    {
      action FEMANIMATE
      cstat 257
    }
    else
      ifcount SHRUNKCOUNT
	    sizeto 40 40 
    else
      state genericshrunkcode
  }
  else ifaction FEMGROW
  {
    ifcount 32
    {
      ifn SPRITELOTAG 0 seta[].hitag SPRITELOTAG
      respawnhitag
	  seta[].hitag 0
      guts JIBS4 20
      guts JIBS6 20
      spritepal 6
	  
      soundonce LADY_SCREAM
      sound SQUISHED
	  set monstatus 2
      killit
    }
    else
      sizeto MAXXSTRETCH MAXYSTRETCH
  }
  else
    ifspritepal 1
  {
    ifcount THAWTIME
    {
	  ifactor NEWNAKED1
	  action ANEWFEMANG5
	  else
	  ifactor NEWNAKED2
	  action ANEWFEMANG5
	  else
	  ifactor NEWPODFEM1
	  action ANEWFEMANG5
	  else
	  ifactor NEWFEM9
	  action ANEWFEMANG5
	  else
      action ANEWFEMANG8
      getlastpal
    }
    else
      ifcount FROZENDRIPTIME
    {
      ifactioncount 26
      {
        spawn WATERDRIP
        resetactioncount
      }
    }

    ifhitweapon
    {
      ifwasweapon FREEZEBLAST
      {
	    resetcount resetactioncount
        strength 0
        break
      }
	  lotsofglass 10
      state standard_jibs
      sound GLASS_BREAKING
      ifn SPRITELOTAG 0 seta[].hitag SPRITELOTAG
      respawnhitag
	  seta[].hitag 0
      ifrnd 84
        spawn BLOODPOOL
      set monstatus 2
      killit
    }
    
    break
  }
  ifhitweapon
  {
    ifdead
    {
	  ife babesaved THISACTOR set babesaved -1
      ifwasweapon GROWSPARK
      {
        cstat 0
        sound ACTOR_GROWING
        action FEMGROW
        break
      }
      else ifwasweapon FREEZEBLAST
      {
        ifaction FEMSHRUNK
          break

		ifactor NEWNAKED1
		action ANEWANG5FRO
	    else
		ifactor NEWPODFEM1
		action ANEWANG5FRO
		else
		ifactor NEWFEM9
		action ANEWANG5FRO
		else
		ifactor NEWNAKED2
		action ANEWANG5FRO
		else
        action ANEWANG8FRO

        spritepal 1
        strength 0
		resetcount

        sound NEWFREEZE
		state freezeme
        break
      }
      set monstatus 2
      ifrnd 128
        sound DUKE_HIT_STRIPPER1
      else
        sound DUKE_HIT_STRIPPER2
	  ifn SPRITELOTAG 0 seta[].hitag SPRITELOTAG
      respawnhitag
	  seta[].hitag 0
      state standard_jibs
      state random_wall_jibs
	  ifactor NEWPODFEM1
	  {
		spritepal 6
		debris SCRAP3 12
		killit
	  }
	  ifactor NEWFEM9
	  {
		cactor BLOODYPOLE3
		strength TOUGH
	  }
	  ifactor SNIPERCAUGHT
	  {
	    cactor BLOODYPOLE3
		strength TOUGH
		espawn EDFSNIPER
		seta[RETURN].pal sprite[].pal
		seta[RETURN].htextra 30
		seta[RETURN].htpicnum RPG
		seta[RETURN].htang sprite[].htang
	  }
	  ifactor SNIPERHANG
	  {
		espawn 18245
		// cactor NEWCEILSLIME
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		geta[].cstat temp
		ifvarand temp 1 xorvar temp 1
		ifvarand temp 256 xorvar temp 256
		seta[RETURN].cstat temp
		espawn EDFSNIPER
		seta[RETURN].pal sprite[].pal
		seta[RETURN].htextra 30
		seta[RETURN].htpicnum RPG
		seta[RETURN].htang sprite[].htang
		killit
	  }
	  ifactor NEWPODFEM2
	  {
		spritepal 6
		debris SCRAP3 12
		killit
	  }
	  ifactor NEWFEM5
	  {
		cactor BLOODYPOLE
		strength TOUGH
	  }
	  ifactor NEWFEM8
	  {
		cactor BLOODYPOLE2
		strength TOUGH
	  }
	  ifactor NEWFEM11
	  {
		cactor BLOODYPOLE4
		strength TOUGH
	  }
      ifactor NEWFEM6
	  {
		cactor FEM6PAD
        cstat 0
	  }
	  ifactor NEWFEM10
	  {
	    cactor FEM6PAD
		cstat 0
	  }
	  ifactor NEWFEM7
	  {
	    cactor FEM6PAD
        cstat 0
	  }
	  ifactor NEWNAKED1 
	  {
	    espawn 18245
		// cactor NEWCEILSLIME
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		geta[].cstat temp
		ifvarand temp 1 xorvar temp 1
		ifvarand temp 256 xorvar temp 256
		seta[RETURN].cstat temp
		killit
	  }
	  ifactor NEWNAKED2
	  {
		espawn 18245
		// cactor NEWCEILSLIME2
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		geta[].cstat temp
		ifvarand temp 1 xorvar temp 1
		ifvarand temp 256 xorvar temp 256
		seta[RETURN].cstat temp
		killit
	  }
	  action FEMANIMATE
    }
    else
    {
      ifwasweapon SHRINKSPARK
      {
        sound ACTOR_SHRINKING
		set shrunken 1
        break
      }
      else
        ifwasweapon GROWSPARK
          sound SPARKLESOUND
      

      sound SQUISHED

      guts JIBS6 1
    }
  }
ends

defstate saveme

  ifg countvar 0 // rescue process has started
  {
	seta[].htextra -1
	add countvar 1
	ifle countvar 60
	{
		set temp player[].player_par
		modvar temp 6
		ife temp 0
		{
			geta[].z savz, sub savz 8192 seta[].z savz
			espawn BIGSMOKE seta[RETURN].pal 6 
			rand x 768 sub x 384 add x sprite[RETURN].x seta[RETURN].x x
			rand y 768 sub y 384 add y sprite[RETURN].y seta[RETURN].y y
			add savz 8192 seta[].z savz
		}
		// ifspritepal 6 getlastpal else spritepal 6
		geta[].alpha temp
		add temp 4
		seta[].alpha temp
	}
	else 
	{
		ifspritepal 6 getlastpal
		ife countvar 61 
		{
			ifactor NEWFEM5 
			{ 
				espawn BLOODLESSPOLE
				ifvarand sprite[].cstat 8 seta[RETURN].cstat 8
				seta[RETURN].xrepeat sprite[].xrepeat
				seta[RETURN].yrepeat sprite[].yrepeat
				espawn SAVEDNEWFEM5 
			} 
			else
			ifactor NEWFEM8
			{ 
				espawn BLOODLESSPOLE2
				ifvarand sprite[].cstat 8 seta[RETURN].cstat 8
				seta[RETURN].xrepeat sprite[].xrepeat
				seta[RETURN].yrepeat sprite[].yrepeat
				espawn SAVEDFEM8
			}
			else
			ifactor NEWFEM11
			{ 
				espawn BLOODLESSPOLE4
				ifvarand sprite[].cstat 8 seta[RETURN].cstat 8
				seta[RETURN].xrepeat sprite[].xrepeat
				seta[RETURN].yrepeat sprite[].yrepeat
				espawn SAVEDFEM11
			}
			else
			ifactor NEWPODFEM2 
			{ 
				espawn EMPTYPOD2
				ifvarand sprite[].cstat 8 seta[RETURN].cstat 8
				seta[RETURN].xrepeat sprite[].xrepeat
				seta[RETURN].yrepeat sprite[].yrepeat
				espawn SAVEDPOD2 
			} 
			else
			ifactor NEWFEM6
			{
				espawn NEWFEM6PAD
				ifvarand sprite[].cstat 8 seta[RETURN].cstat 8
				seta[RETURN].xrepeat sprite[].xrepeat
				seta[RETURN].yrepeat sprite[].yrepeat
				espawn SAVEDNEWFEM6 
			}
			else
			ifactor NEWFEM10
			{
				espawn NEWFEM6PAD
				ifvarand sprite[].cstat 8 seta[RETURN].cstat 8
				seta[RETURN].xrepeat sprite[].xrepeat
				seta[RETURN].yrepeat sprite[].yrepeat
				espawn SAVEDFEM10
			}
			else
			ifactor NEWFEM7
			{
				espawn NEWFEM6PAD
				ifvarand sprite[].cstat 8 seta[RETURN].cstat 8
				seta[RETURN].xrepeat sprite[].xrepeat
				seta[RETURN].yrepeat sprite[].yrepeat
				espawn SAVEDNEWFEM7 
			}
			else
			ifactor NEWNAKED1 
			{
				espawn 18245 // NEWCEILSLIME
				ifvarand sprite[].cstat 8 seta[RETURN].cstat 8
				seta[RETURN].xrepeat sprite[].xrepeat
				seta[RETURN].yrepeat sprite[].yrepeat
				espawn SAVEDNEWNAKED1 
			}
			else
			ifactor NEWNAKED2
			{
				espawn 18245 // NEWCEILSLIME2
				ifvarand sprite[].cstat 8 seta[RETURN].cstat 8
				seta[RETURN].xrepeat sprite[].xrepeat
				seta[RETURN].yrepeat sprite[].yrepeat
				espawn SAVEDNEWNAKED2 
			}
			else
			ifactor NEWPODFEM1
			{
				espawn EMPTYPOD
				ifvarand sprite[].cstat 8 seta[RETURN].cstat 8
				seta[RETURN].xrepeat sprite[].xrepeat
				seta[RETURN].yrepeat sprite[].yrepeat
				espawn SAVEDNEWFEM5
			}
			else
			ifactor SNIPERCAUGHT
			{
				espawn BLOODLESSPOLE3
				ifvarand sprite[].cstat 8 seta[RETURN].cstat 8
				seta[RETURN].xrepeat sprite[].xrepeat
				seta[RETURN].yrepeat sprite[].yrepeat
				espawn EDFSNIPER
				seta[RETURN].pal sprite[].pal
				killit
			}
			else
			ifactor SNIPERHANG
		  {
			espawn 18245 // NEWCEILSLIME
			ifvarand sprite[].cstat 8 seta[RETURN].cstat 8
			seta[RETURN].xrepeat sprite[].xrepeat
			seta[RETURN].yrepeat sprite[].yrepeat
			espawn EDFSNIPER
			seta[RETURN].pal sprite[].pal
			seta[RETURN].htextra 30
			seta[RETURN].htpicnum RPG
			seta[RETURN].htang sprite[].htang
			killit
		  }
			else
			ifactor NEWFEM9
			{
				espawn BLOODLESSPOLE3
				ifvarand sprite[].cstat 8 seta[RETURN].cstat 8
				seta[RETURN].xrepeat sprite[].xrepeat
				seta[RETURN].yrepeat sprite[].yrepeat
				espawn SAVEDFEM9
			}
			else
			espawn SAVEDNEWFEM5
			
			seta[RETURN].pal sprite[].pal
			seta[RETURN].xrepeat sprite[].xrepeat
			seta[RETURN].yrepeat sprite[].yrepeat
			setav[RETURN].mtype 1
			killit
		}
	}
	break
  }
  ifg sprite[].htextra 0
  ifn sprite[].htowner -1
  {
	ifvarand perks 8
	ife actorvar[sprite[].htowner].team 1
		seta[].htextra -1
  }
  
  ife babejuice 0
  {
	ife babesaved THISACTOR set babesaved -1
	  ifinwater nullop
	  else
		ifp pfacing
		  ifpdistl 1280
		  {
			ifhitspace
			  soundonce KILLME
			  
			ifl player[].fta 60
			{
				setp[].fta 120 setp[].ftq 1115
			}
		  }
		break
  }
   
   
  ife monstatus 2 { ife babesaved THISACTOR set babesaved -1 break }
  
  ifp pfacing
  ifp palive
  ifpdistl 2560
  // ifcansee
  {
    ifn babesaved -1 ifn babesaved THISACTOR
	{
		dist xydist player[].i babesaved
		dist xydist2 player[].i THISACTOR
		ifl xydist2 xydist set babesaved THISACTOR
	}
				
	ife juice_pos 0
	ife player[].kickback_pic 0
	ifcansee
	{
		ife babesaved -1 set babesaved THISACTOR
		ifhitspace
		{
			set juice_pos 1
			ife player[].weapon_pos 0 setp[].weapon_pos -1
		}
		else ifl player[].fta 60 
		{ 
			setp[].fta 120 setp[].ftq 1114 
			ife babesaved -1 set babesaved THISACTOR
		}
	}
	ifge juice_pos 20 ife babesaved THISACTOR
	{
		set juice_pos 50
		sub babejuice 1
		set countvar 1 // starts rescue process
		set babesaved -1
		geta[].htflags temp, orvar temp 4, seta[].htflags temp
		seta[].shade -100
		sound RIDSLIME sound RIDSLIME
		ifn SPRITELOTAG 0 seta[].hitag SPRITELOTAG
		respawnhitag
		seta[].hitag 0
	}
  }
  else ife babesaved THISACTOR set babesaved -1
ends

eventloadactor SNIPERCAUGHT sizeat 28 26 cstator 256 
geta[].lotag SPRITELOTAG seta[].lotag 0 enda

eventloadactor SNIPERHANG sizeat 28 26 cstator 256 
geta[].lotag SPRITELOTAG seta[].lotag 0 enda

useractor notenemy SNIPERCAUGHT SNIPERSTRENGTH ANULLACTION
   state saveme
   state newfemcode
enda

useractor notenemy SNIPERHANG SNIPERSTRENGTH ANULLACTION
   state saveme
   state newfemcode
enda

useractor notenemy NEWFEM5 ROBOTMOUSESTRENGTH ANEWFEMANG8
   state saveme
   state newfemcode
enda

useractor notenemy NEWFEM8 ROBOTMOUSESTRENGTH ANEWFEMANG8
   state saveme
   state newfemcode
enda

useractor notenemy NEWFEM11 ROBOTMOUSESTRENGTH ANEWFEMANG8
   state saveme
   state newfemcode
enda

useractor notenemy NEWPODFEM2 ROBOTMOUSESTRENGTH ANEWFEMANG8
   state saveme
   state newfemcode
enda

useractor notenemy NEWFEM6 ROBOTMOUSESTRENGTH ANEWFEMANG8
   state saveme
   state newfemcode
enda

useractor notenemy NEWFEM7 ROBOTMOUSESTRENGTH ANEWFEMANG8
   state saveme
   state newfemcode
enda

useractor notenemy NEWFEM10 ROBOTMOUSESTRENGTH ANEWFEMANG8
   state saveme
   state newfemcode
enda

useractor notenemy NEWPODFEM1 ROBOTMOUSESTRENGTH ANEWFEMANG5
   state saveme
   state newfemcode
enda

useractor notenemy NEWFEM9 ROBOTMOUSESTRENGTH ANEWFEMANG5
   state saveme
   state newfemcode
enda

useractor notenemy NEWNAKED1 ROBOTMOUSESTRENGTH ANEWFEMANG5
   state saveme
   state newfemcode
enda

useractor notenemy NEWNAKED2 ROBOTMOUSESTRENGTH ANEWFEMANG5
   state saveme
   state newfemcode
enda

defstate bloodlesspolecode

  fall
  cstator 257
      
  ifhitweapon
     ifdead
  {
    sound SQUISHED
	spritepal 6
	debris SCRAP3 12
	state lite_jibs
	killit
  }

ends

useractor notenemy BLOODLESSPOLE TOUGH ANULLACTION state bloodlesspolecode enda

useractor notenemy BLOODLESSPOLE2 TOUGH ANULLACTION state bloodlesspolecode enda

useractor notenemy BLOODLESSPOLE3 TOUGH ANULLACTION state bloodlesspolecode enda

useractor notenemy BLOODLESSPOLE4 TOUGH ANULLACTION state bloodlesspolecode enda

useractor notenemy NEWFEM6PAD TOUGH ANULLACTION state bloodlesspolecode enda

useractor notenemy EMPTYPOD TOUGH ANULLACTION  state bloodlesspolecode enda


move NUDGEVEL 64

defstate savedbabecode
	set team 3
	fall
	ife mtype 1
	{
		add countvar 1
		ife countvar 1 move NUDGEVEL faceplayer
		ife countvar 6 move STOPPED faceplayer
		ife countvar 60 
		{
			sound MEGAPORT
			spawn TRANSPORTERSTAR
		}
		ifg countvar 60
		{
			geta[].alpha temp
			add temp 16
			seta[].alpha temp
			ifge temp 240 
			{
				ife pchar 0
				ifvarand perks 128
				{
					addphealth 20
					set value 20
					state spawnimpcoins
				}
				ife PROGRESSION YES
				{
				set value 20
				state spawnimpcoins
				}
				killit
			}
		}
	}

ends
			
useractor notenemy SAVEDNEWFEM5 TOUGH state savedbabecode enda
useractor notenemy SAVEDPOD2 TOUGH state savedbabecode enda
useractor notenemy SAVEDNEWFEM6 TOUGH state savedbabecode enda
useractor notenemy SAVEDNEWFEM7 TOUGH state savedbabecode enda
useractor notenemy SAVEDFEM8 TOUGH state savedbabecode enda
useractor notenemy SAVEDFEM9 TOUGH state savedbabecode enda
useractor notenemy SAVEDFEM10 TOUGH state savedbabecode enda
useractor notenemy SAVEDFEM11 TOUGH state savedbabecode enda
useractor notenemy SAVEDNEWNAKED1 TOUGH state savedbabecode enda
useractor notenemy SAVEDNEWNAKED2 TOUGH state savedbabecode enda

useractor notenemy 18245 TOUGH

	ifn sprite[].sectnum -1
	{
		ifvarand sprite[].cstat 8 
		getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp
		else
		{
			getceilzofslope sprite[].sectnum sprite[].x sprite[].y temp
			set tempb sprite[].yrepeat, shiftl tempb 8
			add temp tempb
		}
		setsprite THISACTOR sprite[].x sprite[].y temp
	}

enda

actor FEM7 TOUGH FEMANIMATE
  state tipme
  state femcode
enda
actor FEM8 TOUGH FEMANIMATE
  state femcode
enda
actor FEM9 TOUGH FEMANIMATE
  state femcode
enda
actor FEM10 TOUGH FEMANIMATESLOW
  state tipme
  state femcode
enda
useractor notenemy FEM11 TOUGH FEMANIMATE
  state killme
  state femcode
enda

useractor notenemy HELLONURSE MANWOMANSTRENGTH FEMANIMATE
  state tipme
  state femcode
enda

useractor notenemy BETTY MANWOMANSTRENGTH FEMANIMATE
  state tipme
  state femcode
enda

useractor notenemy NEWHANGBABE TOUGH FEMANIMATE
  state killme
  state femcode
enda

useractor notenemy POLESTRIPPER TOUGH FEMANIMATE
  state tipme
  state femcode
enda

useractor notenemy NEWSLIMEBABE TOUGH FEMANIMATE
  state killme
  state femcode
enda

useractor notenemy NEWSLIMEBABE2 TOUGH FEMANIMATE
  state killme
  state femcode
enda

useractor notenemy FEM12 TOUGH FEMANIMATE
  state killme
  state femcode
enda

useractor notenemy FEM13 TOUGH FEMANIMATE
  state tipme
  state femcode
enda

useractor notenemy ORCHID TOUGH FEMANIMATE
  state tipme
  state femcode
enda

useractor notenemy CHUNLI MANWOMANSTRENGTH FEMANIMATE
  state tipme
  state femcode
enda


useractor notenemy BLUEHANGBABE TOUGH FEMANIMATE
  state killme
  state femcode
enda

useractor notenemy SCUBAGIRL TOUGH FEMANIMATE
  state femcode
enda

action LARADEAD1 2
action LARADEAD2 1
action LARAFROZEN

state laracode
  state killme
  // sizeat 32 32
  cstator 257
  ife monstatus 0 set monstatus 1
  set team 3
  state monsterai
  
      fall
      ifaction ANULLACTION nullop else
	  ifaction LARAFROZEN nullop else
        ifhitweapon
          ifdead
      {
		set monstatus 2
		spritepal 6
        state standard_jibs
        killit
      }
    

  ifaction FEMSHRUNK
  {
    ifcount SHRUNKDONECOUNT
    {
      action ANULLACTION
      cstat 257
    }
    else
      ifcount SHRUNKCOUNT
        sizeto 32 32
    else
      state genericshrunkcode
  }
  else ifaction FEMGROW
  {
    ifcount 32
    {
      respawnhitag
      guts JIBS4 20
      guts JIBS6 20
      spritepal 6
	  ifactor CHUNLI soundonce CHUNLIDIES
	  else
	  ifactor TUBEGUY soundonce MC_DEATH else
	  ifactor FROGMASCOT 
	  {
		soundonce MC_DEATH 
		spritepal 32
		debris SCRAP3 18
	  }
	  else
	  ifactor LARRY soundonce MC_DEATH else
      soundonce LADY_SCREAM
      debris SCRAP3 4
      sound SQUISHED
	  set monstatus 2
      killit
    }
    else
      sizeto MAXXSTRETCH MAXYSTRETCH
  }

  
  ifaction LARAFROZEN
  {
    ifcount THAWTIME
    {
      action ANULLACTION
      getlastpal
    }
    else
      ifcount FROZENDRIPTIME
    {
      ifactioncount 26
      {
        spawn WATERDRIP
        resetactioncount
      }
    }

    ifhitweapon
    {
      ifwasweapon FREEZEBLAST
      {
	    resetcount resetactioncount
        strength 0
        break
      }
	  lotsofglass 10
      state standard_jibs
      sound GLASS_BREAKING
      respawnhitag
      ifrnd 84
        spawn BLOODPOOL
      set monstatus 2
      killit
    }
    else
      ifp pfacing
        ifpdistl FROZENQUICKKICKDIST
          state pkick_check
    break
  }

  ifhitweapon
  {
    ifdead
    {
	  set monstatus 2
      ifwasweapon GROWSPARK
      {
        cstat 0
        move 0
        sound ACTOR_GROWING
        action FEMGROW
        break
      }
      else ifwasweapon FREEZEBLAST
      { 
        ifaction FEMSHRUNK
          break

        
        action LARAFROZEN
        move 0
        spritepal 1
        strength 0

        sound NEWFREEZE
		state freezeme
        break
      }

      ifrnd 128
        sound DUKE_HIT_STRIPPER1
      else
        sound DUKE_HIT_STRIPPER2

      respawnhitag
      state standard_jibs
      state random_wall_jibs
      spawn BLOODPOOL
	  ifactor LARATRAPPED action LARADEAD1 else
	  action LARADEAD2
	  strength 30
    }
    else
    {
      ifwasweapon SHRINKSPARK
      {
        sound ACTOR_SHRINKING
        move 0
        action FEMSHRUNK
        cstat 0
        break
      }
      else
        ifwasweapon GROWSPARK
          sound SPARKLESOUND
      sound SQUISHED
      guts JIBS6 1
    }
  }
ends

useractor notenemy LARATRAPPED TOUGH ANULLACTION state laracode enda
useractor notenemy LARATRAPPED2 TOUGH ANULLACTION state laracode enda

action AWALLFEMDEAD 3

useractor notenemy WALLFEM1 TOUGH ANULLACTION

ifaction ANULLACTION
{
	cstator 256
	ifhitweapon
	{
		guts JIBS6 1
		sound SQUISHED
		ifdead
		{
			state lite_jibs
			action AWALLFEMDEAD
		}
	}
}

enda

useractor notenemy WALLFEM2 TOUGH ANULLACTION

ifaction ANULLACTION
{
	cstator 256
	ifhitweapon
	{
		guts JIBS6 1
		sound SQUISHED
		ifdead
		{
			state lite_jibs
			action AWALLFEMDEAD
		}
	}
}

enda

useractor notenemy HANGBABEDEAD TOUGH

	cstator 256
	ifhitweapon
	{
		spritepal 6 guts JIBS6 1 getlastpal
		sound SQUISHED
		ifdead
		{
			state lite_jibs
			killit
		}
	}

enda

useractor notenemy FEM6DEAD TOUGH

cstator 256
ifhitweapon
{
	spritepal 6
	guts JIBS6 1
	sound SQUISHED
    ifdead
	{
		state lite_jibs
		cactor FEM6PAD
	}
	getlastpal
}
enda   

useractor notenemy FEM5DEAD TOUGH

ifhitweapon
{
	spritepal 6
	guts JIBS6 1
	sound SQUISHED
    ifdead
	{
		state lite_jibs
		cactor BLOODYPOLE
	}
	getlastpal
}
enda

useractor notenemy PODFEMDEAD TOUGH

ifhitweapon
{
	spritepal 6
	guts JIBS6 1
	sound SQUISHED
    ifdead
	{
		state lite_jibs
		killit
	}
	getlastpal
}
enda 

actor TOUGHGAL MANWOMANSTRENGTH TOUGHGALANIM
  state toughgaltalk
  state femcode
enda

// actor NAKED1 TOUGH FEMNEW3
  // state killme
  // state femcode
// enda
// actor PODFEM1 TOUGH FEMANIMATE
  // state killme
  // state femcode
// enda
actor BLOODYPOLE TOUGH
  state femcode
enda
actor BLOODYPOLE2 TOUGH
  state femcode
enda
actor BLOODYPOLE3 TOUGH
  state femcode
enda
actor BLOODYPOLE4 TOUGH
  state femcode
enda
actor STATUEFLASH
  fall
  ifcount 32
    cactor STATUE
enda
actor STATUE
  fall
  ifp pfacing
    ifpdistl 1280
      ifhitspace
  {
    cactor STATUEFLASH
    move 0
  }
enda

actor MIKE
  ifp pfacing
    ifpdistl 1280
      ifhitspace
        mikesnd
enda

move EXPLODING
spriteshadow SERIOUSBOMB
useractor notenemy SERIOUSBOMB 1

fall
ifmove 0
{
	move STOPPED
	cstator 256
}
ifhitweapon
{
	ifmove STOPPED
		move EXPLODING
}

ifmove EXPLODING
{	
	ifspritepal 6 getlastpal else spritepal 6
	ifcount 10
	{
		spawn EXPLOSION2
		ifrnd 128 sound PIPEBOMB_EXPLODE
		else
		sound ROBOT_EXPLODE
		debris SCRAP1 3
		debris SCRAP2 3
		getlastpal
		debris SCRAP1 3
		debris SCRAP2 3
		hitradius 2560 20 35 50 60
		killit
	}
}
enda

action ATIFASHAKE  2  3  1  1  10

spriteshadow TIFA
useractor notenemy TIFA 60 ANULLACTION

fall
ifmove 0
{
	move STOPPED
	cstator 256
}

ifaction ANULLACTION
ifhitspace
ifp pfacing
ifpdistl 1560
ifcansee
{
	action ATIFASHAKE
}

ifaction ATIFASHAKE
	ifactioncount 6
		action ANULLACTION
		
ifhitweapon
{
	spawn BLOOD
	ifdead
	{
		sound LADY_SCREAM
		state standard_jibs
		killit
	}
}

enda

action BLOODFRAMES 0 4 1 1 15
actor BLOOD 0 BLOODFRAMES
  sizeto 72 72 sizeto 72 72 sizeto 72 72
  ifpdistg 3144 killit
  ifactioncount 4 killit
enda

action EGGOPEN1 1 1 1 1 4
action EGGOPEN2 2 1 1 1 4
action EGGOPEN3 2 1 1 1 4
action EGGWAIT  0
action EGGFROZEN 1
action EGGGROW 1
action EGGSHRUNK 1

move EGGFALLVEL 32

actor EGG TOUGH
  fall
  ifn thiscam -1 { resetcount break }
  ifspawnedby DEVOURER ifmove 0 move EGGFALLVEL randomangle
  ifmove EGGFALLVEL iffloordistl 8 move STOPPED
  ifaction 0
  {
    ifcount 64
    {
      ifrnd 128
      {
        action EGGWAIT
        move 0
      }
      else
      {
        sound SLIM_HATCH
        action EGGOPEN1
      }
    }
  }
  else
    ifaction EGGOPEN1
      ifactioncount 4
        action EGGOPEN2
  else
    ifaction EGGOPEN2
      ifactioncount 4
    {
	  ife mtype 3
	  {
		ifinwater spawn WATERSLIME else spawn GREENSLIME
	  }
	  else
	  ife mtype 2 spawn OCTABRAIN else
	  ife mtype 1 
	  {
	    ifinwater { spawn WATERSLIME spawn WATERSLIME spawn WATERSLIME }
		else { spawn GREENSLIME spawn GREENSLIME spawn GREENSLIME }
	  }
	  else
	  {
		espawn GREENSLIME
		setav[RETURN].monstflags monstflags
		set team 3
	  }
      action EGGOPEN3
    }
  else
    ifaction EGGGROW
      state genericgrowcode
  else
    // ifaction EGGSHRUNK
      // state genericshrunkcode
  // else
    ifaction EGGFROZEN
  {
    ifcount THAWTIME
    {
      action 0
      getlastpal
    }
    else
      ifcount FROZENDRIPTIME
    {
      ifactioncount 26
      {
        spawn WATERDRIP
        resetactioncount
      }
    }

    ifhitweapon
    {
      ifwasweapon FREEZEBLAST
      {
	    resetcount resetactioncount
        strength 0
        break
      }  
	  lotsofglass 10
      state lite_jibs
      sound GLASS_BREAKING
      ifrnd 84
        spawn BLOODPOOL

	  ifaction EGGWAIT { ifrnd 32 spawn RESCUEREFILL }
	  else ifrnd 16 spawn RESCUEREFILL
      addkills 1 state enemy_death
      killit
    }

    // ifp pducking
    ifp pfacing
      ifpdistl FROZENQUICKKICKDIST
        state pkick_check

    break
  }
  set spawnprotect 0
  ifspritepal 33 getlastpal
  state monsterai
  set team 3
  ifhitweapon
  {
    ifdead
    {
      ifwasweapon FREEZEBLAST
      {
        sound NEWFREEZE
        spritepal 1
        move 0
        action EGGFROZEN
        strength 0
		state freezeme
        break
      }
      else
        ifwasweapon GROWSPARK
      {
        cstat 0
        move 0
        sound ACTOR_GROWING
        action EGGGROW
        break
      }
	  ifaction EGGWAIT ifrnd 32 spawn RESCUEREFILL
	  else ifrnd 16 spawn RESCUEREFILL
      addkills 1 state enemy_death
	  spritepal 6
      sound SQUISHED
      guts JIBS2 1
	  guts JIBS3 1
	  guts JIBS4 1
	  guts JIBS5 1
	  set countvarb 0
	  getlastpal
	  whilevarn countvarb 6
	  {
		  rand zdist 1024
		  sub zdist 3500
		  ezshoot zdist EGGJIBPROJ
		  rand angvar 2047
		  seta[RETURN].ang angvar
		  // seta[RETURN].pal 0
		  add countvarb 1
	  }
      killit
    }
    else
      ifwasweapon SHRINKSPARK
      {
        // move 0
        sound ACTOR_SHRINKING
        // action EGGSHRUNK
		set shrunken 1
        break
      }

      ifwasweapon GROWSPARK
        sound SPARKLESOUND
  }
  else
    ifaction EGGWAIT
  {
    ifcount 512
      ifrnd 2
    {
      ifn shrunken 0
        break
      sound SLIM_HATCH
      action EGGOPEN1
    }
  }

enda

eventloadactor EGGYOUNG sizeat 16 16 enda
eventloadactor EGGMEDIUM sizeat 20 20 enda

action EGGPHASE2 1
action EGGPHASE3 2

useractor enemy EGGYOUNG TOUGH 

ifmove 0
{
	move STOPPED geth
	sizeat 16 16
	cstator 256
	set team 3
}
fall
state monsterai

ifge sprite[].htextra sprite[].extra
{
	cactor EGG
	geta[].xrepeat x, div x 2
	seta[].xrepeat x, seta[].yrepeat x
	action EGGWAIT
    move 0
	break
}
ifhitweapon
{
	spritepal 6
	guts JIBS6 1
	getlastpal
}

set temp player[].player_par
modvar temp 15
ife temp 0
{
	espawn SPEEDBLUR
	setav[RETURN].mtype sprite[].htdispicnum
	seta[RETURN].xrepeat sprite[].xrepeat
	seta[RETURN].yrepeat sprite[].yrepeat
	seta[RETURN].alpha 80
	seta[RETURN].pal sprite[].pal
	seta[RETURN].mdflags 16
	
	geta[].xrepeat x
	add x 1
	seta[].xrepeat x, seta[].yrepeat x
	
	ifge x 24 ifaction 0 { action EGGPHASE2 sizeat 20 20 }
	ifge x 32 ifaction EGGPHASE2 { action EGGPHASE3 sizeat 26 26 }
	ifge x 40 ifaction EGGPHASE3
	{
		cactor EGG
		div x 2
		seta[].xrepeat x, seta[].yrepeat x
		action EGGWAIT
		move 0
	}
}

enda

useractor enemy EGGMEDIUM TOUGH 

cactor EGGYOUNG
move STOPPED geth
sizeat 20 20
cstator 256
action EGGPHASE2

enda

actor KNEE KNEE_WEAPON_STRENGTH enda
actor SPIT SPIT_WEAPON_STRENGTH enda
actor CHAINGUN CHAINGUN_WEAPON_STRENGTH enda
actor SHOTGUN SHOTGUN_WEAPON_STRENGTH enda
actor FIRELASER FIRELASER_WEAPON_STRENGTH enda
actor HEAVYHBOMB HANDBOMB_WEAPON_STRENGTH enda
actor BOUNCEMINE BOUNCEMINE_WEAPON_STRENGTH enda
actor MORTER MORTER_WEAPON_STRENGTH enda
actor SHRINKSPARK SHRINKER_WEAPON_STRENGTH enda

move TOPLAYER 32
actor GROWSPARK GROWSPARK_WEAPON_STRENGTH

ifmove 0 { move TOPLAYER faceplayer ifspawnedby LOVEBOMB cstator 130 }

  ifcount 18
    killit
  else
    ifcount 9
  {
    sizeto 0 0
    sizeto 0 0
    sizeto 0 0
    sizeto 0 0
  }
  else
  {
    ifspawnedby LOVEBOMB { sizeto 10 10 sizeto 10 10 }
	else
	{
    sizeto 28 28
    sizeto 28 28
    sizeto 28 28
    sizeto 28 28
	}
  }
enda

actor RPG RPG_WEAPON_STRENGTH enda
actor FREEZEBLAST FREEZETHROWER_WEAPON_STRENGTH enda
actor DEVISTATORBLAST FREEZETHROWER_WEAPON_STRENGTH enda
actor COOLEXPLOSION1 COOL_EXPLOSION_STRENGTH enda
actor TRIPBOMB TRIPBOMB_STRENGTH enda

defstate checkbleeding
	
	
	ifspawnedby APLAYER
	{
		set temp NO
		ife player[].curr_weapon PISTOL_WEAPON
		{
			ife pchar 0 ifvarand dukeupgrades[PISTOL_WEAPON] 1 set temp YES
			ife pchar 1 ifvarand shellyupgrades[PISTOL_WEAPON] 1 set temp YES
			ife pchar 2 ifvarand wesupgrades[PISTOL_WEAPON] 1 set temp YES
		}
		
		ifvarand gotshock 2 nullop else
		ife player[].curr_weapon CHAINGUN_WEAPON
		{
			ife pchar 0 ifvarand dukeupgrades[CHAINGUN_WEAPON] 2 set temp YES
			ife pchar 1 ifvarand shellyupgrades[CHAINGUN_WEAPON] 2 set temp YES
			ife pchar 2 ifvarand wesupgrades[CHAINGUN_WEAPON] 2 set temp YES
		}
		// ife player[].curr_weapon GROW_WEAPON ife pchar 2 set temp YES
		
		ife sprite[hitsprite].picnum ARMPIG ife actorvar[hitsprite].mtype 0 set temp NO
		
		ife temp YES
		{
			ifn hitsprite -1
			ife sprite[hitsprite].htpicnum SHOTSPARK1
			ifg sprite[hitsprite].htextra 1
			ifn actorvar[hitsprite].monstatus 2
			{
				ife actorvar[hitsprite].team 1
				ifvarand perks 8 nullop else
				{
					geta[hitsprite].htextra temp
					ife temp -1 set temp 0
					shiftr temp 1
					getav[hitsprite].bleeding tempb
					ifl tempb 0 mul tempb -1
					add tempb temp
					setav[hitsprite].bleeding tempb
					seta[hitsprite].htowner player[].i
					spawn WOUNDSPRITE
				}
			}
		}
		
		espawn JIBS6
		seta[RETURN].zvel 0
		seta[RETURN].xvel 24
		randvar temp 2047
		seta[RETURN].ang temp
		seta[RETURN].xrepeat 14
		seta[RETURN].yrepeat 14
		geta[hitsprite].picnum picnum
		switch picnum // should still be set from list that brought us here
			case NEWBEAST
			case CYBERBEAST case CRONEN
			case ZOMBIE case ARMYANT case ARMYANTCRAWL
			case EGG
			case BOSS4
				seta[RETURN].pal 6 // 8
			break
		endswitch

		ifrnd 48
		{
			ifrnd 64 espawn BLOODSPLASH1 else
			ifrnd 128 espawn BLOODSPLASH2 else
			espawn BLOODSPLASH3
			geta[hitsprite].picnum picnum
			switch picnum // should still be set from list that brought us here
			case NEWBEAST
			case CYBERBEAST case CRONEN
			case ZOMBIE case ARMYANT case ARMYANTCRAWL
			case BOSS4
				seta[RETURN].pal 6 // 8
			break
			endswitch
		}
	}

ends

defstate bullet_spark
ifmove 0
{
	cstat 1154
	sizeat 1 1
	ifrnd 128 cstator 4 ifrnd 128 cstator 8
	seta[].blend 255
	move STOPPED
}
ifmove STOPPED
{
	seta[].shade -16
	geta[].xrepeat temp add temp 2 
	ife initsprite SHOTGUN_WEAPON ifg temp 4 set temp 4
	seta[].xrepeat temp
	seta[].yrepeat temp
	
	ifcount 4 killit
}
ends

useractor notenemy METALSPARK1 state bullet_spark enda
useractor notenemy METALSPARK2 state bullet_spark enda
useractor notenemy METALSPARK3 state bullet_spark enda
useractor notenemy METALSPARK4 state bullet_spark enda
useractor notenemy METALSPARK5 state bullet_spark enda

spritenoshade SHOTSPARK1
spriteflags SHOTSPARK1 33554432
action WEAP2FRAMES 0  4  1  1  6
actor SHOTSPARK1 PISTOL_WEAPON_STRENGTH WEAP2FRAMES

  seta[].shade -127
  seta[].blend 1
  cstator 2
 
  ifdead
    killit
  ifactioncount 4
    killit
  else
  {
    ifactioncount 3
    {
      ifinwater
      spawn WATERBUBBLE
    }
    else
      ifcount 2 nullop
      else ife initsprite 0
	  {
		ife sprite[].yvel DEAGLEBULLET
		{
			cstat 32768
			espawn LASERHIT
			ife pchar 2 ife sprite[].owner player[].i
			ife player[].curr_weapon GROW_WEAPON
			{
				seta[RETURN].blend 1
				seta[RETURN].cstat 2
				seta[RETURN].pal 1
			}
		}
	    ifvare sprite[THISACTOR].yvel FIREBEAM
		{
		  geta[].htg_t 8 hitsprite
		  ifn hitsprite -1
		  {
			getav[hitsprite].burning burning
			add burning 36
			setav[hitsprite].burning burning
		  }
		  else ifrnd 16 { ifrnd 128 spawn BURNING else spawn BURNING2 }
		  ifn shotpitch 0
		  {
			  headspritestat spriteid 1
			  whilevarn spriteid -1
			  {
				  ife sprite[spriteid].picnum BEAMTRAIL
				  {
					  ife actorvar[spriteid].shotpitch 0
					  setav[spriteid].shotpitch shotpitch
				  }
				  nextspritestat spriteid spriteid
			  }
			  killit
		  }
		}
		else
		ifvare sprite[THISACTOR].yvel ICEBEAM
		{
		  geta[].htg_t 8 hitsprite
		  ifn hitsprite -1
			seta[hitsprite].htpicnum FREEZEBLAST
		  spritepal 1
		  lotsofglass  2
		  ifn shotpitch 0
		  {
			  headspritestat spriteid 1
			  whilevarn spriteid -1
			  {
				  ife sprite[spriteid].picnum ICEBEAMTRAIL
				  ife actorvar[spriteid].shotpitch 0
				  setav[spriteid].shotpitch shotpitch
				  nextspritestat spriteid spriteid
			  }
			  killit
		  }
		}
		else
		ife sprite[].yvel SHOCKBEAM
		{
			geta[].htg_t 8 hitsprite
			ifn hitsprite -1 ife sprite[hitsprite].picnum SHOCK_ACTOR { killit break }
			espawn SHOCK_ACTOR
			
			ifn hitsprite -1
			{
				ifvarand actorvar[hitsprite].monstflags 1048576
				{
					seta[hitsprite].htextra -1
					geta[hitsprite].extra temp
					add temp 5, ifg temp 32767 set temp 32767
					seta[hitsprite].extra temp
				}
				else
				{
					setav[RETURN].myspawner hitsprite
					ifn sprite[].htowner -1
					ife actorvar[sprite[].htowner].team 1
					ifn startshocktime -1
					setav[RETURN].mtype player[].player_par
					ife pchar 0 ifvarand dukeupgrades[CHAINGUN_WEAPON] 16 setav[RETURN].botclip YES
					ife pchar 1 ifvarand shellyupgrades[CHAINGUN_WEAPON] 16 setav[RETURN].botclip YES
					ife pchar 2 ifvarand wesupgrades[CHAINGUN_WEAPON] 16 setav[RETURN].botclip YES
				}
			}
			 
			ifn sprite[].htowner player[].i
			{
				headspritestat spriteid 1
			    whilevarn spriteid -1
			    {
				  ife sprite[spriteid].picnum LIGHTNING_TRAIL1
				  {
					  ife actorvar[spriteid].shotpitch 0
					  ife actorvar[spriteid].mtype NO
					  {
						setav[spriteid].shotpitch shotpitch
						setav[spriteid].mtype YES
					  }
				  }
				  
				  nextspritestat spriteid spriteid
			    }
			    killit
			}
		}
		else
		ife sprite[].yvel FIREBOLT
		{
			
			findnearactorz BURNING 1024 8192 target
			ife target -1 findnearactorz BURNING2 1024 8192 target
			ife target -1
			{
				ifrnd 128 espawn BURNING else espawn BURNING2	
				ifspawnedby APLAYER setav[RETURN].team 1 else
				ife sprite[].owner myshelly setav[RETURN].team 1 
			}
			
			
		}
        ifonwater
          spawn WATERSPLASH2
		else
		{
			set initsprite 1
			geta[].xrepeat x mul x 2 seta[].xrepeat x
			geta[].yrepeat y mul y 2 seta[].yrepeat y
			cstator 128
		}	
		
		// ifspawnedby APLAYER
		set temp NO
		ifspawnedby APLAYER set temp YES else
		ife sprite[].owner myshelly set temp YES
		
		// ife player[].curr_weapon SHOTGUN_WEAPON
		ife temp YES
		ifn sprite[].yvel SWITCHBULLET
		{
			set temp NO
			ifvarand dukeupgrades[SHOTGUN_WEAPON] 8
			ifvarand dukeupgrades[SHOTGUN_WEAPON] 4
			ife player[].curr_weapon SHOTGUN_WEAPON
			ife pchar 0 
			ife sprite[].owner player[].i
			set temp YES
			ifvarand gotDB 2 set temp NO
			
			ifg plevel 3
			ife sprite[].owner myshelly ifge sprite[myshelly].picnum DUKEBOT
			ifle sprite[myshelly].picnum DUKEBOTCROUCH set temp YES
			
			ife temp YES
			{
				geta[].htg_t 8 hitsprite
				state spawnradwound
			}
			
			ifspawnedby APLAYER
			{
				ife player[].curr_weapon SHOTGUN_WEAPON
				{
					set temp NO
					ife pchar 0 ife shotexpduke YES set temp YES
					ife pchar 1 ife shotexpshelly YES set temp YES
					ife temp YES
					{
						ifvarand gametips 1 { xorvar gametips 1 savegamevar gametips }
						// ifpdistg 1280
						// {
							// geta[].htg_t 8 hitsprite
							// ifn hitsprite -1 geta[hitsprite].htextra savz
							// findnearspritez EXPLOSION2 1024 8192 temp
							// ife temp -1
							// {
								// hitradius 1024 4 8 12 16
								// headspritestat spriteid 6
								// whilevarn spriteid -1
								// {
									// getactor[spriteid].picnum picnum
									// switch picnum
									// case CRACK1 case CRACK2 case CRACK3 case CRACK4
									// dist xydist THISACTOR spriteid
									// ifl xydist 1025
									// {
									// setactor[spriteid].htextra -1
									// setactor[spriteid].htpicnum picnum
									// }
									// break
									// default break
									// endswitch
									// nextspritestat spriteid spriteid
								// }
							// }
							// ifn hitsprite -1 seta[hitsprite].htextra savz
						// }
						espawn EXPLOSION2
						
						seta[].yvel RPG
						seta[RETURN].xrepeat 12
						seta[RETURN].yrepeat 12
						stopsound EXPLODE2
						soundonce EXPLODE2
						geta[].htg_t 8 hitsprite
						ifn hitsprite -1
						{
							seta[RETURN].xrepeat 20
							seta[RETURN].yrepeat 20
							seta[hitsprite].htpicnum RPG
							// geta[hitsprite].htextra temp
							// ifg temp 0
							// {
								// ife pchar 0 add temp 5 else
								// add temp 4
								// seta[hitsprite].htextra temp
							// }
						}

					}
				}
			}
		}
		
		ifn sprite[].owner -1
		ifvarand actorvar[sprite[].owner].monstflags 128 // multishot
		{
			espawn EXPLOSION2
			seta[RETURN].xrepeat 12
			seta[RETURN].yrepeat 12
			stopsound EXPLODE2
			soundonce EXPLODE2
		}
		
		
		
		set TILETYPE -1
		geta[].htg_t 8 hitsprite
		ifn hitsprite -1
		{
			ife sprite[hitsprite].picnum LASERWALL
			{
				spawn SPARKFALL spawn SPARKFALL spawn SPARKFALL spawn SPARKFALL
			}
			ife sprite[hitsprite].picnum SHOCKBALL2
			{
				setav[hitsprite].monstatus 2
			}
			ife sprite[hitsprite].picnum SHOCKBALL
			{
				setav[hitsprite].monstatus 2
			}
			// ife sprite[hitsprite].picnum BEACHBALLPROJ
			// {
				// seta[hitsprite].htextra 5
				// seta[hitsprite].htpicnum SHOTSPARK1
				// seta[hitsprite].htang sprite[].ang
				// seta[hitsprite].ang sprite[].ang
				// seta[hitsprite].htowner THISACTOR
				// geta[hitsprite].xvel x
				// add x 256 mul x 2 ifg x 644 set x 644
				// seta[hitsprite].xvel x
				// geta[hitsprite].zvel z
				// sub z 1024
				// seta[hitsprite].zvel z
				// geta[hitsprite].yvel temp
				// ifl temp 3 add temp 1
				// seta[hitsprite].yvel temp
				// break
			// }
			ife sprite[].yvel FIREBOLT
			ifn sprite[hitsprite].htowner hitsprite
			{
				ife hitsprite player[].i
				ife sprite[].owner myshelly nullop else
				{
					getav[hitsprite].burning temp
					add temp 10
					setav[hitsprite].burning temp
					break
				}
			}
			ife sprite[].yvel SABERPROJ
			{
				ifspawnedby APLAYER ife pchar 2 soundonce RENDFLESH else
				ifspawnedby WESBOT soundonce RENDFLESH
				else
				soundoncevar sabhitsnd 
				ife actorvar[hitsprite].monstatus 1
				{
					getav[hitsprite].stun temp
					add temp 1
					setav[hitsprite].stun temp
				}
			}
			ife sprite[].yvel BARRETPROJ 
			{
				seta[hitsprite].htpicnum RPG
				seta[].yvel RAILPROJ
				set chainsparksprite THISACTOR
			}
			ife sprite[].yvel EXPBULLET seta[hitsprite].htpicnum RPG
			
			geta[hitsprite].picnum picnum
			
			switch picnum
			case LIZTROOP case LIZMAN case LIZRANGER 
			case PIGCOP case NEWPIG case NEWPIGDIVE
			case NEWPIGPISS
			case NEWTROOP case NEWTROOPDUCKING
			case NEWTROOPONTOILET
			case PIGCOPDIVE case LIZRANGERDUCKING
			case LIZTROOPONTOILET case LIZTROOPJUSTSIT
			case NEWBEAST
			case CYBERBEAST case CRONEN
			case ZOMBIE case ARMYANT case ARMYANTCRAWL
			case SPACEBULL case CRAZYLADY
			case COMMANDER case NEWCOMM
			case NEWTSABERDEATH case LIZMANSABERDEATH
			case NEWPIGSABERDEATH case DEASABERDEATH
			case MANDOSABERDEATH case SYTHSABERDEATH case SITHSABERDEATH
				ifn sector[].lotag 2
				{
					ife sprite[].yvel SAWPROJ { soundonce SAWFLESH set sawfleshtime 3 }
					else
					ife sprite[].yvel KNIFEPROJ sound KNIFEIMPACT
					else
					ife sprite[].yvel SABERPROJ
					{
						ife pchar 2
						{
							add saberblood 300
							ifg saberblood 5400 set saberblood 5400
							ife picnum NEWBEAST set saberpal 11 else
							ife picnum CYBERBEAST set saberpal 11 else
							ife picnum CRONEN set saberpal 11 else
							ife picnum ZOMBIE set saberpal 11 else
							ife picnum ARMYANT set saberpal 11 else
							ife picnum ARMYANTCRAWL set saberpal 11 else
							set saberpal 10
						}
					}
					else
					ifn sprite[].yvel RPG
					{
						ifsound BODYHIT ifsound BODYHIT2 nullop else
						{
							ifsound BODYHIT sound BODYHIT2 else
							ifsound BODYHIT2 sound BODYHIT
						}
					}
				}
				ifspawnedby EDFSNIPER seta[].htpicnum APLAYER
				ifspawnedby EDFSNIPERCROUCH seta[].htpicnum APLAYER
				
				ife picnum ARMYANTCRAWL ife actorvar[hitsprite].initsprite YES // upside down ant
					seta[].htpicnum SHOTSPARK1 // prevents headshot
					
				
				// ife picnum NEWCOMM
				// ifg sprite[hitsprite].extra 200 nullop
				// else
				// ife picnum COMMANDER
				// ifg sprite[hitsprite].extra 200 nullop
				// else
				// ife picnum NEWBEAST
				// ifg sprite[hitsprite].extra 160 nullop
				// else
				// ife picnum CYBERBEAST
				// ifg sprite[hitsprite].extra 180 nullop
				// else
				// ife picnum ARMPIG
				// ifg sprite[hitsprite].extra 160 nullop
				// else
				// ife picnum SPACEBULL
				// ifg sprite[hitsprite].extra 160 nullop
				// else
				
				ifspawnedby APLAYER
				ifn sprite[].yvel SAWPROJ
				ifn sprite[].yvel RPG
				{
					set zdist tiledata[picnum].ysize
					ife actorvar[hitsprite].mtype 3 
					{
						ife picnum LIZTROOP 
						{
						set zdist 52
						// seta[].yvel RAILPROJ
						}
						
						ife picnum NEWTROOP
						{
						set zdist 70
						// seta[].yvel RAILPROJ
						}
					}
					mul zdist sprite[hitsprite].yrepeat
					ife picnum PIGCOPDIVE mul zdist 7 else
					ife picnum NEWPIGDIVE mul zdist 7 else
					mul zdist 6 // 5
					div zdist 2 // distance up to the head
					geta[hitsprite].z z
					sub z zdist
					ifle sprite[].z z
					{
						set temp sprite[hitsprite].extra
						div temp 2
						ifge sprite[hitsprite].htextra temp
						{
							set xydist 3072
							ife pchar 2 ife player[].curr_weapon GROW_WEAPON
							set xydist 5120
							ife player[].curr_weapon SHOTGUN_WEAPON
							ife zoomin YES set xydist 8192
							ife player[].curr_weapon CHAINGUN_WEAPON
							ife zoomin YES set xydist 8192
							findplayer xydist2
							
							geta[].z z2
							ife sprite[].yvel RAILPROJ 
							{
								seta[hitsprite].htpicnum HEADJIB1
								ife zoomin YES ife actorvar[hitsprite].droptile 0 setav[hitsprite].droptile NUKECOIN
								ifrnd 84
								ife sprite[hitsprite].htowner player[].i
								ife player[].curr_weapon DEVISTATOR_WEAPON
								{
									ife pchar 0 // DUKE
									{
										ifrnd 128 globalsound DUKE_SNIPE1 else
										globalsound DUKE_SNIPE2
									}
									else ife pchar 1 // BOMBSHELL
									{
										ifrnd 128 globalsound B_HEADSHOT else
										globalsound B_GUNCONTROL
									}
									else ife pchar 2 // WES
									{
										ifrnd 128 globalsound WESONESHOTKILL else
										globalsound WESMADEPOINT
									}
								}
							}
							else
							ifl xydist2 xydist
							{
								ifg sprite[hitsprite].htextra 60
								{
									seta[hitsprite].htpicnum HEADJIB1
									ife sprite[].yvel SABERPROJ setav[hitsprite].thirdbasetimer 999
								}
								else
								ifg sprite[hitsprite].htextra sprite[hitsprite].extra
								{
									ife sprite[].yvel SABERPROJ
									{
										ifn sprite[hitsprite].htpicnum SABERPROJ
										seta[hitsprite].htpicnum HEADJIB1
										setav[hitsprite].thirdbasetimer 999
									}
									else
									ifrnd 64
										seta[hitsprite].htpicnum HEADJIB1	
								}
								
							}
						}
						// geta[hitsprite].htextra temp
						// ifg temp 0
						// {
							// mul temp 3 div temp 2
							// seta[hitsprite].htextra temp
						// }
					}
					
					
				}
				state checkbleeding
			break
			case ARMPIG case BOSS1 case NEWBATLORD case QUEEN
			case BOSS2 case BOSS3 case BOSS4 case PIGBOSS case NURGLE
			
			case FEMCIV case FEMCIVCROUCH case FEMCIV2 case FEMCIV2CROUCH 
			case FEMCIV3 case FEMCIV3CROUCH case FEMCIV5 case FEMCIV5CROUCH
			case MALECIV1 case MALECIV1CROUCH case MALECIV2 case MALECIV2CROUCH 
			case MALECIV4 case MALECIV4CROUCH case MALECIV3 case MALECIV3CROUCH
			case MALECIV5 case MALECIV5CROUCH
			case MALECIV6 case MALECIV6CROUCH case MALECIV2SMOKING
			case GUARD case GUARDCROUCH case CRYSTAL case MAIDNPC
			case EDFSNIPER case EDFSNIPERCROUCH case EDFTROOP
			case NAKEDBABE case NAKEDBABECROUCH case PIGSTRIPPER
			case STRIPPER case STRIPPERCROUCH case KBABE case KBABECROUCH case CHEERLEADER
			case CHEERLEADERCROUCH case HOOKER case HOOKERCROUCH case POLEDANCER
			case CAVEGIRL case CAVEGIRLCROUCH case BIKINIBABE case BIKINIBABE2
			case FATGUY1 case FATGUY2 case ALIENCIVMALE case ALIENCIVFEM
			case SHOWERGIRL case STRIPPER2
			case SHARK case OCTABRAIN case MEGABRAIN
			case LIZDOG case EGG
			case SHELLY case SHELLYCROUCH case WESBOT case WESBOTCROUCH
			case DUKEBOT case DUKEBOTCROUCH 
			case APLAYER case LIZELITE case LIZELITECROUCH case CORRUPT
			case MANDOFETT case MANDOCROUCH
			case NAAMAH case NEWPIGDOWN case BATBOSS
				ifn sprite[].yvel SHOTGUN
				ifn sprite[hitsprite].picnum ARMPIG
				ifn sector[].lotag 2
				{
					ife sprite[].yvel SABERPROJ
					{
						ife pchar 2
						{
							add saberblood 30
							ifg saberblood 5400 set saberblood 5400
							ife picnum QUEEN set saberpal 11 else
							ife picnum EGG set saberpal 11
							set saberpal 10
						}
					}
					else
					ifn sprite[].yvel RPG
					{
						ife sprite[].yvel SAWPROJ { soundonce SAWFLESH set sawfleshtime 3 }
						else
						ife sprite[].yvel KNIFEPROJ sound KNIFEIMPACT
						else
						{
							ifsound BODYHIT ifsound BODYHIT2 nullop else
							{
								ifsound BODYHIT sound BODYHIT2 else
								ifsound BODYHIT2 sound BODYHIT
							}
						}
					}
				}
				else 
				ifn sector[].lotag 2
				{
					ifpdistl 4096
					{
						ifsound BODYHIT ifsound BODYHIT2 nullop else
						{
							ifsound BODYHIT sound BODYHIT2 else
							ifsound BODYHIT2 sound BODYHIT
						}
					}
					else soundonce BODYHIT
				}
				state checkbleeding
			break
			case EBARRIER
				spawn SPARKFALL spawn SPARKFALL spawn SPARKFALL
				
				ifspawnedby APLAYER
				{
					set temp NO
					ife player[].curr_weapon PISTOL_WEAPON
					{
						ife pchar 0 ifvarand dukeupgrades[PISTOL_WEAPON] 1 set temp YES
						ife pchar 1 ifvarand shellyupgrades[PISTOL_WEAPON] 1 set temp YES
						ife pchar 2 ifvarand wesupgrades[PISTOL_WEAPON] 1 set temp YES
					}
					ifvarand gotshock 2 nullop else
					ife player[].curr_weapon CHAINGUN_WEAPON
					{
						ife pchar 0 ifvarand dukeupgrades[CHAINGUN_WEAPON] 2 set temp YES
						ife pchar 1 ifvarand shellyupgrades[CHAINGUN_WEAPON] 2 set temp YES
						ife pchar 2 ifvarand wesupgrades[CHAINGUN_WEAPON] 2 set temp YES
					}
					ife temp YES
					{
						ifn hitsprite -1
						ife sprite[hitsprite].htpicnum SHOTSPARK1
						{
							geta[hitsprite].htextra temp
							mul temp 3 div temp 2
							seta[hitsprite].htextra temp
						}
					}
				}

			break
			case SITH
			case SYTH
			case DEANOVA
				ife actorvar[hitsprite].mtype 1 // blocking
				{
					spawn SPARKFALL spawn SPARKFALL
				}
				else
				{
					ifn sprite[].yvel SHOTGUN
					{
						ife sprite[].yvel SABERPROJ
						{
							ife pchar 2
							{
								add saberblood 300
								ifg saberblood 5400 set saberblood 5400
								set saberpal 10
							}
						}
						else
						ifn sprite[].yvel RPG
						ifn sector[].lotag 2
						{
							ife sprite[].yvel SAWPROJ { soundonce SAWFLESH set sawfleshtime 3 }
							else
							ife sprite[].yvel KNIFEPROJ sound KNIFEIMPACT
							else
							{
								ifsound BODYHIT ifsound BODYHIT2 nullop else
								{
									ifsound BODYHIT sound BODYHIT2 else
									ifsound BODYHIT2 sound BODYHIT
								}
							}
								
						}
					}
					else 
					ifn sector[].lotag 2
					{
						ifpdistl 4096
						{
							ifsound BODYHIT ifsound BODYHIT2 nullop else
							{
								ifsound BODYHIT sound BODYHIT2 else
								ifsound BODYHIT2 sound BODYHIT
							}
						}
						else soundonce BODYHIT
					}
					state checkbleeding
				}
			break
			
			default
				ife sprite[].yvel SAWPROJ { soundonce SCRAPE set sawfleshtime 3 }
			break
			endswitch
			
			state tiletype
			switch TILETYPE
			case 1

			espawn WOODFALL
			setav[RETURN].initsprite 1

			break
			case 2 case 3 case 10
			ifsound RENDFLESH { stopsound RENDFLESH sound BLADEHITMET }
			
			
			spawn SPARKFALL
			ife sprite[].yvel SAWPROJ { soundonce SCRAPE set sawfleshtime 3 }
			else
			ifn sprite[].yvel FIREBOLT
			ifn sprite[].yvel SABERPROJ
			state hitmetalsounds
			
			ife sprite[hitsprite].picnum NEWRECON
			ifn sprite[].yvel FIREBOLT
			ifn sprite[].yvel SABERPROJ
			{
				rand temp 4 add temp METALSPARK1 espawnvar temp
				ifspawnedby APLAYER setav[RETURN].initsprite player[].curr_weapon
			}
			
			// apply AP damage for upgraded pistols or chainguns
			
			ifspawnedby APLAYER
			{
				set temp NO
				ife player[].curr_weapon PISTOL_WEAPON
				{
					ife pchar 0 ifvarand dukeupgrades[PISTOL_WEAPON] 1 set temp YES
					ife pchar 1 ifvarand shellyupgrades[PISTOL_WEAPON] 1 set temp YES
					ife pchar 2 ifvarand wesupgrades[PISTOL_WEAPON] 1 set temp YES
				}
				ifvarand gotshock 2 nullop else
				ife player[].curr_weapon CHAINGUN_WEAPON
				{
					ife pchar 0 ifvarand dukeupgrades[CHAINGUN_WEAPON] 2 set temp YES
					ife pchar 1 ifvarand shellyupgrades[CHAINGUN_WEAPON] 2 set temp YES
					ife pchar 2 ifvarand wesupgrades[CHAINGUN_WEAPON] 2 set temp YES
				}
				ife temp YES
				{
					ifn hitsprite -1
					ife sprite[hitsprite].htpicnum SHOTSPARK1
					{
						geta[hitsprite].htextra temp
						mul temp 3 div temp 2
						seta[hitsprite].htextra temp
						spawn LILSCRAP
						state breakmetalsounds
					}
				}
			}
			break
			case 5 case 7
			ife sprite[].yvel SAWPROJ { soundonce SCRAPE set sawfleshtime 3 }
			else
			ifn sprite[].yvel FIREBOLT
			state hitconcretesounds
			espawn CONCRETEFALL
			setav[RETURN].initsprite 1
			break
			endswitch
		}
		else
		{
			geta[].htg_t 6 hitwall
			ifvarn hitwall -1
			{
				getwall[hitwall].nextsector mysector
				
				ifn mysector -1 ifvarand sector[mysector].ceilingstat 1 
				{
					ife sector[mysector].floorz sector[mysector].ceilingz
					killit
				}
				
				set TILETYPE -1
				getwall[hitwall].cstat tempb

				ifvarand tempb 2 // ignore this is upper half of wall
				{
					getwall[hitwall].nextsector B
					ife B -1 getwall[hitwall].picnum picnum
					else
					{
						ifg sprite[].z sector[B].ceilingz
						{
							getwall[hitwall].nextwall B
							ife B -1 getwall[hitwall].picnum picnum
							else getwall[B].picnum picnum
						}
						else getwall[hitwall].picnum picnum
					}
				}
				else
				getwall[hitwall].picnum picnum

				state tiletype
				switch TILETYPE
				case 1
				ife sprite[].yvel SABERPROJ ifn saberpos 0 
				{
					ife pchar 2 soundonce BLADEHITMET else
					soundoncevar sabclashsnd
				}
				espawn WOODFALL
				setav[RETURN].initsprite 1
				ife sprite[].yvel FIREBOLT seta[RETURN].pal 2
				break
				case 2 case 3 case 10
				spawn SPARKFALL
				ifn sprite[].yvel FIREBOLT
				ifn sprite[].yvel SABERPROJ
				{
					rand temp 4 add temp METALSPARK1 espawnvar temp
					ifspawnedby APLAYER setav[RETURN].initsprite player[].curr_weapon
				}
				ife sprite[].yvel SAWPROJ { soundonce SCRAPE set sawfleshtime 3 }
				else
				ife sprite[].yvel SABERPROJ ifn saberpos 0 
				{
					ife pchar 2 soundonce BLADEHITMET else
					soundoncevar sabclashsnd
				}
				else
				ifn sprite[].yvel FIREBOLT
				state hitmetalsounds
				break
				case 5 case 7
				ife sprite[].yvel SAWPROJ { soundonce SCRAPE set sawfleshtime 3 }
				else
				ife sprite[].yvel SABERPROJ ifn saberpos 0 
				{
					ife pchar 2 soundonce BLADEHITMET else
					soundoncevar sabclashsnd
				}
				else
				ifn sprite[].yvel FIREBOLT
				state hitconcretesounds
				espawn CONCRETEFALL
				ife sprite[].yvel FIREBOLT seta[RETURN].pal 2
				setav[RETURN].initsprite 1
				
				break
				default
				ife sprite[].yvel SABERPROJ ifn saberpos 0 
				{
					ife pchar 2 soundonce BLADEHITMET else
					soundoncevar sabclashsnd
				}
				break
				endswitch
			}
			else
			{
				geta[].htg_t 7 hitsector

				ifn hitsector -1
				{
					set TILETYPE -1
					
					getflorzofslope hitsector sprite[].x sprite[].y temp // temp is the return var
					sub temp sprite[].z
					ifl temp 3072
					{
						gets[hitsector].floorpicnum picnum
						set float -2 // floor
					}
					else
					{
						gets[hitsector].ceilingpicnum picnum
						set float 2 // ceiling
					}
					state tiletype
					switch TILETYPE
					case 1
						espawn WOODFALL
						setav[RETURN].initsprite float
						ife sprite[].yvel FIREBOLT seta[RETURN].pal 2
						ife sprite[].yvel SABERPROJ ifn saberpos 0 
						{
							ife pchar 2 soundonce BLADEHITMET else
							soundoncevar sabclashsnd
						}
					break
					case 2 case 3 case 10
						ife sprite[].yvel SAWPROJ { soundonce SCRAPE set sawfleshtime 3 }
						else
						ife sprite[].yvel SABERPROJ ifn saberpos 0 
						{
							ife pchar 2 soundonce BLADEHITMET else
							soundoncevar sabclashsnd
						}
						else
						ifn sprite[].yvel FIREBOLT
						state hitmetalsounds
						espawn SPARKFALL
						setav[RETURN].initsprite float
						ifn sprite[].yvel FIREBOLT
						ifn sprite[].yvel SABERPROJ
						{
							rand temp 4 add temp METALSPARK1 espawnvar temp
							ifspawnedby APLAYER setav[RETURN].initsprite player[].curr_weapon
						}
					break
					case 4
						ifrnd 128 sound BULLETDIRT1 else
						sound BULLETDIRT2
						// dirt debris
					break
					case 5 case 7
						ife sprite[].yvel SAWPROJ { soundonce SCRAPE set sawfleshtime 3 }
						else
						ife sprite[].yvel SABERPROJ ifn saberpos 0 
						{
							ife pchar 2 soundonce BLADEHITMET else
							soundoncevar sabclashsnd
						}
						else
						ifn sprite[].yvel FIREBOLT
						state hitconcretesounds
						espawn CONCRETEFALL
						ife sprite[].yvel FIREBOLT seta[RETURN].pal 2
						setav[RETURN].initsprite float
					break
					default
					ife sprite[].yvel SABERPROJ ifn saberpos 0 
					{
						ife pchar 2 soundonce BLADEHITMET else
						soundoncevar sabclashsnd
					}
					break
					endswitch
				}
			}
		}
			

		
	  }
  }
enda

action BOLTACTION 0 2 1 1 10

spritenoshade BOLT_TRAIL
useractor notenemy BOLT_TRAIL 0 BOLTACTION

ifmove 0
{
	sizeat 8 8
	seta[].shade -100
	ifpdistl 644 killit
	cstat 130
	seta[].blend 1
	ifrnd 128 cstator 4
	ifrnd 128 cstator 8
}
ifactioncount 1 cstator 514
ifactioncount 2 killit

enda


useractor notenemy METALHOLE 0
ifmove 0
{
	sizeat 2 2
	cstator 514 // 2
	move STOPPED
	insertspriteq
	eqspawn METALHOLEINNER
	{
		getactor[THISACTOR].cstat temp
		subvar temp 2
		setactor[RETURN].cstat temp
		setactor[RETURN].xrepeat 2
		setactor[RETURN].yrepeat 2
		getactor[THISACTOR].ang angvar
		setactor[RETURN].ang angvar
	}
}
enda

useractor notenemy ORGANICHOLE 0
ifmove 0
{
	sizeat 4 4
	move STOPPED
	insertspriteq
}
enda

useractor notenemy WOODHOLE 0
ifmove 0
{
	iffloordistl 2 sizeat 6 3 else
	sizeat 4 4
	cstator 2
	move STOPPED
	insertspriteq
	eqspawn WOODHOLEINNER
	
	getactor[THISACTOR].cstat temp
	subvar temp 2
	setactor[RETURN].cstat temp
	setactor[RETURN].xrepeat 4
	setactor[RETURN].yrepeat 4
	getactor[THISACTOR].ang angvar
	setactor[RETURN].ang angvar
	
}
enda

useractor notenemy CONCRETEHOLE 0
ifmove 0
{
	sizeat 2 2
	cstator 2
	move STOPPED
	insertspriteq
}
enda

useractor notenemy ELECTRONICHOLE 0
ifmove 0
{
	sizeat 2 2
	cstator 2
	move STOPPED
	insertspriteq
}
enda


move DUKENOTMOVING
state handle_dead_dukes
  fall
  ifmove 0   // 1st time initializiation...
  {
    ifrnd 128
      cstat 4
    else
      cstat 0
    move DUKENOTMOVING
  }

  ifsquished
  {
    sound SQUISHED
    state random_ooz
    killit
  }
  else
    ifcount 1024
      ifpdistg 4096
        killit
  else
  {
    strength 0
    ifhitweapon
      ifwasweapon RADIUSEXPLOSION
    {
      state standard_jibs
      killit
    }
  }
ends

action PLYINGFRAMES 0 1 0 1 1
actor DUKELYINGDEAD 0 PLYINGFRAMES
  state handle_dead_dukes
enda

// DUKE ALT COSTUME PLAYER ACTIONS
action ALTDUKEGROWING   7681
action ALTDUKESTAND     7681   1   5   1  1
action ALTDUKEEXPLODE   7771   5   1   1   10
action ALTDUKEEXPLODEAD   7776   1   1
action ALTDUKEJPHOUVER  7686   1   5   1
action ALTDUKEWALK    7691   4   5   1   16
action ALTDUKERUN     7691   4   5   1   10
action ALTDUKEWALKBACK  7706   4   5  -1   16
action ALTDUKERUNBACK   7706   4   5  -1   10
action ALTDUKEJUMPING   7721   3   5   1   30
action ALTDUKEFALLING   7731   1   5
action ALTDUKEDUCKING   7736   1   5
action ALTDUKECRAWLING  7736   3   5   1   20
action ALTDUKEKICKING  7711   2   5   1   25
action ALTDUKEFLINTCH  7771  1   1   1   10
action ALTDUKETHROWNBACK  7771  5   1   1   18
action ALTDUKEFROZEN     7691  1   5
action ALTDUKELYINGDEAD   7776  1   1

action ALTDUKEDOWN 7788 2  5  1  50

action ALTDUKESWIMMINGGO   7751   1   5   1   10
action ALTDUKESWIMMING   7751   4   5   1   13
action ALTDUKESWIMMINGWAIT 7756   1   5   1   13
action ALTDUKETREDWATER  7761   2   5   1   24


// BOMBSHELL PLAYER ACTIONS

action APSHELLYGROWING		5281
action APSHELLYSTAND		5281 1  5  1  1
action APSHELLYEXPLODE	    5371 5  1  1  10
action APSHELLYEXPLODEAD	5376 1  1  1  1
action APSHELLYHOUVER		5316 1  5  1  1
action APSHELLYWALK			5286 4  5  1  16
action APSHELLYRUN			5286 4  5  1  10
action APSHELLYWALKBACK		5301 4  5  -1  16
action APSHELLYRUNBACK		5301 4  5  -1 10
action APSHELLYJUMPING		5316 2  5  1  45 // changed from Duke
action APSHELLYFALLING		5321 1  5  1  1
action APSHELLYDUCKING		5326 1  5  1  1
action APSHELLYCRAWLING	    5331 4  5  1  18 // changed from Duke
action APSHELLYKICKING		5306 2  5  1  25
action APSHELLYFLINTCH	   	5371 1  1  1  10
action APSHELLYTHROWNBACK  	5371 5  1  1  18
action APSHELLYFROZEN		5286 1  5
action APSHELLYLYINGDEAD	5376 1  1

action APSHELLYSWIMMINGGO	5351 1  5  1  10
action APSHELLYSWIMMING		5351 4  5  1  13

action APSHELLYSWIMMINGWAIT		5366 1  5  1  13 // changed from Duke
action APSHELLYTREDWATER	5351 4  5  1  13 // changed from Duke

action APSHELLYDOWN		   5390 2  5  1  50
// END OF BOMBSHELL PLAYER ACTIONS

// WES PLAYER ACTIONS

action APWESGROWING		18071
action APWESGUNDOWN	    18076 1  5  1  1
action APWESSTAND		18081 1  5  1  1
action APWESEXPLODE	    18241 6  1  1  10
action APWESEXPLODEAD	18247 1  1  1  1
action APWESHOUVER		18106 1  5  1  1
action APWESWALK		18086 4  5  1  16
action APWESRUN			18086 4  5  1  10
action APWESWALKBACK	18101 4  5  -1  16
action APWESRUNBACK		18101 4  5  -1 10
action APWESJUMPING		18106 2  5  1  45
action APWESFALLING		18111 1  5  1  1
action APWESDUCKING		18116 1  5  1  1
action APWESCRAWLING	18121 4  5  1  18
action APWESTURN1		18161 4  5  1  8
action APWESTURN2		18181 3  5  1  16
action APWESKICKING		18171 5  5  1  8
action APWESFLINTCH	   	18242 1  1  1  10
action APWESTHROWNBACK  18241 6  1  1  18
action APWESFROZEN		18071 1  5
action APWESLYINGDEAD	18247 1  1

action APWESSWIMMINGGO	18141 1  5  1  10
action APWESGLIDING     18146 1  5  1  10
action APWESSWIMMING	18141 4  5  1  13

action APWESSWIMMINGWAIT 18156 1  5  1  13 // changed from Duke
action APWESTREDWATER	18141 4  5  1  13 // changed from Duke

action APWESDOWN		18248 2  5  1  50
// END OF WES PLAYER ACTIONS

action PGROWING   0
action PSTAND     0   1   5   1  1
action PEXPLODE   106   5   1   1   10
action PEXPLODEAD   113   1   1
action PJPHOUVER  15   1   5   1
action PWALK    20   4   5   1   16
action PRUN     20   4   5   1   10
action PWALKBACK  45   4   5  -1   16
action PRUNBACK   45   4   5  -1   10
action PJUMPING   50   4   5   1   30
action PFALLING   65   1   5
action PDUCKING   86   1   5
action PCRAWLING  86   3   5   1   20
action PAKICKING  40   2   5   1   25
action PFLINTCHING  106  1   1   1   10
action PTHROWNBACK  106  5   1   1   18
action PFROZEN     20  1   5
action PLYINGDEAD   113  1   1

action PSWIMMINGGO   375   1   5   1   10
action PSWIMMING   375   4   5   1   13
action PSWIMMINGWAIT 395   1   5   1   13
action PTREDWATER  395   2   5   1   17
action PDUKEDOWN 6161 2  5  1  50

move PSTOPED
move PSHRINKING // used as a var only


defstate altdukeactions

	ifaction PGROWING action ALTDUKEGROWING
	ifaction PSTAND action ALTDUKESTAND
	ifaction PEXPLODE action ALTDUKEEXPLODE
	ifaction PEXPLODEAD action ALTDUKEEXPLODEAD
	ifaction PJPHOUVER action ALTDUKEJPHOUVER
	ifaction PWALK action ALTDUKEWALK
	ifaction PWALKBACK action ALTDUKEWALKBACK
	ifaction PRUNBACK action ALTDUKERUNBACK
	ifaction PJUMPING action ALTDUKEJUMPING
	ifaction PFALLING action ALTDUKEFALLING
	ifaction PDUCKING action ALTDUKEDUCKING
	ifaction PCRAWLING action ALTDUKECRAWLING
	ifaction PAKICKING action ALTDUKEKICKING
	ifaction PFLINTCHING action ALTDUKEFLINTCH
	ifaction PTHROWNBACK action ALTDUKETHROWNBACK
	ifaction PLYINGDEAD action ALTDUKELYINGDEAD
	ifaction PSWIMMINGGO action ALTDUKESWIMMINGGO
	ifaction PSWIMMING action ALTDUKESWIMMING
	ifaction PSWIMMINGWAIT action ALTDUKESWIMMINGWAIT
	ifaction PTREDWATER action ALTDUKETREDWATER
	ifaction PDUKEDOWN action ALTDUKEDOWN
	
	geta[].mdflags temp
	orvar temp 16
	seta[].mdflags temp

ends

defstate shellyactions

	ifaction PGROWING action APSHELLYGROWING
	ifaction PSTAND action APSHELLYSTAND
	ifaction PEXPLODE action APSHELLYEXPLODE
	ifaction PEXPLODEAD action APSHELLYEXPLODEAD
	ifaction PJPHOUVER action APSHELLYHOUVER
	ifaction PWALK action APSHELLYWALK
	ifaction PWALKBACK action APSHELLYWALKBACK
	ifaction PRUNBACK action APSHELLYRUNBACK
	ifaction PJUMPING action APSHELLYJUMPING
	ifaction PFALLING action APSHELLYFALLING
	ifaction PDUCKING action APSHELLYDUCKING
	ifaction PCRAWLING action APSHELLYCRAWLING
	ifaction PAKICKING action APSHELLYKICKING
	ifaction PFLINTCHING action APSHELLYFLINTCH
	ifaction PTHROWNBACK action APSHELLYTHROWNBACK
	ifaction PLYINGDEAD action APSHELLYLYINGDEAD
	ifaction PSWIMMINGGO action APSHELLYSWIMMINGGO
	ifaction PSWIMMING action APSHELLYSWIMMING
	ifaction PSWIMMINGWAIT action APSHELLYSWIMMINGWAIT
	ifaction PTREDWATER action APSHELLYTREDWATER
	
	geta[].mdflags temp
	orvar temp 16
	seta[].mdflags temp

ends

defstate wesactions

	ifaction PGROWING action APWESGROWING
	ifaction PSTAND 
	{
		ifvarand bits 4 action APWESSTAND else
		ifn player[].kickback_pic 0 action APWESSTAND else
		action APWESGUNDOWN
	}
	ifaction PEXPLODE action APWESEXPLODE
	ifaction PEXPLODEAD action APWESEXPLODEAD
	ifaction PJPHOUVER action APWESHOUVER
	ifaction PWALK action APWESWALK
	ifaction PWALKBACK action APWESWALKBACK
	ifaction PRUNBACK action APWESRUNBACK
	ifaction PJUMPING action APWESJUMPING
	ifaction PFALLING action APWESFALLING
	ifaction PDUCKING action APWESDUCKING
	ifaction PCRAWLING action APWESCRAWLING
	ifaction PAKICKING action APWESKICKING
	ifaction PFLINTCHING action APWESFLINTCH
	ifaction PTHROWNBACK action APWESTHROWNBACK
	ifaction PLYINGDEAD action APWESLYINGDEAD
	ifaction PSWIMMINGGO action APWESSWIMMINGGO
	ifaction PSWIMMING action APWESSWIMMING
	ifaction PSWIMMINGWAIT action APWESSWIMMINGWAIT
	ifaction PTREDWATER action APWESTREDWATER
	
	ife pchar 2 
	{
		ifaction APWESSTAND
		ifactioncount 2
		{
			ifvarand bits 4 nullop else
			ifn player[].kickback_pic 0 nullop else
			action APWESGUNDOWN
		}
		else ifaction APWESGUNDOWN
		{
			ifvarand bits 4 action APWESSTAND else
			ifn player[].kickback_pic 0 action APWESSTAND
		}
		ifaction APWESTURN1
		{
			ifactioncount 4 action APWESTURN2
		}
		else
		ifaction APWESTURN2
		{
			ifactioncount 3 action APWESSTAND
		}
		ifg sidekick 0 ifl sidekick 10 { ifaction APWESTURN1 nullop else action APWESTURN1 }
		ifge sidekick 10 ifle sidekick 27 { ifaction APWESTURN2 nullop else action APWESTURN2 }
	}
	geta[].mdflags temp
	orvar temp 16
	seta[].mdflags temp

ends

defstate playerscorecheck

	ife gametime -1 break
	
	ifaction PEXPLODEAD set B 0 else
	ifaction PLYINGDEAD set B 1 else
	ifaction ALTDUKEEXPLODEAD set B 2 else
	ifaction ALTDUKELYINGDEAD set B 3 else
	set B 4
	
	ife gametype DM
	{
		ifactor APLAYER
		{
			ife pchar 0 add duke_deaths 1
			ife pchar 1 add shelly_deaths 1
			ife pchar 2 add wes_deaths 1
		}
		else
		{
			ife pchar 0 add shelly_deaths 1
			ife pchar 1 add duke_deaths 1
			ife pchar 2 add wes_deaths 1
		}
		
		geta[].htowner spriteid
		ifactor APLAYER set spriteid mykiller
		
		
		ifn spriteid -1
		{
			ifn actorvar[spriteid].team team
			{
				set temp NO
				ife sprite[spriteid].picnum MANDOFETT set temp YES
				ife sprite[spriteid].picnum MANDOCROUCH set temp YES
				ife temp YES
				{
					add enemy1_kills 1
					stopallsounds
					rand temp 4
					ife enemy1_kills 1 set temp 4 else
					ife enemy1_kills 2 set temp 0 else
					ife enemy1_kills 3 set temp 1 else
					ife enemy1_kills 4 set temp 2 else
					ife enemy1_kills 5 set temp 3
					ife temp 0 { globalsound MANDO_AMATEUR set subtitle_time 60 set subtitle_numlines 1 set subtitle_start 586 
					set cutcamtime player[].player_par
					set emp_overlay 60
					set emp_overlay_tile 15270
					}
					else
					ife temp 1 { globalsound MANDO_CORPSES set subtitle_time 120 set subtitle_numlines 1 set subtitle_start 587 
					set cutcamtime player[].player_par
					set emp_overlay 120
					set emp_overlay_tile 15270
					}
					else
					ife temp 2 { globalsound MANDO_LEVELS set subtitle_time 90 set subtitle_numlines 1 set subtitle_start 588 
					set cutcamtime player[].player_par
					set emp_overlay 90
					set emp_overlay_tile 15270
					
					}
					else
					ife temp 3 { globalsound MANDO_PATHETIC set subtitle_time 60 set subtitle_numlines 1 set subtitle_start 589 
					set cutcamtime player[].player_par
					set emp_overlay 60
					set emp_overlay_tile 15270
					
					}
					else
					ife temp 4 { globalsound MANDO_RESPAWNTOWN set subtitle_time 150 set subtitle_numlines 1 set subtitle_start 590 
					set cutcamtime player[].player_par
					set emp_overlay 150
					set emp_overlay_tile 15270
					
					}
				}
				ife sprite[spriteid].pal 12 add enemy1_kills 1
				ife sprite[spriteid].pal 10 add enemy2_kills 1
			}
			else
			{
				ife spriteid player[].i
				{
					ife pchar 0 { sub duke_kills 1 sub bluescore 1 }
					ife pchar 1 { sub shelly_kills 1 sub bluescore 1 }
					ife pchar 2 { sub wes_kills 1 sub bluescore 1 }
					
				}
				ife spriteid myshelly
				{
					ifge sprite[myshelly].picnum SHELLY ifle sprite[myshelly].picnum SHELLYCROUCH { sub shelly_kills 1 sub bluescore 1 }
					ifge sprite[myshelly].picnum DUKEBOT ifle sprite[myshelly].picnum DUKEBOTCROUCH { sub duke_kills 1 sub bluescore 1 }
					ifge sprite[myshelly].picnum WESBOT ifle sprite[myshelly].picnum WESBOTCROUCH { sub wes_kills 1 sub bluescore 1 }
				}
				ifl duke_kills 0 set duke_kills 0
				ifl shelly_kills 0 set shelly_kills 0
				ifl wes_kills 0 set wes_kills 0
				ifl bluescore 0 set bluescore 0
			}

		}
	}
	
	
	ifn gametype SURVIVAL
	{
		ifge bluescore scorelimit ifg bluescore redscore { setp[].timebeforeexit 180 set endgametime gametime set gametime -1 }
		ifge redscore scorelimit ifg redscore bluescore { setp[].timebeforeexit 180 set endgametime gametime set gametime -1 }
		
		ife gametime 0 ifn bluescore redscore { setp[].timebeforeexit 180 set endgametime gametime set gametime -1 }
	}
	ife gametype SURVIVAL ifactor APLAYER
	{
		set lastclock totalclock

		ife shellyinmap 0
		{
			set endgametime gametime
			set gametime -1
			set bluescore 0
			set redscore 1000
		}
	}

ends

defstate check_pstandard
  ifp pwalking
  {
	ife pchar 1 action APSHELLYWALK else
	ife pchar 2 action APWESWALK else
	ifvarand altcostume 2 action ALTDUKEWALK else
    action PWALK
  }
  else
    ifp pkicking
	{
	  ife pchar 1 action APSHELLYKICKING else
	  ife pchar 2 action APWESKICKING else
	  ifvarand altcostume 2 action ALTDUKEKICKING else
      action PAKICKING
	}
  else
    ifg qk_proxy 10
  {
	  ife pchar 1 action APSHELLYKICKING else
	  ife pchar 2 action APWESKICKING else
	  ifvarand altcostume 2 action ALTDUKEKICKING else
      action PAKICKING
  }
  else
    ifp pwalkingback
	{
	  ife pchar 1 action APSHELLYWALKBACK else
	  ife pchar 2 action APWESWALKBACK else
	  ifvarand altcostume 2 action ALTDUKEWALKBACK else
      action PWALKBACK
	}
  else
    ifp prunning
	{
	  ife pchar 1 action APSHELLYRUN else
	  ife pchar 2 action APWESRUN else
	  ifvarand altcostume 2 action ALTDUKERUN else
      action PRUN
	}
  else
    ifp prunningback
	{
	  ife pchar 1 action APSHELLYRUNBACK else
	  ife pchar 2 action APWESRUNBACK else
	  ifvarand altcostume 2 action ALTDUKERUNBACK else
      action PRUNBACK
	}
  else
    ifp pjumping
	{
	  ife pchar 1 action APSHELLYJUMPING else
	  ife pchar 2 action APWESJUMPING else
	  ifvarand altcostume 2 action ALTDUKEJUMPING else
      action PJUMPING
	}
  else
    ifp pducking
	{
	  ife pchar 1 action APSHELLYDUCKING else
	  ife pchar 2 action APWESDUCKING else
	  ifvarand altcostume 2 action ALTDUKEDUCKING else
      action PDUCKING
	}
	  
ends


gamevar random_sound 0 0
gamevar sound_temp 0 0

onevent EVENT_LOGO

stopsound FLY_BY

endevent

onevent EVENT_RECOGSOUND

ifl actorvar[].burning 0 set RETURN -1

endevent

onevent EVENT_SOUND

ife RETURN FLY_BY
{
	ifand player[].gm 4 set RETURN OLD_FLYBY
}

ife RETURN BOOKEM ife VOLUME 3 ife LEVEL 42
{
	set RETURN SHAKYGROUNDS3
}

ifsound PROT_BIGSPEECH
{
	set RETURN -1
	break
}
else
ifsound UNBALANCED
{
	set RETURN -1
	break
}
else
ifsound DOMINATION
{
	set RETURN -1
	break
}
else
ifsound DENIED
{
	set RETURN -1
	break
}
else
ifsound HEELTURN
{
	set RETURN -1
	break
}
else
ifsound ONLINEPOLL
{
	set RETURN -1
	break
}
else
ifsound DONTGO
{
	set RETURN -1
	break
}
else
ifsound ITSFINE
{
	set RETURN -1
	break
}
else
ifsound FUNNIEST
{
	set RETURN -1
	break
}
else
ifsound MANDO_ASSIST
{
	set RETURN -1
	break
}

ife RETURN RIPHEADNECK
ifg gametype 0
{
	set RETURN -1
	break
}

ife RETURN KICK_HIT
{
	ifand player[].gm 1 set RETURN MENU_CHANGE 
	else
	{
		ifsound KICK_HIT
		{
			set RETURN -1
			break
		}
	}
}

ife RETURN SQUISHED
{
	displayrandvar random_sound 5
	switch random_sound
	case 0 set RETURN SQUISHED1 break
	case 1 set RETURN SQUISHED2 break
	case 2 set RETURN SQUISHED3 break
	case 3 set RETURN SQUISHED4 break
	case 4 set RETURN SQUISHED5 break
	case 5 set RETURN SQUISHED6 break
	endswitch
	break
}

ife RETURN SHRINKER_FIRE
{
	ife player[].curr_weapon SHRINKER_WEAPON
	{
		set temp NO
		ife pchar 0 ifvarand dukeupgrades[SHRINKER_WEAPON] 1 set temp YES
		ife pchar 1 ifvarand shellyupgrades[SHRINKER_WEAPON] 1 set temp YES
		ife pchar 2 ifvarand wesupgrades[SHRINKER_WEAPON] 1 set temp YES
		ife temp YES
		set RETURN BFGFIRE
		break
	}
}

ife RETURN WHIPYOURASS
ife attmode YES ifl player[].player_par 60
{
	set RETURN -1
	break
}

ife RETURN DUKE_LAND set RETURN -1

geta[THISACTOR].picnum sound_temp 

ife player[].gm 8
{
	ife charsel 4
	{
		ife RETURN BONUS_SPEECH1 set RETURN WESBOOYA
		ife RETURN BONUS_SPEECH2 set RETURN WESSWEET
		ife RETURN BONUS_SPEECH3 set RETURN WESARMYOFME
		ife RETURN BONUS_SPEECH4 set RETURN WESALLCLEAR
		ife RETURN SHOTGUN_COCK set RETURN -1
	}
}
else
ifn sound_temp DUKEBOT
ifn sound_temp DUKEBOTCROUCH
ifn pchar 0
{
	switch RETURN
	case WHIPYOURASS
		ifvarand startmode 4 set RETURN WESBEATYOASS
	break
	case DUKE_USEMEDKIT 
		ife pchar 1 set RETURN B_USEMEDKIT else
		ife pchar 2 set RETURN WESYEAAAH
	break
	case DUKE_SEARCH
	
		ife pchar 1
		{
			ifrnd 128
			set RETURN B_GRUNT else set RETURN B_GRUNT2
		}
		else ife pchar 2
		{
			ifrnd 128 set RETURN WESGRUNT else
			set RETURN WESLAND3
		}
	break
	
	case DUKE_GRUNT 
		
		ife pchar 1
		set RETURN B_GRUNT 
		else ife pchar 2
		set RETURN WESGRUNT
		
	break
	
	case DUKE_SEARCH2 
		ife pchar 1
		set RETURN B_SEARCH 
		else ife pchar 2
		set RETURN WESLAND3
		
	break
	
	case DUKE_LONGTERM_PAIN ife pchar 2 set RETURN WESPAIN3 else { ifrnd 128 set RETURN B_GRUNT else set RETURN B_GASP } break
	case DUKETALKTOBOSS ife pchar 2 set RETURN WESBEATYOASS else set RETURN B_KICKYOURASS break
	case DUKE_SCREAM ife pchar 2 set RETURN WESSCREAM else set RETURN B_FALLING break
	case DUKE_GETWEAPON1 ife pchar 2 set RETURN WESHELLYEAH else set RETURN B_FUCKYEAH break
	case DUKE_GETWEAPON2 ife pchar 2 set RETURN WESNICE else set RETURN B_NICE break
	case DUKE_GETWEAPON3 ife pchar 2 set RETURN WESTALKINGABOUT else { set RETURN B_GROOVY } break
	case DUKE_GETWEAPON4 ife pchar 2 set RETURN WESYEAAAH else set RETURN B_YEAHBABY break
	case DUKE_GETWEAPON5 ife pchar 2 set RETURN WESBOOYA else set RETURN B_KICKASS break
	case DUKE_GETWEAPON6 ife pchar 2 set RETURN WESGETFUN else set RETURN B_HAILQUEEN break
	case DUKE_HIT_STRIPPER1 ife pchar 2 set RETURN WESDAMN else set RETURN B_WHOOPS break
	case DUKE_HIT_STRIPPER2 ife pchar 2 set RETURN WESOHSMACK else set RETURN B_MYBAD break
	case GENERIC_AMBIENCE23 ife pchar 2 set RETURN WESIMMAD else set RETURN B_MYRIDE break
	case GENERIC_AMBIENCE13 ife pchar 2 set RETURN WESIMMAD else set RETURN B_MYRIDE break
	case DUKE_GASP ife pchar 2 set RETURN WESGASP else set RETURN B_GASP break
	case DUKE_PISSRELIEF ife pchar 2 set RETURN -1 else set RETURN B_USEMEDKIT break
	case DUKE_LAND_HURT ife pchar 2 set RETURN WESLAND3 else set RETURN B_HARDLAND break
	case DUKE_CRACK ife pchar 2 set RETURN WESWANNAGO else set RETURN B_AFK1 break
	case DUKE_CRACK2 ife pchar 2 set RETURN WESEVERYBODY else set RETURN B_AFK2 break
	
	case DUKE_GOTHEALTHATLOW ife pchar 2 set RETURN WESYEAAAH else set RETURN B_NEEDEDTHAT break
	case JIBBED_ACTOR4 ife pchar 2 set RETURN WESHOLYSHIT else set RETURN B_JIB1 break
	case JIBBED_ACTOR5 ife pchar 2 set RETURN WESMADEPOINT else set RETURN B_IMGOOD break
	case BOSS4_FIRSTSEE ife pchar 2 set RETURN WESBEATYOASS else set RETURN B_KICKYOURASS break
	case MOUSEANNOY ife pchar 2 set RETURN WESYEAHBITCH else set RETURN B_ANNOYING break
	case WAR_AMBIENCE5 ife pchar 2 set RETURN -1 else set RETURN B_FORCERECKON break
	case WAR_AMBIENCE7 ife pchar 2 set RETURN -1 else set RETURN B_TERMINATED break
	case WAR_AMBIENCE8 ife pchar 2 set RETURN WESEVERYBODY else set RETURN B_KARAOKE break
	case WAR_AMBIENCE9 ife pchar 2 set RETURN WESBEATYOASS else set RETURN B_AVENGE break
	case WAR_AMBIENCE10 ife pchar 2 set RETURN -1 else set RETURN B_KICKCHEW break
	case EATFOOD ife pchar 2 set RETURN WESDINNER else set RETURN B_NOTEATING break
	case DUKE_DEAD ife pchar 2 set RETURN WESDEATH1 else set RETURN B_DIE break
	case DUKE_KILLED1 ife pchar 2 set RETURN WESDEATH3 else set RETURN B_KILLED1 break
	case DUKE_KILLED2 ife pchar 2 set RETURN WESBS else set RETURN B_DAMNFUCK break
	case DUKE_KILLED3 ife pchar 2 set RETURN WESRUIN else set RETURN B_YOUGUYSUCK break
	case DUKE_KILLED4 ife pchar 2 set RETURN WESDEATH2 else set RETURN B_KILLED4 break
	case DUKE_KILLED5 ife pchar 2 set RETURN WESDEATH3 else set RETURN B_KILLED5 break
	case PARTY_SPEECH ife pchar 2 set RETURN WESPLACEISCRAZY else set RETURN B_PARTY break
	case DUKE_STEPONFECES ife pchar 2 set RETURN WESJUSTAINTRIGHT else { ifrnd 128 set RETURN B_EWW else set RETURN B_SHITHAPPENS } break
	case DUKE_TIP1  ife pchar 2 set RETURN WESDANCE else set RETURN B_WANNADANCE break
	case DUKE_TIP2  ife pchar 2 set RETURN WESDAYUM else set RETURN B_SHAKEIT break
	case YOHOO2 ife pchar 2 set RETURN -1 else { set RETURN B_PIRATEWALK } break
	case VACATIONSPEECH ife pchar 2 set RETURN -1 else set RETURN B_VACATIONSPEECH break
	case GENERIC_AMBIENCE20 ife pchar 2 set RETURN -1 else set RETURN B_HAVETHECON break
	case GENERIC_AMBIENCE16 ife pchar 2 set RETURN WESJUSTAINTRIGHT else set RETURN B_DOOMED break
	case SNAKESPEECH ife pchar 2 set RETURN WESJUSTAINTRIGHT else set RETURN B_ESCAPELA break
	case GETBACKTOWORK ife pchar 2 set RETURN -1 else set RETURN B_SLACKER break
	case KTIT ife pchar 2 set RETURN -1 else set RETURN B_KTIT break
	case JIBBED_ACTOR11 ife pchar 2 set RETURN WESOHSMACK else set RETURN -1 break
	case JIBBED_ACTOR12 ife pchar 2 set RETURN WESGETTINGFUN else set RETURN B_SUCKIT break
	case YIPPEE1 ife pchar 2 set RETURN -1 else set RETURN B_YIPPEE break
	case DUKE_LOOKINTOMIRROR ife pchar 2 set RETURN WESARMYOFME else set RETURN B_LOOKGOOD1 break
	case RIPHEADNECK ife pchar 2 set RETURN WESBEATYOASS else set RETURN B_RIPHEADNECK break
	case DUKE_TALKTOBOSSFALL ife pchar 2 set RETURN WESMADEPOINT else set RETURN B_TALKTOBOSSFALL break
	case BOSS4_DEADSPEECH ife pchar 2 set RETURN WESWHATISTHING else set RETURN B_ABORTSPECIES break
	case BONUS_SPEECH1 ife pchar 2 set RETURN WESGOTIT else set RETURN B_LETSROCK break
	case BONUS_SPEECH2 ife pchar 2 set RETURN WESIMONIT else set RETURN SHELLYREADY break
	case BONUS_SPEECH3 ife pchar 2 set RETURN -1 else set RETURN B_JIB10 break
	case BONUS_SPEECH4 ife pchar 2 set RETURN WESYEAAAH else set RETURN B_KICKASS break
	case DUKE_TAKEPILLS ife pchar 2 nullop else set RETURN B_TAKEPILLS break
	case BIGGUNS ife pchar 2 set RETURN WESTALKINGABOUT else set RETURN B_BIGGUNS break
	case YOURUGLY ife pchar 2 set RETURN WESWHATISTHING else set RETURN B_UGLYMOFO break
	case JIBBED_ACTOR3 ife pchar 2 set RETURN WESHOLYSHIT else set RETURN B_JIB1 break
	
	case DUKE_BOOBY
	case GENERIC_AMBIENCE14
	case GENERIC_AMBIENCE15
	case WAR_AMBIENCE6
	case SUPERMARKET
	case MAKEMYDAY
	case YOHOO1
	case AREA51SPEECH
	case DOGROOMSPEECH
	case BOOKEM
	case FOUNDJONES
	case SUNSTORM_SOUND09
	case SUNSTORM_SOUND12
	case SUNSTORM_SOUND14
	case SUNSTORM_SOUND17
	case SUNSTORM_SOUND18
	case SUNSTORM_SOUND19 
	case POSTAL_SPEECH
	case INTRO4_6
	  ifvarand startmode 1 nullop else
	  // ife myshelly -1
		set RETURN -1
	  // else ife actorvar[myshelly].monstatus 2 set RETURN -1
	  // else ife actorvar[myshelly].monstatus 70 set RETURN -1
	break
	case GENERIC_AMBIENCE17 set RETURN -1 break
	// CARIBBEAN VACATION SOUNDS
	case SUNSTORM_SOUND01 ife pchar 2 set RETURN -1 else { set RETURN B_LOVEBOAT } break
	case SUNSTORM_SOUND02 ife pchar 2 set RETURN -1 else { set RETURN B_SURFINSAFARI } break
	case SUNSTORM_SOUND03 ife pchar 2 set RETURN -1 else { set RETURN B_CRASHPARTY } break
	case SUNSTORM_SOUND04 ife pchar 2 set RETURN -1 else { set RETURN B_HATEDISCO } break
	case SUNSTORM_SOUND05 ife pchar 2 set RETURN -1 else { set RETURN B_STAYINALIVE } break
	case SUNSTORM_SOUND06 ife pchar 2 set RETURN -1 else { set RETURN B_LOOKINTOSCORE } break
	case SUNSTORM_SOUND07 ife pchar 2 set RETURN -1 else { set RETURN B_DOORONE } break
	case SUNSTORM_SOUND08 ife pchar 2 set RETURN -1 else { set RETURN B_HOTBABES } break
	// case SUNSTORM_SOUND09 no Bombshell version
	case SUNSTORM_SOUND10 ife pchar 2 set RETURN -1 else { set RETURN B_WOOHOO } break
	case SUNSTORM_SOUND11 ife pchar 2 set RETURN -1 else { set RETURN B_DAPLANE } break
	// case SUNSTORM_SOUND12 no Bombshell version
	case SUNSTORM_SOUND13 ife pchar 2 { } else { set RETURN B_GOESMYRIDE } break
	// case SUNSTORM_SOUND14 no Bombshell version
	case SUNSTORM_SOUND15 case SUNSTORM_SOUND16
		ife pchar 2 set RETURN -1 else { set RETURN B_DECISIONS } break
	// case SUNSTORM_SOUND17 no Bombshell version
	// case SUNSTORM_SOUND18 no Bombshell version
	// case SUNSTORM_SOUND19 no Bombshell version
	case VACA_GETWEAP1 ife pchar 2 set RETURN -1 else { set RETURN B_WOOHOO } break
	case VACA_GETWEAP2 ife pchar 2 set RETURN -1 else { set RETURN B_CRASHPARTY } break
	case VACA_GETWEAP3 ife pchar 2 set RETURN -1 else { set RETURN B_YEAHBABY } break
	case VACA_DIE1 ife pchar 2 { } else { set RETURN B_EWW } break
	case VACA_DIE2 ife pchar 2 set RETURN -1 else { set RETURN B_VACATIONSUCKS } break
	case D_BAIT ife pchar 2 set RETURN -1 else { set RETURN B_BAIT } break
	case D_FISHFOOD ife pchar 2 set RETURN -1 else { set RETURN B_FISHFOOD } break
	case D_ONTHEHOUSE ife pchar 2 set RETURN -1 else { set RETURN B_ONTHEHOUSE } break
	case D_ASSWIPE ife pchar 2 set RETURN -1 else { set RETURN B_SUNASSWIPE } break
	case ENDSEQVOL3SND2 // game over
		ifvarand startmode 1 nullop else set RETURN -1 break
	endswitch
}

endevent

gamevar lastinput 0 1

state switchnuke
	
	ife nukeselect YES
	{
		set WEAPON4_FIRESOUND RPG_BIGSHOOT
		set WEAPON4_TOTALTIME 30
		set WEAPON4_FIREDELAY 5
	}
	else
	ife pchar 2
	{
		set WEAPON4_FIRESOUND RPG_BIGSHOOT
		set WEAPON4_TOTALTIME 50
	}
	else
	ife pchar 1
	{
		ifvarand shellyupgrades[RPG_WEAPON] 1 
		{
			set WEAPON4_FIRESOUND ROCKETFIRE2 
			set WEAPON4_TOTALTIME 20
		}
		else
		{
			set WEAPON4_FIRESOUND RPG_SHOOT
			set WEAPON4_TOTALTIME 30
		}
		set WEAPON4_FIREDELAY 4
	}
	else
	{
		ifvarand dukeupgrades[RPG_WEAPON] 1 set WEAPON4_FIRESOUND ROCKETFIRE2 else
		set WEAPON4_FIRESOUND RPG_SHOOT
		set WEAPON4_TOTALTIME 20
		set WEAPON4_FIREDELAY 4
	}
	
ends

onevent EVENT_PROCESSINPUT

getinput[].bits bits
getinput[].extbits extbits

ifp pducking nullop else // to prevent slidekick from crouch
ifvarand extbits 1 { add forwinput 2 set backinput 0 }
ifvarand extbits 2 { add backinput 2 set forwinput 0 }
ifg forwinput 20 set forwinput 20
ifg backinput 20 set backinput 20

ifvarand bits 536870912 { ifl holdinteract 0 set holdinteract 0 add holdinteract 1 } else 
{
	ifg holdinteract 0 set holdinteract -1
	else ifl holdinteract 0
	{
		sub holdinteract 1
		ifl holdinteract -5
		set holdinteract 0
	}
}

set tempb bits
set xydist scandist
abs xydist
ifl xydist 1561
{
	ifn scannedsprite -1
	{
		switch sprite[scannedsprite].picnum
		case DIPSWITCH case 163
		case DIPSWITCH2 case 165
		case DIPSWITCH3 case 169
		// case HANDSWITCH case 1112
		// case ALIENSWITCH case 1143
		ifvarand bits 536870912 // player pressing space
		{
			xorvar bits 536870912
			setinput[].bits bits
			ifvarand lastinput 536870912 set shootswitch 0 else
			set shootswitch 1
		}
		break
		endswitch
	}
}
set lastinput tempb

ifn player[].movement_lock 0
{
	setinput[].fvel 0
	setinput[].svel 0
}

ifvarand inven_upgrades 8 // ifg player[].boot_amount 0
ife disable_doubletap NO
{
	ifg ltap 0 sub ltap 1
	ifg rtap 0 sub rtap 1
	ifg ftap 0 sub ftap 1
	ifg btap 0 sub btap 1
	
	ife dashing 0
	ife saberdash 0
	ife slidekick 0
	ife sidekick 0
	ife padmove 0
	ife cutcam -1
	ife thiscam -1
	ife movecam -1
	ifp palive
	ifn player[].i redcarrier
	ife player[].movement_lock 0
	{
		// extbits:
		// 1 forward, 2 back, 4 strafe L, 8 strafe R
		getp[].ang dashang
		ifvarand extbits 4 
		{
			sub dashang 512
			ifvarand oldextbits 4 nullop else 
			{
				ifg ltap 0 ifl ltap 6 set dashing 3
				set ltap 6
			}
		}
		
		ifvarand extbits 8 
		{
			add dashang 512
			ifvarand oldextbits 8 nullop else
			{
				ifg rtap 0 ifl rtap 6 set dashing 3
				set rtap 6
			}
		}
		
		ifvarand extbits 2 
		{
			add dashang 1024
			ifvarand oldextbits 2 nullop else 
			{
				ifg btap 0 ifl btap 6 set dashing 3
				set btap 6
			}
		}
		
		ifvarand extbits 1
		{
			ifvarand oldextbits 1 nullop else 
			{
				ifg ftap 0 ifl ftap 6 set dashing 3
				set ftap 6
			}
		}

		
		ife dashing 3
		{
			// getp[].boot_amount temp, sub temp 1, setp[].boot_amount temp
			screensound DASHSOUND
		}
		
	
	}
}

endevent

onevent EVENT_PREUPDATEANGLES

ife zoomin YES
{
	getinput[].q16avel temp
	shiftr temp 1
	setinput[].q16avel temp
	
	getinput[].q16horz temp
	shiftr temp 1
	setinput[].q16horz temp
}

endevent

appendevent EVENT_JUMP

ifvarn transition 0 { setvar RETURN -1 break }

endevent

appendevent EVENT_WEAPKEY2
ifp palive
ife player[].weapon_pos 0
{
	ife player[].curr_weapon PISTOL_WEAPON
	{
		ife LASERMODE 1 // CURRENTLY USING LASER PISTOL
		{
			ife LASERFIRE 0
			{
				ifg COMMAMMO 0
				{
					set LASERMODE -4 // transferring to comm gun
					setp[].weapon_pos -1
					set gun_name LASERPISTOL
					ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
				}
				else
				// ifg LASERAMMO 0
				ifg pistolammo 0 
				{
					set LASERMODE 2 // transferring to regular pistol
					setp[].weapon_pos -1
					// set WEAPON1_SELECTSOUND INSERT_CLIP
					set gun_name FIRSTGUNSPRITE
					ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
				}
			}
		}
		else
		ife LASERMODE NO
		{
			ife player[].kickback_pic 0
			{
				// ife pchar 2
				// {
					// ife weap_owned[203] YES // Wes dual pistol
					// {
						// set B wesupgrades[PISTOL_WEAPON]
						// ifvarand B 4 xorvar B 4 else orvar B 4
						// setarray wesupgrades[PISTOL_WEAPON] B
					// }
				// }
				// else
				// {
					ifg LASERAMMO 0
					{
						set LASERMODE -1 // transferring to laser pistol
						setp[].weapon_pos -1
						set WEAPON1_SELECTSOUND SWITCHTOLASER 
						set gun_name LASERPISTOL
						ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
					}
					else
					ifg COMMAMMO 0
					{
						set LASERMODE -2 // transferring to COMM gun
						setp[].weapon_pos -1
						set WEAPON1_SELECTSOUND SELECT7 
						set gun_name LASERPISTOL
						ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
					}
				// }
			}
		}
		else
		ife LASERMODE 3 // comm gun
		{
			ifg pistolammo 0 
			{
				set LASERMODE 4 // transferring to regular pistol
				setp[].weapon_pos -1
				// set WEAPON1_SELECTSOUND INSERT_CLIP
				set gun_name FIRSTGUNSPRITE
				ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
			}
			else
			ifg LASERAMMO 0
			{
				set LASERMODE -1 // transferring to laser pistol
				setp[].weapon_pos -1
				set WEAPON1_SELECTSOUND SWITCHTOLASER 
				set gun_name LASERPISTOL
				ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
			}
		}
	}
	else
	{
		ife pistolammo 0
		ife player[].kickback_pic 0
		{
			ifg LASERAMMO 0
			{
				set LASERMODE -1 // transferring to laser pistol
				setp[].weapon_pos -1
				set WEAPON1_SELECTSOUND SWITCHTOLASER 
				set gun_name LASERPISTOL
				ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
			}
			else
			ifg COMMAMMO 0
			{
				set LASERMODE -2 // transferring to COMM gun
				setp[].weapon_pos -1
				set WEAPON1_SELECTSOUND SELECT7 
				set gun_name LASERPISTOL
				ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
			}
		}
	}
}
endevent

appendevent EVENT_WEAPKEY3

ifge pchar 1 ifle pchar 2
ife player[].weapon_pos 0
ife player[].curr_weapon SHOTGUN_WEAPON
ifp palive
{
	ifvarand gotbow 1 ife player[].gotweapon SHOTGUN_WEAPON YES 
	{
		ife player[].curr_weapon SHOTGUN_WEAPON
		ife player[].kickback_pic 0
		ife player[].weapon_pos 0
		{
			setp[].weapon_pos -1
			ifvarand gotbow 2 
			{
				orvar gotbow 8 // shotgun
				set gun_name SHOTGUNSPRITE
				ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
			}
			else 
			{
				orvar gotbow 4 // switching to bow
				al gotbow
				set gun_name BOWSPRITE
				ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
			}
		}
	}
	
}

ife pchar 0
ife player[].weapon_pos 0
ife player[].curr_weapon SHOTGUN_WEAPON
ifp palive
{
	ifvarand gotDB 1 ife player[].gotweapon SHOTGUN_WEAPON YES 
	{
		ife player[].curr_weapon SHOTGUN_WEAPON
		ife player[].kickback_pic 0
		ife player[].weapon_pos 0
		{
			setp[].weapon_pos -1
			ifvarand gotDB 2 
			{
				orvar gotDB 8 // switching to regular shotgun
				set gun_name SHOTGUNSPRITE
				ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
			}
			else 
			{
				orvar gotDB 4 // switching to DB shotgun
				set gun_name SHOTGUNSPRITE
				ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
			}
		}
	}
	
}
endevent

appendevent EVENT_WEAPKEY4

set temp NO
ifvarand gotshock 1
ifvarand dukeupgrades[CHAINGUN_WEAPON] 8
ife pchar 0 set temp YES

ifvarand gotshock 1
ifvarand shellyupgrades[CHAINGUN_WEAPON] 8
ife pchar 1 set temp YES

ifvarand gotshock 1
ifvarand wesupgrades[CHAINGUN_WEAPON] 8
ife pchar 2 set temp YES

ife temp YES
ife player[].weapon_pos 0
ife player[].curr_weapon CHAINGUN_WEAPON
ifp palive
{
	ife player[].gotweapon CHAINGUN_WEAPON YES 
	{
		ife player[].curr_weapon CHAINGUN_WEAPON
		ife player[].kickback_pic 0
		ife player[].weapon_pos 0
		{
			setp[].weapon_pos -1
			ifvarand gotshock 2 
			{
				orvar gotshock 8 // switching to CHAINGUN
				set gun_name CHAINGUNSPRITE
				ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
			}
			else 
			{
				orvar gotshock 4 // switching to executioner
				set gun_name CHAINGUNSPRITE
				ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
			}
		}
	}
	
}

ife pchar 2
ife player[].weapon_pos 0
ife player[].curr_weapon CHAINGUN_WEAPON
ife player[].kickback_pic 0
ifp palive
	ife weap_owned[221] YES // Wes dual uzi
	{
		set B wesupgrades[CHAINGUN_WEAPON]
		ifvarand B 1 xorvar B 1 else orvar B 1
		setarray wesupgrades[CHAINGUN_WEAPON] B
		state wesweapons
	}

endevent

appendevent EVENT_WEAPKEY5

ifg nukeamount 0 ife player[].gotweapon RPG_WEAPON YES 
{
	ife player[].curr_weapon RPG_WEAPON
	ife player[].kickback_pic 0
	ife player[].weapon_pos 0
	{
		setp[].weapon_pos -1
		ife nukeselect YES 
		{
			set nukeselect -2 // switching to regular RPG 
			set gun_name RPGSPRITE
			ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
		}
		else 
		{
			set nukeselect -1 // switching to NUKE
			set gun_name NUKESPRITE
			ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
		}
	}
}

endevent


appendevent EVENT_WEAPKEY7

ife player[].curr_weapon SHRINKER_WEAPON
ife player[].gotweapon GROW_WEAPON YES
ife player[].weapon_pos 0
{
	set gun_name GROWSPRITEICON
	ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
	break
} 


ife player[].curr_weapon GROW_WEAPON
ife player[].gotweapon SHRINKER_WEAPON YES
ife player[].weapon_pos 0
{
	set gun_name SHRINKERSPRITE
	ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
	break
}

endevent

appendevent EVENT_WEAPKEY8

ifvarand gotrailgun 1 ife player[].gotweapon DEVISTATOR_WEAPON YES 
{
	ife player[].curr_weapon DEVISTATOR_WEAPON
	ife player[].kickback_pic 0
	ife player[].weapon_pos 0
	{
		setp[].weapon_pos -1
		ifvarand gotrailgun 2 
		{
			orvar gotrailgun 8 // switching to devistator 
			set gun_name DEVISTATORSPRITE
			ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
		}
		else 
		{
			orvar gotrailgun 4 // switching to railgun
			set gun_name RAILGUNSPRITE
			ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
		}
	}
}

endevent

appendevent EVENT_WEAPKEY10

ife player[].weapon_pos 0
ife player[].curr_weapon FREEZE_WEAPON
ifp palive
{
	ifvarand gotplasma 1 ife player[].gotweapon FREEZE_WEAPON YES 
	{
		ife player[].curr_weapon FREEZE_WEAPON
		ife player[].kickback_pic 0
		ife player[].weapon_pos 0
		{
			setp[].weapon_pos -1
			ifvarand gotplasma 2 
			{
				orvar gotplasma 8 // switching to freezer or incinerator 
				set gun_name FREEZESPRITE
				ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
			}
			else 
			{
				orvar gotplasma 4 // switching to plasma
				set gun_name PLASMASPRITE
				ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
			}
		}
	}
	
}
endevent

definegamefuncname 39 ZOOM_OUT_MAP
definegamefuncname 40 ZOOM_IN_MAP

definegamefuncname 42 DASH
onevent EVENT_HOLSTER // used for dash
	set RETURN -1
	
	ifvarand inven_upgrades 8 // ifg player[].boot_amount 0
	{
		ife dashing 0
		ife saberdash 0
		ife slidekick 0
		ife sidekick 0
		ife padmove 0
		ife cutcam -1
		ife thiscam -1
		ife movecam -1
		ifp palive
		ifn player[].i redcarrier
		ife player[].movement_lock 0
		{
			// extbits:
			// 1 forward, 2 back, 4 strafe L, 8 strafe R
			getp[].ang dashang
			ifvarand extbits 4 
			{
				ifvarand extbits 1
					sub dashang 256
				else
				ifvarand extbits 2
					sub dashang 768
				else
					sub dashang 512
			}
			else
			ifvarand extbits 8 
			{ 
				ifvarand extbits 1
					add dashang 256
				else
				ifvarand extbits 2
					add dashang 768
				else
					add dashang 512
			}
			else
			ifvarand extbits 2 
				add dashang 1024 

			
			set dashing 3
			// getp[].boot_amount temp, sub temp 1, setp[].boot_amount temp
			screensound DASHSOUND
			
		
		}
	}
	else
		ife player[].fta 0 quote 1184

endevent

definegamefuncname 18 RELOAD_WEAPON
onevent EVENT_AIMDOWN

// same as bits 16
set RETURN -1

ifn pchar 0
{
	set B player[].ammo_amount SHOTGUN_WEAPON
	sub B 1
	
	ife player[].weapon_pos 0
	ife player[].kickback_pic 0
	{
		ife pchar 1
		ife m4reload 0
		ifl m4clip 30
		ife player[].curr_weapon CHAINGUN_WEAPON
		ifg player[].ammo_amount CHAINGUN_WEAPON m4clip
		{
			set m4reload 1
		}
		
		set TMP_A NO
		ife pchar 1 ifvarand shellyupgrades[SHOTGUN_WEAPON] 128 set TMP_A YES
		ife pchar 2 ifvarand wesupgrades[SHOTGUN_WEAPON] 128 set TMP_A YES
		
		ife player[].curr_weapon SHOTGUN_WEAPON
		ife TMP_A YES
		ifg B 0
		ife player[].reloading NO
		ifl spasclip 8
		ifg B spasclip
		{
			setp[].reloading YES
			setp[].kickback_pic 11
			ifl B 8
			set spasclip B else
			set spasclip 8
		}	
	}
}

ife pchar 2
{
	ife player[].weapon_pos 0
	ife player[].kickback_pic 0
	{
	
		ife player[].curr_weapon CHAINGUN_WEAPON
		ife uzireload 0
		ifl uziclip 32
		ifg player[].ammo_amount CHAINGUN_WEAPON uziclip
		{
			set uzireload 1
		}
		
		ife player[].curr_weapon GROW_WEAPON
		ifl skarclip 20
		ifg player[].ammo_amount GROW_WEAPON skarclip
		{
			setp[].reloading YES
			setp[].kickback_pic 5
		}
		
		ife player[].curr_weapon SHRINKER_WEAPON
		ifl skarclipB 10
		ifg player[].ammo_amount SHRINKER_WEAPON skarclipB
		{
			setp[].reloading YES
			setp[].kickback_pic 5
		}
	}
}

// RELOAD WHEN USING PISTOL	
ife LASERMODE NO
ife player[].curr_weapon PISTOL_WEAPON
ife player[].kickback_pic 0
ife player[].weapon_pos 0
{
	ifn THISCLIP PISTOLCLIP
	ifg player[].ammo_amount PISTOL_WEAPON THISCLIP
	{
		ife pchar 2 setp[].kickback_pic 9
		else
		ife pchar 1 setp[].kickback_pic 10
		else
		setplayer[THISACTOR].kickback_pic 7
		setplayer[THISACTOR].reloading YES
		ife pchar 0 ifvarand dukeupgrades[PISTOL_WEAPON] 8 sound GLOCKMAGOUT else
		ife pchar 1 { ifvarand shellyupgrades[PISTOL_WEAPON] 8 { sound GLOCKMAGOUT setplayer[THISACTOR].kickback_pic 7 } else
		sound DEAGLE_CLIPOUT } else
		sound EJECT_CLIP
	}
}
endevent


onevent EVENT_ALTWEAPON

ifvarand gotrailgun 1 ife player[].gotweapon DEVISTATOR_WEAPON YES 
{
	ife player[].curr_weapon DEVISTATOR_WEAPON
	ife player[].kickback_pic 0
	ife player[].weapon_pos 0
	{
		setp[].weapon_pos -1
		ifvarand gotrailgun 2
		{
			orvar gotrailgun 8 // switching to devistator 
			set gun_name DEVISTATORSPRITE
			ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
		}
		else 
		{
			orvar gotrailgun 4 // switching to railgun
			set gun_name RAILGUNSPRITE
			ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
		}
	}
}

ifvarand gotplasma 1 ife player[].gotweapon FREEZE_WEAPON YES 
{
	ife player[].curr_weapon FREEZE_WEAPON
	ife player[].kickback_pic 0
	ife player[].weapon_pos 0
	{
		setp[].weapon_pos -1
		ifvarand gotplasma 2 
		{
			orvar gotplasma 8 // switching to freezer or incinerator 
			set gun_name FREEZESPRITE
			ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
		}
		else 
		{
			orvar gotplasma 4 // switching to plasma
			set gun_name PLASMASPRITE
			ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
		}
	}
}

ife player[].curr_weapon SHRINKER_WEAPON
{
	set gun_name GROWSPRITEICON
	ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
} 
else
ife player[].curr_weapon GROW_WEAPON
{
	set gun_name SHRINKERSPRITE
	ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
}

ife player[].curr_weapon RPG_WEAPON
ife player[].weapon_pos 0
ife player[].kickback_pic 0
ife player[].gotweapon RPG_WEAPON YES 
{
	ifg nukeamount 0 
	{
		setp[].weapon_pos -1
		ife nukeselect YES 
		{
			set nukeselect -2 // switching to regular RPG 
			set gun_name RPGSPRITE
			ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
		}
		else 
		{
			set nukeselect -1 // switching to NUKE
			set gun_name NUKESPRITE
			ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
		}
	}
	else
	// CHANGE AMMO TYPE WHEN USING RPG
	ife pchar 1
	ifg player[].ammo_amount RPG_WEAPON 0
	{
		ifvarand shellyupgrades[RPG_WEAPON] 1 nullop else
		{
			ife rpgtype 0 set rpgtype 1 else
			ife rpgtype 1 set rpgtype 0
			setp[].kickback_pic 10
			set rpgchange YES
			ifvarand gametips 8 { xorvar gametips 8 savegamevar gametips }
		}
	}
}

ifge pchar 1 ifle pchar 2
{
	ife player[].weapon_pos 0
	ife player[].kickback_pic 0
	{
		ife pchar 1
		ife m4reload 0
		ifl m4clip 30
		ife player[].curr_weapon CHAINGUN_WEAPON
		ifg player[].ammo_amount CHAINGUN_WEAPON m4clip
		{
			set m4reload 1
		}
		else
		ife player[].curr_weapon SHOTGUN_WEAPON
		ifvarand gotbow 1 ife player[].gotweapon SHOTGUN_WEAPON YES 
		{
			ife player[].curr_weapon SHOTGUN_WEAPON
			ife player[].kickback_pic 0
			ife player[].weapon_pos 0
			{
				setp[].weapon_pos -1
				ifvarand gotbow 2 
				{
					orvar gotbow 8 // switching to freezer or incinerator 
					set gun_name SHOTGUNSPRITE
					ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
				}
				else 
				{
					orvar gotbow 4 // switching to bow
					set gun_name BOWSPRITE
					ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
				}
			}
		}
	}
}

ife pchar 2
{
	ife player[].weapon_pos 0
	ife player[].kickback_pic 0
	{
		ife uzireload 0
		ifl uziclip 32
		ife player[].curr_weapon CHAINGUN_WEAPON
		ifg player[].ammo_amount CHAINGUN_WEAPON uziclip
		{
			set uzireload 1
		}
	}
}

ifvarand gotDB 2 nullop else
ife pchar 0
ife player[].curr_weapon SHOTGUN_WEAPON
ife player[].weapon_pos 0
ife player[].kickback_pic 0
ifvarand dukeupgrades[SHOTGUN_WEAPON] 4
ife weap_owned[13] YES
{
	setp[].kickback_pic 9
	set B dukeupgrades[SHOTGUN_WEAPON]
	ifvarand B 2 
	{
		xorvar B 2
		quote 364
	}
	else 
	{
		orvar B 2
		quote 365
	}
	setarray dukeupgrades[SHOTGUN_WEAPON] B
}

ifp palive
ife player[].weapon_pos 0
{
	ife player[].curr_weapon PISTOL_WEAPON
	{
		ife LASERMODE YES
		{
			ifg LASERAMMO 0
			ife LASERFIRE 0
			ifg pistolammo 0 
			{
				set LASERMODE 2 // transferring to regular pistol
				setp[].weapon_pos -1
				// set WEAPON1_SELECTSOUND INSERT_CLIP
				set gun_name FIRSTGUNSPRITE
				ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
			}
		}
		else
		ife LASERMODE NO
		{
			ifg LASERAMMO 0
			ife player[].kickback_pic 0
			{
				set LASERMODE -1 // transferring to laser pistol
				setp[].weapon_pos -1
				set WEAPON1_SELECTSOUND SWITCHTOLASER 
				set gun_name LASERPISTOL
				ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
			}
		}
		else
		{
			ife pistolammo 0
			ifg LASERAMMO 0
			ife player[].kickback_pic 0
			{
				set LASERMODE -1 // transferring to laser pistol
				setp[].weapon_pos -1
				set WEAPON1_SELECTSOUND SWITCHTOLASER 
				set gun_name LASERPISTOL
				ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
			}
		}
	}
	
	ife pchar 0
	ife player[].curr_weapon SHOTGUN_WEAPON
	{
		ifvarand gotDB 1 ife player[].gotweapon SHOTGUN_WEAPON YES 
		{
			ife player[].curr_weapon SHOTGUN_WEAPON
			ife player[].kickback_pic 0
			{
				setp[].weapon_pos -1
				ifvarand gotDB 2 
				{
					orvar gotDB 8 // switching to regular shotgun
					set gun_name SHOTGUNSPRITE
					ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
				}
				else 
				{
					orvar gotDB 4 // switching to DB shotgun
					set gun_name SHOTGUNSPRITE
					ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
				}
			}
		}
		
	}
	
}

endevent

state holotaunts

	ifsound HOLOTAUNT1 break
	ifsound HOLOTAUNT2 break
	ifsound HOLOTAUNT3 break
	ifsound HOLOTAUNT4 break
	ifsound HOLOTAUNT5 break
	rand temp 4
	ife temp 0 sound HOLOTAUNT1 else
	ife temp 1 sound HOLOTAUNT2 else
	ife temp 2 sound HOLOTAUNT3 else
	ife temp 3 sound HOLOTAUNT4 else
	ife temp 4 sound HOLOTAUNT5

ends

onevent EVENT_HOLODUKEOFF
	
	stopsound HOLOTAUNT1
	stopsound HOLOTAUNT2
	stopsound HOLOTAUNT3
	stopsound HOLOTAUNT4
	stopsound HOLOTAUNT5
	ifn mynaamah -1 setav[mynaamah].monstatus 2
	
		
endevent

onevent EVENT_HOLODUKEON
	
	ife pchar 2
	{
		ife mynaamah -1
		{
			ifg player[].holoduke_amount 0
			{
				espawn NAAMAH
				set mynaamah RETURN
			}
		}
		else setav[mynaamah].monstatus 2
		set RETURN -1
		break
	}
	ifg player[].holoduke_amount 0
	state holotaunts
		
endevent

onevent EVENT_USENIGHTVISION

	ife player[].heat_on NO
	{
		ife aimbot_on YES
		{
			sound NITEVISION_ONOFF
			set aimbot_on NO
			quote 710
			set RETURN -1
		}
		else
		{
			
			ifvarand inven_upgrades 2
			ifg player[].heat_amount 0
			{
				sound AIMBOT_ON
				set RETURN -1
				set aimbot_on YES
				quote 709
			}
		}
	}

endevent


definegamefuncname 11 SWAP_CHARACTERS
onevent EVENT_LOOKUP

	set RETURN -1
	ifvarand bits 8192 ifvarand oldbits 8192 break
	
	ifn myshelly -1
	ife actorvar[myshelly].monstatus 70 // waiting
	{
		setav[myshelly].monstatus 30
		seta[myshelly].htactorstayput -1
		ife sprite[myshelly].picnum SHELLY quote 147
		ife sprite[myshelly].picnum SHELLYCROUCH quote 147
		ife sprite[myshelly].picnum DUKEBOT quote 148
		ife sprite[myshelly].picnum DUKEBOTCROUCH quote 148
		ife sprite[myshelly].picnum WESBOT quote 1196
		ife sprite[myshelly].picnum WESBOTCROUCH quote 1196
		// break
	}
	
	set temp YES
	ife switchmode NO 
	{
		ife player[].cursectnum -1 set temp NO
		ifn myshelly -1
		{
			ife sprite[myshelly].sectnum -1 set temp NO
			ife shellysquish YES set temp NO
		}
	}
	ife movecam -1
	ifn myshelly -1
	ife pdown NO
	ife actorvar[myshelly].monstatus 30
	// ifl actorvar[myshelly].FEMFALLDMG 60
	ifp palive
	ifg sprite[myshelly].xrepeat 18
	ifg sprite[player[].i].xrepeat 32
	ife player[].on_crane -1
	ife player[].reloading NO
	ifl switchboost 60
	ife temp YES
	{
		set x sprite[myshelly].x
		set y sprite[myshelly].y
		set z sprite[myshelly].z
		set angvar sprite[myshelly].ang
		set mysector sprite[myshelly].sectnum
		
		setav[myshelly].monstatus 60 // trigger to switch characters
		
		ife switchmode 0
		{
			getp[].posz zdist add zdist 8192
			setsprite myshelly player[].posx player[].posy zdist
			changespritesect myshelly player[].cursectnum
			setsprite player[].i x y z
			changespritesect player[].i mysector
			setp[].cursectnum mysector
			setp[].posx x
			setp[].posy y
			sub z 8192
			setp[].posz z
			setp[].ang angvar
			
			ifn sector[sprite[myshelly].sectnum].lotag 2 
			{
				setgamepalette 0
				setp[].heat_on NO
			}
		}
		ifge sprite[myshelly].picnum SHELLY ifle sprite[myshelly].picnum SHELLYCROUCH
		{ 
			globalsound SHELLYREADY { set pchar 1 state shellyweapons }
			set temp FULLBOTCHARGE
			ifge shellycharge temp
			{
				set shellycharge 0
				set switchboost SWITCHBOOSTTIME
				set damagecount 0
				ifvarand gametips 1024 { xorvar gametips 1024 savegamevar gametips }
			}
		} 
		else
		ifge sprite[myshelly].picnum DUKEBOT ifle sprite[myshelly].picnum DUKEBOTCROUCH
		{
			globalsound ROCKIN { set pchar 0 state dukeweapons }
			set temp FULLBOTCHARGE
			ifge dukecharge temp
			{
				set dukecharge 0
				set switchboost SWITCHBOOSTTIME
				set damagecount 0
				ifvarand gametips 1024 { xorvar gametips 1024 savegamevar gametips }
			}
		}
		else
		{
			globalsound WESIMONIT { set pchar 2 state wesweapons }
			set temp FULLBOTCHARGE
			ifge wescharge temp
			{
				set wescharge 0
				set switchboost SWITCHBOOSTTIME
				set damagecount 0
				ifvarand gametips 1024 { xorvar gametips 1024 savegamevar gametips }
			}
		}
		setav[myshelly].navpoint -1
		ife redcarrier player[].i set redcarrier myshelly else
		ife bluecarrier player[].i set bluecarrier myshelly else
		ife redcarrier myshelly set redcarrier player[].i else
		ife bluecarrier myshelly set bluecarrier player[].i
	}
	else
	{
		ife myshelly -1 quote 1132 else
		ife pdown NO
		{
			ifn switchboost 0 quote 1129 else
			ife shellysquish YES quote 1130 else
			ife actorvar[myshelly].monstatus 2 quote 1131 else
			ifge actorvar[myshelly].FEMFALLDMG 60 quote 1133 else
			ifl sprite[myshelly].xrepeat 18 quote 1134 else
			quote 1209
			// ife pchar 0 quote 1209 else
			// ife pchar 1 quote 138
		}
	}

endevent

definegamefuncname 6 INTERACT
definegamefuncname 29 USE_INVENTORY
definegamefuncname 48 ADRENALIN
definegamefuncname 49 KICK
definegamefuncname 60 SUBWEAPON
definegamefuncname 36 VENDOR_MENU
onevent EVENT_TURNAROUND

	set RETURN -1
	ifn thiscam -1 break
	ifn vrscreen_time 0 break
	ife epselect -1 break
	
	// ife pchar 2 
	// { 
		// ifn vendor_screen 0 setp[].movement_lock 0 
		// set vendor_screen 0
		// break
	// }
	
	ife vendorupgrade NO { quote 742 break }
	
	ife vendor_screen 0
	{
		set vendor_screen -20
		set cmode 0
	}
	else
	ifg vendor_screen 9 set vendor_screen 1 // -10
	else
	ifg vendor_screen 0 
	{
		// set vendor_screen -12
		ife pchar 2 set vendor_screen 30 else
		ife pchar 0 set vendor_screen 10 else
		set vendor_screen 20
	}
	
	
endevent

onevent EVENT_ALTFIRE

set RETURN -1
ifp palive nullop else break
ifn player[].weapon_pos 0 break

// CHANGE AMMO TYPE WHEN USING RPG
ifvarand shellyupgrades[RPG_WEAPON] 1 nullop else
ife pchar 1
ife player[].curr_weapon RPG_WEAPON
ife player[].kickback_pic 0
ife nukeselect NO
ifg player[].ammo_amount RPG_WEAPON 0
{
	ife rpgtype 0 set rpgtype 1 else
	ife rpgtype 1 set rpgtype 0
	setp[].kickback_pic 10
	set rpgchange YES
	ifvarand gametips 8 { xorvar gametips 8 savegamevar gametips }
}

ife pchar 2
ife player[].curr_weapon HANDBOMB_WEAPON
ife player[].kickback_pic 0
ifg player[].ammo_amount HANDBOMB_WEAPON 0
{
	set burstfired 3
	setp[].kickback_pic 1
}
// RELOAD WHEN USING PISTOL	
ife LASERMODE NO
ife player[].curr_weapon PISTOL_WEAPON
ife player[].kickback_pic 0
{
	ifn THISCLIP PISTOLCLIP
	ifg player[].ammo_amount PISTOL_WEAPON THISCLIP
	{
		ife pchar 2 setp[].kickback_pic 9
		else
		ife pchar 1 setp[].kickback_pic 10
		else
		setplayer[THISACTOR].kickback_pic 7
		setplayer[THISACTOR].reloading YES
		ife pchar 0 ifvarand dukeupgrades[PISTOL_WEAPON] 8 sound GLOCKMAGOUT else
		ife pchar 1 
		{ 
			ifvarand shellyupgrades[PISTOL_WEAPON] 8 { sound GLOCKMAGOUT setplayer[THISACTOR].kickback_pic 7 } else
			sound DEAGLE_CLIPOUT 
		} else
		sound EJECT_CLIP
	}
}
// CHANGE AMMO TYPE ON SHOTGUN
// or START STAKE-FIRE FOR WES

ife player[].curr_weapon SHOTGUN_WEAPON
ife player[].kickback_pic 0
{
	set temp NO
	ifvarand shellyupgrades[SHOTGUN_WEAPON] 1 ife pchar 1 set temp YES
	ifvarand dukeupgrades[SHOTGUN_WEAPON] 1 ife pchar 0 set temp YES
	
	ifvarand gotbow 2 ifge pchar 1 ifle pchar 2 set temp NO // holding bow
	
	ife temp YES
	{
		ife pchar 0 ifvarand dukeupgrades[SHOTGUN_WEAPON] 4 ifl holdaltfire 10 nullop else
		{
			ife pchar 0 ifvarand gotDB 2 
			{ 
				ifvarand dukeupgrades[SHOTGUN_WEAPON] 32 setp[].kickback_pic 17
				else setp[].kickback_pic 23 
				screensound DBOPEN 
			} 
			else
			setp[].kickback_pic 5
			ife pchar 1 ifvarand shellyupgrades[SHOTGUN_WEAPON] 128 set WEAPON2_TOTALTIME 24
			ife pchar 0 set burstfired 2 else
			set burstfired YES
			set holdaltfire 0
			ife pchar 0
			{
				ife shotexpduke 0 { quote 210 set shotexpduke 1 }
				else { quote 211 set shotexpduke 0 }
			}
			ife pchar 1 
			{
				ife shotexpshelly 0 { quote 210 set shotexpshelly 1 }
				else { quote 211 set shotexpshelly 0 }
			}
		}
	}
	
	ifvarand gotbow 2 nullop else
	ife pchar 2 ifg stakes 0
	{
		set stakefire YES
		setp[].kickback_pic 1
		sub stakes 1
		set WEAPON2_FIRESOUND SHOOTSTAKE
		set WEAPON2_SHOOTS STAKEPROJ
		set WEAPON2_SHOTSPERBURST 0
	}
}

ife player[].curr_weapon TRIPBOMB_WEAPON
ife player[].kickback_pic 0
{
	set temp NO
	ife pchar 0 ife weap_owned[80] YES ife weap_owned[81] YES set temp YES
	ife pchar 1 ife weap_owned[180] YES ife weap_owned[181] YES set temp YES
	ife pchar 2 ife weap_owned[280] YES ife weap_owned[281] YES set temp YES
	ife temp YES
	{
		setp[].weapon_pos -1
		ife WEAPON8_SHOOTS HANDHOLDINGLASER orvar gotspider 4 else
		ife WEAPON8_SHOOTS SPIDERMINEFALLING orvar gotspider 8 
		
		ifvarand gametips 2048 { xorvar gametips 2048 savegamevar gametips }
	}
}

// FIRE SHOCKBALL WHEN USING UPGRADED PLASMA RIFLE
ifvarand gotplasma 1 ifvarand gotplasma 2
ife player[].curr_weapon 9
ife player[].kickback_pic 0
ifg player[].ammo_amount 9 3
{
	// set temp NO
	// ife pchar 0 ifvarand dukeupgrades[FREEZE_WEAPON] 2 set temp YES
	// ife pchar 1 ifvarand shellyupgrades[FREEZE_WEAPON] 2 set temp YES
	// ife temp YES
	// {
		setplayer[THISACTOR].kickback_pic 1
		set WEAPON9_SHOOTS SHOCKBALL2
		set WEAPON9_FIRESOUND SHOCKBALLFIRE
		set WEAPON9_TOTALTIME 20
		getp[].ammo_amount 9 temp
		sub temp 3
		setp[].ammo_amount 9 temp
	// }
}

endevent

defstate landsounds

	set stepcount -32768
	
	
	ife player[].spritebridge YES
	{ 
		getp[].sbs spriteid // GET THE FLATSPRITE'S ID TAG
		geta[spriteid].picnum picnum // CHECK IT'S TEXTURE
	}
	else
	{
		getplayer[].posz z
		addvar z 6144
		getzrange player[].posx player[].posy z player[].cursectnum z2 tempb temp spriteid 256 CLIPMASK0
		subvar spriteid 49152
		ifvarg spriteid -1 ifvarl spriteid 16384
			geta[spriteid].picnum picnum
		else
		gets[].floorpicnum picnum
	}

	set TILETYPE 7 // default
	state tiletype
	
	ife TILETYPE 8 ifge raining 0 set TILETYPE 7

	ifvare TILETYPE 1 sound LANDWOOD else
	ifvare TILETYPE 2 
	{
		ifge picnum BMWM4 ifle picnum ROVER sound LANDCAR else
		sound LANDMETAL 
	}
	else
	ifvare TILETYPE 3 sound LANDMETAL else
	ifvare TILETYPE 4 sound LANDDIRT else
	ifvare TILETYPE 6 sound LANDCARPET else
	ifvare TILETYPE 7 sound LANDNORMAL else
	ifvare TILETYPE 8 sound LANDSNOW else
	ifvare TILETYPE 9 sound LANDWATER else
	ifvare TILETYPE 11 sound PL_SQUISH2 else
	sound LANDNORMAL
ends

defstate stepsounds

// ifsound PROT_BIGSPEECH break

	ife TILETYPE 8 ifge raining 0 set TILETYPE 7

switch TILETYPE	

		case 0
		case 7
		// normal step
		randvarvar temp 3
		ife temp 0 sound PL_STEP1 else
		ife temp 1 sound PL_STEP2 else
		ife temp 2 sound PL_STEP3 else
		ife temp 3 sound PL_STEP4
		break
		
		case 1
		// wood step
		randvarvar temp 3
		ife temp 0 sound PL_WOOD1 else
		ife temp 1 sound PL_WOOD2 else
		ife temp 2 sound PL_WOOD3 else
		ife temp 3 sound PL_WOOD4
		break
		
		case 2
		// metal step
		ifge picnum BMWM4 ifle picnum ROVER nullop else
		ifsound DUKE_WALKINDUCTS nullop else
		{
			randvarvar temp 3
			ife temp 0 sound PL_METAL1 else
			ife temp 1 sound PL_METAL2 else
			ife temp 2 sound PL_METAL3 else
			ife temp 3 sound PL_METAL4
		}
		break
		
		case 3
		// grate step
		// sound DUKE_WALKINDUCTS
		randvarvar temp 3
			ife temp 0 sound PL_GRATE1 else
			ife temp 1 sound PL_GRATE2 else
			ife temp 2 sound PL_GRATE3 else
			ife temp 3 sound PL_GRATE4
		break
		
		case 4
		// grass step
		randvarvar temp 3
		ife temp 0 sound PL_GRASS1 else
		ife temp 1 sound PL_GRASS2 else
		ife temp 2 sound PL_GRASS3 else
		ife temp 3 sound PL_GRASS4
		break
		
		case 5
		// tile step
		randvarvar temp 3
		ife temp 0 sound PL_TILE1 else
		ife temp 1 sound PL_TILE2 else
		ife temp 2 sound PL_TILE3 else
		ife temp 3 sound PL_TILE4
		break
		
		case 6
		// carpet step
		randvarvar temp 3
		ife temp 0 sound PL_CARPET1 else
		ife temp 1 sound PL_CARPET2 else
		ife temp 2 sound PL_CARPET3 else
		ife temp 3 sound PL_CARPET4
		
		break
		
		case 8
		// snow step
		rand temp 5
		ife temp 0 sound PL_SNOW1 else
		ife temp 1 sound PL_SNOW2 else
		ife temp 2 sound PL_SNOW3 else
		ife temp 3 sound PL_SNOW4 else
		ife temp 4 sound PL_SNOW5 else
		ife temp 5 sound PL_SNOW6 else
		ifactor APLAYER
		{
			  setp[].footprintcount 2
			  setp[].footprintpal 33
			  setp[].footprintshade 0
		}
		break
		
		case 9 
		// soundonce DUKE_ONWATER
		break
		
		case 11
		// squishy
		randvarvar temp 3
		ife temp 0 sound STEPORG1 else
		ife temp 1 sound STEPORG2 else
		ife temp 2 sound STEPORG3 else
		sound STEPORG4
		break
		
		case 12
		// dirt
		randvarvar temp 3
		ife temp 0 sound PL_DIRT1 else
		ife temp 1 sound PL_DIRT2 else
		ife temp 2 sound PL_DIRT3 else
		ife temp 3 sound PL_DIRT4
		break
		
		default 
		// normal step
		randvarvar temp 3
		ife temp 0 sound PL_STEP1 else
		ife temp 1 sound PL_STEP2 else
		ife temp 2 sound PL_STEP3 else
		ife temp 3 sound PL_STEP4
		break	
		endswitch	

ends

state stepsoundstuff

	ifinwater break
	ifonwater break
	iffloordistl 8 nullop else break

	ifp pjetpack break

	ifp pducking break
	ifp pstanding { set stepcount 32000 break }

	getp[].posxv x
	div x 644
	mulvarvar x x
	getp[].posyv y
	div y 644
	mulvarvar y y
	add x y
	sqrt x x
	ifg x 4400 set x 4400 // max stepping speed
	add stepcount x

	ife player[].spritebridge YES
	{ 
		getp[].sbs spriteid // GET THE FLATSPRITE'S ID TAG
		geta[spriteid].picnum picnum // CHECK IT'S TEXTURE
	}
	else
	{
		getplayer[].posz z
		addvar z 6144
		getzrange player[].posx player[].posy z player[].cursectnum z2 tempb temp spriteid 256 CLIPMASK0
		subvar spriteid 49152
		ifvarg spriteid -1 ifvarl spriteid 16384
			geta[spriteid].picnum picnum
		else
		gets[].floorpicnum picnum
	}
	
	
	set TILETYPE 7
	state tiletype

	ifg stepcount 32768
	{
		subvar stepcount 32768	
		ife TILETYPE 8 sub stepcount 16384
		state stepsounds
	}

ends

state checkhitscan

getp[].cursectnum mysector
ifl mysector 0 
	break
ifg mysector 4095 
    break

getp[].ang angvar
getp[].horiz zdist
sub zdist 100

getp[].weapon_pos temp
abs temp
mul temp 3
sub zdist temp

mul zdist -2048
cos mycos angvar
sin mysin angvar

// horiz at 0 z angle is 100; pos for up, neg for down


hitscan player[].posx player[].posy player[].posz mysector mycos mysin zdist hitsector hitwall hitsprite hitx hity hitz CLIPMASK1 // clipmask

set scannedsprite hitsprite

ifn monid -1
{
	ifg sprite[monid].statnum 2 set monid -1 else
	ifn actorvar[monid].monstatus 1 set monid -1
}

ife autoaim -1 getp[].auto_aim autoaim

ifn onturret -1 
{
	ifn player[].auto_aim NO getp[].auto_aim autoaim
	setp[].auto_aim NO
}
else
ife player[].curr_weapon KNEE_WEAPON
{
	ifn player[].auto_aim 0
	{
		getp[].auto_aim autoaim
		setp[].auto_aim NO
	}
}
else
ifn scannedsprite -1
ife actorvar[scannedsprite].monstatus 1
{
	ife dashtarg -1 ifn saberdash 0
		set dashtarg scannedsprite 
		
	ife kicktarg -1 ifg sidekick 2
		set kicktarg scannedsprite
		
	ifn player[].auto_aim 0
	{
		getp[].auto_aim autoaim
		setp[].auto_aim NO
	}
	
	ife zoomin YES
	ife player[].curr_weapon RPG_WEAPON
	ifg player[].ammo_amount RPG_WEAPON 0
	ife player[].kickback_pic 0
	ife player[].weapon_pos 0
	ife targetwait 0
	ifn scannedsprite targetlock[0]
	ifn scannedsprite targetlock[1]
	ifn scannedsprite targetlock[2]
	ifn actorvar[scannedsprite].team team
	{
		// clean up array first
		ifn targetlock[2] -1 ife targetlock[1] -1 
		{ setarray targetlock[1] targetlock[2] setarray targetlock[2] -1 }
		ifn targetlock[1] -1 ife targetlock[0] -1 
		{ setarray targetlock[0] targetlock[1] setarray targetlock[1] -1 }
		
		set temp NO
		ife pchar 0 ifvarand dukeupgrades[RPG_WEAPON] 4 set temp YES
		ife pchar 1 ifvarand shellyupgrades[RPG_WEAPON] 4 set temp YES
		ife targetlock[0] -1
		{
			sound TARGETLOCK
			setarray targetlock[0] scannedsprite
			geta[scannedsprite].mdflags temp
			orvar temp 16
			seta[scannedsprite].mdflags temp
		}
		else
		ife temp YES
		ife targetlock[1] -1
		ifg player[].ammo_amount RPG_WEAPON 1
		{
			sound TARGETLOCK
			setarray targetlock[1] scannedsprite
			geta[scannedsprite].mdflags temp
			orvar temp 16
			seta[scannedsprite].mdflags temp
		}
		else
		ife temp YES
		ife targetlock[2] -1
		ifg player[].ammo_amount RPG_WEAPON 2
		{
			sound TARGETLOCK
			setarray targetlock[2] scannedsprite
			geta[scannedsprite].mdflags temp
			orvar temp 16
			seta[scannedsprite].mdflags temp
		}
	}
}
else ife zoomin NO
		setp[].auto_aim autoaim

set scandist sprite[].x
sub scandist hitx
mul scandist scandist
set tempb sprite[].y
sub tempb hity
mul tempb tempb
add scandist tempb
sqrt scandist scandist
set tempc 0
ifn hitsector -1
{
	gets[hitsector].ceilingz z
	sub z hitz
	ifg z -1024
	{
		ifvarand sector[hitsector].ceilingstat 1 mul scandist -1
		set tempc 1 // hit ceiling
	}
	ifg scandist 0
	{
		ifn hitwall -1
		{
			getwall[hitwall].nextsector temp
			ifn temp -1
			{
				gets[temp].ceilingz z
				
				// sub z hitz
				ifg z hitz // -1024
				{
					ifvarand sector[temp].ceilingstat 1 mul scandist -1
				}
			}
		}
		// laser tripbomb place on floor code
		ifvarand sector[hitsector].floorstat 1 nullop else
		ife triphack -1
			ifp palive
			ife tempc 0 ifl scandist 1024
			ifp ponground iffloordistl 16
			ife sector[hitsector].floorslope 0
			ife hitwall -1
			ifvarand bits 4
			ifl PLAYERONTHEBIKE 1
			ife player[].curr_weapon 8
			ife player[].transporter_hold 0
			ife player[].kickback_pic 0
			ife player[].weapon_pos 0
			ifg player[].ammo_amount 8 0
			ife hitsprite -1
		{
			set tripz hitz
			set tripx hitx
			set tripy hity
			set triphack hitsector
			setp[].kickback_pic 1
		}
	}
}

/*
ife player[].heat_on NO
ifg scandist 0
ife currentweapon PISTOL_WEAPON
ife LASERMODE NO
ife PISTOLDOT YES
ife pchar 0
ifn startmode -1
ife movecam -1
{
	getp[].ang angvar
	getp[].horiz zdist
	sub zdist 135

	getp[].weapon_pos temp
	abs temp
	mul temp 3
	sub zdist temp
	
	set temp gun_pos
	div temp -2
	sub zdist temp
	
	ifp pstanding nullop else
	{
		set temp weapon_xoffset
		div temp 2
		add angvar temp
	}
	
	mul zdist -2048
	cos mycos angvar
	sin mysin angvar

	hitscan player[].posx player[].posy player[].posz mysector mycos mysin zdist hitsector hitwall hitsprite hitx hity hitz CLIPMASK0
	
	
	espawn LASERDOT
	set dotsprite RETURN
	setsprite RETURN hitx hity hitz
	
	
	ifn hitsprite -1 seta[RETURN].cstat 8322 else
	ifn hitwall -1 seta[RETURN].cstat 8322 else
	ifn hitsector -1
	{
		ife tempc 1 { ife sector[hitsector].ceilingslope 0 seta[RETURN].cstat 8354 else seta[RETURN].cstat 8322 }
		else { ife sector[hitsector].floorslope 0 seta[RETURN].cstat 8354 else seta[RETURN].cstat 8322 }
	}
	seta[RETURN].mdflags 16
	ife sprite[RETURN].cstat 8322
	{
		getp[].ang angvar
		add angvar 1024
		set x sprite[RETURN].x
		set temp scandist
		shiftr temp 3
		ifg temp 128 set temp 128
		add x temp
		rotatepoint sprite[RETURN].x sprite[RETURN].y x sprite[RETURN].y angvar x2 y2
		setsprite RETURN x2 y2 sprite[RETURN].z
	}
	updatesectorz sprite[RETURN].x sprite[RETURN].y sprite[RETURN].z tempb
	ifvarn tempb -1
	{
		getflorzofslope tempb sprite[RETURN].x sprite[RETURN].y temp
		sub temp 512
		ifg sprite[RETURN].z temp seta[RETURN].z temp
		changespritesect RETURN tempb
	}
	
}
*/

ends


spritenoshade LASERDOT
spritenopal LASERDOT
useractor notenemy LASERDOT 0

	// ifinwater nullop else
	// ifonwater nullop else
	// {
		// geta[].sectnum mysector
		// set tempc NO
		// headspritesect spriteid mysector
		// whilevarn spriteid -1
		// {
			// ife sprite[spriteid].picnum SECTOREFFECTOR
			// ife sprite[spriteid].lotag 7 set tempc YES
			// nextspritesect spriteid spriteid
		// }
		// ife tempc YES killit
	// }
	seta[].shade -127
	seta[].blend 255
	sizeat 32 32
	cstator 128
	ifcount 6 killit
	// set xydist scandist
	// shiftr xydist 8 // 9
	// add xydist 8 // 18
	// ifg xydist 255 set xydist 255
	// seta[].xrepeat xydist seta[].yrepeat xydist
	// ifcount 1 
	// { 
		// ife dotsprite THISACTOR set dotsprite -1 
		// killit 
	// }

enda


spritenoshade AIRFLASH1
spritenoshade AIRFLASH2
useractor notenemy AIRFLASH1 0

ifmove 0
{
	move STOPPED
	seta[].shade -127
	ife mtype 1 sizeat 20 20 else
	ife mtype 2 sizeat 24 24 else
	sizeat 16 16
	cstat 146
	espawn AIRFLASH2
	setav[RETURN].mtype mtype
	geta[].ang angvar
	sub angvar 512
	seta[].ang angvar
}
sizeto 0 0
sizeto 0 0

enda

useractor notenemy AIRFLASH2

ifmove 0
{
	move STOPPED
	ife mtype 1 sizeat 20 20 else
	ife mtype 2 sizeat 24 24 else
	sizeat 16 16
	cstat 38
	seta[].shade -127
}
sizeto 0 0
sizeto 0 0
enda


onevent EVENT_DISPLAYROOMS

ifn SAVEDANGCOUNT 0 
{
	set cameraang SAVEDANG
	setp[].ang SAVEDANG
}

ife player[].movement_lock 31
ife cutcam -1
ife thiscam -1
ife movecam -1
ife player[].on_crane -1
{
	set cameraang oang
	set camerahoriz 100
}

ifn thiscam -1 
{
	ifn goalang ocameraang
	{
		getincangle angvar goalang ocameraang
		
		set temp framerate
		div temp 30
		ifl temp 1 set temp 1
		div angvar temp
		sub ocameraang angvar
	}
	set cameraang ocameraang
	break
}

ifvarg PLAYERONTHEBIKE 0 
{
	set camerahoriz bikehoriz
	// set cameraang bikeang
	
	ifn bikeang ocameraang
	{
		getincangle angvar bikeang ocameraang
		
		set temp framerate
		div temp 30
		ifl temp 1 set temp 1
		div angvar temp
		sub ocameraang angvar
	}
	set cameraang ocameraang

	set cameraz bikez
	// setp[].rotscrnang bikerot
}

// ifn player[].ang ocameraang
// ife cutcam -1
// ife movecam -1
// ife player[].movement_lock 0
// ife player[].over_shoulder_on NO
// ife player[].newowner -1
// {
	// getincangle angvar player[].ang ocameraang
		
	// set temp framerate
	// div temp 30
	// ifl temp 1 set temp 1
	// div angvar temp
	// sub ocameraang angvar
	
	// set cameraang ocameraang
// }
// else
// ife player[].ang cameraang set ocameraang player[].ang

ifn cutcam -1
ifg cutcamtime 0
{
	set camerax sprite[cutcam].x
	set cameray sprite[cutcam].y
	set cameraz sprite[cutcam].z
	
}

ife pchar 1
{
	ifn player[].transporter_hold 0
	ife player[].holster_weapon YES
	ifsound DUKE_URINATE
	{
		add cameraang 1024
		add cameraz 3072
	}
	ifn player[].newowner -1
	{
		set cameratoggle YES
		getp[].i spriteid
		seta[spriteid].cstat 32768
	}
}

// ifn player[].newowner -1 set cameraang sprite[player[].newowner].ang

ifn vr -1 ife zoomin YES // player[].heat_on YES
	setaspect vr yxaspect
	
// ife shellycam YES
// ife pdown YES
// ifn myshelly -1
// {
	// set camerax sprite[myshelly].x
	// set cameray sprite[myshelly].y
	// set cameraz sprite[myshelly].z
	// sub cameraz 8192
	
	// set cameraang sprite[myshelly].ang
	// set camerasect sprite[myshelly].sectnum
	

// }

ifn movecam -1
{
	set camerax sprite[movecam].x
	set cameray sprite[movecam].y
	set cameraz sprite[movecam].z
	set cameraang sprite[movecam].ang
	set camerasect sprite[movecam].sectnum
	
	
	set temp actorvar[movecam].mtype
	sub temp 50
	mul temp 2
	add temp 100
	
	set camerahoriz temp
}
// else
// ife zoomin YES
// {

	// ifn cameraang oang
	// {
		// getincangle angvar cameraang oang
		// shiftr angvar 1
		// add cameraang angvar
	// }
	// set camerahoriz ohoriz
// }
else
ifp pducking nullop else
ifn slidekick 0 add cameraz 2048

ife pdown YES sub cameraz 4096

ifg shipcam -1
{
	getactor[shipcam].z z
	sub z 8192
	
	getav[shipcam].droptile z2
	sub z2 player[].posz
	sub z z2
	
	getp[].posx x2
	getp[].posy y2
	getav[shipcam].startx x
	getav[shipcam].starty y

	subvarvar x2 x
	subvarvar y2 y
	getangle angvar x2 y2 // angvar is now the displacement angle
	
	add angvar shipangoff
	
	set xydist x
	sub xydist player[].posx
	mul xydist xydist
	sub y player[].posy
	mul y y
	add xydist y
	sqrt xydist xydist
	
	set xvel sprite[shipcam].x
	add xvel xydist
	
	add angvar shipang // sprite[shipcam].ang
	
	rotatepoint sprite[shipcam].x sprite[shipcam].y xvel sprite[shipcam].y angvar x2 y2

	set tempH sprite[shipcam].sectnum
	updatesector x2 y2 tempH
	ife tempH -1 set tempH sprite[shipcam].sectnum

	getav[shipcam].mtype angvar
	
	ifn angvar shipang
	{
		getincangle tempd angvar shipang
		shiftr tempd 1
		sub shipang tempd
	}
	set angvar shipang
	
	add angvar player[].ang
	ifn shipangstart 999999
	sub angvar shipangstart

// code to bob up and down
/*	
	subvar z 2048		
	setvarvar temp player[].player_par
	
	// shiftvarl temp 5
	mul temp 24
	sin tempb temp
	shiftvarr tempb 2 // 4	
	subvarvar z tempb
	
*/
	
/*
	getav[shipcam].shotpitch temp
	shiftr temp 6 // temp is now goal for shiphoriz
	ifg temp 64 set temp 64, ifl temp -64 set temp -64
	ifg temp shiphoriz add shiphoriz 1 else
	ifl temp shiphoriz sub shiphoriz 1

	getincangle temp sprite[shipcam].ang angvar
	abs temp
	ifg temp 512
		sub temp 1024
	
	
	set tempb shiphoriz
	shiftr temp 6
	div tempb temp
	
	add tempb camerahoriz
	ifg tempb 299 set tempb 299
	ifl tempb -99 set tempb -99
*/	

	// showview x2 y2 z angvar camerahoriz tempH 0 0 319 199
	
	showviewunbiased x2 y2 z angvar camerahoriz tempH 0 0 319 199
	
}
	
endevent



defstate switchplasma

	ifvarand gotplasma 2 // just put plasma in top position
	state setplasmagun
	else // just put plasma in bottom position
	{
		// weapon9 standard settings
		ife pchar 0 state dukeweapons else 
		ife pchar 1 state shellyweapons else
		ife pchar 2 state wesweapons
	}

ends

defstate in_menu
	setp[].knuckle_incs 0
	setp[].crack_time 0
	setp[].movement_lock 31
	ifg sprite[].htextra 0
	{
		geta[].htextra temp
		div temp 2
		seta[].htextra temp
		seta[].htextra -1
		// ifn vendor_screen 0 
		// { 
			// set vendor_screen 0 
			// setp[].movement_lock 0
			// set tempselect -1
			// break 
		// }
	}
	setp[].kickback_pic 0
	setp[].jumping_counter 0
	setp[].weapon_pos 10 // -9
	setp[].quick_kick 0
	getp[].ang temp
	// getp[].oang tempb
	set tempb oang
	
	set cmode 0
	getincangle angvar temp tempb
	div angvar 3
	sub cursorx angvar
	setp[].ang oang // player[].oang
	ifl cursorx 0 set cursorx 0
	ifg cursorx 320 set cursorx 320
	
	getp[].horiz temp
	// getp[].ohoriz tempb
	set tempb ohoriz
	sub temp tempb
	getuserdef[].mouseflip tempc
	ife tempc 0
	add cursory temp
	else
	sub cursory temp
	ifl cursory 0 set cursory 0
	ifg cursory 200 set cursory 200
	setp[].horiz 100
ends


defstate resetplayeramounts

	set cmode 0
	set THISCLIP PISTOLCLIP
	set m4clip 30
	set uziclip 32
	set skarclip 20
	set skarclipB 10
	set spasclip 8
	set o2damage 0
	set myshelly -1
	set shellyinmap 0
	set shellyhp healthbuff
	set cutcam -1
	set cutcamtarget -1
	set emp_overlay 0
	set cutcamtime 0
	set cutcamsound 0
	set cutcamchannel 0
	set deathcounter 450
	set blockang 6666
	set saberpos 0
	
	ife pchar 0 
		state dukeweapons 
	else
	ife pchar 1  
		state shellyweapons 
	else ife pchar 2 state wesweapons

	ifn pchar 2 ife gotsaw YES ifg sawammo 0 state sawon
	else state sawoff
	
	// max health failsafe check
	setp[].max_player_health healthbuff

ends

defstate applystartguns

// bitfield
// 1 = pistol
// 2 = shotgun
// 4 = chaingun and executioner
// 8 = RPG
// 16 = pipebombs
// 32 = shrinker or bmfg
// 64 = devastator
// 128 = spider-bombs or tripbombs
// 256 = freezer or incinerator
// 512 = babifier
// 1024 = terminator gun
// 2048 = light saber
// 4096 = chainsaw
// 8192 = alien blaster
// 16384 = railgun or penetrator

ife gametype 0
{
	ifg player[].ammo_amount PISTOL_WEAPON 96 setp[].ammo_amount PISTOL_WEAPON 96
	else
	ifl player[].ammo_amount PISTOL_WEAPON 48 setp[].ammo_amount PISTOL_WEAPON 48
}
else
{
	setp[].gotweapon PISTOL_WEAPON NO
	setp[].ammo_amount PISTOL_WEAPON 0	
}
setp[].gotweapon SHOTGUN_WEAPON NO
setp[].ammo_amount SHOTGUN_WEAPON 1
set stakes 0
setp[].gotweapon CHAINGUN_WEAPON NO
setp[].ammo_amount CHAINGUN_WEAPON 0
setarray weap_owned[221] NO // Wes dual uzi
set TMP_A wesupgrades[CHAINGUN_WEAPON]
ifvarand TMP_A 1 xorvar TMP_A 1
setarray wesupgrades[CHAINGUN_WEAPON] TMP_A

setarray weap_owned[203] NO // Wes dual pistol
set TMP_A wesupgrades[PISTOL_WEAPON]
ifvarand TMP_A 4 xorvar TMP_A 4
setarray wesupgrades[PISTOL_WEAPON] TMP_A


setp[].gotweapon RPG_WEAPON NO
setp[].ammo_amount RPG_WEAPON 0
setp[].gotweapon HANDBOMB_WEAPON NO
setp[].ammo_amount HANDBOMB_WEAPON 0
setp[].gotweapon SHRINKER_WEAPON NO
setp[].ammo_amount SHRINKER_WEAPON 0
setp[].gotweapon DEVISTATOR_WEAPON NO
setp[].ammo_amount DEVISTATOR_WEAPON 0
setp[].gotweapon TRIPBOMB_WEAPON NO
setp[].ammo_amount TRIPBOMB_WEAPON 0
setp[].gotweapon FREEZE_WEAPON NO
setp[].ammo_amount FREEZE_WEAPON 0
setp[].gotweapon GROW_WEAPON NO
setp[].ammo_amount GROW_WEAPON 0
set nukeamount 0
set nukeselect NO
set gotplasma NO
set plasmammo 0
state sawoff
set gotsaber 0
set sawammo 0
set LASERAMMO 0
set COMMAMMO 0
set LASERMODE 0
set gotrailgun NO
set railgunammo 0
set dbammo 0
set arrows 0
// set gotDB 0
// set gotbow 0

setp[].curr_weapon KNEE_WEAPON
setp[].weapon_pos -9
setp[].kickback_pic 0

ife VOLUME 6 
{
	ifge LEVEL 29 ifle LEVEL 31 ifl player[].player_par 200 break 
}
// an ancients level, starts without weapons but they are needed for ammo

ifvarand startguns 1
{
	setp[].gotweapon PISTOL_WEAPON YES
	ife gametype 0 set temp 96 else set temp 48
	setp[].ammo_amount PISTOL_WEAPON temp
}
ifvarand startguns 2
{
	setp[].gotweapon SHOTGUN_WEAPON YES
	ife gametype 0 set temp 13 else set temp 7
	setp[].ammo_amount SHOTGUN_WEAPON temp
	set stakes 5
	
	ifg gametype 0
	{
		orvar gotbow 1
		orvar gotDB 1
		set arrows 12
		set dbammo 10
	}
}
ifvarand startguns 4
{
	setp[].gotweapon CHAINGUN_WEAPON YES
	ife gametype 0 set temp 100 else set temp 50
	setp[].ammo_amount CHAINGUN_WEAPON temp
}
ifvarand startguns 8
{
	setp[].gotweapon RPG_WEAPON YES
	ife gametype 0 set temp 6 else set temp 3
	setp[].ammo_amount RPG_WEAPON temp
}
ifvarand startguns 16
{
	setp[].gotweapon HANDBOMB_WEAPON YES
	ife gametype 0 set temp 6 else set temp 3
	setp[].ammo_amount HANDBOMB_WEAPON temp
}
ifvarand startguns 32
{
	setp[].gotweapon SHRINKER_WEAPON YES
	ife gametype 0 set temp 12 else set temp 6
	setp[].ammo_amount SHRINKER_WEAPON temp
}
ifvarand startguns 64
{
	setp[].gotweapon DEVISTATOR_WEAPON YES
	ife gametype 0 set temp 36 else set temp 18
	setp[].ammo_amount DEVISTATOR_WEAPON temp
}
ifvarand startguns 128
{
	setp[].gotweapon TRIPBOMB_WEAPON YES
	ife gametype 0 set temp 6 else set temp 3
	setp[].ammo_amount TRIPBOMB_WEAPON temp
}
ifvarand startguns 256
{
	setp[].gotweapon FREEZE_WEAPON YES
	ife gametype 0 set temp 40 else set temp 20
	setp[].ammo_amount FREEZE_WEAPON temp
}
ifvarand startguns 512
{
	setp[].gotweapon GROW_WEAPON YES
	ife gametype 0 set temp 48 else set temp 24
	setp[].ammo_amount GROW_WEAPON temp
}
ifvarand startguns 1024 // TERMINATOR GUN
{
	setp[].gotweapon FREEZE_WEAPON YES
	set gotplasma 3
	// ife gametype 0 set plasmammo 40 else set plasmammo 20
	ife gametype 0 setp[].ammo_amount FREEZE_WEAPON 40 else setp[].ammo_amount FREEZE_WEAPON 20
	
}
ifvarand startguns 2048 // LIGHT SABER
{
	state sawoff
	ife startguns 2048 set gotsaber 99
	else set gotsaber 30
	set sawammo 0
}
ifvarand startguns 4096 // CHAINSAW
ifn pchar 2
{
	state sawon
	set sawammo 300
	set gotsaber 0
}
ifvarand startguns 8192 // ALIEN PISTOL
{
	set LASERAMMO 20
	setp[].gotweapon PISTOL_WEAPON YES
	set LASERMODE 0
}
ifvarand startguns 16384 // RAILGUN
{
	setp[].gotweapon DEVISTATOR_WEAPON YES
	set gotrailgun 3
	// ife gametype 0 set railgunammo 16 else set railgunammo 8
	ife gametype 0 setp[].ammo_amount DEVISTATOR_WEAPON 24 else setp[].ammo_amount DEVISTATOR_WEAPON 12
}
ifvarand startguns 32768 // BOW AND DB SHOTGUN
{
	setp[].gotweapon SHOTGUN_WEAPON YES
	orvar gotbow 1
	orvar gotDB 1
	set arrows 24
	set dbammo 24
}
// set player to the appropriate weapon

ifvarand startguns 1 setp[].curr_weapon PISTOL_WEAPON else
ifvarand startguns 8192 { setp[].curr_weapon PISTOL_WEAPON set LASERMODE -1 } else
ifvarand startguns 2 setp[].curr_weapon SHOTGUN_WEAPON else
ifvarand startguns 32768 ifn pchar 2 setp[].curr_weapon SHOTGUN_WEAPON else
ifvarand startguns 4 setp[].curr_weapon CHAINGUN_WEAPON else
ifvarand startguns 8 setp[].curr_weapon RPG_WEAPON else
ifvarand startguns 16 setp[].curr_weapon HANDBOMB_WEAPON else
ifvarand startguns 32 setp[].curr_weapon SHRINKER_WEAPON else
ifvarand startguns 512 setp[].curr_weapon GROW_WEAPON else
ifvarand startguns 64 setp[].curr_weapon DEVISTATOR_WEAPON else
ifvarand startguns 16384 setp[].curr_weapon DEVISTATOR_WEAPON else
ifvarand startguns 256 setp[].curr_weapon FREEZE_WEAPON else
ifvarand startguns 1024 setp[].curr_weapon FREEZE_WEAPON else
ifvarand startguns 2048 setp[].curr_weapon KNEE_WEAPON else
ifvarand startguns 4096 setp[].curr_weapon KNEE_WEAPON else
ifvarand startguns 128 setp[].curr_weapon TRIPBOMB_WEAPON

ife pchar 0 state dukeweapons else
ife pchar 1 state shellyweapons
else ife pchar 2 state wesweapons

ifvarand startguns 32768
ife player[].curr_weapon SHOTGUN_WEAPON
ifle player[].ammo_amount SHOTGUN_WEAPON 1
{
	ifg pchar 0 orvar gotbow 2 else
	orvar gotDB 2
}

ends

state pbodyreset
	
	ifaction PLYINGDEAD
        spawn DUKELYINGDEAD
	ifaction APSHELLYLYINGDEAD
        spawn DUKELYINGDEAD
	ifaction APWESLYINGDEAD	
		spawn DUKELYINGDEAD
	ife pchar 2 action APWESSTAND else
	ife pchar 1 action APSHELLYSTAND else
	ifvarand altcostume 2 action ALTDUKESTAND else
	action PSTAND
	set PSHRINKING 0
	// set startmode -1
	setarray visited[LEVEL] 0
	set gotsaw NO set sawammo 0 state sawoff
	set onturret -1
	set shellyhp healthbuff
	
ends

defstate clearpweapons

	setp[].gotweapon PISTOL_WEAPON YES
	setp[].ammo_amount PISTOL_WEAPON 48
	setp[].gotweapon SHOTGUN_WEAPON NO
	setp[].ammo_amount SHOTGUN_WEAPON 1
	set stakes 0
	setp[].gotweapon CHAINGUN_WEAPON NO
	setp[].ammo_amount CHAINGUN_WEAPON 0
	setarray weap_owned[221] NO // Wes dual uzi
	set TMP_A wesupgrades[CHAINGUN_WEAPON]
	ifvarand TMP_A 1 xorvar TMP_A 1
	setarray wesupgrades[CHAINGUN_WEAPON] TMP_A
	
	set TMP_A wesupgrades[PISTOL_WEAPON]
	ifvarand TMP_A 4 { xorvar TMP_A 4 setarray weap_owned[203] NO }
	setarray wesupgrades[PISTOL_WEAPON] TMP_A
	
	setp[].gotweapon RPG_WEAPON NO
	setp[].ammo_amount RPG_WEAPON 0
	setp[].gotweapon HANDBOMB_WEAPON NO
	setp[].ammo_amount HANDBOMB_WEAPON 0
	setp[].gotweapon SHRINKER_WEAPON NO
	setp[].ammo_amount SHRINKER_WEAPON 0
	setp[].gotweapon DEVISTATOR_WEAPON NO
	setp[].ammo_amount DEVISTATOR_WEAPON 0
	setp[].gotweapon TRIPBOMB_WEAPON NO
	setp[].ammo_amount TRIPBOMB_WEAPON 0
	setp[].gotweapon FREEZE_WEAPON NO
	setp[].ammo_amount FREEZE_WEAPON 0
	setp[].gotweapon GROW_WEAPON NO
	setp[].ammo_amount GROW_WEAPON 0
	set nukeamount 0
	set nukeselect NO
	set gotplasma NO
	set plasmammo 0
	state sawoff
	set gotsaber 0
	set sawammo 0
	set LASERAMMO 0
	set COMMAMMO 0
	set LASERMODE 0
	set gotrailgun NO
	set railgunammo 0

	ife pchar 0 state dukeweapons else
	ife pchar 1 state shellyweapons
	else ife pchar 2 state wesweapons

ends

state spreset
	ifn vrtrip 0
	{
		set vrscreen_time 32
		set vrscreen VR1
		set vrkilled vrtrip
	}
	else
	{
		ife gametype 0 { set credits 0 set lastcredits 0 set gameover YES }
		setp[].dead_flag -1
		set redscore 1000 set bluescore 0
		strength -1
		resetplayer
	}
ends

state survivalreset

	ife gametype SURVIVAL set survivor_winner NO
	ifn player[].timebeforeexit 0 break
	
	ifn vrtrip 0
	{
		set vrscreen_time 32
		set vrscreen VR1
		set vrkilled vrtrip
		break
	}
	
	set temp lastclock
	add temp 480
	ifg totalclock temp
	{
		setp[].dead_flag 0
		setp[].newowner -1
		setp[].wackedbyactor -1
		setp[].weapon_pos -8
		setp[].fta 0
		strength MAXPLAYERHEALTH
		cstat 257
		state resetplayeramounts
		setp[].shield_amount 0
		setp[].jetpack_amount 0
		setp[].boot_amount 0
		setp[].steroids_amount 0
		setp[].firstaid_amount 0
		setp[].heat_amount 0
		setp[].scuba_amount 0
		setp[].holoduke_amount 0
		setp[].kickback_pic 0
		seta[].htextra -1
		set LASERAMMO 0
		set COMMAMMO 0
		set pistolammo 0
		set LASERMODE NO
		set endgametime gametime
		set gametime -1
		
		set redscore 1000
		set bluescore 0
		set burning 0
		set pdown NO
		set survivor_winner NO
		setplayer[].timebeforeexit 40
	}
ends

defstate resetplayerstuff

	set savedvalue NO
	ifl gametype 1 set savedvalue YES
	ife gametype SURVIVAL set savedvalue YES
	
	ife savedvalue YES
	{
		ifvarand perks 64 ifge rescuecharge RESCUEAMOUNT
		ife shellyinmap 0 set shellyinmap 50
		
		ifinouterspace set falldeath YES
		ife falldeath YES set deathcounter 0
	
		ifn shellyinmap 0
		ifn gametime -1
		ifg deathcounter 0
		{
			ife pdown NO
			{
				ife pchar 0 
				{ 
					ifvarand altcostume 2 action ALTDUKEDOWN else
					action PDUKEDOWN 
					set dukecharge 0 
				}
				ife pchar 1 { action APSHELLYDOWN set shellycharge 0 }
				ife pchar 2 { action APWESDOWN set wescharge 0 }
				set pdown YES
				set slidekick 0
				set sidekick 0
				ife gametype SURVIVAL { set bluescore 0 set redscore 1000 }
				set deathcounter 450
				ifactorsound THISACTOR LASERLOOP stopactorsound THISACTOR LASERLOOP
				ifactorsound THISACTOR FREEZELOOP stopactorsound THISACTOR FREEZELOOP
				set zombieonplayer -1
				setp[].dead_flag 0 // -1
				seta[].mdflags 16
				seta[].htextra -1
				set monstatus 2
				setp[].shield_amount 0
				ifn gametype 0
				{
					getp[].ammo_amount PISTOL_WEAPON temp
					shiftr temp 1
					setp[].ammo_amount PISTOL_WEAPON temp
					getp[].ammo_amount SHOTGUN_WEAPON temp
					shiftr temp 1
					setp[].ammo_amount SHOTGUN_WEAPON temp
					shiftr stakes 1
					getp[].ammo_amount CHAINGUN_WEAPON temp
					shiftr temp 1
					setp[].ammo_amount CHAINGUN_WEAPON temp
					getp[].ammo_amount RPG_WEAPON temp
					shiftr temp 1
					setp[].ammo_amount RPG_WEAPON temp
					getp[].ammo_amount HANDBOMB_WEAPON temp
					shiftr temp 1
					setp[].ammo_amount HANDBOMB_WEAPON temp
					getp[].ammo_amount SHRINKER_WEAPON temp
					shiftr temp 1
					setp[].ammo_amount SHRINKER_WEAPON temp
					getp[].ammo_amount DEVISTATOR_WEAPON temp
					shiftr temp 1
					setp[].ammo_amount DEVISTATOR_WEAPON temp
					getp[].ammo_amount TRIPBOMB_WEAPON temp
					shiftr temp 1
					setp[].ammo_amount TRIPBOMB_WEAPON temp
					getp[].ammo_amount FREEZE_WEAPON temp
					shiftr temp 1
					setp[].ammo_amount FREEZE_WEAPON temp
					getp[].ammo_amount GROW_WEAPON temp
					shiftr temp 1
					setp[].ammo_amount GROW_WEAPON temp
					shiftr LASERAMMO 1
				
					set nukeamount 0
					ife nukeselect YES
					{
						set nukeselect NO
						setp[].ammo_amount RPG_WEAPON weap4ammo
						state switchnuke
					}
				
				}
				shiftr railgunammo 1
				shiftr plasmammo 1
				shiftr weap4ammo 1
				shiftr COMMAMMO 1
				setp[].over_shoulder_on YES
				
				ifmove PSHRINKING move 0
				set PSHRINKING 0
				sizeat 42 36
				cstat 257
			}
			
			// setp[].movement_lock 15
			ife pchar 0 { ifvarand altcostume 2 action ALTDUKEDOWN else action PDUKEDOWN }
			ife pchar 1 action APSHELLYDOWN
			ife pchar 2 action APWESDOWN

			setp[].weapon_pos -8
			setp[].jumping_counter 0
			ifhitweapon { }
			ifstrength 5 strength 5
			setp[].quick_kick 0
			set qk_proxy 0
			ifrnd 3 spawn BLOODPOOL
			ifinwater setp[].airleft 150
			quote 266
			cstat 257
			
			ife ikicked -2 addphealth 2
			
			set temp NO
			ifge sprite[].extra 75 set temp YES
			ife ikicked -96 set temp YES
			ife temp YES
			{
				ife pchar 0
				{
					ifrnd 84 sound DUKE_REVIVE1 else
					ifrnd 128 sound DUKE_REVIVE2 else
					sound DUKE_REVIVE3
				}
				ife pchar 1
					sound SHELLYREADY
				setp[].movement_lock 0
				setp[].fta 0
				setp[].dead_flag 0
				setp[].newowner -1
				set zombieonplayer -1
				seta[].htextra -1
				setp[].wackedbyactor -1
				set burning 0
				set pdown NO
				ife gametype SURVIVAL { set bluescore 1 set redscore 0 }
				set monstatus 1
				set ikicked 0
				set falldeath NO
				ife pchar 2 action APWESSTAND else
				ife pchar 1 action APSHELLYSTAND else
				ifvarand altcostume 2 action ALTDUKESTAND else
				action PSTAND
				set PSHRINKING 0
				setp[].over_shoulder_on NO
				set deathcounter 450
				set spawnprotect 150
				break
			}
			
			ifhitspace 
			{
				// set pdown NO 
				state pbodyreset
				ife gametype 0 state spreset
				else ife gametype SURVIVAL { set lastclock 0 state survivalreset }
			}

			break
		}
		else
		{
			ife gametype SURVIVAL
			{
				state survivalreset
				break
			}
			ifn vrtrip 0
			{
				set vrscreen_time 32
				set vrscreen VR1
				set vrkilled vrtrip
				break
			}
			quote 13
			ifhitspace set pdown NO else 
			ife pdown YES
			ife shellyinmap NO set pdown NO
			
			ife deathcounter 0 set pdown NO
			
			ife gametype 0 
			ife pdown NO
			ife vrtrip 0
			{
				set credits 0 set lastcredits 0
				setp[].dead_flag -1
				strength -1
				set gameover YES 
				resetplayer
			}

			break
		}
	}
	else
	{
		set radaron NO
		set temp totalclock
		sub temp deathtime
		ife gametime -1 set temp 600
		ifl temp 600
		{
			cstat 0
			ifg temp 480 quote 204 else
			ifg temp 360 quote 203 else
			ifg temp 240 quote 202 else
			ifg temp 120 quote 201 else
			quote 200
			break
		}
		set spawnprotect 40
		set radaron YES
	}
	
	state pbodyreset
	
	set savedvalue NO
	ifl gametype 1 set savedvalue YES
	ife gametype SURVIVAL set savedvalue YES
	
	ife savedvalue YES
		state spreset	
	else
	{
		// manual stuff
		ifmove PSHRINKING move 0
		set PSHRINKING 0
		sizeat 42 36
        cstat 257
		setp[].dead_flag 0
		setp[].newowner -1
		setp[].wackedbyactor -1
		setp[].weapon_pos -8
		setp[].fta 0
		setp[].movement_lock 0
		set burning 0
		// ife gametype DM
		ifg gametype 0
		ifg pstarts 0
		{
			set tempb pstarts
			sub tempb 1
			rand temp tempb
			set mysector 0
			updatesectorz loadx[temp] loady[temp] loadz[temp] mysector
			ifn temp -1
			{
				setp[].posx loadx[temp]
				setp[].posy loady[temp]
				setp[].posz loadz[temp]
				setp[].cursectnum mysector
				setp[].posxv 0
				setp[].posyv 0
				setp[].poszv 0
			}
		}
		else
		{
			set temp 0
			updatesectorz loadx[LEVEL] loady[LEVEL] loadz[LEVEL] temp
			ifn temp -1
			{
				setp[].posx loadx[LEVEL]
				setp[].posy loady[LEVEL]
				setp[].posz loadz[LEVEL]
				setp[].cursectnum temp
			}
		}
		strength MAXPLAYERHEALTH
		ifn gametype 0 seta[].extra player[].max_player_health
		cstat 257
		state resetplayeramounts
		setp[].shield_amount 0
		setp[].jetpack_amount 0
		setp[].boot_amount 0
		setp[].steroids_amount 0
		setp[].firstaid_amount 0
		setp[].holoduke_amount 0
		setp[].heat_amount 0
		setp[].scuba_amount 0
		setp[].kickback_pic 0
		seta[].htextra -1
		set LASERAMMO 0
		set COMMAMMO 0
		set pistolammo 0
		set LASERMODE NO
		set totalxp 0
		ifn startguns -1 state applystartguns
		else
		{
			setp[].gotweapon PISTOL_WEAPON YES
			setp[].curr_weapon PISTOL_WEAPON
			setp[].ammo_amount PISTOL_WEAPON 48
			setp[].gotweapon SHOTGUN_WEAPON NO
			setp[].ammo_amount SHOTGUN_WEAPON 1
			set stakes 0 
			setp[].gotweapon CHAINGUN_WEAPON NO
			setp[].ammo_amount CHAINGUN_WEAPON 0
			setarray weap_owned[221] NO // Wes dual uzi
			set TMP_A wesupgrades[CHAINGUN_WEAPON]
			ifvarand TMP_A 1 xorvar TMP_A 1
			setarray wesupgrades[CHAINGUN_WEAPON] TMP_A
			set TMP_A wesupgrades[PISTOL_WEAPON]
			ifvarand TMP_A 4 xorvar TMP_A 4
			setarray wesupgrades[PISTOL_WEAPON] TMP_A
			setp[].gotweapon RPG_WEAPON NO
			setp[].ammo_amount RPG_WEAPON 0
			setp[].gotweapon HANDBOMB_WEAPON NO
			setp[].ammo_amount HANDBOMB_WEAPON 0
			setp[].gotweapon SHRINKER_WEAPON NO
			setp[].ammo_amount SHRINKER_WEAPON 0
			setp[].gotweapon DEVISTATOR_WEAPON NO
			setp[].ammo_amount DEVISTATOR_WEAPON 0
			setp[].gotweapon TRIPBOMB_WEAPON NO
			setp[].ammo_amount TRIPBOMB_WEAPON 0
			setp[].gotweapon FREEZE_WEAPON NO
			setp[].ammo_amount FREEZE_WEAPON 0
			setp[].gotweapon GROW_WEAPON NO
			setp[].ammo_amount GROW_WEAPON 0
		}
	}

ends

state sabersound

	randvar temp 3
	ife temp 0 sound SABSWING1 else
	ife temp 1 sound SABSWING3 else
	ife temp 2 sound SABSWING4 else
	ife temp 3 sound SABSWING5
	// sabswing2 currently not used

ends

state gladiatorstuff

	ifg emptalk 0
	{
		sub emptalk 1
		set emp_frame 10902
		ife emptalk 0 
		{
			set emp_frame 10901
			globalsound BIGCHEER
			starttrackslot 4 4 
			ifn empactivation 0
			{
				operateactivators empactivation 0
				operatemasterswitches empactivation
				operaterespawns empactivation
				
				setvar B 0
				
				whilevarvarn B NUMWALLS
				{
					// ife wall[B].overpicnum W_FORCEFIELD
					ife wall[B].lotag empactivation
					{
						setw[B].cstat 0
					}
					add B 1
				}
				
				set empactivation 0
			}
			
		}
	}
	ifg subtitle_time 0 
	{
		sub subtitle_time 1
		setp[].knuckle_incs 0
		setp[].crack_time 0
	}

ends

defstate raincode

setvar tempe 0
setvar countvar 0
setvarvar countvarb raining
abs countvarb

ifl framerate lastframerate
ifl framerate 60
{
	ifg raining 0 sub raining 1 else
	add raining 1
	sub countvarb 1
	ifle countvarb 0 break
}
else ifge framerate 80
ifvarand player[].player_par 1
{
	ifg wantrain 0 ifl raining wantrain add raining 1 else
	ifl wantrain 0 ifg raining wantrain sub raining 1
}

ifg countvarb framerate { set countvarb framerate sub countvarb 5 ifle countvarb 0 break }

ifvarg countvarb 255 setvar countvarb 255
getp[].posx x
getp[].posy y
set countvar countvarb
whilevarn countvar 0
{
	sub countvar 1
	set xydist x
	randvarvar temp rainradius // the random component of the distance from player
	add temp 512
	add xydist temp
	randvar angvar 2047
	
	rotatepoint x y xydist y angvar tempb y
	// tempb and y are the new x and y coords
	
	set tempd player[].cursectnum
	updatesector tempb y tempd
	ifvarn tempd -1
	{
		set temp NO
		
		ife rainpal SCRAPFALL
		{
			ifvarand sector[tempd].ceilingstat 1 nullop else
			set temp YES
		}
		else
		{
			ifvarand sector[tempd].ceilingstat 1
			ifvarn sector[tempd].hitag 101
			set temp YES
		}
		ife temp YES
		{
			getsector[tempd].ceilingpal temp
			ifvare temp 0
			{
				getsector[tempd].ceilingpicnum picnum
				ifvarn picnum MOONSKY1 ifvarn picnum BIGORBIT1 setvar temp 1
			}
			ifvarn temp 0
			{
				// getceilzofslope tempd tempb y z // z is the return var
				// ifvarl raining 0 // don't put snow too high up
				// {
					// getplayer[THISACTOR].posz temp
					// set tempc temp
					// sub temp z // positive value is distance above player to ceiling
					// ifg temp snowceiling 
					// {
						// sub tempc snowceiling 
						// set z tempc
					// }
				// }
				// updatesectorz tempb y z tempd
				// ifvarn tempd -1
				// {
					getplayer[THISACTOR].posz z
					set tempc snowceiling
					ifg raining 0 mul tempc 4
					sub z tempc
					ife rainpal SCRAPFALL
						espawn SCRAPFALL
					else
					ifg raining 0
					{
						ife countvar 0
						ifge raining 72
						ifrnd 16
						{
							espawn LIGHTNING2
							setav[RETURN].countvarb YES
							set z sector[tempd].floorz
						}
						else
						espawn RAINSPRITE
					}
					else espawn SNOWSPRITE
					setsprite RETURN tempb y z
					seta[RETURN].htbposx sprite[RETURN].x
					seta[RETURN].htbposy sprite[RETURN].y
					seta[RETURN].htbposz sprite[RETURN].z
					add tempe 1
				// }
			}
		}
	}
}

ife rainpal SCRAPFALL break

ifg raining 16 
{
	ifoutside
	{
		// soundonce RAIN
		ifactorsound THISACTOR HRAINLOOP nullop else sound HRAINLOOP
	}
	else
	{
		stopactorsound THISACTOR HRAINLOOP
	    ifg tempe 4
	    soundonce RAINWINDOW //else stopsound RAINWINDOW
    }
}
else ifvarg raining 0
{
	ifoutside
	{
		// soundonce RAINLOOP
		ifactorsound THISACTOR RAINLOOP nullop else sound RAINLOOP
	}
	 else
	{
		stopactorsound THISACTOR RAINLOOP
	    ifvarg tempe 4
	    soundonce RAINWINDOW //else stopsound RAINWINDOW
    }
}

ends

state switchboostcode

ife switchboost SWITCHBOOSTTIME
{
	globalsound SWITCHBOOSTSND
	palfrom 50 40 40 63
}
getp[].player_par temp

ifphealthl 25
{
	ifvarand temp 1
	addphealth 1
}
else
ifphealthl 50
{
	ife gametype 0 modvar temp 10 else
	modvar temp 5
	ife temp 0 addphealth 1
}
else
ifphealthl 75
{
	ife gametype 0 modvar temp 15 else
	modvar temp 10
	ife temp 0 addphealth 1
}
else
{
	ife gametype 0 modvar temp 30 else
	modvar temp 15
	ife temp 0 addphealth 1
}

sub switchboost 1

ends

defstate firelaserpistol
	ifge LASERCHARGE 32
	{
		set temp NO
		ife pchar 0 ifvarand dukeupgrades[PISTOL_WEAPON] 16 set temp YES
		ife pchar 1 ifvarand shellyupgrades[PISTOL_WEAPON] 16 set temp YES
		ife pchar 2 ifvarand wesupgrades[PISTOL_WEAPON] 16 set temp YES
		ife temp YES
		{
			setprojectile[ARCBALLPROJ2].extra 120
			setprojectile[ARCBALLPROJ2].velmult 2
			setprojectile[ARCBALLPROJ2].xrepeat 20
			setprojectile[ARCBALLPROJ2].yrepeat 20	
			shoot ARCBALLPROJ2
			sound BFGFIRE2
			setprojectile[ARCBALLPROJ2].extra 60
			setprojectile[ARCBALLPROJ2].velmult 1
			setprojectile[ARCBALLPROJ2].xrepeat 24
			setprojectile[ARCBALLPROJ2].yrepeat 24	
		}
		else
		{
			setprojectile[FIRELASER2].cstat 32768
			setprojectile[FIRELASER2].xrepeat 64
			setprojectile[FIRELASER2].yrepeat 64
			setprojectile[FIRELASER2].extra 100
			setprojectile[FIRELASER2].hitradius 1560
			setprojectile[FIRELASER2].velmult 2
			setprojectile[FIRELASER2].spawns SHOCKBALL_EXP
			setprojectile[FIRELASER2].isound MEGAIMPACT2
			shoot FIRELASER2
			setprojectile[FIRELASER2].cstat 130
			setprojectile[FIRELASER2].xrepeat 32
			setprojectile[FIRELASER2].yrepeat 32
			setprojectile[FIRELASER2].extra 18
			setprojectile[FIRELASER2].hitradius 0
			setprojectile[FIRELASER2].velmult 1
			setprojectile[FIRELASER2].spawns PLASMA_EXP
			setprojectile[FIRELASER2].isound MEGAIMPACT1
			sound FIRE_LASER
			setactorsoundpitch THISACTOR FIRE_LASER -768
		}
		ifvarand gametips 2 { xorvar gametips 2 savegamevar gametips }
		subvar LASERAMMO 5
		set LASERCHARGE 0
		ifl LASERAMMO 0 set LASERAMMO 0
	}
	else
	{
		set temp NO
		ife pchar 0 ifvarand dukeupgrades[PISTOL_WEAPON] 16 set temp YES
		ife pchar 1 ifvarand shellyupgrades[PISTOL_WEAPON] 16 set temp YES
		ife pchar 2 ifvarand wesupgrades[PISTOL_WEAPON] 16 set temp YES
		ife temp YES
		{
			sound TERMLASER
			setprojectile[BIGBOIPROJ].offset 224
			setprojectile[BIGBOIPROJ].extra 20
			shoot BIGBOIPROJ
			setprojectile[BIGBOIPROJ].offset 14354
			setprojectile[BIGBOIPROJ].extra 4
		}
		else
		{
			setprojectile[FIRELASER2].cstat 32768
			shoot FIRELASER2
			setprojectile[FIRELASER2].cstat 130
			sound FIRE_LASER
		}
		sub LASERAMMO 1
		setp[].ammo_amount PISTOL_WEAPON LASERAMMO
		ife LASERAMMO 0 
		{
			set LASERMODE 2
			setp[].weapon_pos -1
			setp[].ammo_amount PISTOL_WEAPON pistolammo
		}
	}
ends

defstate firecommgun
	screensound COMET_FIRE
	setprojectile[COMETPROJ].extra 105
	eshoot COMETPROJ
	seta[RETURN].pal 8
	setprojectile[COMETPROJ].extra 60
	sub COMMAMMO 1
	setp[].ammo_amount PISTOL_WEAPON COMMAMMO
	ife COMMAMMO 0 
	{
		set LASERMODE 4
		setp[].weapon_pos -1
		setp[].ammo_amount PISTOL_WEAPON pistolammo
	}
ends

defstate wesoverride

	// cursory 98 start of replace duke line, 107 eol
	// cursory 122 start of bombshell replace line, 131 eol
	// cursory 146 start of keep both, 155 eol
	
	set TMP_A NO
	ifhitspace set TMP_A YES
	ifvarand bits 4 set TMP_A YES
	
	ife TMP_A YES
	{
		ifge cursory 98 ifle cursory 107 set wesreplace 1
		ifge cursory 122 ifle cursory 131 set wesreplace 2
		ifge cursory 146 ifle cursory 155 set wesreplace 0
	}
	ife wesreplace 0 // wes does not replace anyone
	{
		set epselect tempselect 
		ife epselect 4 set startmode 1
		ife epselect 7 set startmode 3
	}
	else
	ife wesreplace 1 // wes replaces duke
	{
		set epselect tempselect 
		ife epselect 4 // epselect 4 = new invastion
		{
			set startmode 4 set charsel 4
		}
		ife epselect 7 // epselect 7 = space gladiators
		{
			set startmode 6 set charsel 6
		}
	}
	else
	ife wesreplace 2 // wes replaces bombshell
	{
		set epselect tempselect 
		ife epselect 4 // epselect 4 = new invastion
		{
			set startmode 4 set charsel 4
		}
		ife epselect 7 // epselect 7 = space gladiators
		{
			set startmode 5 set charsel 5
		}
	}

ends

defstate startmodecode

	state in_menu
	
	ifcount 15 nullop else ife epselect -1 break
	
	set temp NO
	ifvarand bits 4 set temp YES
	ifhitspace set temp YES
	ife temp YES
	{
		// DEANOVA cursorx 15, 54 cursory 60,160 orvar 16
		// WES cursorx 80, 118 cursory 60,160 orvar 4
		// DUKE cursorx 145,185 cursory 60,160 orvar 1
		// BOMBSHELL cursorx 202,238 cursory 60,160 orvar 2
		// MANDO cursorx 255, 311 cursory 60,160 orvar 8
		
		
		ifge cursorx 15 ifle cursorx 54
		ifge cursory 60 ifle cursory 160
		ifn bits oldbits
		{
			ifvarand charsel 16 xorvar charsel 16 else
			{
				quote 1212
				// orvar charsel 16
				soundonce DEA_GREETING
			}
		}
		
		ifge cursorx 80 ifle cursorx 118
		ifge cursory 60 ifle cursory 160
		ifn bits oldbits
		{
			ifvarand charlocked 4
			{
				ifvarand charsel 4 { xorvar charsel 4 sub numchars 1 } else
				{
					ifge numchars 2 quote 1214 else
					{
						orvar charsel 4
						soundonce WESGOTYOURBACK 
						setp[].fta 0
						add numchars 1
					}
				}
			}
		}
		
		ifge cursorx 145 ifle cursorx 185
		ifge cursory 60 ifle cursory 160
		ifn bits oldbits
		{
			ifvarand charsel 1 { xorvar charsel 1 sub numchars 1 } else
			{
				ifge numchars 2 quote 1214 else
				{
					orvar charsel 1
					soundonce DUKE_ROGER1
					setp[].fta 0
					add numchars 1
				}
			}
		}
		
		ifge cursorx 202 ifle cursorx 238
		ifge cursory 60 ifle cursory 160
		ifn bits oldbits
		{
			ifvarand charsel 2 { xorvar charsel 2 sub numchars 1 } else
			{
				ifge numchars 2 quote 1214 else
				{
					orvar charsel 2
					soundonce B_HAILQUEEN
					setp[].fta 0
					add numchars 1
				}
			}
		}
		
		ifge cursorx 255 ifle cursorx 311
		ifge cursory 60 ifle cursory 160
		ifn bits oldbits
		{
			ifvarand charsel 8 xorvar charsel 8 else
			{
				// orvar charsel 8
				quote 1213
				soundonce MANDO_CORPSES
			}
		}

		ifg cursorx 0 ifl cursorx 45
		ifg cursory 20 ifl cursory 50 // 160
		{
			set tempb YES
			ife attmode YES set tempb NO
			ife LEVEL 7 ife VOLUME 0 set tempb YES
	
			ifn bits oldbits
			ife tempb YES
			{
				sound SWITCH_ON
				ife PROGRESSION YES 
				{
					set PROGRESSION NO
					set attmode NO
					set credits 1000
					set lastcredits 1000
					set vendorupgrade YES
					ifn radaron -1 set radaron YES
				}
				else
				{
					set PROGRESSION YES
					set attmode 2
					set credits 10000
					set lastcredits 10000
					set vendorupgrade YES
					ifn radaron -1 set radaron YES
				}
			}	
		}
		
		ifge cursorx 240
		ifg cursory 20 ifl cursory 50 // 160
		{
			ifl charsel 1 { set charsel 1 set numchars 1 }
			set startmode charsel
			setp[].movement_lock 0
			ifvarand startmode 16 set pchar 4 else
			ifvarand startmode 8 set pchar 3 else
			ifvarand startmode 4 { set pchar 2 state wesweapons } else
			ifvarand startmode 2 { set pchar 1 state shellyweapons } else
			{ set pchar 0 state dukeweapons }
			
			// all other player combos that are not D&B
			ifvarand startmode 1 // spawn DUKEBOT
			{
				ife pchar 0 nullop else { espawn DUKEBOT set myshelly RETURN }
			}
			
			ifvarand startmode 2 // spawn SHELLY
			{
				ife pchar 1 nullop else { espawn SHELLY set myshelly RETURN }
			}
			ifvarand startmode 4 // spawn WESBOT
			{
				ife pchar 2 nullop else { espawn WESBOT set myshelly RETURN }
			}
			ifvarand startmode 8 // spawn MANDOFETT
			{
				ife pchar 3 nullop else { espawn MANDOFETT set myshelly RETURN seta[RETURN].pal 3 }
			}
			ifvarand startmode 16 // spawn DEANOVA
			{
				ife pchar 4 nullop else { espawn DEANOVA set myshelly RETURN }
			}
		}
/*
		ifg cursorx 99 ifl cursorx 225
		ifg cursory 140 ifl cursory 202
		{
			// COOP SELECTION
			set startmode 3
			ife pchar 0 spawn SHELLY else spawn DUKEBOT
			setp[].movement_lock 0
		}

		ifg cursorx 18 ifl cursorx 143
		ifg cursory 80 ifl cursory 135
		{
			// DUKE SOLO SELECTION
			set startmode 1
			setp[].movement_lock 0
		}
		
		ifg cursorx 179 ifl cursorx 304
		ifg cursory 80 ifl cursory 135
		{
			// BOMBSHELL SOLO SELECTION
			set startmode 2
			set pchar 1
			setp[].movement_lock 0
		}
*/
		

	}
	set oldbits bits
	
ends

defstate vrmenucode

	set vendor_screen 0
	state in_menu
	ifg cursorx 60 ifl cursorx 260
	{
		ifg cursory 50 ifl cursory 70
			set tempselect 1
		else
		ifg cursory 110 ifl cursory 130
			set tempselect 2
		else
			set tempselect -1
			
		set temp NO
		ifvarand bits 4 set temp YES
		ifhitspace set temp YES
		
		ife temp YES
		{
			ife tempselect 1 // abort simulation
			{
				set vrscreen_time 32
				set vrscreen VR1
				set vrmenu NO
				break
			}
			ife tempselect 2 // normal eduke menu
			{
				set vrmenu -1
				setp[].movement_lock 0
				setp[].gm 5
				cmenu 50
			}
		}
	}
	
ends

defstate matchmenucode

	
	ifg matchmenu 100 break // gives player a message only

	state in_menu
	// works in tandem with code in EVENT_ GAME for MATCHSTART
	
	
	ifl matchmenu 0 // hack to make the level start for free immediately
	{
		set cursorx 220
		set cursory 100
		set bits 4
		mul matchmenu -1
	}
	
	ifg cursorx 60 ifl cursorx 110
	{
		ifg cursory 90 ifl cursory 130
		{
			set tempselect 0  // NO
			
			set temp NO
			ifvarand bits 4 set temp YES
			ifhitspace set temp YES
			ife temp YES
			{
				set matchmenu NO
				set menuoff YES
				setp[].movement_lock 0
			}
		}
		else set tempselect -1
	}
	else
	ifg cursorx 210 ifl cursorx 260
	{
		ifg cursory 90 ifl cursory 130
		{
			set tempselect 1 // YES
			set temp NO
			ifvarand bits 4 set temp YES
			ifhitspace set temp YES
			ife temp YES
			{
				ifg matchmenu 1
				{
					// ifl credits 1000
					// ife ancients_transport 0
					// {
						// quote 361
						// set matchmenu NO
						// set menuoff YES
						// setp[].movement_lock 0
						// break
					// }
					
					 
					ife ancients_transport 0
					{
						ifge credits 1000
						{
							sub credits 1000
							sub lastcredits 1000
						}
						else
						{
							set credits 0
							set lastcredits 0
						}
					}
					set menuoff YES
					set matchmenu NO
					findnearsprite VRSET 1560 spriteid
					ifn spriteid -1 setav[spriteid].countvar 1
					
					// ife matchlevel 29 operateactivators 13 0 
					// closes secret door
					
					set vrtrip matchlevel
					set vrscreen VR1
					set vrscreen_time 32
					break
					
				}
				set spriteid 0
				headspritestat spriteid 1
				whilevarn spriteid -1
				{
					ife sprite[spriteid].picnum FEMCIV3 ife actorvar[spriteid].botclip 10
						setav[spriteid].monstatus 66
						
					ife sprite[spriteid].picnum DUMCIV setav[spriteid].monstatus 2
					
					nextspritestat spriteid spriteid
					
					
				}
				ife matchmenu YES
				{
					ifge wave 4 add wave 1
				}
				setp[].movement_lock 0
				
				
				setarray keycards[LEVEL] player[].got_access
				setarray secretrooms[LEVEL] player[].secret_rooms
				setarray savelevel[LEVEL] YES
				savemapstate
				startlevel 6 matchlevel
			}
		}
		else set tempselect -1
	}
	else set tempselect -1
	

ends

defstate equipshield

	ifg tempselect 6
	{
		ife tempselect 7 { ife novatype 1 break set novatype 1 }
		ife tempselect 8 { ife novatype 2 break set novatype 2 }
		ife tempselect 9 { ife novatype 3 break set novatype 3 }
	}
	else
	set es_type tempselect
	set es_hp 0
	set es_delaycount 300
	globalsound EQUIPSHIELD

ends

defstate equipweapon

	// applies bits to dukeupgrades or shellyupgrades associated with tempselect
	// deselects bits if appropriate
	// calls dukeweapons or shellyweapons
	switch tempselect
	case 100 // vanilla pistol
		set temp PISTOL_WEAPON 
		set B dukeupgrades[temp]
		set tempb B
		ifvarand B 8 xorvar B 8
	break
	case 101 // glock18
		set temp PISTOL_WEAPON 
		set B dukeupgrades[temp]
		set tempb B
		orvar B 8
	break
	case 102 // AP rounds
		set temp PISTOL_WEAPON 
		set B dukeupgrades[temp]
		set tempb B
		orvar B 1
	break
	case 103 // dual wield
		set temp PISTOL_WEAPON 
		set B dukeupgrades[temp]
		set tempb B
		orvar B 4
	break
	case 104 // regular alien blaster
		set temp PISTOL_WEAPON 
		set B dukeupgrades[temp]
		set tempb B
		ifvarand B 16 xorvar B 16
	break
	case 105 // upgraded blaster
		set temp PISTOL_WEAPON 
		set B dukeupgrades[temp]
		set tempb B
		orvar B 16
	break
	case 106 // doubled pistol ammo
		set temp PISTOL_WEAPON 
		set B dukeupgrades[temp]
		set tempb B
		orvar B 32
	break
	
	case 107 // increased pistol reload speed
		set temp -1
		ifvarand perks 2048 nullop else
		{ orvar perks 2048 sound SKARCLIPIN }
	break
	
	case 110 // vanilla shotty
		set temp SHOTGUN_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		ifvarand B 4 xorvar B 4
	break
	case 111 // explosive shells
		set temp SHOTGUN_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 1
		
	break
	
	case 112 // DB shotty
		set temp SHOTGUN_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 16
		ifvarand gotDB 1 nullop else
		orvar gotDB 1
	break
	
	case 113 // DB shotty +reload speed
		set temp SHOTGUN_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 32
		
	break
	
	case 114 // atomic shotty
		set temp SHOTGUN_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 4
	break
	case 115 // rad shells
		set temp SHOTGUN_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 8
	break
	
	case 116 // burst fire
		set temp SHOTGUN_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 2
	break
	
	case 120 // vanilla chaingun
		set temp CHAINGUN_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
	break
	case 121 // minigun
		set temp CHAINGUN_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 1
	break
	case 122 // AP
		set temp CHAINGUN_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 2
	break
	case 123 // +max ammo
		set temp CHAINGUN_WEAPON
		set B dukeupgrades[temp]
		orvar B 4
	break
	case 124 // executioner
		set temp CHAINGUN_WEAPON
		set B dukeupgrades[temp]
		orvar B 8
		orvar gotshock 1
	break
	
	case 125 // chain gang
		set temp CHAINGUN_WEAPON
		set B dukeupgrades[temp]
		orvar B 16
	break
	
	case 130 // vanilla RPG
		set temp RPG_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
	break
	case 131 // smart RPG
		set temp RPG_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 1
	break
	case 132 // fast rox
		set temp RPG_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 2
	break
	case 133 // multi rox
		set temp RPG_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 4
	break
	case 140 // regular pipebombs
		set temp HANDBOMB_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
	break
	
	case 141 // cluster pipebombs
		set temp HANDBOMB_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 1
	break
	
	case 142 // smart bomblets
		set temp HANDBOMB_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 2
	break
	
	case 150 // regular shrinker
		set temp SHRINKER_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
		
		setarray shellyupgrades[SHRINKER_WEAPON] 0
	break
	
	case 151 // BMFG
		set temp SHRINKER_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 1
	break
	
	case 152 // BMFG altfire
		set temp SHRINKER_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 2
	break
	
	case 153 // plasma rifle big mag
		set temp FREEZE_WEAPON
		set B dukeupgrades[temp]
		orvar B 2
	break
	
	case 154 // babifier
		set temp GROW_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
	break
	
	case 155 // fan service
		set temp GROW_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		ifvarand B 2 xorvar B 2
		orvar B 1
	break
	
	case 156 // BFF ray
		set temp GROW_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
		orvar B 2
	break
	
	case 157 // plasma rifle
		set temp FREEZE_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		// ifvarand B 2 xorvar B 2
	break
	
	case 160 // normal devastator
		set temp DEVISTATOR_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
		ifvarand B 2 xorvar B 2
	break
	
	case 161 // meteorator
		set temp DEVISTATOR_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 1
	break
	
	case 162 // quad barrels
		set temp DEVISTATOR_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 2
	break
	
	case 170 // railgun
		set temp DEVISTATOR_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		ifvarand B 4 xorvar B 4
	break
	
	case 171 // barret
		set temp DEVISTATOR_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 4
	break
	
	case 172 // barret semi-auto
		set temp DEVISTATOR_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 8
	break
	
	case 180 // laser tripbomb
		set temp TRIPBOMB_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		ifvarand B 4 xorvar B 4
		ifvarand B 1 xorvar B 1
	break
	
	case 181 // spider bomb
		set temp TRIPBOMB_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 1
	break
	
	case 182 // spider mobility upgrade
		set temp TRIPBOMB_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 2
	break
	
	case 183 // deathbeam mine
		set temp TRIPBOMB_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
		orvar B 4
	break
		
	case 190 // REGULAR FREEZER
		set temp FREEZE_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
	break
	
	case 191 // ICEBEAM
		set temp FREEZE_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 1
	break
	
	case 194 // DEFLECT HITSCAN
		set temp KNEE_WEAPON
		set B dukeupgrades[temp]
		set tempb B
		orvar B 1
	break
	
	case 200 // D.E.
		set temp PISTOL_WEAPON 
		set B shellyupgrades[temp]
		set tempb B
		ifvarand B 8 xorvar B 8
	break
	case 201 // shelly glock18
		set temp PISTOL_WEAPON 
		set B shellyupgrades[temp]
		set tempb B
		orvar B 8
	break
	case 202 // shelly AP
		set temp PISTOL_WEAPON 
		set B shellyupgrades[temp]
		set tempb B
		orvar B 1
	break
	case 203 // shelly dual pistols
		set temp PISTOL_WEAPON 
		set B shellyupgrades[temp]
		set tempb B
		orvar B 4
	break
	case 204 // regular alien blaster
		set temp PISTOL_WEAPON 
		set B shellyupgrades[temp]
		set tempb B
		ifvarand B 16 xorvar B 16
	break
	case 205 // upgraded blaster
		set temp PISTOL_WEAPON 
		set B shellyupgrades[temp]
		set tempb B
		orvar B 16
	break
	case 206 // doubled pistol ammo
		set temp PISTOL_WEAPON 
		set B shellyupgrades[temp]
		set tempb B
		orvar B 32
	break
	
	case 207 // increased pistol reload speed
		set temp -1
		ifvarand perks 2048 nullop else
		{ orvar perks 2048 sound SKARCLIPIN }
	break
	
	case 210 // shelly shotgun
		set temp SHOTGUN_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		ifvarand B 4 
		{
			xorvar B 4 // removes bow
			ifg player[].ammo_amount SHOTGUN_WEAPON player[].max_ammo_amount SHOTGUN_WEAPON	
				setp[].ammo_amount SHOTGUN_WEAPON player[].max_ammo_amount SHOTGUN_WEAPON
		}
	break
	case 211 // explosive rounds
		set temp SHOTGUN_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 1
	break
	case 212 // semi-auto shotgun
		set temp SHOTGUN_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 128
	break
	case 214 // bow
		set temp SHOTGUN_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 4
		orvar B 32 // get spy arrows for free
		ifvarand gotbow 1 nullop else
		{
			orvar gotbow 1
			setp[].weapon_pos -1
			orvar gotbow 4
		}
		
	break
	case 215 // explosive arrows
		set temp SHOTGUN_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		set TMP_B wesupgrades[temp]
		orvar TMP_B 8
		setarray wesupgrades[temp] TMP_B
		orvar B 8
		setarray weap_owned[215] YES // set Wes equivalent
	break
	case 216 // multishot arrows
		set temp SHOTGUN_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 16
		set TMP_B wesupgrades[temp]
		orvar TMP_B 16
		setarray wesupgrades[temp] TMP_B
		setarray weap_owned[216] YES // set Wes equivalent
	break
	case 217 // electric arrows
		set temp SHOTGUN_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 64
		set TMP_B wesupgrades[SHOTGUN_WEAPON]
		orvar TMP_B 768
		setarray wesupgrades[SHOTGUN_WEAPON] TMP_B
		setarray weap_owned[217] YES // set Wes equivalent
	break
	case 220 // M4
		set temp CHAINGUN_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
	break
	case 221 // double m4
		set temp CHAINGUN_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 1
	break
	case 222 // AP M4
		set temp CHAINGUN_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 2
	break
	case 223 // +max ammo M4
		set temp CHAINGUN_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 4
	break
	case 224 // executioner
		set temp CHAINGUN_WEAPON
		set B shellyupgrades[temp]
		orvar B 8
		orvar gotshock 1
	break
	case 225 // chain gang
		set temp CHAINGUN_WEAPON
		set B shellyupgrades[temp]
		orvar B 16
	break
	case 230 // vanilla RPG
		set temp RPG_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
	break
	case 231 // smart RPG
		set temp RPG_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 1
	break
	case 232 // fast rox
		set temp RPG_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 2
	break
	case 233 // multi rox
		set temp RPG_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 4
	break
	
	case 240 // regular turret
		set temp HANDBOMB_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
	break
	
	case 241 // missile turret
		set temp HANDBOMB_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 1
	break
	
	case 242 // armored turrets
		set temp HANDBOMB_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 2
	break
	
	case 250 // regular shrinker
		set temp SHRINKER_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
		setarray dukeupgrades[SHRINKER_WEAPON] 0
	break
	
	case 251 // BMFG
		set temp SHRINKER_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 1
	break
	
	
	case 252 // BMFG altfire
		set temp SHRINKER_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 2
	break
	
	case 253 // plasma rifle big mag
		set temp FREEZE_WEAPON
		set B shellyupgrades[temp]
		orvar B 2
	break
	
	case 254 // babifier
		set temp GROW_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
	break
	
	case 255 // fan service
		set temp GROW_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		ifvarand B 2 xorvar B 2
		orvar B 1
	break
	
	case 256 // BFF ray
		set temp GROW_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
		orvar B 2
	break
	
	case 257 // plasma rifle
		set temp FREEZE_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		// ifvarand B 2 xorvar B 2
	break
	
	case 260 // regular devastator
		set temp DEVISTATOR_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
		ifvarand B 2 xorvar B 2
	break
	
	case 261 // sticky bombs
		set temp DEVISTATOR_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 1
	break
	
	case 262 // quad barrels
		set temp DEVISTATOR_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 2
	break
	
	case 270 // regular railgun
		set temp DEVISTATOR_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		ifvarand B 4 xorvar B 4
	break
	
	case 271 // barret
		set temp DEVISTATOR_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 4
	break
	
	case 272 // barret semi-auto
		set temp DEVISTATOR_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 8
	break
	
	case 280 // tripbombs
		set temp TRIPBOMB_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		ifvarand B 4 xorvar B 4
		ifvarand B 1 xorvar B 1
	break
	
	case 281 // spider bombs
		set temp TRIPBOMB_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 1
	break
	
	case 282 // spider mobility upgrade
		set temp TRIPBOMB_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 2
	break
	
	case 283 // deathbeam mine
		set temp TRIPBOMB_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
		orvar B 4
	break
	
	case 290 // INCINERATOR
		set temp FREEZE_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
	break
	
	case 291 // INCINERATOR UPGRADE
		set temp FREEZE_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 1
	break
	case 294 // DEFLECT HITSCAN
		set temp KNEE_WEAPON
		set B shellyupgrades[temp]
		set tempb B
		orvar B 1
	break
	
	// 300-399 Wes weapon upgrades
	// case 300 // regular pistol
		// set temp PISTOL_WEAPON 
		// set B wesupgrades[temp]
		// set tempb B
		// ifvarand B 8 xorvar B 8
	// break
	
	case 302 // Wes AP
		set temp PISTOL_WEAPON 
		set B wesupgrades[temp]
		set tempb B
		orvar B 1
	break
	// case 303 // Wes dual pistols
		// set temp PISTOL_WEAPON 
		// set B wesupgrades[temp]
		// set tempb B
		// orvar B 4
	// break
	case 304 // regular alien blaster
		set temp PISTOL_WEAPON 
		set B wesupgrades[temp]
		set tempb B
		ifvarand B 16 xorvar B 16
	break
	case 305 // upgraded blaster
		set temp PISTOL_WEAPON 
		set B wesupgrades[temp]
		set tempb B
		orvar B 16
	break
	case 306 // doubled pistol ammo
		set temp PISTOL_WEAPON 
		set B wesupgrades[temp]
		set tempb B
		orvar B 32
	break
	
	case 307 // increased pistol reload speed
	    set temp -1
		ifvarand perks 2048 nullop else
		{ orvar perks 2048 sound SKARCLIPIN }
	break
	
	case 310 // Wes shotgun
		set temp SHOTGUN_WEAPON
		set B wesupgrades[temp]
		set tempb B
	break
	// case 311 // explosive rounds
		// set temp SHOTGUN_WEAPON
		// set B wesupgrades[temp]
		// set tempb B
		// orvar B 1
	// break
	case 312 // semi-auto shotgun
		set temp SHOTGUN_WEAPON
		set B wesupgrades[temp]
		set tempb B
		orvar B 128
	break
	case 314 // bow
		set temp SHOTGUN_WEAPON
		set B wesupgrades[temp]
		set tempb B
		orvar B 4
		orvar B 32 // get spy arrows for free
		ifvarand gotbow 1 nullop else
		{
			orvar gotbow 1
			setp[].weapon_pos -1
			orvar gotbow 4
		}
		
	break
	// wesupgrades[SHOTGUN_WEAPON] 16=MULTI, 32=SPY, 8=RADIOACTIVE, 256=ICE, 512=FIRE
	case 315 // RADIOACTIVE arrows
		set temp SHOTGUN_WEAPON
		set B wesupgrades[temp]
		set tempb B
		orvar B 8
		set TMP_B shellyupgrades[temp]
		orvar TMP_B 8
		setarray shellyupgrades[temp] TMP_B
		setarray weap_owned[115] YES // set Bombshell equivalent
	break
	case 316 // multishot arrows
		set temp SHOTGUN_WEAPON
		set B wesupgrades[temp]
		set tempb B
		orvar B 16
		set TMP_B shellyupgrades[temp]
		orvar TMP_B 16
		setarray shellyupgrades[temp] TMP_B
		setarray weap_owned[116] YES // set Bombshell equivalent
	break
	case 317 // ELEMENTAL
		set temp SHOTGUN_WEAPON
		set B wesupgrades[temp]
		set tempb B
		orvar B 768
		
		set TMP_B shellyupgrades[SHOTGUN_WEAPON]
		orvar TMP_B 64
		setarray shellyupgrades[SHOTGUN_WEAPON] TMP_B
		setarray weap_owned[117] YES // set Bombshell equivalent
	break
	case 320 // M4
		set temp CHAINGUN_WEAPON
		set B wesupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
	break
	// case 321 // double m4
		// set temp CHAINGUN_WEAPON
		// set B wesupgrades[temp]
		// set tempb B
		// orvar B 1
	// break
	case 322 // AP uzi
		set temp CHAINGUN_WEAPON
		set B wesupgrades[temp]
		set tempb B
		orvar B 2
	break
	case 323 // +max ammo M4
		set temp CHAINGUN_WEAPON
		set B wesupgrades[temp]
		set tempb B
		orvar B 4
	break
	case 324 // executioner
		set temp CHAINGUN_WEAPON
		set B wesupgrades[temp]
		orvar B 8
		orvar gotshock 1
	break
	case 325 // chain gang
		set temp CHAINGUN_WEAPON
		set B wesupgrades[temp]
		orvar B 16
	break
	case 330 // vanilla RPG
		set temp RPG_WEAPON
		set B wesupgrades[temp]
		set tempb B
		// ifvarand B 1 xorvar B 1
	break
	
	case 340 // regular icebombs
		set temp HANDBOMB_WEAPON
		set B wesupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
	break
	
	case 341 // cluster icebombs
		set temp HANDBOMB_WEAPON
		set B wesupgrades[temp]
		set tempb B
		orvar B 1
	break
	
	case 342 // smart icebombs
		set temp HANDBOMB_WEAPON
		set B wesupgrades[temp]
		set tempb B
		orvar B 2
	break
	
	case 351 // blood zombie
		set temp SHRINKER_WEAPON
		set B wesupgrades[temp]
		orvar B 1
	break

	case 353 // plasma rifle big mag
		set temp FREEZE_WEAPON
		set B wesupgrades[temp]
		orvar B 2
	break
	
	case 355 // SCAR full auto
		set temp GROW_WEAPON
		set B wesupgrades[temp]
		orvar B 1
	break
	
	case 357 // plasma rifle
		set temp FREEZE_WEAPON
		set B wesupgrades[temp]
		set tempb B
		// ifvarand B 2 xorvar B 2
	break
	
	case 360 // regular devastator
		set temp DEVISTATOR_WEAPON
		set B wesupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
		ifvarand B 2 xorvar B 2
	break
	
	case 362 // quad barrels
		set temp DEVISTATOR_WEAPON
		set B wesupgrades[temp]
		set tempb B
		orvar B 2
	break
	
	case 370 // regular railgun
		set temp DEVISTATOR_WEAPON
		set B wesupgrades[temp]
		set tempb B
		ifvarand B 4 xorvar B 4
	break
	
	case 371 // barret
		set temp DEVISTATOR_WEAPON
		set B wesupgrades[temp]
		set tempb B
		orvar B 4
	break
	
	case 372 // barret semi-auto
		set temp DEVISTATOR_WEAPON
		set B wesupgrades[temp]
		set tempb B
		orvar B 8
	break
	
	case 380 // tripbombs
		set temp TRIPBOMB_WEAPON
		set B wesupgrades[temp]
		set tempb B
		ifvarand B 4 xorvar B 4
		ifvarand B 1 xorvar B 1
	break
	
	case 381 // spider bombs
		set temp TRIPBOMB_WEAPON
		set B wesupgrades[temp]
		set tempb B
		orvar B 1
	break
	
	case 382 // spider mobility upgrade
		set temp TRIPBOMB_WEAPON
		set B wesupgrades[temp]
		set tempb B
		orvar B 2
	break
	
	case 383 // deathbeam mine
		set temp TRIPBOMB_WEAPON
		set B wesupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
		orvar B 4
	break
	
	case 390 // Blade Launcher
		set temp FREEZE_WEAPON
		set B wesupgrades[temp]
		set tempb B
		ifvarand B 1 xorvar B 1
	break
	
	case 391 // Blade Launcher upgrade
		set temp FREEZE_WEAPON
		set B wesupgrades[temp]
		set tempb B
		orvar B 1
	break
	case 394 // DEFLECT HITSCAN
		set temp KNEE_WEAPON
		set B wesupgrades[temp]
		set tempb B
		orvar B 1
	break
	
	case 600 // EMT TRAINING
		set B inven_upgrades
		ifvarand B 16 nullop else
		{
			orvar B 16 sound GETATOMICHEALTH 
		}
	break
	case 601 // UPGRADED MEDKIT
		set B inven_upgrades
		ifvarand B 1 nullop else
		{ orvar B 1 sound GETATOMICHEALTH }
	break
	case 602 // NORMAL GOGGLES
		set B inven_upgrades
		ifvarand B 2 { xorvar B 2 sound GETATOMICHEALTH }
	break
	case 603 // AIMBOT GOGGLES
		set B inven_upgrades
		ifvarand B 2 nullop else
		{ orvar B 2 sound GETATOMICHEALTH }
	break
	case 604 // COVER CUBE CRUSHER
		set B inven_upgrades
		ifvarand B 32 nullop else
		{ orvar B 32 sound GETATOMICHEALTH }
	break
	case 605 // HOLOBAGGER
		set B inven_upgrades
		ifvarand B 4 nullop else
		{ 
			orvar B 4 sound GETATOMICHEALTH 
			orvar fetchquest 512
		}
	break
	case 606 // NORMAL BOOTS
		set B inven_upgrades
		ifvarand B 8 { xorvar B 8 sound GETATOMICHEALTH }
	break
	case 607 // DASH BOOTS
		set B inven_upgrades
		ifvarand B 8 nullop else
		{ orvar B 8 sound GETATOMICHEALTH }
	break
	case 610 // 125 health
		add healthbuff 25
		setp[].max_player_health healthbuff
		addphealth 25
	break
	case 611 // coin magnet
		ifvarand perks 32 nullop else
		{ orvar perks 32 sound GETATOMICHEALTH }
	break
	case 612 // low health regen
		// orvar perks 16
		ife regenmax 0 set regenmax 20 else
		add regenmax 10
		sound GETATOMICHEALTH
	break
	
	case 613 // EDF rescue
		ifvarand perks 64 nullop else
		{ orvar perks 64 sound GETATOMICHEALTH }
	break
	
	case 614 // kick damage boost
		ifvarand perks 4 nullop else
		{ orvar perks 4 sound GETATOMICHEALTH }
	break
	
	case 615 // I-FRAMES, was RADAR
		// ifvarand perks 2 nullop else
		// { orvar perks 2
		// set radaron YES sound GETATOMICHEALTH }
		add iframes_max 8
		sound GETATOMICHEALTH
	break
	
	case 616 // no self-damage
		ifvarand perks 8 nullop else
		{ orvar perks 8 sound GETATOMICHEALTH }
	break
	
	case 617 // companion sideguns
		ifvarand perks 1 nullop else
		{ orvar perks 1 sound GETATOMICHEALTH }
	break
	
	case 620 // duke perk
		ifvarand perks 128 nullop else
		{ orvar perks 128 sound GETATOMICHEALTH }
	break
	
	case 621 // bombshell perk
		ifvarand perks 256 nullop else
		{ orvar perks 256 sound GETATOMICHEALTH }
	break
	
	case 622 // wes perk
		ifvarand perks 512 nullop else
		{ orvar perks 512 sound GETATOMICHEALTH }
	break
	
	case 623 // auto-revive
		ifvarand perks 1024 nullop else
		{ orvar perks 1024 sound GETATOMICHEALTH }
	break
	
	default 
		set temp PISTOL_WEAPON
		set B 0
		set tempb 0
	break
	endswitch
	ifge tempselect 600 // inventory upgrades
	{
		ifle tempselect 607
			set inven_upgrades B
	}
	else
	{
		ifn temp -1
		{
			ife pchar 0 setarray dukeupgrades[temp] B else
			ife pchar 1 setarray shellyupgrades[temp] B else
			ife pchar 2 setarray wesupgrades[temp] B
		}
		ife pchar 0 state dukeweapons else ife pchar 1 state shellyweapons
		else ife pchar 2 state wesweapons
		
		ifn B tempb soundvar WEAPON2_SELECTSOUND // NEWSHOTCOCK 
	}
ends

defstate purchaseshield

// prevent purchase of shield mod if no shield is owned
// also prevent purchase of advanced shields
ifg tempselect 3
{
	ife es_type 0
	{
		quote 393
		break
	}
}

switch tempselect
case 1 set tempd 5000 break
case 2 set tempd 6000 break
case 3 set tempd 7000 break

case 4 ife gametype 0 ife vrtrip 0 set tempd 12000 else set tempd 16000 break
case 5 ife gametype 0 ife vrtrip 0 set tempd 16000 else set tempd 20000 break
case 6 ife gametype 0 ife vrtrip 0 set tempd 20000 else set tempd 24000 break

// 7-9 are shield mods

case 7 set tempd 8000 break
case 8 set tempd 8000 break
case 9 set tempd 8000 break
endswitch

// discounts

set temp 1
ifl tempselect 7
{
	state shield_discount
}
else
ifl tempselect 10
{
	state nova_discount
}

// ife gametype 0 ife myshelly -1 { mul tempd 2 div tempd 3 }

ifge credits tempd
{
	state randgetweapsnds
	sub credits tempd
	sub lastcredits tempd
	setarray es_owned[tempselect] YES
	set es_battery -1
	ife wave 0 set wave 1
}
else quote 361

ends

defstate purchaseweapon

ifge credits tempd
{
	// state randgetweapsnds
	sub credits tempd
	sub lastcredits tempd
	switch tempc // some purchases are repeatable
	case  510 // max health buy 
	case  512 // max regen buy
	case  515 // I-frames buy
		set tempH weap_owned[tempc]
		add tempH 1
		setarray weap_owned[tempc] tempH
	break
	default
		setarray weap_owned[tempc] YES
	break
	endswitch
	
	ifge sprite[].extra 75
	ife checkpoints NO
	state autosave
	
	switch tempselect
	case 100 set award_screen 9912 set award_string 324 sound OGUS_GOTCHA break // pistol
	case 101 set award_screen 9933 set award_string 325 sound OGUS_SOLD break // GLOCK 18
	case 102
		set award_screen 9913 set award_string 326 sound OGUS_DONTASK break // AP ROUNDS
	
	case 103 set award_screen 9924 set award_string 327 sound OGUS_SOLD break // DUAL WIELDING
	case 104 case 304
		set award_screen 9907 set award_string 250 sound OGUS_SOLD break // alien blaster
	case 105 case 305
		set award_screen 9908 set award_string 251 sound OGUS_DONTASK break // blaster upgrade
	case 106 case 206 case 306
		set award_screen 9906 set award_string 791 sound OGUS_SOLD break // double pistol ammo
	case 107 case 207 case 307
		set award_screen 12536 set award_string 1352  sound OGUS_SOLD break // + pistol reload speed
	case 110 set award_screen 9940 set award_string 331 sound OGUS_GOTCHA break // shotgun
	case 111 set award_screen 9928 set award_string 218 sound OGUS_SOLD break // explosive shells
	case 112 set award_screen 16593 set award_string 2880 sound OGUS_SOLD break // DB shotty
	case 113 set award_screen 16594 set award_string 1352 sound OGUS_GAMEBREAKER break // + reload speed
	case 114 set award_screen 9935 set award_string 309 sound OGUS_DONTASK break // atomic shotty
	case 115 set award_screen 9909 set award_string 392 sound OGUS_DONTASK break // rad shells
	case 116 set award_screen 9947 set award_string 337 sound OGUS_DONTASK break // burst fire
	case 120 set award_screen 9922 set award_string 54 sound OGUS_GOTCHA break // chaingun
	case 121 set award_screen 9934 set award_string 339 sound OGUS_SOLD break // minigun
	case 122
		set award_screen 9948 set award_string 326 sound OGUS_DONTASK break // AP chaingun
	case 123 case 323
		set award_screen 9950 set award_string 340 sound OGUS_SOLD break // double chain ammo
	case 124 case 324 
		set award_screen 9910 set award_string 1121 sound OGUS_GAMEBREAKER break // executioner
	case 125 case 225 case 325
		set award_screen 16590 set award_string 1156 sound OGUS_DONTELL break // chain gang
	case 130
		set award_screen 9919 set award_string 56 sound OGUS_SOLD break // RPG
	case 131 set award_screen 9943 set award_string 344 sound OGUS_SOLD break
	case 132 set award_screen 9952 set award_string 345 sound OGUS_SOLD break
	case 133 set award_screen 9953 set award_string 346 sound OGUS_DONTELL break
	case 140 set award_screen 9954 set award_string 370 sound OGUS_GOTCHA break // PIPEBOMB
	case 141
		set award_screen 9955 set award_string 371 sound OGUS_DONTELL break
	case 142
		set award_screen 16532 set award_string 1119 sound OGUS_DONTELL break // smart bomblets
	case 150 set award_screen 9911 set award_string 385 sound OGUS_SOLD break // SHRINKER
	case 151 set award_screen 9914 set award_string 386 sound OGUS_GAMEBREAKER break // BMFG
	case 152 set award_screen 9982 set award_string 1117 sound OGUS_GAMEBREAKER break // BMFG altfire
	case 153 case 253 case 353
		set award_screen 16586 set award_string 1125 sound OGUS_SOLD break // plasma double ammo
	case 154 set award_screen 9920 set award_string 387 sound OGUS_SOLD break // EXPANDER
	case 155 set award_screen 16536 set award_string 388 sound OGUS_DONTELL break // fan service
	case 156 case 256 set award_screen 18825 set award_string 2890 sound OGUS_GAMEBREAKER break // fan service
	case 157 case 257 set award_screen 16587 set award_string 1124 sound OGUS_SOLD break // plasma rifle
	
	case 160 set award_screen 9923 set award_string 376 sound OGUS_SOLD break // DEVASTATOR
	case 360 set award_screen 19268 set award_string 376 sound OGUS_SOLD break // DEVASTATOR
	case 161 set award_screen 16537 set award_string 377 sound OGUS_DONTELL break
	case 162
		set award_screen 16538 set award_string 1118 sound OGUS_DONTELL break // QUAD BARRELS
	case 362 set award_screen 19267 set award_string 1118 sound OGUS_DONTELL break // QUAD BARRELS
	case 170 set award_screen 9963 set award_string 383 sound OGUS_SOLD break // RAILGUN
	case 171 case 371
		set award_screen 9964 set award_string 384 sound OGUS_DONTELL break // BARRET
	case 172 case 272 case 372
		set award_screen 16585 set award_string 1123 sound OGUS_SOLD break // BARRET SEMI-AUTO
	case 180 set award_screen 9962 set award_string 380 sound OGUS_DONTASK break // TRIPBOMBS
	case 181 set award_screen 9960 set award_string 381 sound OGUS_SOLD break
	case 182 set award_screen 9961 set award_string 382 sound OGUS_SOLD break
	case 183 case 283 set award_screen 16588 set award_string 1128 sound OGUS_SOLD break
	case 190 set award_screen 9931 set award_string 366 sound OGUS_GOTCHA break // FREEZER
	case 191 set award_screen 9932 set award_string 367 sound OGUS_SOLD break // ICEBEAM
	case 194 case 294 case 394
		set award_screen 16531 set award_string 1122 sound OGUS_SOLD break // DEFLECT HITSCAN
	
	case 200 set award_screen 9915 set award_string 330 sound OGUS_GOTCHA break // pistol
	case 201 set award_screen 9933 set award_string 325 sound OGUS_SOLD break
	case 202 set award_screen 9916 set award_string 326 sound OGUS_DONTASK break
	case 203 set award_screen 9925 set award_string 327 sound OGUS_SOLD break
	case 204 set award_screen 9907 set award_string 250 sound OGUS_SOLD break // alien blaster
	case 205 set award_screen 9908 set award_string 251 sound OGUS_DONTASK break // blaster upgrade
	case 210 set award_screen 9941 set award_string 331 sound OGUS_GOTCHA break // shotgun
	case 211 set award_screen 9928 set award_string 190 sound OGUS_DONTASK break
	case 212 case 312 set award_screen 16592 set award_string 2870 sound OGUS_DONTASK break // semi-auto shotgun
	case 214 // case 314
		set award_screen 9921 set award_string 333 sound OGUS_SOLD break // bow
	case 215
		set award_screen 9946 set award_string 332 sound OGUS_DONTELL break // explosive arrows
	case 315
		set award_screen 19279 set award_string 1235 sound OGUS_DONTELL break // RADIOACTIVE arrows
	case 216 case 316
		set award_screen 9944 set award_string 334 sound OGUS_SOLD break // multishot
	case 217
		set award_screen 9945 set award_string 335 sound OGUS_DONTASK break // electric
	case 317
		set award_screen 19278 set award_string 1234 sound OGUS_DONTASK break // elemental
	case 220 set award_screen 9917 set award_string 341 sound OGUS_GOTCHA break // chaingun
	case 320 set award_screen 19266 set award_string 1236 sound OGUS_GOTCHA break // uzi
	case 221 set award_screen 9926 set award_string 342 sound OGUS_GAMEBREAKER break
	case 222 case 322 set award_screen 9948 set award_string 326 sound OGUS_SOLD break
	case 223 set award_screen 9949 set award_string 340 sound OGUS_SOLD break
	case 224 set award_screen 9910 set award_string 1121 sound OGUS_GAMEBREAKER break // SHOCK RIFLE
	case 230 set award_screen 9951 set award_string 56 sound OGUS_GOTCHA break // RPG
	case 330 set award_screen 19263 set award_string 1237 sound OGUS_GOTCHA break // Wes RPG
	case 231 set award_screen 9943 set award_string 344 sound OGUS_SOLD break
	case 232 set award_screen 9952 set award_string 345 sound OGUS_SOLD break
	case 233 set award_screen 9953 set award_string 346 sound OGUS_DONTELL break
	case 240 set award_screen 9956 set award_string 372 sound OGUS_SOLD break // TURRETS
	case 241 set award_screen 9957 set award_string 375 sound OGUS_DONTELL break
	case 242 set award_screen 16533 set award_string 1120 sound OGUS_DONTELL break //  armored turrets
	case 340 set award_screen 19261 set award_string 1238 sound OGUS_SOLD break // bombs
	case 341 set award_screen 19258 set award_string 371 sound OGUS_DONTELL break // cluster
	case 342 set award_screen 19259 set award_string 1119 sound OGUS_DONTELL break // seeking
	case 250 set award_screen 9911 set award_string 385 sound OGUS_GOTCHA break // SHRINKER
	case 251 set award_screen 9914 set award_string 386 sound OGUS_GAMEBREAKER break // BMFG
	case 351 set award_screen 19271 set award_string 1247 sound OGUS_GAMEBREAKER break // blood zombie
	case 252 set award_screen 9982 set award_string 1117 sound OGUS_GAMEBREAKER break // BMFG altfire
	case 254 set award_screen 9920 set award_string 387 sound OGUS_SOLD break // EXPANDER
	case 255 set award_screen 16536 set award_string 388 sound OGUS_DONTELL break // fan service
	case 355 set award_screen 19270 set award_string 1246 sound OGUS_DONTELL break // SCAR full auto
	case 260 set award_screen 9927 set award_string 378 sound OGUS_SOLD break // DEVASTATOR
	case 261 set award_screen 9959 set award_string 379 sound OGUS_DONTELL break
	case 262 set award_screen 16538 set award_string 1118 sound OGUS_DONTELL break // QUAD BARRELS
	case 270 set award_screen 9963 set award_string 383 sound OGUS_SOLD break // RAILGUN
	case 271 set award_screen 9964 set award_string 384 sound OGUS_GAMEBREAKER break // BARRET
	case 280 case 380 set award_screen 9962 set award_string 380 sound OGUS_SOLD break // TRIPBOMBS
	case 281 case 381 set award_screen 9960 set award_string 381 sound OGUS_SOLD break
	case 282 case 382 set award_screen 9961 set award_string 382 sound OGUS_SOLD break
	case 290 set award_screen 9929 set award_string 368 sound OGUS_SOLD break // INCINERATOR
	case 291 set award_screen 9930 set award_string 369 sound OGUS_DONTELL break // FIREBEAM
	case 391 set award_screen 19269 set award_string 1242 sound OGUS_DONTELL break // FASTER BL
	case 302 set award_screen 9948 set award_string 326 sound OGUS_DONTASK break // AP ROUNDS
	
	case 600 set award_screen 14327 set award_string 2680 break // EMT TRAINING
	case 601 set award_screen 14328 set award_string 702 break // UPGRADED MEDKIT
	case 602 set award_screen 14329 set award_string 703 break // NORMAL GOGGLES
	case 603 set award_screen 14330 set award_string 704 break // AIMBOT GOGGLES
	case 604 set award_screen 14324 set award_string 705 break // COVER CUBE CRUSHER
	case 605
	    ife pchar 2 { set award_screen 18826 set award_string 2900 }
		else
		{ set award_screen 14333 set award_string 706 }
	break // HOLOBAGGER
	case 606 set award_screen 14331 set award_string 707 break // NORMAL BOOTS
	case 607 set award_screen 14332 set award_string 708 break // DASH BOOTS
	case 610 set award_screen 15353 set award_string 779 break // MAX HEALTH 125
	case 611 set award_screen 15354 set award_string 780 break // COIN MAGNET
	case 612 set award_screen 15355 set award_string 781 break // LOW HEALTH REGEN
	case 613 set award_screen 14326 set award_string 1087 break // EDF Rescue
	case 614 set award_screen 15358 set award_string 782 break // QUICKER KICKS
	case 615 set award_screen 19257 set award_string 1287 break // I-FRAMES, was RADAR
	case 616 set award_screen 16535 set award_string 784 break // NO SELF DAMAGE
	case 617 set award_screen 9981 set award_string 785 break // COMPANION SIDEGUNS

	case 620 set award_screen 16595 set award_string 3130 break // DUKE PERK
	case 621 set award_screen 16596 set award_string 3140 break // BOMBSHELL PERK
	case 622 set award_screen 16597 set award_string 3150 break // WES PERK
	case 623 set award_screen 16598 set award_string 3160 break // AUTO-REVIVE
	
	endswitch
	// ifn gametype -1
	// {
		// stopsound OGUS_GOTCHA
		// stopsound OGUS_SOLD
		// stopsound OGUS_DONTASK
		// stopsound OGUS_GAMEBREAKER
		// stopsound OGUS_GAMEBREAKER
	// }
}
else quote 361
	

ends

state awardcode

	ifl award_time 30 state in_menu
	else ife award_time 30 setp[].movement_lock 0
	ifg subtitle_time 0
	{
		quote 311
		ifhitspace add tempselect 1
		ifg tempselect 20 { set subtitle_time 0 setp[].fta 0 }
	}
	ife subtitle_time 0
	add award_time 1
	ife award_time 1 // give reward
	{
		// note that in most cases, upgrade flags are set in state purchaseweapon, not here
		globalsound WEAPON_UPGRADE
		
		switch award_screen
		case 9907 case 9908
			set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES 
			ifg LASERAMMO 10 set temp NO
			ife temp YES spawn LASERPISTOL
		break
		case 9910
			set temp YES
			ife player[].gotweapon 3 YES ifg player[].ammo_amount 3 10 set temp NO
			ife temp YES spawn SHOCKRIFLESPRITE
		break
		case 9911
		case 19271
			set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES 
			ife player[].gotweapon 6 YES ifg player[].ammo_amount 6 10 set temp NO
			ife temp YES spawn SHRINKERSPRITE
		break
		case 9914
			set temp YES
			ife player[].gotweapon 6 YES ifg player[].ammo_amount 6 10 set temp NO
			ife temp YES spawn SHRINKERSPRITE
		break
		case 9912 case 9933 case 9913 case 9924
		case 9915 case 9916 case 9925
			set temp YES
			ife player[].gotweapon 1 YES ifg player[].ammo_amount 1 10 set temp NO
			ife temp YES spawn FIRSTGUNSPRITE
		break
		case 9920
			set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES 
			ife player[].gotweapon 11 YES ifg player[].ammo_amount 11 10 set temp NO
			ife temp YES spawn GROWSPRITEICON
		break
		case 9940 case 9935 case 9928 case 9947
		case 9941 case 9909
			set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES 
			ife player[].gotweapon 2 YES ifg player[].ammo_amount 2 10 set temp NO
			ife temp YES spawn SHOTGUNSPRITE
		break
		case 8909  // ATOMIC SHOTTY
			// setarray dukeupgrades[SHOTGUN_WEAPON] 4
			ifvarand charsel 1
			{
				set B dukeupgrades[SHOTGUN_WEAPON]
				orvar B 4
				setarray dukeupgrades[SHOTGUN_WEAPON] B
				setarray weap_owned[14] YES
			}
			set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES
			ife player[].gotweapon 2 YES ifg player[].ammo_amount 2 10 set temp NO
			ife temp YES spawn SHOTGUNSPRITE
			ifvarand charsel 1
			set pchar 0
			
		break
		case 9922 case 9934 case 9948 case 9950
		case 9917 case 9926 case 9949
			set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES 
			ife player[].gotweapon 3 YES ifg player[].ammo_amount 3 10 set temp NO
			ife temp YES spawn CHAINGUNSPRITE
		break
		case 9921
			spawn BOWSPRITE
		break
		case 9944 case 9945 case 9946
		case 19279 case 19278
			spawn BOWSPRITE
			// spawn QUIVERSPRITE
		break
		case 9919 case 9943 case 9952 case 9953
		case 9951
			set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES 
			ife player[].gotweapon 4 YES ifg player[].ammo_amount 4 10 set temp NO
			ife temp YES spawn RPGSPRITE
		break
		case 9923 case 16537 case 16538
			set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES 
			ife player[].gotweapon 7 YES ifg player[].ammo_amount 7 10 set temp NO
			ife temp YES spawn DEVISTATORSPRITE
		break
		case 9927 case 9959	
			set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES 
			ife player[].gotweapon 7 YES ifg player[].ammo_amount 7 10 set temp NO
			ife temp YES spawn DEVISTATORSPRITE
		break
		
		case 9930
		case 9932
			set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES 
			ife player[].gotweapon 9 YES ifg player[].ammo_amount 9 10 set temp NO
			ife temp YES
			{
				spawn FREEZESPRITE spawn FREEZEAMMO
			}
		break
		case 9954 case 9955
		case 9956 case 9957
			set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES 
			ife player[].gotweapon 5 YES ifg player[].ammo_amount 5 10 set temp NO
			ife temp YES spawn HBOMBAMMO
		break
		case 9960 case 9961 case 9962 case 16588
			set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES 
			ife player[].gotweapon 8 YES ifg player[].ammo_amount 8 10 set temp NO
			ife temp YES
			{
			spawn TRIPBOMBSPRITE
			spawn TRIPBOMBSPRITE
			}
		break
		
		case 9963 case 9964
			set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES 
			ife temp YES spawn RAILGUNSPRITE
		break
		
		case VENDORUPGRADE
			spawn VENDORUPGRADE
		break
/*
		case 14327 // REGULAR MEDKIT
		case 14328 // UPGRADED MEDKIT
			set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES ife temp YES spawn FIRSTAID
		break 
*/	
		case 14329 // NORMAL GOGGLES
		case 14330 // AIMBOT GOGGLES
			// set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES ife temp YES 
			spawn HEATSENSOR
		break
		case 14324 // COVER CUBE CRUSHER
			spawn COVERSPRITE
		break
		
		case 14333 // HOLOBAGGER
		case 18826 // NAAMAH++
			// set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES ife temp YES 
			spawn HOLODUKE
		break 
		// case 14331 // NORMAL BOOTS
		case 14332 // DASH BOOTS
			// set temp NO ife gametype -1 set temp YES ife attmode YES set temp YES ife temp YES 
			spawn BOOTS
		break
		
		case 16531
			ife player[].gotweapon 11 YES ifg player[].ammo_amount 11 10 nullop else
			spawn SABERSPRITE
		break
		case 16536
			ife player[].gotweapon 11 YES ifg player[].ammo_amount 11 10 nullop else
			spawn GROWSPRITEICON
		break
		
		case 16586 case 16587
			ife player[].gotweapon 9 YES ifg player[].ammo_amount 9 10
			ifvarand gotplasma 1 nullop else
			spawn PLASMASPRITE
		break
		
		case 16593
			spawn DBSPRITE
		break
	
		endswitch
	}
	ife award_time 75 { set award_time 0 set award_screen 0 set tempselect -1 }
	

ends

state vendor_tab

	ifl cursorx 47 { set tempselect -1 break }
	ifg cursorx 272 { set tempselect -1 break }
	set tempselect cursorx 
	sub tempselect 47 // min 0, max 225
	mul tempselect 10
	div tempselect 225 // yields value between 0 and 9
	ifg tempselect 9 set tempselect 9
	ife pchar 0 add tempselect 1000 else 
	ife pchar 1 add tempselect 2000 else
	ife pchar 2 add tempselect 3000
	
ends

defstate set_item_number

	ifge cursory 30 ifle cursory 44
	{
		ifge cursorx 278 ifle cursorx 291 set tempselect 10 // exit button
		else set tempselect -1
		break
	}
	else ifge cursory 49 ifle cursory 62
	{
		state vendor_tab
		break
	}
	
	ifl cursorx 60 { set tempselect -1 break }
	ifge cursorx 255 { set tempselect -1 break }
	ifl cursory 85 { set tempselect -1 break }
	ifg cursory 163 { set tempselect -1 break }
	
	switch vendor_screen
	case 13 case 14
	case 16 case 17 case 18
	case 23 case 24
	case 26 case 27 case 28
	case 33 case 34
	case 36 case 37 case 38
		// one row settings
		ifl cursory 95 set tempselect -1 else
		ifg cursory 125 set tempselect -1 else
		ifg cursorx 104 ifl cursorx 110 set tempselect -1 else
		ifg cursorx 154 ifl cursorx 160 set tempselect -1 else
		ifg cursorx 204 ifl cursorx 210 set tempselect -1 else
		{
			set tempselect vendor_screen
			mul tempselect 10
			ifge cursorx 110 add tempselect 1
			ifge cursorx 160 add tempselect 1
			ifge cursorx 210 add tempselect 1
			
			// grayed out item deselect hack
			
			ife tempselect 142 // smart bomblets
			{
				ifvarand dukeupgrades[HANDBOMB_WEAPON] 1 nullop else
				set tempselect -1
				// don't allow smart bomblets without cluster bomb upgrade
			}
			ife tempselect 342 // smart bomblets
			{
				ifvarand wesupgrades[HANDBOMB_WEAPON] 1 nullop else
				set tempselect -1
				// don't allow smart bomblets without cluster bomb upgrade
			}
			ife tempselect 172 // barret semi-auto
			{
				ifvarand dukeupgrades[DEVISTATOR_WEAPON] 4 nullop else
				set tempselect -1
			}
			ife tempselect 272 // barret semi-auto
			{
				ifvarand shellyupgrades[DEVISTATOR_WEAPON] 4 nullop else
				set tempselect -1
			}
			ife tempselect 372 // barret semi-auto
			{
				ifvarand wesupgrades[DEVISTATOR_WEAPON] 4 nullop else
				set tempselect -1
			}
			ife tempselect 133 // multirockets
			{
				ifvarand dukeupgrades[RPG_WEAPON] 1 nullop else
				set tempselect -1
				// don't allow mulrirockets without smart launcher
			}
			ife tempselect 233 // multirockets
			{
				ifvarand shellyupgrades[RPG_WEAPON] 1 nullop else
				set tempselect -1
				// don't allow mulrirockets without smart launcher
			}
			
		}
		
	break
	case 10 case 11 case 12 case 15 case 19
	case 20 case 21 case 22 case 25 case 29
	case 30 case 31 case 32 case 35 case 39
		// two row settings
		ifg cursory 115 ifl cursory 133 set tempselect -1 else
		ifg cursorx 104 ifl cursorx 110 set tempselect -1 else
		ifg cursorx 154 ifl cursorx 160 set tempselect -1 else
		ifg cursorx 204 ifl cursorx 210 set tempselect -1 else
		{
			set tempselect vendor_screen
			mul tempselect 10
			ifge cursorx 110 add tempselect 1
			ifge cursorx 160 add tempselect 1
			ifge cursorx 210 add tempselect 1
			ifge cursory 133 add tempselect 4
		}
		
		ife tempselect 115 // radioactive shells
		{
			ifvarand dukeupgrades[SHOTGUN_WEAPON] 4 nullop else
			set tempselect -1
			// don't allow rad shells without atomic shotty
		}
		ife tempselect 116 // burstfire
		{
			ifvarand dukeupgrades[SHOTGUN_WEAPON] 4 nullop else
			set tempselect -1
			// don't allow burstfire without atomic shotty
		}
		ife tempselect 152 // BMFG altfire
		{
			ifvarand dukeupgrades[SHRINKER_WEAPON] 1 nullop else
			set tempselect -1
			// don't allow BMFG altfire without BMFG
		}
		ife tempselect 252 // BMFG altfire
		{
			ifvarand shellyupgrades[SHRINKER_WEAPON] 1 nullop else
			set tempselect -1
			// don't allow BMFG altfire without BMFG
		}
		ife tempselect 125 // chain gang
		{
			ifvarand dukeupgrades[CHAINGUN_WEAPON] 8 nullop else
			set tempselect -1
		}
		ife tempselect 225 // chain gang
		{
			ifvarand shellyupgrades[CHAINGUN_WEAPON] 8 nullop else
			set tempselect -1
		}
		ife tempselect 325 // chain gang
		{
			ifvarand wesupgrades[CHAINGUN_WEAPON] 8 nullop else
			set tempselect -1
		}
	break
	default set tempselect -1 break
	endswitch
	

ends

defstate vendorcode


	// ifg pchar 1
	// {
		// ifg vendor_screen 9
		// {
			// set vendor_screen 1
			// set lastscreen 1
		// }
	// }
	
	ifl vendor_screen 0
	{
		add vendor_screen 1
		ife vendor_screen 0 set vendor_screen 1
		ife vendor_screen -11 
		{
			// ifl lastscreen 10 set lastscreen 10
			
			ife pchar 0 set vendor_screen lastscreen else
			{
				set vendor_screen lastscreen 
				ifge vendor_screen 10 
				{
					add vendor_screen 10 
					ife pchar 2 add vendor_screen 10
				}
			}
		}
		break
	}

	state in_menu
	ife vendor_used NO
	{
		set vendor_used YES
		ife VOLUME 5 ife LEVEL 11 // attrition tutorial
			operateactivators 1 0
	}
	else ife vendor_used YES
	ifge credits 20000 
	set vendor_used 2
	
	// check for attempts to close window by clicking outside of it
	set temp NO
	ifhitspace set temp YES
	ifvarand bits 4 set temp YES
	ife temp YES
	{
		set temp NO
		ifle cursory 25 set temp YES
		ifge cursory 190 set temp YES
		ifge cursorx 295 set temp YES
		ifle cursorx 20 set temp YES
		ife temp YES
		{
			ife vendor_screen 5
			ife gameover YES
			{
				setuserdef[].display_bonus_screen 0
				endofgame 2
			}
			set vendor_screen 0
			setp[].movement_lock 0
			break
		}
	}
	
	// check for high score button
	set temp NO
	ifhitspace set temp YES
	ifvarand bits 4 set temp YES
	ife temp YES
	ife challenge YES
	{
		ifge cursorx 21 ifle cursorx 48
		ifge cursory 175 ifle cursory 196
		{
			set vendor_screen 5
			set lastscreen vendor_screen
			set tempselect -1
			break
		}
	}
	
	// check for options menu button
	set temp NO
	ifhitspace set temp YES
	ifvarand bits 4 set temp YES
	ife temp YES
	ifn vendor_screen 5
	ifn vendor_screen 7
	{
		ifge cursorx 280 ifle cursorx 292
		ifge cursory 75 ifle cursory 152
		{
			set vendor_screen 7
			screensound TABSELECT
			set lastscreen vendor_screen
			set tempselect -1
			break
		}
	}
	
	ifge cursory 180 ifle cursory 190
	{
		ife attmode YES
		ifn VOLUME 0
		{
			ifge cursorx 73 ifle cursorx 140 set tempselect 904 else
			ifge cursorx 175 ifle cursorx 232 set tempselect 905 else
			set tempselect -1
			ifn tempselect -1
			ifg leveltoken 0
			ife restartatt 0
			{
				set temp NO
				ifvarand bits 4 set temp YES
				ifhitspace set temp YES
				ife temp YES
				{
					ife tempselect 904 set restartatt 90
					else
					ife tempselect 905
					{
						state next_att_map
						set restartatt -90
					}
					set bigmsg 1113
					set bigmsgcount 90
					sub leveltoken 1
					set vendor_screen 0
					setp[].movement_lock 0
					screensound GETATOMICHEALTH
					ife VOLUME 5 ife LEVEL 11 set playerxp 0
					break
				}
			}
			break
		}
	}
	ife vendor_screen 1 // shield vendor
	{
		set lastscreen vendor_screen
		ifge cursory 70 ifle cursory 82
		{
			ifge cursorx 48 ifle cursorx 90 set tempselect 1 else
			ifge cursorx 124 ifle cursorx 166 set tempselect 2 else
			ifge cursorx 200 ifle cursorx 242 set tempselect 3 else
			set tempselect -1
		}
		else
		ifge cursory 90 ifle cursory 102
		{
			ifge cursorx 48 ifle cursorx 90 set tempselect 4 else
			ifge cursorx 124 ifle cursorx 166 set tempselect 5 else
			ifge cursorx 200 ifle cursorx 242 set tempselect 6 else
			set tempselect -1
		}
		else
		ifge cursory 110 ifle cursory 122
		{
			ifge cursorx 48 ifle cursorx 90 set tempselect 7 else
			ifge cursorx 124 ifle cursorx 166 set tempselect 8 else
			ifge cursorx 200 ifle cursorx 242 set tempselect 9 else
			set tempselect -1
		}
		else
		ifge cursory 30 ifle cursory 44
		{
			ifge cursorx 278 ifle cursorx 291 set tempselect 10 // exit button
			else set tempselect -1
			
		}
		else ifge cursory 49 ifle cursory 62
		{
			ifl cursorx 47 { set tempselect -1 } else
			ifg cursorx 270 { set tempselect -1 } else
			ifg cursorx 212 set tempselect 903 else
			ifg cursorx 156 set tempselect 902 else
			ifg cursorx 100 set tempselect 901
			else set tempselect 904
		}
		else set tempselect -1
	}
	else ife vendor_screen 2 // inventory upgrades
	{
		set lastscreen vendor_screen
		ifge cursory 30 ifle cursory 44
		{
			ifge cursorx 278 ifle cursorx 291 set tempselect 10 // exit button
			else set tempselect -1
			
		}
		else ifge cursory 49 ifle cursory 62
		{
			ifl cursorx 47 { set tempselect -1 } else
			ifg cursorx 270 { set tempselect -1 } else
			ifg cursorx 212 set tempselect 903 else
			ifg cursorx 156 set tempselect 902 else
			ifg cursorx 100 set tempselect 901
			else set tempselect 904
		}
		else
		{
			ife es_type 0 ife attmode NO set tempselect -1 // locked until you have eshield
			else
			{
				// two row settings
				ifg cursory 165 set tempselect -1 else
				ifg cursory 115 ifl cursory 133 set tempselect -1 else
				ifg cursorx 104 ifl cursorx 110 set tempselect -1 else
				ifg cursorx 154 ifl cursorx 160 set tempselect -1 else
				ifg cursorx 204 ifl cursorx 210 set tempselect -1 else
				{
					// up to 320 tempselect, weap_owned == tempselect --100
					set tempselect 600
					ifge cursorx 110 add tempselect 1
					ifge cursorx 160 add tempselect 1
					ifge cursorx 210 add tempselect 1
					ifge cursory 133 add tempselect 4
				}
			}
		}
		// else set tempselect -1
	}
	else ife vendor_screen 3 // perks
	{
		set lastscreen vendor_screen
		ifge cursory 30 ifle cursory 44
		{
			ifge cursorx 278 ifle cursorx 291 set tempselect 10 // exit button
			else set tempselect -1
			
		}
		else ifge cursory 49 ifle cursory 62
		{
			ifl cursorx 47 { set tempselect -1 } else
			ifg cursorx 270 { set tempselect -1 } else
			ifg cursorx 212 set tempselect 903 else
			ifg cursorx 156 set tempselect 902 else
			ifg cursorx 100 set tempselect 901
			else set tempselect 904
		}
		else ifge cursory 64 ifle cursory 72
		{
			ifge cursorx 195 ifle cursorx 254 set tempselect 906 else
			set tempselect -1
			
			ife VOLUME 6 ifge LEVEL 38 set tempselect -1
		}
		else
		{
			ife vendorupgrade NO set tempselect -1 // locked until you portable vendor
			else
			{
				// two row settings
				ifl cursory 78 set tempselect -1 else
				ifg cursory 165 set tempselect -1 else
				ifg cursory 115 ifl cursory 133 set tempselect -1 else
				ifg cursorx 104 ifl cursorx 110 set tempselect -1 else
				ifg cursorx 154 ifl cursorx 160 set tempselect -1 else
				ifg cursorx 204 ifl cursorx 210 set tempselect -1 else
				{
					// up to 620 tempselect, weap_owned == tempselect --100
					set tempselect 610
					ifge cursorx 110 add tempselect 1
					ifge cursorx 160 add tempselect 1
					ifge cursorx 210 add tempselect 1
					ifge cursory 133 add tempselect 4
				}
			}
		}
		// else set tempselect -1
	}
	else ife vendor_screen 4 // character sheet
	{
		set lastscreen vendor_screen
		ifge cursory 30 ifle cursory 44
		{
			ifge cursorx 278 ifle cursorx 291 set tempselect 10 // exit button
			else set tempselect -1
			
		}
		else ifge cursory 49 ifle cursory 62
		{
			ifl cursorx 47 { set tempselect -1 } else
			ifg cursorx 270 { set tempselect -1 } else
			ifg cursorx 212 set tempselect 903 else
			ifg cursorx 156 set tempselect 902 else
			ifg cursorx 100 set tempselect 901
			else set tempselect 904
		}
		else
		{
			
			ifge cursory 113 ifle cursory 121
			{
				// costume selection
				ifge cursorx 58 ifle cursorx 218
				{
					set tempselect cursorx
					sub tempselect 58
					div tempselect 10
					add tempselect 640
				}
				else set tempselect -1
			}
			else
			{
				ifg cursory 111 ifl cursory 129 set tempselect -1 else
				ifg cursorx 104 ifl cursorx 110 set tempselect -1 else
				ifg cursorx 154 ifl cursorx 160 set tempselect -1 else
				ifg cursorx 204 ifl cursorx 210 set tempselect -1 else
				{
					// up to 640 tempselect, weap_owned == tempselect --100
					set tempselect 630
					ifge cursorx 110 add tempselect 1
					ifge cursorx 160 add tempselect 1
					ifge cursorx 210 add tempselect 1
					ifge cursory 129 add tempselect 4
				}
			}
			
		}
	}
	else ife vendor_screen 5 // high score display
	{
		
	}
	else ife vendor_screen 6 // perks page 2
	{
		set lastscreen vendor_screen
		ifge cursory 30 ifle cursory 44
		{
			ifge cursorx 278 ifle cursorx 291 set tempselect 10 // exit button
			else set tempselect -1
			
		}
		else ifge cursory 49 ifle cursory 62
		{
			ifl cursorx 47 { set tempselect -1 } else
			ifg cursorx 270 { set tempselect -1 } else
			ifg cursorx 212 set tempselect 903 else
			ifg cursorx 156 set tempselect 902 else
			ifg cursorx 100 set tempselect 901
			else set tempselect 904
		}
		else ifge cursory 64 ifle cursory 72
		{
			ifge cursorx 40 ifle cursorx 110 set tempselect 907 else
			set tempselect -1
		}
		else
		{
			ife vendorupgrade NO set tempselect -1 // locked until you portable vendor
			else
			{
				// two row settings
				ifl cursory 78 set tempselect -1 else
				ifg cursory 165 set tempselect -1 else
				ifg cursory 115 ifl cursory 133 set tempselect -1 else
				ifg cursorx 104 ifl cursorx 110 set tempselect -1 else
				ifg cursorx 154 ifl cursorx 160 set tempselect -1 else
				ifg cursorx 204 ifl cursorx 210 set tempselect -1 else
				{
					// up to 630 tempselect, weap_owned == tempselect --100
					set tempselect 620
					ifge cursorx 110 add tempselect 1
					ifge cursorx 160 add tempselect 1
					ifge cursorx 210 add tempselect 1
					ifge cursory 133 set tempselect -1 // add tempselect 4
				}
			}
		}
		
	}
	else ife vendor_screen 7
	{
		// set lastscreen vendor_screen
		ifge cursory 30 ifle cursory 44
		{
			ifge cursorx 278 ifle cursorx 291 set tempselect 10 // exit button
			else set tempselect -1
			
		}
		// check for upgrades menu button
		set temp NO
		ifvarand bits 536870912 nullop else
		ifhitspace set temp YES
		ifvarand oldbits 4 nullop else
		ifvarand bits 4 set temp YES
		ife temp YES
		{
			ifge cursorx 18 ifle cursorx 30
			ifge cursory 75 ifle cursory 152
			{
				ifg lastscreen 6 ifl lastscreen 10 set lastscreen 1 else
				ifl lastscreen 1 set lastscreen 1
				set vendor_screen lastscreen
				set lastscreen vendor_screen
				set tempselect -1
				screensound TABSELECT
				break
			}
			ifge cursorx 151 ifle cursorx 162
			{
				ifge cursory 62 ifle cursory 72
				ifg optionstart FIRSTOPTION
				{
					// up arrow
					sub optionstart 8
					ifl optionstart FIRSTOPTION set optionstart FIRSTOPTION
					sub currentoption 8
					ifl currentoption FIRSTOPTION set optionstart FIRSTOPTION
					screensound TABSELECT
				}
				else
				ifge cursory 162 ifle cursory 172
				ifl currentoption LASTOPTION
				{
					// down arrow
					add optionstart 8
					set B LASTOPTION
					sub B 7
					ifg optionstart B set optionstart B
					add currentoption 8
					ifg currentoption LASTOPTION set currentoption LASTOPTION
					screensound TABSELECT
				}
			}
		}

		ifvarand oldextbits 1 nullop else
		ifvarand extbits 1 // pressed forward
		{
			sub currentoption 1 ifl currentoption FIRSTOPTION set currentoption FIRSTOPTION
			ifl currentoption optionstart set optionstart currentoption
		}
		
		ifvarand oldextbits 2 nullop else
		ifvarand extbits 2 // pressed backward
		{
			set B optionstart
			add B 7
			ifl currentoption LASTOPTION
			{
				add currentoption 1 ifg currentoption B ifl B LASTOPTION add optionstart 1
			}
		}
		
		ifvarand oldbits 4 nullop else
		ifvarand bits 4
		ifg cursory 75 ifl cursory 156
		{
			set tempc currentoption
			set B optionstart
			set temp cursory
			sub temp 75
			div temp 10
			add B temp
			set currentoption B
			ifsound TABSELECT nullop else
			ifn tempc currentoption screensound TABSELECT
		}
		ife currentoption 3210
		{
			set subtitle_time 6
			set subtitle_numlines 3
			set subtitle_start 3175
		} else
		ifge currentoption 3213 ifle currentoption 3216
		{
			set subtitle_time 6
			set subtitle_numlines 2
			set subtitle_start 3178
		} else
		ife currentoption 3217
		{
			set subtitle_time 6
			set subtitle_numlines 3
			set subtitle_start 3075
		}
		
		set temp NO
		ifvarand oldextbits 4 nullop else
		ifvarand extbits 4 // strafe left
			set temp extbits
		ifvarand oldextbits 8 nullop else
		ifvarand extbits 8 // strafe right
			set temp extbits

		ifn temp NO
		{
			switch currentoption
				case 3202 // DIFFICULTY
					set tempc SKILL
					ifvarand extbits 4 sub SKILL 1 else ifvarand extbits 8 add SKILL 1
					ifl SKILL 1 set SKILL 1 ifg SKILL 5 set SKILL 5
					ife attmode 2 ifl SKILL 3 set SKILL 3
					ife SKILL 4 setuserdef[].player_skill 5 else
					setuserdef[].player_skill SKILL
					ifn tempc SKILL
					{
						screensound TABSELECT
						set subtitle_time 120
						set subtitle_numlines 1
						set subtitle_start 3128
					}
				break
				case 3203 // RADAR DISPLAY
					set tempc radaron
					ifvarand extbits 4 set radaron -1 else ifvarand extbits 8 set radaron YES
					ifn tempc radaron
					screensound TABSELECT
					savegamevar radaron
				break
				case 3204 // ENEMY HEALTH BARS
					set tempc MONHUD
					ifvarand extbits 4 set MONHUD -1 else ifvarand extbits 8 set MONHUD YES
					ifn tempc MONHUD
					screensound TABSELECT
					savegamevar MONHUD
				break
				case 3205 // SHOW ENEMY POINTS
					set tempc SHOWPOINTS
					ifvarand extbits 4 set SHOWPOINTS -1 else ifvarand extbits 8 set SHOWPOINTS YES
					ifn tempc SHOWPOINTS
					screensound TABSELECT
					savegamevar SHOWPOINTS
				break
				case 3206 // FOOTSTEP SOUNDS
					set tempc STEPSOUNDS
					ifvarand extbits 4 set STEPSOUNDS -1 else ifvarand extbits 8 set STEPSOUNDS YES
					ifn tempc STEPSOUNDS
					screensound TABSELECT
					savegamevar STEPSOUNDS
				break
				case 3207 // DISABLE GAMETIPS
					set tempb disable_tips
					
					ifvarand extbits 4 set disable_tips NO else ifvarand extbits 8 set disable_tips YES
					ifn tempb disable_tips
					screensound TABSELECT
					savegamevar disable_tips
					ifn tempb disable_tips ife disable_tips NO set gametips 32767
				break
				case 3208 // DISABLE AUTOSAVE MID-LEVEL
					set tempc AUTOSAVE
					ifvarand extbits 4 set AUTOSAVE YES else ifvarand extbits 8 set AUTOSAVE -1
					ifn tempc AUTOSAVE
					screensound TABSELECT
					savegamevar AUTOSAVE
				break
				case 3209 // DISABLE DOUBLE-TAP DASH
					set tempc disable_doubletap
					ifvarand extbits 4 set disable_doubletap YES else ifvarand extbits 8 set disable_doubletap NO
					ifn tempc disable_doubletap
					screensound TABSELECT
					savegamevar disable_doubletap
				break
				case 3210 // RANDOM ENEMY REPLACEMENTS
				ifn attmode 1
				{
					set tempc NEWENEMIES
					ifvarand extbits 4 set NEWENEMIES -1 else ifvarand extbits 8 set NEWENEMIES YES
					ifn tempc NEWENEMIES
					screensound TABSELECT
					savegamevar NEWENEMIES
				}
				break
				case 3211 // KICKBABLE HEADS
					set tempc disable_kickheads
					ifvarand extbits 4 set disable_kickheads YES else ifvarand extbits 8 set disable_kickheads NO
					ifn tempc disable_kickheads
					screensound TABSELECT
					savegamevar disable_kickheads
				break
				case 3212 // JIBS DURATION
					ifvarand extbits 4 ifg jibs_duration 0 
					{
						sub jibs_duration 1800 
						ifle jibs_duration 0 set jibs_duration -1
					}
					else ifvarand extbits 8 ifl jibs_duration 108000 
					{
						ife jibs_duration -1 set jibs_duration 1800 else
						add jibs_duration 1800
					}
					
					screensound TABSELECT
					savegamevar jibs_duration
				break
				case 3213 // MAX AI TARGET RANGE IN METERS
					ifvarand extbits 4 ifg MAXRANGE 8192
						sub MAXRANGE 8192 
					else ifvarand extbits 8 ifl MAXRANGE 262144 
						add MAXRANGE 8192
					screensound TABSELECT
				break
				case 3214 // DUKE & BOMBSHELL BOTS AVOID MELEE
					set tempc avoid_melee
					ifvarand extbits 4 set avoid_melee NO else ifvarand extbits 8 set avoid_melee YES
					ifn tempc avoid_melee
					screensound TABSELECT
				break
				case 3215 // RAIN
					
					ifvarand extbits 4 sub raining 4 else ifvarand extbits 8 ifl raining 80 add raining 4
					screensound TABSELECT
					ifl raining 0 set raining 0
					set wantrain raining
				break
				case 3216 // SNOW
					
					ifvarand extbits 4 add raining 4 else ifvarand extbits 8 ifg raining -40 sub raining 4
					screensound TABSELECT
					ifg raining 0 set raining 0
				break
				
				case 3217 // MIRRORED MAPS
				
					ifvarand extbits 4 
					ife mirror_maps YES
					{
						set mirror_maps NO 
						ife mirror_thismap -1 set mirror_thismap NO
						else
						ife mirror_thismap YES set mirror_thismap -1
						screensound TABSELECT
					}
					else ifvarand extbits 8 
					ife mirror_maps NO
					{
						set mirror_maps YES
						ife mirror_thismap -1 set mirror_thismap YES
						else
						ife mirror_thismap NO set mirror_thismap -1
						screensound TABSELECT
					}
					savegamevar mirror_maps
					screensound TABSELECT
					
				break
				
				case 3218 // ENEMY INFIGHTING
					set tempc disable_infighting
					ifvarand extbits 4 set disable_infighting YES else ifvarand extbits 8 set disable_infighting NO
					ifn tempc disable_infighting
					screensound TABSELECT
					savegamevar disable_infighting
				break
				
				case 3219 // RESET DEFAULT OPTIONS
					ifvarand extbits 4 set reset_options NO else ifvarand extbits 8 set reset_options YES
					screensound TABSELECT
				break
				
			endswitch
		}
		
	}
	else ifg vendor_screen 9 
	{
		state set_item_number
		set lastscreen vendor_screen
		ifg lastscreen 29 sub lastscreen 20 else
		ifg lastscreen 19 sub lastscreen 10
	}
	
	set B NO
	ifvarand oldbits 536870912 nullop else
	ifhitspace set B YES
	ifvarand oldbits 4 nullop else
	ifvarand bits 4 set B YES
	ife B YES
	ifg vendor_screen 0
	{
		ife vendor_screen 5
		{
			ife gameover YES
			{
				setuserdef[].display_bonus_screen 0
				endofgame 2
			}
			else
			{
				set vendor_screen 1
				set tempselect -1
				setp[].movement_lock 0
			}
		}
		else
		ife tempselect 10
		{
			ifg vendor_screen 9
			ife gametype -1
			{
				ifrnd 16 sound OGUS_DRINKLATER else
				sound OGUS_GOODMATCH
			}
			set vendor_screen 0
			set tempselect -1
			setp[].movement_lock 0
			// globalsound TABSELECT
			
		}
		else
		ifg tempselect 0
		{
			ifge tempselect 1000 // weapon tabs
			{
				// ifg pchar 1 set tempselect vendor_screen else
				ife pchar 0
					sub tempselect 990
				else
				ife pchar 1
					sub tempselect 1980
				else
				ife pchar 2
					sub tempselect 2970
					
				ifn vendor_screen tempselect
				{
					set vendor_screen tempselect
					screensound TABSELECT
				}
				set tempselect -1
			}
			else
			ifge tempselect 600 // inventory stuff
			{
				ife tempselect 901
				{
					ifn vendor_screen 1
					{
						set vendor_screen 1
						screensound TABSELECT
						set tempselect -1
					}
				}
				else
				ife tempselect 902
				{
					ifn vendor_screen 2
					{
						set vendor_screen 2
						screensound TABSELECT
						set tempselect -1
					}
				}
				else
				ife tempselect 903
				{
					ifn vendor_screen 3
					{
						set vendor_screen 3
						screensound TABSELECT
						set tempselect -1
					}
				}
				else
				ife tempselect 904
				{
					ifn vendor_screen 4
					{
						set vendor_screen 4
						screensound TABSELECT
						set tempselect -1
					}
				}
				else
				ife tempselect 906 // go to perks page 2
				{
					ifn vendor_screen 6
					{
						set vendor_screen 6
						screensound TABSELECT
						set tempselect -1
					}
				}
				else
				ife tempselect 907 // go to perks page 1 from 2
				{
					ifn vendor_screen 3
					{
						set vendor_screen 3
						screensound TABSELECT
						set tempselect -1
					}
				}
				else
				{
					set tempc tempselect
					sub tempc 100
					ifge tempc 530 // costume selection
					{
						ifge tempc 540 // costume color
						{
							switch tempc
							set pal -1
							case 540 setp[].palookup 0 setuserdef[].color 0 set pal 0 break
							case 541 setp[].palookup 10 setuserdef[].color 10 set pal 10 break
							case 542 setp[].palookup 11 setuserdef[].color 11 set pal 11 break
							case 543 setp[].palookup 12 setuserdef[].color 12 set pal 12 break
							case 544 setp[].palookup 13 setuserdef[].color 13 set pal 13 break
							case 545 setp[].palookup 14 setuserdef[].color 14 set pal 14 break
							case 546 setp[].palookup 15 setuserdef[].color 15 set pal 15 break
							case 547 setp[].palookup 16 setuserdef[].color 16 set pal 16 break
							case 548 setp[].palookup 21 setuserdef[].color 21 set pal 21 break
							case 549 setp[].palookup 22 setuserdef[].color 22 set pal 22 break
							case 550 setp[].palookup 23 setuserdef[].color 23 set pal 23 break
							case 551 setp[].palookup 35 setuserdef[].color 35 set pal 35 break
							case 552 setp[].palookup 36 setuserdef[].color 36 set pal 36 break
							case 553 setp[].palookup 42 setuserdef[].color 42 set pal 42 break
							case 554 setp[].palookup 43 setuserdef[].color 43 set pal 43 break
							case 555 setp[].palookup 49 setuserdef[].color 49 set pal 49 break
							endswitch
							screensound TABSELECT
							ifn pal -1 { ife pchar 0 set dukepal pal else ife pchar 1 set shellypal pal else
							ife pchar 2 set wespal pal }
							savegamevar dukepal
							savegamevar shellypal
							savegamevar wespal

						}
						else
						{
							ife pchar 0
							{
								ife tempc 530 // default costume
								{
									ifvarand altcostume 8 xorvar altcostume 8
									orvar altcostume 2
									orvar altcostume 16
								}
								else
								ife tempc 531 // classic costume
								{
									ifvarand altcostume 16 xorvar altcostume 16
									ifvarand altcostume 8 xorvar altcostume 8
									ifvarand altcostume 2 xorvar altcostume 2
									action PSTAND
								}
								else
								ife tempc 532 // space costume
								{
									orvar altcostume 8
									orvar altcostume 2
									ifvarand altcostume 16 xorvar altcostume 16
								}
								else
								ife tempc 533 // vacation costume
								{
									orvar altcostume 2
									ifvarand altcostume 16 xorvar altcostume 16
									ifvarand altcostume 8 xorvar altcostume 8
								}
								ifsound BODYSEARCH nullop else sound BODYSEARCH
							}
							else
							{
								ife tempc 530 // default costume
								{
									ifvarand altcostume 1 xorvar altcostume 1
									ifvarand altcostume 4 xorvar altcostume 4
									ifvarand altcostume 32 xorvar altcostume 32
								}
								else
								ife tempc 531 // EDF
								{
									orvar altcostume 1
									ifvarand altcostume 4 xorvar altcostume 4
									ifvarand altcostume 32 xorvar altcostume 32
								}
								else
								ife tempc 532 // space gladiator
								{
									orvar altcostume 4
									ifvarand altcostume 1 xorvar altcostume 1
									ifvarand altcostume 32 xorvar altcostume 32
								}
								else
								ife tempc 533 // bikini
								{
									orvar altcostume 32
									ifvarand altcostume 1 xorvar altcostume 1
									ifvarand altcostume 4 xorvar altcostume 4
								}
								ifsound BODYSEARCH nullop else sound BODYSEARCH
							}
							savegamevar altcostume
						}
						break
					}
					// don't equip stacking upgrades!
					ifn tempc 510 // +25 health
					ifn tempc 512 // regen health +
					ifn tempc 515 // i-frames +
					ife weap_owned[tempc] YES
					{
						state equipweapon
					}
					else
					{
						set tempI weap_owned[tempc]
						set TMP_B tempselect
						state pricetable // tempd now holds price
						set temp weap_owned[tempc]
						state purchaseweapon
						set temp weap_owned[tempc]
						ifg weap_owned[tempc] tempI // purchase successful
						{
							state equipweapon
							set vendor_screen 0
							set tempselect -1
							setp[].movement_lock 0
						}
					}
				}
			}
			else
			ifge tempselect 100 // weapon stuff
			{
				set tempc tempselect
				sub tempc 100
				ife weap_owned[tempc] YES
				{
					state equipweapon
				}
				else
				{
					set TMP_B tempselect
					state pricetable // tempd now holds price
					state purchaseweapon
					ife weap_owned[tempc] YES // purchase successful
					{
						state equipweapon
						set vendor_screen 0
						set tempselect -1
						setp[].movement_lock 0
					}
				}
				
			}
			else
			ifl tempselect 10 // shields
			{
				ife es_owned[tempselect] YES
				{
					ifn es_type tempselect { state equipshield sound SWITCH_ON }
				}
				else
				{
					state purchaseshield
					ife es_owned[tempselect] YES // purchase successful
						state equipshield
				}
			}
			
		}
	}

ends

state endcamsequence

	set thiscam -1
	set SPRITELOTAG 0
	setp[].movement_lock 0
	setuserdef[THISACTOR].clipping NO
	setp[].posx startx
	setp[].posy starty
	setp[].posz initsprite
	setp[].posxv 0
	setp[].posyv 0
	setp[].ang lastangvel
	setp[].player_par 1
	setp[].horiz 100
	set ohoriz 100
	set mysector player[].cursectnum
	updatesectorz startx starty initsprite mysector
	setp[].cursectnum mysector
	
	getflorzofslope mysector startx starty z
	seta[].z z
	sub z 8192
	setp[].posz z
	
	setp[].player_par 1
	ife LEVEL 13 
	{
		operatemasterswitches 1
		starttrackslot 7 9
	}

ends

state findnextcam

	ife actorvar[thiscam].initsprite 1
	{
		state endcamsequence
		break
	}
	headspritestat spriteid 991
	whilevarn spriteid -1
	{
		ife actorvar[spriteid].SPRITELOTAG SPRITELOTAG
		{
			ifn actorvar[thiscam].initflags 0
			// getp[].ang angvel
			set angvel goalang
			
			set thiscam spriteid
		}

		nextspritestat spriteid spriteid
	}

ends

state camtrackcode // CAMTRACK sprites

	ife VOLUME 6 ifg LEVEL 12 ifl LEVEL 38
	soundonce BIGCHEER

	ife SPRITELOTAG 0
	{
		getp[].posx startx
		getp[].posy starty
		getp[].posz initsprite
		getp[].ang angvel
		
		set ocameraang angvel
		set lastangvel angvel
		set goalang angvel
		set SPRITELOTAG 2 // set to the lotag of the next camera
		setp[].posx sprite[thiscam].x
		setp[].posy sprite[thiscam].y
		setp[].posz sprite[thiscam].z
		setp[].cursectnum sprite[thiscam].sectnum
		setp[].horiz 100
		set ohoriz 100
		set raining rainstart 
		state findnextcam
		ife thiscam -1 break
	}

	setp[].knuckle_incs 0
	setp[].falling_counter 0
	setp[].movement_lock 31
	setuserdef[THISACTOR].clipping YES
	seta[].htextra -1
	setp[].kickback_pic 0
	setp[].jumping_counter 0
	setp[].weapon_pos -9
	setp[].over_shoulder_on NO
	setp[].quick_kick 0
	setp[].fta 0
	
	getactor[thiscam].x x2
	getactor[thiscam].y y2
	getactor[].x x
	getactor[].y y

	subvarvar x2 x
	subvarvar y2 y
	
	getangle angvar x2 y2
	
	// getactor[].ang tempb
	set tempb angvel
	getincangle tempd angvar tempb	
	setvarvar tempe tempd
	abs tempe
	ifvarl tempd 17 ifvarg tempd -17
	setvarvar tempb angvar
	else
	{
		shiftvarr tempd 3 // 3  2
		ifvarg tempd 0 subvarvar tempb tempd else
		ifvarl tempd 0 { mulvar tempd -1 addvarvar tempb tempd }
	}
	set angvel tempb

	ifn actorvar[thiscam].initflags 0
	{
		set TMP_A goalang // player[].ang
		getincangle tempd sprite[thiscam].ang TMP_A
		ifvarl tempd 17 ifvarg tempd -17
		setvarvar TMP_A sprite[thiscam].ang
		else
		{
			shiftvarr tempd 2 // 3
			ifvarg tempd 0 subvarvar TMP_A tempd else
			ifvarl tempd 0 { mulvar tempd -1 addvarvar TMP_A tempd }
		}
		// setplayer[].ang TMP_A
		set goalang TMP_A
	}
	else
		// setplayer[].ang tempb
		set goalang tempb
		
	set oang goalang // player[].ang
	
	cos xvel tempb
	sin yvel tempb		
	shiftvarl xvel 12
	shiftvarl yvel 12
	shiftvarr tempe 2 // 1
	ifvarl tempe 8 setvar tempe 8
	divvarvar xvel tempe
	divvarvar yvel tempe
		
	getplayer[].posxv x
	getplayer[].posyv y
	shiftvarr xvel 3
	shiftvarr yvel 3
	addvarvar x xvel
	addvarvar y yvel
	setplayer[].posxv x
	setplayer[].posyv y	
	getactor[thiscam].z z2
	getactor[].z z
	ldist xydist THISACTOR thiscam
	ife xydist 0 set xydist 1
	subvarvar z2 z
	// shiftvarl z2 8
	mul z2 384
	
	ifg player[].cursectnum -1
	ifg z2 0
	{
		getflorzofslope player[].cursectnum player[].posx player[].posy temp
		sub temp z
		ifl temp 3072 set z2 0	
	}
		
	
	divvarvar z2 xydist
	subvar z2 256
	setplayer[].poszv z2
	set temp player[].cursectnum
	updatesectorz player[].posx player[].posy player[].posz temp
	ifn temp -1 setp[].cursectnum temp
	ifp ponground
	{
		getplayer[].posz z
		subvar z 1024
		setplayer[].posz z
		addvar z 8192
		setactor[].z z
	}		
	ldist xydist THISACTOR thiscam
	ifvarl xydist 1280
	{
		add SPRITELOTAG 1
		state findnextcam
	}
	ifhitspace
	{
		state endcamsequence
	}

ends

state transitioncode


	ifvarl transition 30
	ifg transition 15
	setplayer[THISACTOR].ang sprite[myspawner].ang

	ifg transition 15
	{
		setplayer[THISACTOR].posxv 0
		setplayer[THISACTOR].posyv 0
	}

	ifvare transition 30
	{
		// switch to other door
		getactorvar[myspawner].initsprite temp
		setvar spriteid 0
		whilevarn spriteid 16384
		{
			ifvarn sprite[spriteid].statnum 1024
			ifvare sprite[spriteid].picnum FAKEDOOR
			ifvarvarn myspawner spriteid
			ifvarvare actorvar[spriteid].initsprite temp
			{
				setvarvar myspawner spriteid
				setsprite THISACTOR sprite[myspawner].x sprite[myspawner].y sprite[myspawner].z
				setplayer[THISACTOR].posx sprite[myspawner].x
				setplayer[THISACTOR].posy sprite[myspawner].y
				getactor[myspawner].z z
				subvar z 8192
				setplayer[THISACTOR].posz z
				setplayer[THISACTOR].cursectnum sprite[myspawner].sectnum		
				setvar spriteid 16383
			}
			addvar spriteid 1
		}
		
		ifn myspawner -1
		ifn actorvar[myspawner].initflags 0
		{
			getav[myspawner].initflags SPRITELOTAG
			state AActivation
			set SPRITELOTAG 0
		}
	}

		
	subvar transition 1
	ifvare transition 0 setvar myspawner -1

ends

move PGROWINGPOP        // Used only as a variable

gamevar lastbobang 0 1
gamevar lastsway 1024 1

actor APLAYER MAXPLAYERHEALTH PSTAND 0 0
	
ifg fastfire 0 sub fastfire 1
ifg justblocked 0 sub justblocked 1

ife music_menupos YES
{
	setmusicposition music_position
	set music_menupos -1
}

ifn nomon 0
{
	headspritestat spriteid 1
	whilevarn spriteid -1
	{
		ife actorvar[spriteid].monstatus 1
		ifn actorvar[spriteid].team 1
		{
			seta[spriteid].picnum TRACER
			seta[spriteid].cstat 32768
		}
		nextspritestat spriteid spriteid
	}
}

ife challenge YES
ife gameover YES
ifn vendor_screen 5
ife player[].timebeforeexit 0	
{
	al THISACTOR
	setuserdef[].display_bonus_screen 0
	endofgame 2
}

ifg player[].heat_amount 180
ife aimbot_on YES
	set fastfire 2

ifge SKILL 4
{
	headspritestat spriteid 2 // 0
	whilevarn spriteid -1
	{
		switch sprite[spriteid].picnum
		case NEWTROOP case NEWTROOPSTAYPUT case NEWTROOPRUNNING case TANK
		case NEWTROOPJETPACK case NEWPIG case NEWPIGSTAYPUT case NEWPIGDIVE
		case NEWBEAST case NEWBEASTJUMP case NEWBEASTCROUCH case NEWBEASTSTAYPUT
		case OCTABRAIN case OCTABRAINSTAYPUT case ROTATEGUN case COMMANDER case COMMANDERSTAYPUT
		case NEWCOMM case LIZMAN case LIZMANSTAYPUT
		case LIZMANJUMP case LIZMANSPITTING case DRONE 
		case ARMPIG case EDFPIG case TERMINATOR case TERMINATORSTAYPUT case TERMINATORDUCKING
		case ARMYANT case ARMYANTJUMP case ARMYANTCRAWL case ARMYANTCRAWLPUT
		case BOSS2FLY case CANHEADNOARMS case CHEERBOT case CORRUPT case CRAZYLADY 
		case CYBERBEAST case DEVOURER case NEWRECON case LARGEMAN case SMALLMAN
		case LIZRANGER case LIZRANGERSTAYPUT case LIZRANGERDUCKING 
		case LIZDOG case LIZDOGSTAYPUT case LIZELITE case LIZELITECROUCH case LIZTURRET case MEGABRAIN
		case MANDOFETT case MANDOCROUCH case MECHBRAIN case MECHBRAINSTAYPUT
		case ZOMBIE case SPACEBULL case SPACEBULLSTAYPUT case SPACEBULLDUCKING 
		case NEWSENTRY case PATROLSENTRY case PIGSUV case CRONEN case SCUBATROOP case NURGLE
		ifn actorvar[spriteid].monstatus 2
		{
			set target spriteid
			state targetcheck
			ifn target -1
			{
				changespritestat spriteid 1
				seta[spriteid].httimetosleep 100
			}
		}
		break
		case BOSS1 case BOSS1STAYPUT case NEWBATLORD case NEWBATLORDSTAYPUT
		case BOSS2 case BOSS2STAYPUT
		case BOSS3 case BOSS3STAYPUT case QUEEN
		case LIZBOSS case PIGBOSS 
		case BOSS4 case BOSS4STAYPUT
		case BATBOSS case CANHEAD 
		case DRPROTON case PSPIDER
		ifn actorvar[spriteid].monstatus 2
		ifn sprite[spriteid].pal 0
		{
			set target spriteid
			state targetcheck
			ifn target -1
			{
				changespritestat spriteid 1
				seta[spriteid].httimetosleep 100
			}
		}
		break
		endswitch
		nextspritestat spriteid spriteid
	}
}

set temp NO
ifg fastfire 0 set temp YES
ife LASERMODE 0 ife player[].curr_weapon PISTOL_WEAPON
ifge player[].kickback_pic WEAPON1_TOTALTIME
ifvarand perks 2048
set temp YES

ifg fastfire 0 set temp YES

ife temp YES
ifn player[].curr_weapon KNEE_WEAPON
ifn player[].curr_weapon HANDBOMB_WEAPON
ifn player[].curr_weapon HANDREMOTE_WEAPON
{
	set B NO
	set temp 0
	ifn player[].kickback_pic 0
	{
		set B YES
		switch player[].curr_weapon
		case 1 set temp WEAPON1_FIREDELAY 
			ifl THISCLIP 1 set B NO
			break
		case 2 set temp WEAPON2_FIREDELAY break
		case 3 set temp WEAPON3_FIREDELAY break
		case 4 set temp WEAPON4_FIREDELAY break
		case 5 set temp WEAPON5_FIREDELAY break
		case 6 set temp WEAPON6_FIREDELAY break
		case 7 set temp WEAPON7_FIREDELAY break
		case 8 set temp WEAPON8_FIREDELAY break
		case 9 set temp WEAPON9_FIREDELAY break
		case 11 set temp WEAPON11_FIREDELAY break
		endswitch
	}
	
	ifg LASERFIRE 0
	{
		set B YES
		ife LASERMODE 1 // laser pistol
			set temp 2
		else
		ife LASERMODE 3 // comm gun
			set temp 10
			
		sub temp 1
		
		ife LASERFIRE temp set B NO
		else add LASERFIRE 1
	}	
	ifn m4reload 0 ife pchar 1 ife player[].curr_weapon CHAINGUN_WEAPON set B YES
	ifn uzireload 0 ife pchar 2 ife player[].curr_weapon CHAINGUN_WEAPON set B YES
	
	ifn player[].reloading 0 
	{
		set B YES
		set tempb player[].kickback_pic
		add tempb 1
		ife player[].curr_weapon PISTOL_WEAPON ifge tempb WEAPON1_RELOAD set B NO
		ife player[].curr_weapon SHOTGUN_WEAPON ifge tempb WEAPON2_RELOAD set B NO
	}
	else
	ife player[].curr_weapon PISTOL_WEAPON
	{
		ife pchar 0 ifvarand dukeupgrades[PISTOL_WEAPON] 8 set B NO
		ife pchar 1 ifvarand shellyupgrades[PISTOL_WEAPON] 8 set B NO
	}
	
	ifn temp 0
	{
		// ife player[].kickback_pic temp set B NO
		set tempb temp
		sub tempb 1
		ife player[].kickback_pic tempb set B NO
	}
	
	ife B YES
	{
		ifn player[].kickback_pic 0
		{
			getp[].kickback_pic tempb
			add tempb 1
			setp[].kickback_pic tempb
		}
		else 
		{
			ifn m4reload 0 add m4reload 1
			ifn uzireload 0 add uzireload 1
		}
	
	}

}

ife testrecent YES
{
	set temp 0
	whilevarn temp RECATTMAPS
	{
		set tempb recentmaps[temp]
		al tempb
		add temp 1
	}
	set testrecent NO
	setp[].timebeforeexit 100
}
ifn restartatt 0
{
	ifl restartatt 0 add restartatt 1 else
	ifg restartatt 0 sub restartatt 1
	
	ife restartatt 1
	{
		set restartatt 0
		startlevel VOLUME LEVEL 
		break
	}
	
	ife restartatt -1
	{
		set restartatt 0
		startlevel ATTVOLUME ATTLEVEL
		break
	}
	
	seta[].htextra -1
	setp[].timebeforeexit 0
}

getp[].weapon_pos temp
ifn temp 0 ifn temp -9 ifn temp 10
{
	ife temp 1 ifl combotime 0 set combotime 20
	
	set TMP_B player[].curr_weapon
	// ife TMP_B 0
	// {
		// ife WEAPON0_SHOOTS SAWPROJ set TMP_B 10 else
		// ifg gotsaber 0 set TMP_B 10
	// }
	// else
	ife TMP_B 10 set TMP_B 5

	ife pchar 0 set TMP_A dweaplevel[TMP_B] else
	ife pchar 2 set TMP_A wweaplevel[TMP_B] else
	set TMP_A bweaplevel[TMP_B]
	
	ifg TMP_A 0
	{
		sub temp 1
		setp[].weapon_pos temp
	}
}

ifvarn transition 0 state transitioncode // for use with fake door transports

ifg heldnear 0
{
	sub heldnear 1
	ifl player[].fta 60
	{
		setp[].fta 120 setp[].ftq 1361
	}
}
else ife player[].ftq 1361 ifg player[].fta 10 setp[].fta 10

ifn heldobject -1
	ife sprite[heldobject].statnum 1024 set heldobject -1


ifn heldobject -1
{
	set heldnear 0
	ifl heldtime 10 add heldtime 1
	setp[].weapon_pos 10
	ifvarand sprite[heldobject].cstat 1 // blocking
	{
		geta[heldobject].cstat temp
		xorvar temp 1
		seta[heldobject].cstat temp
	}
	seta[heldobject].ang player[].ang
	set x player[].posx
	add x 384
	rotatepoint player[].posx player[].posy x player[].posy player[].ang savx savy
	
	set savz player[].posz
	add savz 8704
	
	
	set z2 heldtime
	mul z2 512
	sub savz z2
	
	seta[heldobject].zvel 0
	
	setsprite heldobject savx savy savz
	
	ife heldtime 10
	{
		set temp NO
		ifvarand bits 4 set temp YES
		ifhitspace set temp YES
		ife temp YES
		{
			ifvarand bits 4
			{
				switch sprite[heldobject].picnum 
				case BOWLINGBALL
					seta[heldobject].ang player[].ang
					seta[heldobject].htextra 11
					seta[heldobject].htpicnum KNEE
					seta[heldobject].htowner player[].i
					seta[heldobject].htang player[].ang
				break
				default
					seta[heldobject].ang player[].ang
					setav[heldobject].savedvalue sprite[heldobject].statnum
					setav[heldobject].mtype sprite[heldobject].picnum
					seta[heldobject].mdflags 16
					seta[heldobject].picnum THROWNOBJECT
					changespritestat heldobject 1

				break
				endswitch
			}
			else
			ifn sprite[heldobject].picnum BOWLINGBALL
			{
				seta[heldobject].ang player[].ang
				setav[heldobject].savedvalue sprite[heldobject].statnum
				setav[heldobject].mtype sprite[heldobject].picnum
				seta[heldobject].mdflags 16
				seta[heldobject].picnum THROWNOBJECT
				changespritestat heldobject 1
				setav[heldobject].stun 1
			}
			seta[heldobject].cstat heldcstat
			set heldobject -1 set heldtime -10 
		}
	}
}
else ifl heldtime 0 add heldtime 1

// ife crawlclock YES set crawlclock totalclock

ifvarn raining 0 ifg framerate 20 state raincode

ife spectate YES
	set team 3
else
set team 1

ifn thiscam -1 { state camtrackcode break }

ifg player[].invdisptime 0
{
	setp[].invdisptime 0
	set invswitch 9
}
ifg invswitch 0 sub invswitch 1

ifg player[].cursectnum -1
	setarray psectvisited[player[].cursectnum] YES

ifn player[].cursectnum osector
{
	ifn osector -1 set menuoff NO
	getp[].cursectnum osector
}
ifn cmode 0
{
	ife cmode 1 quote 168 else
	ife cmode 2 quote 186 else
	ife cmode 3 quote 185 else
	ife cmode 4 quote 184 else
	quote 182
	setp[].jumping_counter 0
	setp[].weapon_pos -9
	ifvarand extbits 2 set cmode 0 else // BACKWARD = CANCEL
	ifvarand extbits 1 set cmode 2 else // FORWARD = HOLD POSITION
	ifvarand extbits 4 set cmode 3 else // LEFT = CHANGE COSTUME
	ifvarand extbits 8 set cmode 4 // RIGHT = SWAP CHARACTERS
	// lockplayer 10
	setp[].runspeed 0
	// ife userdef[].god NO
	// ifg sprite[].htextra 0 set cmode 0
}

ifn endlevel 0
{
	setp[].timebeforeexit endlevel
	set endlevel 0
}

ifn vrscreen_time 0
ife subtitle_time 0
ife award_time 0
{
	state in_menu
	ifg vrscreen_time 0
	{
		ife vrscreen_time 32 { stopallsounds screensound VRTRANSND }
		sub vrscreen_time 1
		set temp vrscreen_time
		modvar temp 4
		ife temp 0 add vrscreen 1
		ife vrscreen_time 0
		{
			setp[].dead_flag 0
			set pdown NO
			set ikicked 0
			ife pchar 2 action APWESSTAND else
			ife pchar 1 action APSHELLYSTAND else
			ifvarand altcostume 2 action ALTDUKESTAND else
			action PSTAND
				
			set spriteid 0
			headspritestat spriteid 1
			whilevarn spriteid -1
			{
				ife sprite[spriteid].picnum DUMCIV setav[spriteid].monstatus 2
				nextspritestat spriteid spriteid
			}
			setp[].movement_lock 0
			
			ife VOLUME 6 ife LEVEL 12
			{
				set gametype 0
				setarray keycards[LEVEL] player[].got_access
				setarray secretrooms[LEVEL] player[].secret_rooms
				setarray savelevel[LEVEL] YES
				savemapstate
				startlevel 6 matchlevel
			}
			else 
			{
				startlevel 6 12
			}
		}
	}
	ifl vrscreen_time 0
	{
		ife vrscreen_time -32 { stopallsounds screensound VRTRANSND }
		add vrscreen_time 1
		set temp vrscreen_time
		modvar temp 4
		ife temp 0 sub vrscreen 1
		
		ife vrscreen_time 0
		{
			setp[].movement_lock 0
			setp[].player_par 1
		}
	}
	getplayer[].ang oang
	getplayer[].horiz ohoriz
	break
}

// remnant of when hardest skill had faster game speed
// ife SKILL 5
// {
	// ife player[].jumping_counter 901
	// {
		// setp[].jumping_counter 0
		// setp[].poszv -2560
	// }
// }
// else
ife player[].jumping_counter 541 // 721
{
	set temp NO
	ife pchar 3 
		set temp YES
	ifn gametype 0 set temp YES
	// ifvarand inven_upgrades 8 ifg player[].boot_amount 0 set temp YES
	ife temp YES
	{
		setp[].jumping_counter 0
		getp[].poszv z 
		sub z 1792 // 644 
		setp[].poszv z
	}
}

ifvarg PLAYERONTHEBIKE 0
{
	ifvare player[THISACTOR].over_shoulder_on 1
	setplayer[THISACTOR].over_shoulder_on 0
	ifn bikerot 0 setp[].rotscrnang bikerot
}
else
ife pchar 2
ifn sector[].lotag 2
ife player[].jumping_counter 0
ifp palive
ifg glidetime 0
{
	// glide code
	ifg player[].poszv 1560
	{
		ifvarand gametips 8192
		ife subtitle_time 0
		ifg player[].falling_counter 5
		{
			set subtitle_time 60
			set subtitle_numlines 1
			set subtitle_start 1202
		}
		ifvarand bits 1
		{
			ifvarand gametips 8192 { xorvar gametips 8192 savegamevar gametips }
			setp[].jumping_toggle 1
			getp[].poszv zdist
			sub zdist 72
			mul zdist 8, div zdist 9
			ifvarand extbits 2 
			ife glideboost 0
			// ifg player[].poszv 2048
			{
				sub glidetime 15
				screensound GLIDEUP
				ifl zdist 2048 set zdist 2048
				mul zdist -3
				div zdist 2
				sub zdist 512
				ifl zdist -5120 set zdist -5120
				set glideboost 1
			}
			setp[].poszv zdist
		}
	}
	
	ifaction APWESFROZEN nullop else
	ifn player[].poszv 0
	ifvarand bits 1
	{
		sub glidetime 1
		action APWESGLIDING
		ifsound GLIDELOOP nullop else screensound GLIDELOOP
		cos xvel player[].ang
		sin yvel player[].ang
		
		ifvarand extbits 2
		{
			set B player[].poszv
			abs B
			// shiftr B 4
			div B 20
			mul xvel B
			mul yvel B
			// shiftl xvel 6
			// shiftl yvel 6
		}
		else
		{
			shiftl xvel 5
			shiftl yvel 5
		}
		add xvel player[].posxv
		add yvel player[].posyv
		setp[].posxv xvel
		setp[].posyv yvel
		
		getp[].falling_counter temp
		ifg temp 7 
		{
			sub temp 1
			sub glidetime 1
			ifvarand player[].player_par 1 { sub temp 1 sub glidetime 1 }
			setp[].falling_counter temp
		}
	}
}



ifp ponground 
{
	set glideboost 0
	set glidetime GLIDEMAX
	stopsound GLIDELOOP
	stopsound GLIDEUP
	ifaction APWESGLIDING action APWESSTAND
}

ifg shipcam -1
{
	ifg actorvar[shipcam].ikicked 0
	{
		ifactorsound THISACTOR TRAINLOOP nullop else sound TRAINLOOP
		ifg sprite[shipcam].xvel startx add startx 16 else
		ifl sprite[shipcam].xvel startx sub startx 16
		ifl startx 0 set startx 0
		setactorsoundpitch THISACTOR TRAINLOOP startx
		

	}
}

ifp ponground setp[].autostep 5120 else
	setp[].autostep 4096
	
ifgapzl 32 setp[].autostep 4096
	
getp[].cursectnum mysector
ifg mysector -1
{
	getflorzofslope mysector player[].posx player[].posy z
	getceilzofslope mysector player[].posx player[].posy z2
	sub z z2
	ifl z 6656 
	{
		setp[].autostep 4096
		
		ifp ponground
		ifn sector[mysector].floorslope 0
		{
			getp[].posz z add z 1536 setp[].posz z
			geta[].z z add z 1536 seta[].z z
		}
	}
}


ifn gametype 0 // gladiator
ife player[].ftq 102 setp[].ftq 236 // prevents "FRY YOUR ASS" quote from displaying at match end


// *** START OF LIGHTSABER CODE

ife pchar 2
{
	set sab_idle 19458
	ifg saberblood 0 sub saberblood 1
	ife VOLUME 6 ifg LEVEL 37 nullop else
	ife gotsaber 0 set gotsaber 1
	
	// holoduke quote check
	ife player[].ftq 91 setp[].ftq 1201
	
	ifsound MOVESWORD nullop else
	ife holdinteract 1
	ife saberpos 0
	ife player[].curr_weapon KNEE_WEAPON
		screensound MOVESWORD
}
else
{
	ife pchar 0
	set sab_idle 10928
	else
	set sab_idle 10940
	rand temp 5
	add sab_idle temp
}
	
ife saberpos 0 ife saberdash 0 set dashtarg -1
ifn blockang 6666
{
	// ifg sprite[].htextra 0 ife sprite[].htpicnum SHOTSPARK1
	// { seta[].htextra -1 ifl blockang 0 set blockang -9 else set blockang 9 }
	ife gotsaber 0 set blockang 6666
	ifg PLAYERONTHEBIKE 0 set blockang 6666
	ifn player[].weapon_pos 0 set blockang 6666
	ifn player[].curr_weapon KNEE_WEAPON set blockang 6666
	ifn blockang 6666
	{
		setp[].kickback_pic 0 // prevents KNEE from firing
		
		ifl blockang 0 { set saberpos 85 add blockang 1 } else
		ifg blockang 0 { set saberpos 86 sub blockang 1 }
		
		ifvarand bits 4 ifg gotsaber 1
		{
			ifg blockang -6 ifl blockang 6
			set blockang 0
		}
		ife blockang 0 
		{
			set blockang 6666 ifg gotsaber 0 
			ifn halfpoint 0 set halfpoint 0 else
			{ 
				ife pchar 2 addphealth -3
				else
				sub gotsaber 1 
				set halfpoint 1 
			}
		}
		ife blockang 6666 { set saberpos 0 setp[].kickback_pic 0 }
	}
}
ifn saberpos 0
{
	setp[].curr_weapon KNEE_WEAPON
	setp[].weapon_pos 0
	set sidekick 0
	set qk_proxy 0
	setp[].quick_kick 0
	getp[].ang savx
	getp[].horiz savy
	set angvar savx
	set y2 savy
	set safecount 0 // firing flag
	switch saberpos
	// angle 2 R to L
	case 8 add y2 16 add angvar 32 set safecount 1 break
	case 9 add y2 8 add angvar 16 ifg gotsaber 0 { shoot SABERPROJ shoot SABERPROJ } set safecount 1 break
	case 10 sub y2 8 sub angvar 16 ifg gotsaber 0 { shoot SABERPROJ shoot SABERPROJ } set safecount 1 break
	case 11 sub y2 16 sub angvar 32 set safecount 1 break
	// angle 2 L to R
	case 24 add y2 16 sub angvar 32 set safecount 1 break
	case 25 add y2 8 sub angvar 16 ifg gotsaber 0 { shoot SABERPROJ shoot SABERPROJ } set safecount 1 break
	case 26 sub y2 8 add angvar 16 ifg gotsaber 0 { shoot SABERPROJ shoot SABERPROJ } set safecount 1 break
	case 27 sub y2 16 add angvar 32 set safecount 1 break
	// downstrike
	case 39 add y2 20 set safecount 1 break
	case 40 add y2 10 set safecount 1 break
	case 41 ifg gotsaber 0 { shoot SABERPROJ shoot SABERPROJ } set safecount 1 break
	case 42 sub y2 10 set safecount 1 break
	case 43 sub y2 20 set safecount 1 break
	// angle 3 right to left
	case 52 sub y2 16 add angvar 32 set safecount 1 break
	case 53 sub y2 8 add angvar 16 ifg gotsaber 0 { shoot SABERPROJ shoot SABERPROJ } set safecount 1 break
	case 54 add y2 8 sub angvar 16 ifg gotsaber 0 { shoot SABERPROJ shoot SABERPROJ } set safecount 1 break
	case 55 add y2 16 sub angvar 32 ifg gotsaber 0 { shoot SABERPROJ shoot SABERPROJ } set safecount 1 break
	// angle 3 left to right
	case 65 sub y2 16 sub angvar 32 set safecount 1 break
	case 66 sub y2 8 sub angvar 32 ifg gotsaber 0 { shoot SABERPROJ shoot SABERPROJ } set safecount 1 break
	case 67 add y2 8 add angvar 16 ifg gotsaber 0 { shoot SABERPROJ shoot SABERPROJ } set safecount 1 break
	case 68 add y2 16 add angvar 32 set safecount 1 break
	
	endswitch
	
	/*
	case 8 case 9 case 10 case 11 // angle 2 R to L
	case 24 case 25 case 26 case 27 // angle 2 L to R
	case 39 case 40 case 41 case 42 case 43 // vertical
	case 52 case 53 case 54 case 55 // angle 3 R to L
	case 65 case 66 case 67 case 68 // angle 3 L to R
	shoot SABERPROJ shoot SABERPROJ shoot SABERPROJ
	*/
	
	ifn safecount 0
	{
		setp[].ang angvar
		setp[].horiz y2
		ifg gotsaber 0 { shoot SABERPROJ shoot SABERPROJ }
		setp[].ang savx
		setp[].horiz savy
	}
	
	setp[].kickback_pic 99 // to prevent KNEE from firing
	ifg saberpos 0
	{
		ife blockang 6666 // not blocking
		add saberpos 1
		ife saberpos 19 set saberpos 22 else
		ife saberpos 75 set saberpos 51 else
		ife saberpos 80 set saberpos 64 
		
		ifp palive
		ifvarand bits 4 // holding fire
		ifg gotsaber 0
		{
			ife saberpos 14 // finished angle 2 R to L
			{
				randvar temp 1
				ife temp 0 set saberpos 19 else
				set saberpos 76 
				ife pchar 2 sound BLADESWING else
				state sabersound
			}
			
			ife saberpos 31 // finished angle 2 L to R
			{
				randvar temp 2
				ife temp 0 set saberpos 5 else
				ife temp 1 set saberpos 39 else
				set saberpos 71
				ife pchar 2 sound BLADESWING else
				state sabersound
			}
			ife saberpos 47 // finished downward strike
			{
				randvar temp 2
				ife temp 0 set saberpos 19 else
				ife temp 1 set saberpos 76 else
				ife temp 2 set saberpos 71
				ife pchar 2 sound BLADESWING else
				state sabersound
			}
			ife saberpos 58 // completed angle 3 from R to L
			{
				ifrnd 128 set saberpos 19 else
				set saberpos 76
				ife pchar 2 sound BLADESWING else
				state sabersound
			}
			ife saberpos 71 // finished angle 3 from L to R
			{
				ifrnd 128 set saberpos 5 // defaults to
				ife pchar 2 sound BLADESWING else
				state sabersound
			}
			ifg saberpos 86 { addlogvar saberpos set saberpos 0 } 
			// failsafe
		}
		else
		{
			ife saberpos 13 mul saberpos -1
			ife saberpos 29 mul saberpos -1
			ife saberpos 33 set saberpos 5
			ife saberpos 45 set saberpos -45
			ife saberpos 58 set saberpos -13
			ife saberpos 71 set saberpos -29
		}
		
		ifg saberpos 86 { addlogvar saberpos set saberpos 0 } 
		// failsafe
		
	}
	else
	{
		// return to start
		add saberpos 1
		ife saberpos -7 set saberpos 0
		ife saberpos -24 set saberpos 0
		ife saberpos -40 set saberpos 0
		ife saberpos 0 setp[].kickback_pic 0
	}
}

add sabhitsnd 1 ifg sabhitsnd 1536 set sabhitsnd 1533
add sabclashsnd 1 ifg sabclashsnd 1540 set sabclashsnd 1537

ife player[].curr_weapon KNEE_WEAPON setp[].reloading 0

ifp palive ifn gotsaber 0 ife player[].curr_weapon KNEE_WEAPON
ife onturret -1
ife vendor_screen 0
ife subtitle_time 0 
{
	ife saberpos 0 setp[].kickback_pic 0
	setp[].knuckle_incs 0
	
	ifn player[].weapon_pos 0 
	ife slidekick 0
	ife sidekick 0
	ife jumpkick 0
	ife pdown NO
	{ 
		ife player[].weapon_pos -9 
		ifn pchar 2
			soundonce SABERON 
	}
	else
	{
		ife pchar 2 { ifactorsound THISACTOR SABERIDLE stopactorsound THISACTOR SABERIDLE  }
		else
		soundonce SABERIDLE
		ife saberpick -1 { globalsound WAR_AMBIENCE5 set saberpick 0 }
		// ife saberlight -1 state spawnsaberlight
	}
	ife lastpchar 2 
	ifn pchar lastpchar
		ife gotsaber 1 stopactorsound THISACTOR SABERIDLE
}
else
{
	stopactorsound THISACTOR SABERON
	
	ifactorsound THISACTOR SABERIDLE 
	ifp palive ife pdown NO
	ife subtitle_time 0
	ifn pchar 2
		sound SABEROFF 
		
	
	
	stopactorsound THISACTOR SABERIDLE
	
	set lastsab 0
	ife saberpick YES 
	{
		ife player[].weapon_pos -9
		{
			setp[].curr_weapon KNEE_WEAPON
			set saberpick -1
		}
		ifp palive nullop else set saberpick NO
	}
	
}
	ifn dashing 0
	{
		set saberdash 0
		ifg dashing 0
		{
			cos xvel dashang
			sin yvel dashang
			// shiftl xvel 10
			// shiftl yvel 10
			mul xvel 768
			mul yvel 768
			setp[].posxv xvel
			setp[].posyv yvel
			sub dashing 1
			ife dashing 0 set dashing -30
		}
		else ifl dashing 0 add dashing 1
	}
	ifg saberdash 0
	{
		add saberdash 1
		ife saberdash 9 { ife dashtarg -1 ifg gotsaber 0 ifn pchar 2 sub gotsaber 1 set saberdash 0 }
		
		ife saberdash 2
		{
			randvar temp 4
			ife temp 0 { set saberpos 1 ife pchar 2 sound BLADESWING else sound SABSWING1 } else
			ife temp 1 { set saberpos 15 ife pchar 2 sound BLADESWING else sound SABSWING3 } else
			ife temp 2 { set saberpos 35 ife pchar 2 sound BLADESWING else sound SABSWING4 } else
			ife temp 3 { set saberpos 47 ife pchar 2 sound BLADESWING else sound SABSWING5 } else
			{ set saberpos 60 ife pchar 2 sound BLADESWING else sound SABSWING3 }
		}
		setplayer[THISACTOR].falling_counter 0
		setplayer[THISACTOR].hard_landing 0
		cos xvel dashang
		sin z2 dashang
		ife dashtarg -1
		{
			 // shiftvarl xvel 7 shiftvarl z2 7
			 mul xvel 96 mul z2 96
		}
		else
		{
			dist xydist THISACTOR dashtarg
			shiftvarr xydist 4
			mul xvel xydist
			mul z2 xydist
		}
		ifn dashtarg -1
		{
			dist xydist THISACTOR dashtarg
			ifl xydist 480 { set xvel 0 set z2 0 }
		}
		getplayer[THISACTOR].posxv x
		getplayer[THISACTOR].posyv y
		addvarvar x xvel
		addvarvar y z2
		setplayer[THISACTOR].posxv x
		setplayer[THISACTOR].posyv y
		
		ifn dashtarg -1
		{
			geta[dashtarg].x x2
			geta[dashtarg].y y2
			sub x2 player[].posx
			sub y2 player[].posy
			getangle angvar x2 y2
			setp[].ang angvar
		}
	}
	
	ifvarand extbits 64
	ife saberdash 0
	ife dashing 0
	ife jumpkick 0
	ife slidekick 0
	ife player[].curr_weapon KNEE_WEAPON
	ife saberpos 0
	ife player[].kickback_pic 0
	ife player[].weapon_pos 0
	ifg gotsaber 0
	ifp palive
	{
		// ifvarand gametips 128 xorvar gametips 128
		set saberdash 1
		getp[].ang dashang
	}
// ** END OF LIGHTSABER CODE

ifvarand extbits 64 add holdaltfire 1 else set holdaltfire 0

ifvarn chainsparksprite -1
{
	ifvarn sprite[chainsparksprite].statnum 1024
	{
		getplayer[THISACTOR].posx savx
		getplayer[THISACTOR].posy savy
		getplayer[THISACTOR].posz savz
		getplayer[THISACTOR].cursectnum TMP_A
		
		setvarvar x2 sprite[chainsparksprite].x
		addvar x2 384
		rotatepoint sprite[chainsparksprite].x sprite[chainsparksprite].y x2 sprite[chainsparksprite].y sprite[chainsparksprite].ang x y
		set temp sprite[chainsparksprite].sectnum
		updatesector x y temp
		ifvarn temp -1
		{
			setplayer[THISACTOR].posx x
			setplayer[THISACTOR].posy y
			getactor[chainsparksprite].z z
			subvar z 2048
			setplayer[THISACTOR].posz z
			
			addvar z 8192
			getplayer[THISACTOR].i TMP_B
			setsprite TMP_B x y z
			changespritesect TMP_B temp
			setplayer[THISACTOR].cursectnum temp
			
			shoot BARRETPROJ	
			
			setplayer[THISACTOR].posx savx
			setplayer[THISACTOR].posy savy
			setplayer[THISACTOR].posz savz
			setplayer[THISACTOR].cursectnum TMP_A
			addvar savz 8192
			setsprite TMP_B savx savy savz
			changespritesect TMP_B TMP_A
		}
	}
	setvar chainsparksprite -1
}

ife cmode 0
{
	ifg gametype 0 
	{
		set temp NO
		ifvarand extbits 1 set temp YES
		ifvarand extbits 2 set temp YES
		ife temp YES
		{
			ifvarand extbits 4 setp[].runspeed FLAGRUNSPEED else
			ifvarand extbits 8 setp[].runspeed FLAGRUNSPEED else
			setp[].runspeed RUNNINGSPEED
		}
		else setp[].runspeed RUNNINGSPEED
		
	}
	else setp[].runspeed RUNNINGSPEED
	
	ife pdown YES setp[].runspeed 10240
}

ifg gamespeed 120
{
	set temp NO
	set tempb NO
	ifvarand extbits 1 set tempb YES
	ifvarand extbits 2 set tempb YES
	ifvarand extbits 4 set temp YES
	ifvarand extbits 8 set temp YES
	getp[].runspeed xvel
	ifp ponground
	{
		ife temp YES ife tempb YES
		{
			mul xvel 8 div xvel 9
		}
		else
		{
			mul xvel 9 div xvel 10
		}
	}
	ifp pshrunk nullop else
	ifl gametype 1
	setp[].runspeed xvel
	
	getp[].poszv z
	ifg z 4096 set z 4096
	setp[].poszv z
}


ife win 2 // give upgrades
{
	set healthbuff 150
	setp[].max_player_health healthbuff
	set ancients 7
	set temp 0
	whilevarn temp 400
	{
		setarray weap_owned[temp] YES
		add temp 1
	}
	set temp 0
	whilevarn temp 12
	{
		setarray dukeupgrades[temp] 1023
		setarray shellyupgrades[temp] 1023
		setarray wesupgrades[temp] 1023
		add temp 1
	}
	ife gametype 0
	{
		spawn FIRSTGUNSPRITE
		spawn SHOTGUNSPRITE
		spawn CHAINGUNSPRITE
		spawn RPGSPRITE
		spawn HBOMBAMMO
		spawn SHRINKERSPRITE
		spawn DEVISTATORSPRITE
		spawn FREEZESPRITE
		spawn GROWSPRITEICON
		spawn LASERPISTOL
		spawn BOWSPRITE
		spawn DBSPRITE
		spawn TRIPBOMBSPRITE
		spawn TRIPBOMBSPRITE
		add credits 50000
		add lastcredits 50000
		ifl plevel 4 set plevel 4
		ife attmode 0 set attmode 2
	}
	
	set es_type 5
	set es_battery -1
	set es_hp 0
	set es_delaycount 100
	set novatype 1
	screensound EQUIPSHIELD
	
	ife pchar 0 state dukeweapons else
	ife pchar 1 state shellyweapons else
	ife pchar 2 state wesweapons
	set win 0
}

ifg gametype 0
ifg gametime 0
{
	ifg gametime 1 ife win 1
	{
		set gametime 1
		set bluescore scorelimit
		add bluescore 1000
		ife gametype SURVIVAL
		{
			set spawnsleft 0
			ifg monleft 1 set monleft 1
			headspritestat spriteid 1
			whilevarn spriteid -1
			{
				ifn actorvar[spriteid].teamspawned -1
				ife actorvar[spriteid].monstatus 1
				ife actorvar[spriteid].team 0
				ifg sprite[spriteid].extra 5
					seta[spriteid].extra 5
					
				nextspritestat spriteid spriteid
			}
		}
		set win 0
	}
	ifn gametype SURVIVAL sub gametime 1
	ife unbalanced NO
	ifn gametype SURVIVAL
	{
		set temp redscore
		mul temp 7
		div temp 4
		ifl temp bluescore // IMBALANCE!
		{
			ifl gametime 7200
			{
				set unbalanced YES
				// stopallsounds
				set emp_overlay_tile 12266
				set cutcamtime player[].player_par
				ife gametype DM
				{
					screensound DOMINATION
					screensound DOMINATION
					screensound DOMINATION
					screensound DOMINATION
					set emp_overlay 60
					set subtitle_time 60
					set subtitle_start 739
					set subtitle_numlines 1
				}
				else
				{
					screensound UNBALANCED
					screensound UNBALANCED
					screensound UNBALANCED
					screensound UNBALANCED
					set emp_overlay 240
					set subtitle_time 240
					set subtitle_start 534
					set subtitle_numlines 2
				}
				
			}
			else
			{
				set tempb bluescore
				// mul tempb 5
				// div tempb 3
				mul tempb 2
				ifg tempb scorelimit
				{
					set unbalanced YES
					// stopallsounds
					set emp_overlay_tile 12266
					set cutcamtime player[].player_par
					ife gametype DM
					{
						screensound DOMINATION
						screensound DOMINATION
						screensound DOMINATION
						screensound DOMINATION
						set emp_overlay 60
						set subtitle_time 60
						set subtitle_start 739
						set subtitle_numlines 1
					}
					else
					{
						screensound UNBALANCED
						screensound UNBALANCED
						screensound UNBALANCED
						screensound UNBALANCED
						set emp_overlay 240
						set subtitle_time 240
						set subtitle_start 534
						set subtitle_numlines 2
					}
				}
			}
		}
		
		// ifhitspace
		// ife thiscam -1
		// {
			// set unbalanced YES
			// globalsound UNBALANCED
			// set emp_overlay_tile 12266
			// set emp_overlay 240
			// set cutcamtime player[].player_par
			// set subtitle_time 240
			// set subtitle_start 534
			// set subtitle_numlines 2
		// }
	}
}

ife gametime 0 ifg gametype 0
{
	// end game or overtime
	ifn redscore bluescore
	{
		setp[].timebeforeexit 180 set endgametime gametime set gametime -1
	}
}

ife gametype SURVIVAL state sethordeval else
ife gametype -1 state sethordeval else
ife gametype DM state sethordeval

state spawnprotectcode
ife pdown YES { set monstatus 2 set ppowcount 0 set prating 0 }
else
{
	ifp palive
	{
		ifspritepal 33 
		ife spawnprotect 0
		{
			ife pchar 0 seta[].pal dukepal
			ife pchar 1 seta[].pal shellypal
			ife pchar 2 seta[].pal wespal
		}
		set mlevel plevel
		set temp player[].player_par
		modvar temp 15
		ife temp 0
		{
			// if score is high enough, add 1 to ppowcount
			set prating 0
			
			ife player[].gotweapon PISTOL_WEAPON YES
			{
				set tempb player[].ammo_amount PISTOL_WEAPON
				div tempb 3, ifg tempb 50 set tempb 50 add prating tempb
				add prating LASERAMMO
			}
			ife player[].gotweapon SHOTGUN_WEAPON YES
			{
				set tempb player[].ammo_amount SHOTGUN_WEAPON
				ifg tempb 51 set tempb 51
				add prating tempb
			}
			ife player[].gotweapon CHAINGUN_WEAPON YES
			{
				set tempb player[].ammo_amount CHAINGUN_WEAPON
				div tempb 3, ifg tempb 50 set tempb 50 add prating tempb
			}
			ife player[].gotweapon RPG_WEAPON YES
			{
				set tempb player[].ammo_amount RPG_WEAPON
				mul tempb 3, ifg tempb 50 set tempb 50 add prating tempb
			}
			set tempb player[].ammo_amount HANDBOMB_WEAPON
			mul tempb 2
			ifg tempb 50 set tempb 50
			add prating tempb
			ife player[].gotweapon SHRINKER_WEAPON YES
			{
				set tempb player[].ammo_amount SHRINKER_WEAPON
				mul tempb 2, ifg tempb 50 set tempb 50 add prating tempb
				add prating COMMAMMO
			}
			ife player[].gotweapon DEVISTATOR_WEAPON YES
			{
				set tempb player[].ammo_amount DEVISTATOR_WEAPON
				add prating tempb
				ifg tempb 50 set tempb 50
				add prating railgunammo
			}
			ife player[].gotweapon TRIPBOMB_WEAPON YES
			{
				set tempb player[].ammo_amount TRIPBOMB_WEAPON
				mul tempb 3, ifg tempb 50 set tempb 50 add prating tempb
			}
			ife player[].gotweapon FREEZE_WEAPON YES
			{
				set tempb player[].ammo_amount FREEZE_WEAPON
				add prating tempb
				ifg tempb 50 set tempb 50
				add prating plasmammo
			}
			ife player[].gotweapon GROW_WEAPON YES
			{
				set tempb player[].ammo_amount GROW_WEAPON
				ifg tempb 50 set tempb 50
				add prating tempb
			}
			ifg gotsaber 0
			{
				set tempb gotsaber
				ifg tempb 30 set tempb 30
				add prating tempb
			}
			ifg pchar 0 ifl pchar 3
			ifvarand gotbow 1
			ifg arrows 0
			{
				set tempb arrows
				ifg tempb 50 set tempb 50
				add prating tempb
			}
			ife pchar 0
			ifvarand gotDB 1
			{
				set tempb dbammo
				ifg tempb 50 set tempb 50
				add prating tempb
			}
			ifg prating 500 set prating 500 // max from ammo
			
			set tempb sprite[].extra
			mul tempb 4
			add prating tempb
			
			set tempb player[].firstaid_amount
			mul tempb 3 div tempb 2
			add prating tempb
			
			set tempb player[].max_player_health
			mul tempb 3
			sub prating tempb
			
			ife es_type 0 set tempb player[].shield_amount else
			{
				set tempb es_hp
				add tempb es_battery
				div tempb 2
			}
			ifg tempb 150 set tempb 150
			add prating tempb
			
			set TMP_B 9000
			ifg plevel 3
			{
				set tempb plevel
				mul tempb 9
				sub TMP_B tempb
			}
			
			ifg prating TMP_B
			ifge SKILL 3
			add ppowcount 1
			else set ppowcount 0
		}
		set monstatus 1
		// ife mysignpost -1 state spawnmysignpost
		ife gametype 0 ifge sprite[].extra 75
		ifp ponground
		ife AUTOSAVE YES
		ife checkpoints NO
		{
			set temp player[].player_par
			sub temp lastsave
			ifg temp 5400
			{
				set spriteid player[].i
				setav[spriteid].spawnprotect 90
				state autosave
			}
		}
	}
	else ifn sprite[].pal 1 set monstatus 2
}

ifl gametype 1
ifn myshelly -1
{
	set x trueoldx
	set y trueoldy
	sub x player[].posx
	mul x x
	sub y player[].posy
	mul y y
	add x y
	sqrt x x
	ifg x 4096
	ife actorvar[myshelly].monstatus 30
	{
		setsprite myshelly player[].posx player[].posy player[].posz
		setav[myshelly].crumbwait 0
	}
	// also move them when in a sector where floor or ceiiling could move
	// ifn sprite[myshelly].sectnum player[].cursectnum
	// {
		// headspritesect spriteid player[].cursectnum
		// whilevarn spriteid -1
		// {
			// ife sprite[spriteid].statnum 3
			// ifge sprite[spriteid].lotag 31 ifle sprite[spriteid].lotag 32
			// {
				// setsprite myshelly player[].posx player[].posy player[].posz
				// setav[myshelly].crumbwait 0
				// set spriteid -1
			// }
			// ifn spriteid -1
			// nextspritesect spriteid spriteid
		// }
	// }
}
getp[].posx trueoldx
getp[].posy trueoldy

state gladiatorstuff

// movement tech block
/*
set temp NO
ifinwater nullop else
ife slidekick 0
{
	ifg player[].kickback_pic 0 ifl player[].kickback_pic 13
	ifn player[].curr_weapon HANDBOMB_WEAPON
	ifn player[].curr_weapon HANDREMOTE_WEAPON
	set temp YES
	else
	ifn LASERFIRE 0 set temp YES
	
	getinput[].fvel x2
	getinput[].svel y2
	ifle x2 1800 ifge x2 -1800
	ifle y2 1800 ifge y2 -1800
		set temp NO
}
ife temp YES
{
	set x RUNNINGSPEED
	shiftr x 3
	set x2 RUNNINGSPEED
	sub x2 x
	setp[].runspeed x2
}
else setp[].runspeed RUNNINGSPEED
*/

ifg padmove 0
{
	cos xvel padang
    sin yvel padang
     
	mul xvel jumpadxvel
	mul yvel jumpadxvel
    setplayer[THISACTOR].posxv xvel
	setplayer[THISACTOR].posyv yvel
	
	setplayer[THISACTOR].falling_counter 0
	ife pchar 0
	{
		ifaction PJUMPING nullop else action PJUMPING
	}
	ife pchar 1
	{
		ifaction APSHELLYJUMPING nullop else action APSHELLYJUMPING
	}
	ife pchar 2
	{
		ifaction APWESGLIDING nullop else
		ifaction APWESJUMPING nullop else action APWESJUMPING
	}
	
	sub padmove 1
	ife padmove 0 setp[].movement_lock 0
}
ifp ponground set nofalldamage 0
ifn nofalldamage 0 setp[].falling_counter 0
ife globalnofall YES setp[].falling_counter 0


ifg cutcamtime 0
{
	ifn cutcam -1
	{
		setp[].kickback_pic 0
		setp[].weapon_pos -9
		setp[].quick_kick 0
		setp[].over_shoulder_on YES
		ife player[].ftq 80 setp[].fta 0
		stopactorsound THISACTOR DUKE_GRUNT
		setp[].knuckle_incs 0
		setp[].horiz 100
		seta[].htextra -1
		lockplayer 10
		setp[].posx sprite[cutcam].x
		setp[].posy sprite[cutcam].y
		setp[].jumping_counter 0
	}
	else ifg emp_overlay 0 // braccus overlay feature
	{
		set tempb player[].player_par
		sub tempb cutcamtime
		ifg tempb 1 // advance frame
		ifl emp_overlay_tile 12270
		{
			add emp_overlay_tile 1
			ifg emp_overlay_tile 12269 set emp_overlay_tile 12266
			set cutcamtime player[].player_par
		}

		sub emp_overlay 1
		ife emp_overlay 0
			set cutcamtime 0
	}
}

set temp NO
ifvarand perks 4 set temp YES
ifg fastfire 0 set temp YES
// ife pchar 2 set temp YES

ife temp YES
{
	ifg qk_proxy 0
	{
		switch qk_proxy
		case 15 case 13 case 11 case 9 case 4 // case 2
			sub qk_proxy 1
		break
		endswitch
		
		sub qk_proxy 1
		ife qk_proxy 9 
		{
			shoot KNEE
			ifn zombieonplayer -1
			{
				seta[zombieonplayer].htpicnum KNEE
				seta[zombieonplayer].htextra KNEE_WEAPON_STRENGTH
				seta[zombieonplayer].htowner THISACTOR
				seta[zombieonplayer].htang player[].ang
			}
		}
	}
	else
	ifn player[].quick_kick 0
	{
		switch player[].quick_kick
		case 14 case 12 case 10 case 8 case 4 // case 2
			getp[].quick_kick temp
			sub temp 1
			setp[].quick_kick temp
		break
		case 9
			ifn zombieonplayer -1
			{
				seta[zombieonplayer].htpicnum KNEE
				seta[zombieonplayer].htextra KNEE_WEAPON_STRENGTH
				seta[zombieonplayer].htowner THISACTOR
				seta[zombieonplayer].htang player[].ang
			}
		break
		endswitch
	}
	else
	ife LASERMODE 0
	ife player[].curr_weapon 0
	ifn player[].kickback_pic 0
	{
		switch player[].kickback_pic
		case 9 case 7 case 3 case 1
			getp[].kickback_pic temp
			add temp 1
			setp[].kickback_pic temp
		break
		endswitch
	}
}
else
ifg qk_proxy 0
{
	sub qk_proxy 1
	ife qk_proxy 9 
	{
		shoot KNEE
		ifn zombieonplayer -1
		{
			seta[zombieonplayer].htpicnum KNEE
			seta[zombieonplayer].htextra KNEE_WEAPON_STRENGTH
			seta[zombieonplayer].htowner THISACTOR
			seta[zombieonplayer].htang player[].ang
		}
	}
}

ifg juice_pos 0
{
	ifhitspace ifn babesaved -1 add juice_pos 1
	else { ifg juice_pos 30 set juice_pos 30 sub juice_pos 1 }
	ifge juice_pos 50 set juice_pos 50
	ifge player[].weapon_pos 0 setp[].weapon_pos -9
	
}
ife babesaved -1 ife player[].ftq 1114 setp[].fta 0

ifg musicwait 0
{
	sub musicwait 1
	ife musicwait 0 
	{
		ife VOLUME 4 ife LEVEL 4
		{
			starttrack 8
		}
		else
		{
			// starttrackvar LEVEL
			getuserdef[].music_episode mtype
			getuserdef[].music_level tempb
			starttrackslot mtype tempb
		}
	}
}

// ifhitspace ife pchar 2 ife idleanim 0 set idleanim 1
ife pchar 2 
{
	ifn sidekick 0 set idleanim 0
	ifn qk_proxy 0 set idleanim 0
}
ifg idleanim 0
{
	add idleanim 1
	
	ifn pchar 2
	{
	ifge idleanim 69 // nice!
	set idleanim 0
	}
	else
	{
		setp[].crack_time 600
		stopactorsound THISACTOR SAWBLADE_LOOP
		ifvarand idleanim 1
		ifg idleanim 30 ifl idleanim 320
		{
			ifg idleanim 110 ifl idleanim 180 nullop else
			{
				set temp westhumbs
				ifrnd 128
				{
					rand westhumbs 3
					ifn temp westhumbs screensound PRESSBUTTON
				}
			}
		}
		ifge idleanim 329
		set idleanim 0
	}

	
	ifg player[].weapon_pos 8 setp[].weapon_pos 11 else
	ife player[].weapon_pos 0 setp[].weapon_pos 11
	
	ifn player[].fist_incs 0 set idleanim 0
	ifvarand bits 4 { set idleanim 0 setp[].weapon_pos 3 }
	ifvarand extbits 64 { set idleanim 0 setp[].weapon_pos 3 }
	// ifhitspace set idleanim 0
	ifn player[].kickback_pic 0 set idleanim 0
	
	ife idleanim 50
	ifn pchar 2
	{
		espawn BIGSMOKE 
		
		getp[].posx x2
		add x2 160
		getp[].ang angvar, add angvar 48
		getp[].posz z add z 1024
		getp[].horiz zdist
		sub zdist 100
		shiftl zdist 5
		sub z zdist
		rotatepoint player[].posx player[].posy x2 player[].posy angvar x y
		setsprite RETURN x y z
		seta[RETURN].xrepeat 10
		seta[RETURN].yrepeat 10
	}
	
}

ifhitspace nullop else
ife player[].movement_lock 0
ifl player[].crack_time 550
ifg player[].crack_time 400
ife player[].tipincs 0
ifl PLAYERONTHEBIKE 1
ifn sector[].lotag 2
ifrnd 4
ife idleanim 0
{
	ife pchar 2 ifrnd 128 nullop else
	{
	set idleanim 1
	setp[].weapon_pos -1
	}
}


ifsound B_AFK2
{
	ifn extbits 0 stopsound B_AFK2
	ifn bits 8388640 stopsound B_AFK2
}
ifsound B_AFK1
{
	ifn extbits 0 stopsound B_AFK1
	ifn bits 8388640 stopsound B_AFK1
}
ife pchar 2
{
	state wesactions
	ife cameratoggle YES // using a camera
	{
		cstat 257
		set cameratoggle NO
	}
	ifn sector[].lotag 2 ife player[].ftq 89 setp[].ftq 1200
}
else
ife pchar 1 
{
	state shellyactions
	ife cameratoggle YES // using a camera
	{
		cstat 257
		set cameratoggle NO
	}
}
else
{
	ifn myvictim -1
	{
		ife myvictim -2 // friendly fire
		ifrnd 64
		{
			ifsound DUKE_FRIEND_F1 nullop else
			ifsound DUKE_FRIEND_F2 nullop else
			{
				ifrnd 128 globalsound DUKE_FRIEND_F1 else
				globalsound DUKE_FRIEND_F2
				
			}
		}
		set myvictim -1
	}
}

ifg switchboost 0 state switchboostcode

ife player[].ammo_amount PISTOL_WEAPON 0 
	set THISCLIP PISTOLCLIP
else
ife player[].curr_weapon PISTOL_WEAPON
ife LASERMODE 0
ifl player[].ammo_amount PISTOL_WEAPON THISCLIP set THISCLIP player[].ammo_amount PISTOL_WEAPON

ifg THISCLIP PISTOLCLIP set THISCLIP PISTOLCLIP

ife player[].curr_weapon PISTOL_WEAPON
ife LASERMODE NO getp[].ammo_amount PISTOL_WEAPON pistolammo



ifn pchar lastpchar
{
	set idleanim 0
	ife pchar 0 
	{
		setp[].palookup dukepal
		setuserdef[].color dukepal
		savegamevar shellypal
		state dukeweapons 
		action PSTAND 
		ifg vendor_screen 4 
		{ 
			set temp lastpchar
			mul temp 10
			sub vendor_screen temp
			set cursorx 160 set cursory 100 
		}
	}
	else
	ife pchar 1 
	{ 
		setp[].palookup shellypal
		setuserdef[].color shellypal
		savegamevar shellypal
		state shellyweapons
		action APSHELLYSTAND 
		ifg vendor_screen 4 
		{ 
			set temp lastpchar
			sub temp pchar
			mul temp 10
			sub vendor_screen temp
			
			set cursorx 160 set cursory 100 
		}
		// 0 = regular; 1 = burning; 2 = explosive; 3 = multi; 4 = freeze; 5 = spy; 6 = electric
		// 7 = blood; 8 = radioactive
		ife arrowtype 8 set arrowtype 2
		ife arrowtype 7 set arrowtype 0
		ife arrowtype 1 set arrowtype 6
		ife arrowtype 4 set arrowtype 6
		
		ife player[].curr_weapon SHOTGUN_WEAPON
		ife zoomin YES
		{
			set zoomin NO
			set zoomcount -6
			setp[].auto_aim autoaim
		}
	}
	else
	ife pchar 2
	{
		setp[].palookup wespal
		setuserdef[].color wespal
		savegamevar wespal
		state wesweapons
		action APWESSTAND 
		ifg vendor_screen 4 
		{ 
			set temp lastpchar
			sub temp pchar
			mul temp 10
			sub vendor_screen temp
			set cursorx 160 set cursory 100 
		}
		
		ife gotsaw YES
		{
			state sawoff
			ifg sawammo 0
			{
				espawn SAWSPRITE
				setsprite RETURN player[].posx player[].posy player[].posz
				seta[RETURN].ang player[].ang
				setav[RETURN].initsprite sawammo
				set sawammo 0
				set gotsaw NO
			}
		}
		
		// 0 = regular; 1 = burning; 2 = explosive; 3 = multi; 4 = freeze; 5 = spy; 6 = electric
		// 7 = blood; 8 = radioactive
		ife arrowtype 2 set arrowtype 8
		ife arrowtype 0 set arrowtype 7
		ife arrowtype 6 set arrowtype 4
		
		getp[].ammo_amount SHRINKER_WEAPON temp
		mul temp 4
		setp[].ammo_amount SHRINKER_WEAPON temp
		
		getp[].ammo_amount GROW_WEAPON temp
		mul temp 2
		setp[].ammo_amount GROW_WEAPON temp
		
	}
	ife player[].scuba_amount 1
	{
		setp[].scuba_amount 0
		ife player[].inven_icon 6 setp[].inven_icon 0
	}
	ife lastpchar 2 
	{
		ife gotsaber 1 set gotsaber 0
		getp[].ammo_amount SHRINKER_WEAPON temp
		div temp 4
		setp[].ammo_amount SHRINKER_WEAPON temp
		
		getp[].ammo_amount GROW_WEAPON temp
		div temp 2
		setp[].ammo_amount GROW_WEAPON temp
	}
	
	set lastpchar pchar
	geta[].mdflags temp
	orvar temp 16
	seta[].mdflags temp
	

	// wake up items so they have correct animations
	headspritestat spriteid 0
	whilevarn spriteid -1
	{
		ife actorvar[spriteid].monstatus 100 // item
		{
			changespritestat spriteid 1
		}
		nextspritestat spriteid spriteid
	}
	headspritestat spriteid 2
	whilevarn spriteid -1
	{
		ife actorvar[spriteid].monstatus 100 // item
		{
			changespritestat spriteid 1
		}
		nextspritestat spriteid spriteid
	}

}
// else
// ifn player[].palookup 255
// {
		// ife pchar 2
			// set wespal player[].palookup
		// else
		// ife pchar 0 
			// set dukepal player[].palookup 
		// else
		// ife pchar 1
			// set shellypal player[].palookup
// }


ifn zombieonplayer -1
{
	set sidekick 0
	ifn sprite[zombieonplayer].statnum 1 set zombieonplayer -1
	
	ifn sprite[zombieonplayer].picnum ZOMBIE 
		ifn sprite[zombieonplayer].picnum CORRUPT
			ifn sprite[zombieonplayer].picnum NEWBEAST
				ifn sprite[zombieonplayer].picnum TERMINATOR
	set zombieonplayer -1
	
	ifl sprite[zombieonplayer].extra 1 set zombieonplayer -1
	ifn zombieonplayer -1
	{
		add zombiecount 1
		ifg zombiecount 5
		{
			set zombiecount 0
			ife sprite[zombieonplayer].picnum CORRUPT
			{
				ifrnd 128 
				{
					state playerpainsounds
					seta[].htextra 9
					seta[].htpicnum SHOTSPARK1
					seta[].htowner zombieonplayer
					seta[].htang sprite[zombieonplayer].ang
					palfrom 24 63
				}
			}
			else
			ife sprite[zombieonplayer].picnum NEWBEAST
			{
				add zombietile 1
				
				ife zombietile 4719
				{
					state playerpainsounds
					seta[].htextra 50
					seta[].htpicnum SHOTSPARK1
					seta[].htowner zombieonplayer
					seta[].htang sprite[zombieonplayer].ang
					palfrom 50 63
					screensound BEASTBITESND
				}
				ife zombietile 4721
				{
					set zombieonplayer -1
					set zombiecount -30
				}
			}
			else ife sprite[zombieonplayer].picnum ZOMBIE
			{
				add zombietile 1
				ife zombietile 8839 screensound Z_BITE2
				
				ife zombietile 8841
				{
					state playerpainsounds
					seta[].htextra 13
					seta[].htpicnum SHOTSPARK1
					seta[].htowner zombieonplayer
					seta[].htang sprite[zombieonplayer].ang
					palfrom 24 63
				}
				ife zombietile 8844
				{
					state playerpainsounds
					seta[].htextra 11
					seta[].htpicnum SHOTSPARK1
					seta[].htowner zombieonplayer
					seta[].htang sprite[zombieonplayer].ang
					palfrom 24 63
				}
				ifg zombietile 8844 
				{
					set zombietile 8836 
					screensound Z_BITESTART
				}
			}
			
		}
	}
	else
	{
		set zombiecount -30
		set zombietile ZOMBIEBITE
	}
}
else
{
	ifg zombiecount 0 set zombiecount 0
	set zombietile ZOMBIEBITE
	set zombieflip NO
	stopsound Z_BITESTART
	stopsound Z_BITE2
	ifl zombiecount 0 add zombiecount 1
}

ifaction PFROZEN nullop else
ifaction ALTDUKEFROZEN nullop else
ifaction APSHELLYFROZEN nullop else
ifaction APWESFROZEN nullop else
{
	getp[].pycount temp
	ifn temp lastbobang
	{
		ifg temp lastbobang
		{
			sub temp lastbobang
			mul temp 3
			shiftr temp 1
			add temp lastbobang
			setp[].pycount temp
		}
		set lastbobang player[].pycount
	}


	ifn player[].weapon_sway 1024
	{
		getp[].posxv x
		abs x
		shiftr x 14
		getp[].posyv y
		abs y
		shiftr y 14
		add x y
		mul x 2 div x 3
		add lastsway x
		// setp[].weapon_sway lastsway
	}
	else set lastsway 0
}

ifg horizfall 0
{
	getp[].horiz temp
	sub temp 1
	sub horizfall 1
	setp[].horiz temp
	ifle player[].horiz savedhoriz set horizfall 0
}

ifg targetwait 0 sub targetwait 1

ifn pchar 2
ife gotsaw YES ifg sawammo 0
ifn WEAPON0_SHOOTS SAWPROJ state sawon

ife gotsaw NO ife WEAPON0_SHOOTS SAWPROJ state sawoff

// LASER TURRET FIRING CODE
ifn onturret -1
{
	ife countvarc YES
	{
		ife sprite[onturret].picnum EMPTYEDFTURRET
		{
			shoot SHOTSPARK1
			sound MINIFIRE
			spawn SHELL
		}
		else
		{
			setprojectile[GREENLASER].offset 14354
			setprojectile[GREENLASER].extra 24
			shoot GREENLASER
			setprojectile[GREENLASER].offset -160
			setprojectile[GREENLASER].extra 16
			sound TERMLASER
		}
		set countvarc NO
	}
}

ife player[].curr_weapon PISTOL_WEAPON
{
	ife player[].kickback_pic WEAPON1_FIREDELAY
	{
		stopactorsound THISACTOR WEAPON1_FIRESOUND
		espawn SOUNDPLATE
		setav[RETURN].SPRITELOTAG WEAPON1_FIRESOUND
		setav[RETURN].mtype 1
	}
	ife player[].reloading YES
	{
		set temp NO
		ifg fastfire 0 set temp YES
		ifvarand perks 2048 set temp YES
		ife temp YES
		{
			ifge player[].kickback_pic 25
			ifle player[].kickback_pic 26
			
				set THISCLIP PISTOLCLIP
		}
		else
		ife player[].kickback_pic 26
		set THISCLIP PISTOLCLIP
	}
	
	// hack to prevent firing at level start
	// this really sucks
	set temp NO
	ife pchar 0 ifvarand dukeupgrades[PISTOL_WEAPON] 4 ifvarand dukeupgrades[PISTOL_WEAPON] 8 set temp YES
	ife pchar 1 ifvarand shellyupgrades[PISTOL_WEAPON] 4 ifvarand shellyupgrades[PISTOL_WEAPON] 8 set temp YES
	ife temp YES
	{
		ifl player[].player_par 23 setp[].kickback_pic 0
		// also sound hack
		ifsound INSERT_CLIP { stopsound INSERT_CLIP sound GLOCKMAGIN }
		ifsound DEAGLE_CLIPIN { stopsound DEAGLE_CLIPIN sound GLOCKMAGIN }
	}

	set tempb WEAPON1_TOTALTIME
	sub tempb 1
	ife player[].kickback_pic tempb
	ifl THISCLIP 1
	{
		ifg player[].ammo_amount PISTOL_WEAPON 1
		{
			ife pchar 2 setp[].kickback_pic 9
			else
			ife pchar 1 setp[].kickback_pic 10 else
			setplayer[THISACTOR].kickback_pic 7
			setplayer[THISACTOR].reloading YES
			ife pchar 0 ifvarand dukeupgrades[PISTOL_WEAPON] 8 sound GLOCKMAGOUT else
			ife pchar 1 ifvarand shellyupgrades[PISTOL_WEAPON] 8 sound GLOCKMAGOUT else
			ifn pchar 0 sound DEAGLE_CLIPOUT else
			sound EJECT_CLIP
		}
		else
		{
			setp[].kickback_pic 0
			setp[].weapon_pos -1
		}
	}
	
	ife pchar 0
	ifp palive
	{
		ifvarand dukeupgrades[PISTOL_WEAPON] 4
		{
			ifg player[].player_par 5
			ife player[].kickback_pic 5
			{
				ifp pshrunk setp[].kickback_pic 0
				
				ifvarand dukeupgrades[PISTOL_WEAPON] 8
				shoot SHOTSPARK1
				else
				{
					shoot SHOTGUN
					// sound NEW_PISTOL_FIRE
					espawn SOUNDPLATE
					setav[RETURN].mtype 1
					setav[RETURN].SPRITELOTAG NEW_PISTOL_FIRE
				}
			}
			ife player[].kickback_pic 30 sound EJECT_CLIP
			ife player[].kickback_pic 42 sound INSERT_CLIP
		}
		ifvarand dukeupgrades[PISTOL_WEAPON] 8
		{
			ife player[].reloading YES
			{
				ifsound EJECT_CLIP { stopsound EJECT_CLIP sound GLOCKMAGOUT }
				// ifsound INSERT_CLIP { stopsound INSERT_CLIP sound GLOCKMAGIN }
				ife player[].kickback_pic 25 sound GLOCKMAGIN
				else
				{
					set temp NO
					ifg fastfire 0 set temp YES
					ifvarand perks 2048 set temp YES
					
					ife temp YES ife player[].kickback_pic 55 sound GLOCKMAGIN
				}
			}
			ife player[].kickback_pic 3
			{
				ifg fastfire 0
				ifg player[].ammo_amount PISTOL_WEAPON 1
				{
					shoot SHOTSPARK1
					sub THISCLIP 1
					getp[].ammo_amount PISTOL_WEAPON temp
					sub temp 1
					setp[].ammo_amount PISTOL_WEAPON temp
				}
				rand tempb 2
				add tempb 3
				set horizfall tempb
				set savedhoriz player[].horiz
				add tempb player[].horiz
				setp[].horiz tempb
			}
		}
	}
	
	ife pchar 1
	ifp palive
	{
		ife player[].kickback_pic 3
		{
			ifvarand shellyupgrades[PISTOL_WEAPON] 8
			{
				ifg fastfire 0
				ifg player[].ammo_amount PISTOL_WEAPON 1
				{
					shoot SHOTSPARK1
					sub THISCLIP 1
					getp[].ammo_amount PISTOL_WEAPON temp
					sub temp 1
					setp[].ammo_amount PISTOL_WEAPON temp
				}
				rand tempb 2
				add tempb 3
			}
			else
			{
				rand tempb 2
				add tempb 4
			}
			set horizfall tempb
			set savedhoriz player[].horiz
			add tempb player[].horiz
			setp[].horiz tempb
		}
		ifvarand shellyupgrades[PISTOL_WEAPON] 8 
		{
			ifvarand shellyupgrades[PISTOL_WEAPON] 4
			{
				ifg player[].player_par 5
				ife player[].kickback_pic 5
					shoot SHOTSPARK1
			}
		}
		else
		ifvarand shellyupgrades[PISTOL_WEAPON] 4
		{
			ifg player[].player_par 6
			ife player[].kickback_pic 6
			{
				shoot DEAGLEBULLET
				// sound DEAGLE_FIRE
				espawn SOUNDPLATE
				setav[RETURN].mtype 1
				setav[RETURN].SPRITELOTAG DEAGLE_FIRE
				rand tempb 2
				add tempb 4
				set horizfall tempb
				set savedhoriz player[].horiz
				add tempb player[].horiz
				setp[].horiz tempb
			}
		}
		ife player[].kickback_pic 22 // 27
		{
			ifvarand shellyupgrades[PISTOL_WEAPON] 8
			sound GLOCKMAGIN else
			sound DEAGLE_CLIPIN
		}
		
		
		
		ifvarand shellyupgrades[PISTOL_WEAPON] 8 
		{
			set temp NO
			ifg fastfire 0 set temp YES
			ifvarand perks 2048 set temp YES
			ife temp YES ife player[].kickback_pic 33 sound GLOCKMAGOUT
			else ife player[].kickback_pic 34 sound GLOCKMAGOUT
			
			set temp NO
			ifg fastfire 0 set temp YES
			ifvarand perks 2048 set temp YES
			ife temp YES ife player[].kickback_pic 53 sound GLOCKMAGIN
			else ife player[].kickback_pic 54 sound GLOCKMAGIN
		}
		else ife player[].reloading YES
		{
			ife player[].kickback_pic 34 sound DEAGLE_CLIPOUT
			set temp NO
			ifg fastfire 0 set temp YES
			ifvarand perks 2048 set temp YES
			ife temp YES ife player[].kickback_pic 46 sound DEAGLE_CLIPIN
			else
			ife player[].kickback_pic 47 sound DEAGLE_CLIPIN
		}
		
	}
	
	ife pchar 2
	ifp palive
	{
		ife player[].kickback_pic 3
		{
			rand tempb 2
			add tempb 3
			set horizfall tempb
			set savedhoriz player[].horiz
			add tempb player[].horiz
			setp[].horiz tempb
		}
		
		ife player[].reloading YES
		{
			set temp NO
			ifg fastfire 0 ife player[].kickback_pic 15 set temp YES
			else
			ifvarand perks 2048 ife player[].kickback_pic 15 set temp YES
			else
			ife player[].kickback_pic 16 set temp YES
			ife temp YES
			{
				set TMP_A THISCLIP
				set TMP_B PISTOLCLIP
				whilevarvarn TMP_A TMP_B
				{
					spawn SHELL
					add TMP_A 1
					ifg TMP_A TMP_B set TMP_A TMP_B
				}
				// spawn SHELL spawn SHELL spawn SHELL
				// spawn SHELL spawn SHELL spawn SHELL
				// spawn SHELL spawn SHELL
				ifvarand wesupgrades[PISTOL_WEAPON] 4
				{
					// spawn SHELL spawn SHELL spawn SHELL
					// spawn SHELL spawn SHELL spawn SHELL
					// spawn SHELL spawn SHELL
					set TMP_A THISCLIP
					set TMP_B PISTOLCLIP
					whilevarvarn TMP_A TMP_B
					{
						spawn SHELL
						add TMP_A 1
						ifg TMP_A TMP_B set TMP_A TMP_B
					}		
				}
			}
		}
		ifsound EJECT_CLIP { stopsound EJECT_CLIP sound GLOCKMAGIN }
		
		ifvarand wesupgrades[PISTOL_WEAPON] 4
		{
			ifg player[].player_par 6
			ife player[].kickback_pic 7 // 6
			ifg player[].ammo_amount PISTOL_WEAPON 0
			{
				getp[].ammo_amount PISTOL_WEAPON B
				sub B 1, ifl B 0 set B 0
				sub pistolammo 1
				setp[].ammo_amount PISTOL_WEAPON B
				shoot WESBULLET
				// sound DEAGLE_FIRE
				espawn SOUNDPLATE
				setav[RETURN].mtype 1
				setav[RETURN].SPRITELOTAG REVOLVER_FIRE
				rand tempb 2
				add tempb 3
				set horizfall tempb
				set savedhoriz player[].horiz
				add tempb player[].horiz
				setp[].horiz tempb
			}
		}
		
		
		// ife player[].kickback_pic 30 sound DEAGLE_CLIPOUT

		
	}
	
	ifg LASERAMMO 4
	ife LASERMODE YES
	ife LASERFIRE 0
	ifvarand extbits 64
	{
		ife LASERCHARGE 0 sound CHARGESND
		ifg LASERCHARGE 32 soundonce CHARGEHOLD
		ifl LASERCHARGE 52 
		add LASERCHARGE 1
		ifg fastfire 0 add LASERCHARGE 1
		
	}
	else
	{
		stopsound CHARGESND
		stopsound CHARGEHOLD
		ifge LASERCHARGE 32 set LASERFIRE 1
		else set LASERCHARGE 0
	}
	
}
else
{
	stopsound CHARGESND
	stopsound CHARGEHOLD
	set LASERCHARGE 0
}

ife pchar 0
ife player[].curr_weapon CHAINGUN_WEAPON
{
	ifg fastfire 0 set WEAPON3_SHOTSPERBURST 4 else set WEAPON3_SHOTSPERBURST 0
	ife player[].kickback_pic WEAPON3_FIREDELAY
	{
		stopactorsound THISACTOR WEAPON3_FIRESOUND
		espawn SOUNDPLATE
		setav[RETURN].SPRITELOTAG WEAPON3_FIRESOUND
		setav[RETURN].mtype 1
	}
	ifvarand dukeupgrades[CHAINGUN_WEAPON] 8 
	ifvarand gotshock 2 { stopsound MINISPIN set spinup 0 }
	else
	ifvarand dukeupgrades[CHAINGUN_WEAPON] 1
	{
		ife player[].weapon_pos 0
		{
			ifg spinup 0 add spinframe 1
			ifvarand bits 4 { add spinup 1 ifg fastfire 0 add spinup 1 }
			else ifg spinup 0 sub spinup 1
			ifg spinup 12 set spinup 12
			ifl spinup 10 
			{
				ifg spinframe 10370 set spinframe 10367
				ifg player[].kickback_pic 1 setp[].kickback_pic 1
				ife spinup 0 setp[].kickback_pic 0
			}
			else
			ifn player[].kickback_pic 0
			{
				ifl spinframe 10371 set spinframe 10371
				ifg spinframe 10373 set spinframe 10371
				ifg fastfire 0
				ifg player[].ammo_amount CHAINGUN_WEAPON 1
				ifvarand player[].player_par 1
				{
					shoot CHAINGUN
					getp[].ammo_amount CHAINGUN_WEAPON temp
					sub temp 1
					setp[].ammo_amount CHAINGUN_WEAPON temp
				}
				
			}
			ifg spinup 0 soundonce MINISPIN else stopsound MINISPIN
		}
		else { set spinup 0 stopsound MINISPIN }
	}
}
else { stopsound MINISPIN set spinup 0 }

ifl player[].ammo_amount CHAINGUN_WEAPON 1
ifg spinframe 10370 set spinframe 10367 // failsafe

ifl player[].ammo_amount SHOTGUN_WEAPON 1 setp[].ammo_amount SHOTGUN_WEAPON 1

ife pchar 0
ife player[].curr_weapon SHOTGUN_WEAPON
{
	ifvarand gotDB 2
	{
		ifg player[].kickback_pic 11 ifl dbammo 2 setp[].kickback_pic 0
		ifvarand dukeupgrades[SHOTGUN_WEAPON] 32
		{
			ife player[].kickback_pic 21 screensound DBLOAD
			ife player[].kickback_pic 29 screensound DBLOAD
			ife player[].kickback_pic 36 screensound DBCLOSE
			ife player[].kickback_pic 17 spawn SHOTGUNSHELL
		}
		else
		{
			ife player[].kickback_pic 33 screensound DBLOAD
			ife player[].kickback_pic 45 screensound DBLOAD
			ife player[].kickback_pic 53 screensound DBCLOSE
			ife player[].kickback_pic 23 spawn SHOTGUNSHELL
		}
		ife zoomin YES
		{
			set zoomin NO
			set zoomcount -6
			setp[].auto_aim autoaim
		}
	}
	else
	ifvarand dukeupgrades[SHOTGUN_WEAPON] 4
	{
		getp[].kickback_pic temp
		ifn player[].weapon_pos 0 set zoomcount 0
		
		ifg zoomcount 0 ifl zoomcount 7 add zoomcount 1
		ifl zoomcount 0 add zoomcount 1
		
		ifvarand dukeupgrades[SHOTGUN_WEAPON] 2 // burstfire
		ifl burstfired 2 // NO
		ifge player[].kickback_pic 8
		ifle player[].kickback_pic 9
		ifvarand bits 4
		ifg player[].ammo_amount SHOTGUN_WEAPON 1
		{
			setp[].kickback_pic 1
			add burstfired 1
			// set burstfired YES
		}
		ifge player[].kickback_pic 10 set burstfired NO
		
		
		ifvarand dukeupgrades[SHOTGUN_WEAPON] 1 // zoom when release
		{
			ifvarand oldextbits 64
			{
				ife player[].kickback_pic 0 ife player[].weapon_pos 0
				{
					ifvarand extbits 64 nullop else
					ife zoomcount 0 set zoomcount 1
					
					ife zoomin YES
					{
						ifvarand extbits 64 nullop else
						{
							set zoomin NO
							set zoomcount -6
							setp[].auto_aim autoaim
						}
					}
				}
			}
		}
		else
		{
			ifvarand extbits 64
			{
				ife player[].kickback_pic 0 ife player[].weapon_pos 0
				{
					ifvarand oldextbits 64 nullop else
					ife zoomcount 0 set zoomcount 1
					
					ife zoomin YES
					{
						ifvarand oldextbits 64 nullop else
						{
							set zoomin NO
							set zoomcount -6
							setp[].auto_aim autoaim
						}
					}
				}
			}
		}

		ife zoomcount 6
		ife zoomin NO
		{
			set zoomin YES
			set zoomlevel 2
			set vrhi viewingrange
			set vrlo vrhi
			// div vrlo zoomlevel	
			mul vrlo 2
			div vrlo 3
			
			set zoomcount 7
		}
		ifn zoomcount 0 ife zoomin NO setp[].kickback_pic 0
	}
}


ife player[].curr_weapon SHOTGUN_WEAPON
{
	ifvarand gotbow 2
	{
		set temp NO
		
		ife pchar 1 ifvarand shellyupgrades[SHOTGUN_WEAPON] 4 set temp YES
		ife pchar 2 ifvarand wesupgrades[SHOTGUN_WEAPON] 4 set temp YES
		
		ife pchar 2
		ife arrowtype 8 orvar monstflags 4096 else ifvarand monstflags 4096 xorvar monstflags 4096
		
		ife temp YES
		{
			ifvare player[].kickback_pic 1 { sound BOWDRAW set arrowview -1 }
			ifvarg player[].kickback_pic 12 ifvarl player[].kickback_pic 16 ifvarand bits 4
				setplayer[].kickback_pic 14
				
			ifvarand oldextbits 64 nullop else
			ifvarand extbits 64
			ife player[].weapon_pos 0
			{
				screensound HOLSTER
				// 0 = regular; 1 = burning; 2 = explosive; 3 = multi; 4 = freeze; 5 = spy; 6 = electric
				// 7 = blood; 8 = radioactive
				// shellyupgrades[SHOTGUN_WEAPON] 8=EXPLOSIVE, 16=MULTI, 32=SPY, 64=ELECTRIC, 256=ICE, 512=FIRE
				// wesupgrades[SHOTGUN_WEAPON] 8=blood, 16=MULTI, 32=SPY, 64=RADIOACTIVE, 256=ICE, 512=FIRE
				ife pchar 1
				set B shellyupgrades[SHOTGUN_WEAPON]
				else ife pchar 2
				set B wesupgrades[SHOTGUN_WEAPON]
				set TMP_A NO
				whilevarn TMP_A YES
				{
					add arrowtype 1
					
					ife pchar 1
					{
						ifg arrowtype 6 set arrowtype 0
						switch arrowtype
						case 0 set TMP_A YES break
						case 1 ifvarand B 512 set TMP_A YES break
						case 2 ifvarand B 8 set TMP_A YES break
						case 3 ifvarand B 16 set TMP_A YES break
						case 4 ifvarand B 256 set TMP_A YES break
						case 5 ifvarand B 32 set TMP_A YES break
						case 6 ifvarand B 64 set TMP_A YES break
						default set TMP_A YES break
						endswitch
					}
					else
					{
						// wesupgrades[SHOTGUN_WEAPON] 8=blood, 16=MULTI, 32=SPY, 64=RADIOACTIVE, 256=ICE, 512=FIRE
						ifg arrowtype 8 set arrowtype 1
						switch arrowtype
						case 0 set TMP_A NO break
						case 1 ifvarand B 512 set TMP_A YES break
						case 2 set TMP_A NO break
						case 3 ifvarand B 16 set TMP_A YES break
						case 4 ifvarand B 256 set TMP_A YES break
						case 5 ifvarand B 32 set TMP_A YES break
						case 6 set TMP_A NO break
						case 7 set TMP_A YES break
						case 8 ifvarand B 8 set TMP_A YES break
						default set TMP_A YES break
						endswitch
					}
				}
				ifvarand gametips 512 { xorvar gametips 512 savegamevar gametips }
				ife arrowtype 3 set WEAPON2_SHOTSPERBURST 3
			}
			ifn WEAPON2_SHOOTS ARROWPROJ
			ife player[].kickback_pic 0
			{
				ife pchar 1 state shellyweapons else
				ife pchar 2 state wesweapons
			}
			ifn arrowtype 3 set WEAPON2_SHOTSPERBURST 1
			
		}
	}
	else 
	{
		ifvarand monstflags 4096 xorvar monstflags 4096
		set arrowview -1
		ifn pchar 0
		{
			ife player[].kickback_pic 0 
			{
			ife pchar 1 ifvarand shellyupgrades[SHOTGUN_WEAPON] 128
				set WEAPON2_TOTALTIME 11
			else
			ife pchar 2 ifvarand wesupgrades[SHOTGUN_WEAPON] 128
				set WEAPON2_TOTALTIME 11
			}
			
			set temp player[].ammo_amount SHOTGUN_WEAPON
			sub temp 1
			ifl temp spasclip
				set spasclip temp

			
			ife player[].kickback_pic 0
			ife player[].reloading NO
			ife player[].weapon_pos 0
			ifl spasclip 1
			ifg player[].ammo_amount SHOTGUN_WEAPON 1
			{
				setp[].reloading YES
				setp[].kickback_pic 11
				ifl player[].ammo_amount SHOTGUN_WEAPON 9
				{
					set spasclip player[].ammo_amount SHOTGUN_WEAPON 
					sub spasclip 1
				}
				else
				set spasclip 8
			}
		}
		
	}
}
else 
{
	set arrowview -1
	ifvarand monstflags 4096 xorvar monstflags 4096
}

ife pchar 2
ife player[].curr_weapon SHOTGUN_WEAPON
ife stakefire YES
{
	set temp NO
	ife player[].kickback_pic 0 set temp YES else
	ifg player[].kickback_pic 24 set temp YES
	
	ife temp YES
	{
		set stakefire NO
		set WEAPON2_FIRESOUND WES_SHOTTY
		set WEAPON2_SHOOTS SHOTSPARK1
		set WEAPON2_SHOTSPERBURST 8
	}
}

ife pchar 1
ife player[].curr_weapon CHAINGUN_WEAPON
{
	// ife player[].kickback_pic WEAPON3_FIREDELAY
	// {
		// stopactorsound THISACTOR WEAPON3_FIRESOUND
		// espawn SOUNDPLATE
		// setav[RETURN].SPRITELOTAG WEAPON3_FIRESOUND
		// setav[RETURN].mtype 1
	// }
	ifvarand shellyupgrades[CHAINGUN_WEAPON] 8 
	ifvarand gotshock 2 set m4reload 0
	else
	{
		ifl player[].ammo_amount CHAINGUN_WEAPON m4clip
		set m4clip player[].ammo_amount CHAINGUN_WEAPON
		ifvarand player[].kickback_pic 1 nullop else
		ife m4reload 0
		ife player[].weapon_pos 0
		ifl m4clip 1
		ifg player[].ammo_amount CHAINGUN_WEAPON 0
		{
			set m4reload 1
		}
		ifn player[].weapon_pos 0 { set m4reload 0 set zoomcount 0 }
		ifn m4reload 0
		{
			set zoomin NO
			set zoomcount 0
			setp[].kickback_pic 0
			add m4reload 1
			ife m4reload 9 
			{
				ifvarand shellyupgrades[CHAINGUN_WEAPON] 1 sound M4CLIPOUT
				else
				sound SHELLYCLIPOUT
				espawn SHELL
				setav[RETURN].mtype CLIPFALL
			}
			ife m4reload 29 
			{ 
				ifvarand shellyupgrades[CHAINGUN_WEAPON] 1 sound M4CLIPIN
				else sound SHELLYCLIPIN
			}
			ifg m4reload 40
			{
				set m4reload 0
				getp[].ammo_amount CHAINGUN_WEAPON temp
				ifge temp 30
				{
					set m4clip 30
					// sub temp 30
					// setp[].ammo_amount CHAINGUN_WEAPON temp
				}
				else
				{
					set m4clip temp
					// setp[].ammo_amount CHAINGUN_WEAPON 0
				}
			}
		}
		
		ifg fastfire 0
		ifn player[].kickback_pic 0
		{
			ifg player[].ammo_amount CHAINGUN_WEAPON 1
			ifvarand player[].player_par 1
			{
				shoot CHAINGUN
				getp[].ammo_amount CHAINGUN_WEAPON temp
				sub temp 1
				setp[].ammo_amount CHAINGUN_WEAPON temp
			}
			
		}
		
		ifg zoomcount 0 ifl zoomcount 7 add zoomcount 1
		ifl zoomcount 0 add zoomcount 1
		ifvarand extbits 64
		{
			ife m4reload 0 ife player[].weapon_pos 0
			{
				ifvarand oldextbits 64 nullop else
				ife zoomcount 0 set zoomcount 1
				
				ife zoomin YES
				{
					ifvarand oldextbits 64 nullop else
					{
						set zoomin NO
						set zoomcount -6
						setp[].auto_aim autoaim
					}
				}
			}
		}

		ifg zoomcount 6
		ifn zoomin YES
		{
			set zoomin YES
			set zoomlevel 2
			set vr -1
			// set vrhi viewingrange
			// set vrlo vrhi
			// div vrlo zoomlevel	
			set zoomcount 7
			ifvarand gametips 4 { xorvar gametips 4 savegamevar gametips }
		}
		ifn zoomcount 0 ife zoomin NO setp[].kickback_pic 0
	}
}
else set m4reload 0

ife pchar 2
ife player[].curr_weapon CHAINGUN_WEAPON
{

	ifvarand wesupgrades[CHAINGUN_WEAPON] 8 
	ifvarand gotshock 2 set uzireload 0
	else
	{
		ifl player[].ammo_amount CHAINGUN_WEAPON uziclip
		set uziclip player[].ammo_amount CHAINGUN_WEAPON
		ifvarand player[].kickback_pic 1 nullop else
		ife uzireload 0
		ife player[].weapon_pos 0
		ifl uziclip 1
		ifg player[].ammo_amount CHAINGUN_WEAPON 0
		{
			set uzireload 1
		}
		ifn player[].weapon_pos 0 { set uzireload 0 set zoomcount 0 }
		ifn uzireload 0
		{
			set zoomin NO
			set zoomcount 0
			setp[].kickback_pic 0
			add uzireload 1
			ife uzireload 9 
			{
				sound SHELLYCLIPOUT
				espawn SHELL
				setav[RETURN].mtype CLIPFALL
				
				ifvarand wesupgrades[CHAINGUN_WEAPON] 1
				{
					espawn SHELL
					setav[RETURN].mtype CLIPFALL
					set angvar sprite[RETURN].ang
					add angvar 1024
					seta[RETURN].ang angvar
				}
			}
			ife uzireload 25 
				sound SHELLYCLIPIN
			
			ifg uzireload 35
			{
				set uzireload 0
				getp[].ammo_amount CHAINGUN_WEAPON temp
				ifge temp 32
				{
					set uziclip 32
					// sub temp 30
					// setp[].ammo_amount CHAINGUN_WEAPON temp
				}
				else
				{
					set uziclip temp
					// setp[].ammo_amount CHAINGUN_WEAPON 0
				}
			}
		}
		
		ifg fastfire 0
		ifn player[].kickback_pic 0
		{
			ifg player[].ammo_amount CHAINGUN_WEAPON 1
			ifvarand player[].player_par 1
			{
				shoot CHAINGUN
				getp[].ammo_amount CHAINGUN_WEAPON temp
				sub temp 1
				setp[].ammo_amount CHAINGUN_WEAPON temp
			}
			
		}

	}
}
else set uzireload 0

ife pchar 2
{
	set temp NO
	ife player[].curr_weapon GROW_WEAPON { set temp YES set B player[].ammo_amount GROW_WEAPON }
	ife player[].curr_weapon SHRINKER_WEAPON { set temp YES set B player[].ammo_amount SHRINKER_WEAPON }
	ife temp YES
	{
		
		ifvarand extbits 64
		ife player[].kickback_pic 0
		ife player[].weapon_pos 0
		{
			set temp NO
			ifge B 10 set temp YES else
			ifge B 5 ife player[].curr_weapon SHRINKER_WEAPON set temp YES
			ife temp YES
			{
				ife player[].curr_weapon SHRINKER_WEAPON
				{
					set WEAPON6_SHOOTS BLOODBOMB
					set WEAPON6_FIRESOUND GRENADE_SHOOT
					set WEAPON6_TOTALTIME 14
				}
				else
				{
					set WEAPON11_SHOOTS GRENADEPROJ // WESGRENADE
					set	WEAPON11_SHOTSPERBURST 0
					set WEAPON11_FIRESOUND GRENADE_SHOOT
					set WEAPON11_TOTALTIME 14
				}
				setp[].kickback_pic 1
			}
		}
		
		ife WEAPON11_SHOOTS GRENADEPROJ // WESGRENADE
		ifg player[].kickback_pic 12
		{
			set WEAPON11_SHOOTS WESBULLET
			set	WEAPON11_SHOTSPERBURST 2
			set WEAPON11_FIRESOUND WESKAR_FIRE
			set WEAPON11_TOTALTIME 4
		}
		
		ife WEAPON6_SHOOTS BLOODBOMB
		ifg player[].kickback_pic 12
		{
			set WEAPON6_SHOOTS BLOODBULLET
			set WEAPON6_FIRESOUND RPG_SPLIT
			set WEAPON6_TOTALTIME 4
		}
		
		ife player[].curr_weapon SHRINKER_WEAPON
		{
			ifl B skarclipB
			set skarclipB B
		}
		else
		{
			ifl B skarclip
			set skarclip B
		}
		
		ife player[].reloading NO
		ife player[].weapon_pos 0
		ifg B 0
		ifle player[].kickback_pic 1
		{
			set temp NO
			ife player[].curr_weapon SHRINKER_WEAPON ifl skarclipB 1 set temp YES
			ife player[].curr_weapon GROW_WEAPON ifl skarclip 1 set temp YES
			ife temp YES
			{
				setp[].reloading YES
				setp[].kickback_pic 5
			}
		}
		
		ife player[].reloading YES
		{
			ife player[].kickback_pic 17 
			{
				sound SKARCLIPOUT
				espawn SHELL
				setav[RETURN].mtype CLIPFALL
			}
			ife uzireload 35 
				sound AMMOPICK
			
			ifg player[].kickback_pic 40
			{
				setp[].kickback_pic 0
				setp[].reloading 0
				ife player[].curr_weapon SHRINKER_WEAPON
				{
				ifge B 10
					set skarclipB 10
				else
					set skarclipB B
				}
				else
				{
				ifge B 20
					set skarclip 20
				else
					set skarclip B
				}
			}
		}	
	}
}


ife player[].curr_weapon RPG_WEAPON
{
	set temp NO
	ife pchar 0 ifvarand dukeupgrades[RPG_WEAPON] 1 set temp YES
	ife pchar 1 ifvarand shellyupgrades[RPG_WEAPON] 1 set temp YES
	ife pchar 2 set temp YES // ifvarand wesupgrades[RPG_WEAPON] 1 set temp YES
	ife temp YES
	{
		ifg zoomcount 0 ifl zoomcount 7 add zoomcount 1
		ifl zoomcount 0 add zoomcount 1
		ifvarand extbits 64
		{
			ife player[].kickback_pic 0 ife player[].weapon_pos 0
			{
				ifvarand oldextbits 64 nullop else
				ife zoomcount 0 set zoomcount 1
				
				ife zoomin YES
				{
					ifvarand oldextbits 64 nullop else
					{
						set zoomin NO
						set zoomcount -6
						setp[].auto_aim autoaim
					}
				}
			}
		}

		ifg zoomcount 6
		ifn zoomin YES
		{
			set targetwait 10
			set zoomin YES
			set zoomlevel 2
			set vr -1
			// set vrhi viewingrange
			// set vrlo vrhi
			// div vrlo zoomlevel	
			set zoomcount 7
			ifvarand gametips 16 { xorvar gametips 16 savegamevar gametips }
		}
		ifn zoomcount 0 ife zoomin NO setp[].kickback_pic 0
		
		ife zoomin YES
		ife player[].kickback_pic WEAPON4_FIREDELAY
		{
			rand tempb 4
			add tempb 8
			
			set horizfall tempb
			set savedhoriz player[].horiz
			add tempb player[].horiz
			setp[].horiz tempb
		}
		
		// if firing, make sure that all locks are fired at
		ife player[].kickback_pic 8 // just finished firing a rocket
		ifg player[].ammo_amount RPG_WEAPON 0
		{
			ifn targetlock[0] -1 setp[].kickback_pic 3 else
			ifn targetlock[1] -1 setp[].kickback_pic 3 else
			ifn targetlock[2] -1 setp[].kickback_pic 3
		}
		
		ifvarand dukeupgrades[RPG_WEAPON] 4 set tempb YES
		ifvarand shellyupgrades[RPG_WEAPON] 4 set tempb YES
		ife pchar 2 set tempb NO
		ife tempb YES
		{
			ifg loadrox 0 ifg player[].kickback_pic WEAPON4_FIREDELAY
			{
				shoot RPG
				
				ife devside 0
				{
					getp[].ammo_amount RPG_WEAPON temp
					sub temp 1 
					setp[].ammo_amount RPG_WEAPON temp
					
					set devside 1
				}
				else set devside 0
				
				soundvar WEAPON4_FIRESOUND
				ifvarand gametips 32 { xorvar gametips 32 savegamevar gametips }
			}
			ife player[].kickback_pic 0 { set holdfire 0 set loadrox 0 }
			
			ifp palive
			ife player[].weapon_pos 0
			ife zoomcount 0
			ifvarand bits 4 
			ifg player[].kickback_pic 0
			ifl player[].kickback_pic WEAPON4_FIREDELAY
			ifg player[].ammo_amount RPG_WEAPON 0
			{
				add holdfire 1
				ifg fastfire 0 add holdfire 1
				ife holdfire 20 ifg player[].ammo_amount RPG_WEAPON 1 { set loadrox 2 sound LOADROX }
				ife holdfire 40 ifg player[].ammo_amount RPG_WEAPON 2 { set loadrox 3 sound LOADROX }
				ife holdfire 60 ifg player[].ammo_amount RPG_WEAPON 3 { set loadrox 4 sound LOADROX }
				setp[].kickback_pic 1
			}
		}
	}
	else
	ife zoomin YES
	{
		set zoomin NO
		set zoomcount -6
		setp[].auto_aim autoaim
	}
}
else
{
	setarray targetlock[0] -1
	setarray targetlock[1] -1
	setarray targetlock[2] -1
}

// ife player[].curr_weapon SHRINKER_WEAPON
// ife player[].kickback_pic 1
// {
	// set temp NO
	// ife pchar 0 ifvarand dukeupgrades[SHRINKER_WEAPON] 1 set temp YES
	// ife pchar 1 ifvarand shellyupgrades[SHRINKER_WEAPON] 1 set temp YES
	// ife temp YES
	// sound BFGFIRE
// }

ife pchar 0
ife player[].curr_weapon HANDBOMB_WEAPON
ife player[].weapon_pos 0
ife player[].kickback_pic 0
{
	ifvarand extbits 64
	{
		screensound HOLSTER
		setp[].weapon_pos -1
		ife PIPEBOMB_CONTROL 1 { set PIPEBOMB_CONTROL 2 quote 1158 set pipemode 2 } else
		{ set PIPEBOMB_CONTROL 1 quote 1157 set pipemode 1 }
		ifvarand gametips 4096 { xorvar gametips 4096 savegamevar gametips }
	}
}

ife player[].curr_weapon SHRINKER_WEAPON
ife WEAPON6_SHOOTS BMFGPROJ
{
	set temp 0
	ife pchar 0 ifvarand dukeupgrades[SHRINKER_WEAPON] 2 set temp YES
	ife pchar 1 ifvarand shellyupgrades[SHRINKER_WEAPON] 2 set temp YES
	ife temp YES
	ife player[].weapon_pos 0
	ifg player[].ammo_amount SHRINKER_WEAPON 0
	ife player[].kickback_pic 0
	ifvarand extbits 64
	{
		setp[].kickback_pic 1
		set bmfgaltfire YES
	}
	
	
	ifg player[].kickback_pic 0
	ifl player[].kickback_pic WEAPON6_FIREDELAY
	{
		ifvarand bits 4
		{
			getp[].kickback_pic temp
			add temp 1
			ife temp WEAPON6_FIREDELAY
			{
				sub temp 2
				setp[].kickback_pic temp
				stopsound BFGFIRE
			}
			ifsound BFGFIRE nullop else soundonce BFGLOOP
		}	
	}
	ifge player[].kickback_pic WEAPON6_FIREDELAY
	{
		// ifsound BFGFIRE nullop else
		soundonce BFGFIRE2
		
		stopsound BFGLOOP
		stopsound BFGFIRE
	}
	ife player[].kickback_pic 0 set bmfgaltfire NO
}

ife player[].curr_weapon GROW_WEAPON
ife player[].weapon_pos 0
ifge player[].ammo_amount GROW_WEAPON 15
ife player[].kickback_pic 0
ife WEAPON11_SHOOTS GROWSPARK
ifvarand extbits 64
{
	set WEAPON11_SHOOTS LOVEBOMB
	set	WEAPON11_SHOTSPERBURST 0
	set WEAPON11_FIREDELAY 8
	set WEAPON11_TOTALTIME 20
	setp[].kickback_pic 1
}

ife WEAPON11_SHOOTS LOVEBOMB
{
	set temp NO
	ife player[].kickback_pic 0 set temp YES
	ifg player[].kickback_pic 17 set temp YES
	ifn player[].curr_weapon GROW_WEAPON set temp YES
	ifn player[].weapon_pos 0 set temp YES
	ife temp YES
	{
		set WEAPON11_SHOOTS GROWSPARK
		set	WEAPON11_SHOTSPERBURST 0
		set WEAPON11_FIREDELAY 3
		set WEAPON11_TOTALTIME 5
	}
}


ife player[].curr_weapon DEVISTATOR_WEAPON
{
	ifvarand gotrailgun 2
	{
		set temp NO
		ife pchar 0 ifvarand dukeupgrades[DEVISTATOR_WEAPON] 8 set temp YES
		ife pchar 1 ifvarand shellyupgrades[DEVISTATOR_WEAPON] 8 set temp YES
		ife pchar 2 ifvarand wesupgrades[DEVISTATOR_WEAPON] 8 set temp YES
		ife temp YES
		{
			ife player[].kickback_pic 9 setp[].kickback_pic 26
		}
	}
	else
	ife pchar 1
	{
		set temp NO
		ife fastfire 0 
		{
			ife player[].kickback_pic 11 set temp YES
		}
		else
			ife player[].kickback_pic 12 set temp YES
			
		ife temp YES
		{
			ife devside 0 
			{
				set devside 1 
				setprojectile[GRENADEPROJ].offset 65408
				setprojectile[STICKYPROJ].offset 65408
			}
			else
			{
				set devside 0
				setprojectile[GRENADEPROJ].offset 128
				setprojectile[STICKYPROJ].offset 128
			}
		}
		ifvarand shellyupgrades[DEVISTATOR_WEAPON] 2
		ife player[].kickback_pic 3
		{
			ifvarand shellyupgrades[DEVISTATOR_WEAPON] 1
			{
				eshoot STICKYPROJ
				geta[RETURN].z z, sub z 2048 seta[RETURN].z z
				geta[RETURN].zvel z, sub z 1024 seta[RETURN].zvel z
				
				eshoot STICKYPROJ
				geta[RETURN].z z, sub z 2048 seta[RETURN].z z
				geta[RETURN].zvel z, sub z 1024 seta[RETURN].zvel z
			}
			else
			{
				eshoot GRENADEPROJ
				geta[RETURN].z z, sub z 2048 seta[RETURN].z z
				geta[RETURN].zvel z, sub z 1024 seta[RETURN].zvel z
			}
		}
		
	}
	else
	ife pchar 0
	{
		ifvarand dukeupgrades[DEVISTATOR_WEAPON] 1
		{
			ife player[].kickback_pic 2
			{
				ife devside 0 
					set devside 1 
				else
					set devside 0

			}
		}
	}
}

// ZOOM OR UNZOOM RAILGUN
ifvarand oldextbits 64 nullop else
ifvarand extbits 64
{
	ife player[].curr_weapon DEVISTATOR_WEAPON
	ifvarand gotrailgun 2
	ife zoomin NO
	{
		set zoomin YES
		ifvarand gametips 256 { xorvar gametips 256 savegamevar gametips }
		ifn player[].auto_aim 0
		{
			getp[].auto_aim autoaim
			setp[].auto_aim NO
		}
		set zoomlevel 3
		set vrhi viewingrange
		set vrlo vrhi
		// div vrlo zoomlevel	
		div vrlo 3
	}
	else
	ifn zoomin NO
	{
		ife pchar 0 ifvarand dukeupgrades[SHOTGUN_WEAPON] 5 ife player[].curr_weapon SHOTGUN_WEAPON nullop 
		else
		{
			set zoomin NO
			setp[].auto_aim autoaim	
			set zoomcount -6
		}
	}
}

ife player[].curr_weapon FREEZE_WEAPON
{
	ifn player[].kickback_pic 0
	{
		setp[].weapon_sway 1024
		ifvarand shellyupgrades[FREEZE_WEAPON] 1
		ife WEAPON9_SHOOTS FIREBEAM
		soundonce LASERLOOP
		
		ifvarand dukeupgrades[FREEZE_WEAPON] 1
		ife WEAPON9_SHOOTS ICEBEAM
		soundonce FREEZELOOP
		
		
	}
	else 
	{ 
	    ifactorsound THISACTOR LASERLOOP stopactorsound THISACTOR LASERLOOP 
		ifactorsound THISACTOR FREEZELOOP stopactorsound THISACTOR FREEZELOOP 
	}
	
	ifvarand gotplasma 2 // reset in case shockball2 was fired
	{
		ife player[].kickback_pic 0
		state setplasmagun else
		ife player[].kickback_pic 16
		state setplasmagun
		else ifge player[].kickback_pic 12
		ifvarand bits 4 state setplasmagun
	}
}
else { ifactorsound THISACTOR LASERLOOP stopactorsound THISACTOR LASERLOOP 
		ifactorsound THISACTOR FREEZELOOP stopactorsound THISACTOR FREEZELOOP  }

ife player[].curr_weapon CHAINGUN_WEAPON
{
	set temp NO
	ifvarand gotshock 2
	{
		ife pchar 0 ifvarand dukeupgrades[CHAINGUN_WEAPON] 8 set temp YES
		ife pchar 1 ifvarand shellyupgrades[CHAINGUN_WEAPON] 8 set temp YES
		ife pchar 2 ifvarand wesupgrades[CHAINGUN_WEAPON] 8 set temp YES
	}
	ife temp YES
	{
		ifvarand bits 4 nullop else
		state clearshock
		
		ifn player[].kickback_pic 0
		{
			setp[].weapon_sway 1024
			ifg player[].kickback_pic WEAPON3_FIREDELAY 
			{
				set WEAPON3_SHOOTS SHOCKBEAM
				set WEAPON3_FIRESOUND LIGHTNINGFIRE
			}
			
			ifvarand bits 4
			ifn startshocktime -1
			ife player[].weapon_pos 0
			{
				ifactorsound THISACTOR ELECTRICLOOP nullop else sound ELECTRICLOOP
				ife player[].kickback_pic 11
				ife sidekick 0
				ife slidekick 0
				{
					setprojectile[SHOCKBEAM].extra 3
					set picnum METALSPARK1
					rand temp 4
					add picnum temp
					setprojectile[SHOCKBEAM].spawns picnum
					shoot SHOCKBEAM
					setprojectile[SHOCKBEAM].extra 52
					setprojectile[SHOCKBEAM].spawns ELEC_EXP
					setp[].posxv 0
					setp[].posyv 0
				}
				ife player[].kickback_pic 12
				{
					setp[].kickback_pic 9
					setp[].weapon_sway 1024
				}
				set temp player[].player_par
				sub temp startshocktime
				modvar temp 4
				ife temp 0
				{
					getp[].ammo_amount 3 temp
					sub temp 1, ifl temp 0 set temp 0
					setp[].ammo_amount 3 temp
					ife temp 0 state clearshock
				}
			}
			else state clearshock
			
		}
		else
		ifg player[].ammo_amount 3 0
		ife player[].weapon_pos 0
		ifp palive
		{
			ifvarand bits 4 // chain lightning
			{
				getp[].player_par startshocktime
				setp[].kickback_pic 9
				setp[].weapon_sway 1024
				getp[].ammo_amount 3 temp
				sub temp 1
				setp[].ammo_amount 3 temp
			}
			else
			ifvarand extbits 64 // single shot
			ifg player[].ammo_amount 3 4
			{
				setp[].kickback_pic 1
				setp[].weapon_sway 1024
				getp[].ammo_amount 3 temp
				sub temp 5
				setp[].ammo_amount 3 temp
			}
		}
	}
}
else state clearshock

set inithp player[].max_player_health
ife userdef[].god YES 
{
	set bleeding 0
	seta[].htextra -1
}

ife vendorupgrade YES
{
	getkeyname 1101 36 2 // get name of vendor key into quote 1101
	qsprintf 1102 1100 1101
}

// increment or decrement timer variables
add radarupdate 1
ife pdown YES 
{
	setp[].jetpack_on NO
	ifg deathcounter 0 sub deathcounter 1
	ifvarand perks 64 ifge rescuecharge RESCUEAMOUNT
	ifl deathcounter 420
	// ifp ponground
	{
		// spawn in helper troops
		sub rescuecharge RESCUEAMOUNT
		screensound BOSSPORT
		
		getp[].posx savx add savx 1024
		getp[].posy savy add savy 1024

		espawn EDFSNIPER
		setav[RETURN].monstflags 8 // shield
		setav[RETURN].spawnprotect 100
		setav[RETURN].FEMKILLCOUNT 2700
		setav[RETURN].mlevel plevel
		setsprite RETURN savx savy player[].posz
		espawn GLARESTAR
		setsprite RETURN savx savy player[].posz

		sub savx 2048
		sub savy 2048
		
		espawn EDFSNIPER
		setav[RETURN].monstflags 2048 // ghostly
		setav[RETURN].spawnprotect 100
		setav[RETURN].FEMKILLCOUNT 2700
		setav[RETURN].mlevel plevel
		setsprite RETURN savx savy player[].posz
		espawn GLARESTAR
		setsprite RETURN savx savy player[].posz

		add savx 2048
		
		espawn EDFTROOP
		setav[RETURN].monstflags 4
		setav[RETURN].spawnprotect 100
		setav[RETURN].FEMKILLCOUNT 2700
		setav[RETURN].mlevel plevel
		setsprite RETURN savx savy player[].posz
		espawn GLARESTAR
		setsprite RETURN savx savy player[].posz

		add savy 1024
		
		espawn EDFTROOP
		seta[RETURN].pal 22
		setav[RETURN].monstflags 16384 // VAMPIRE
		setav[RETURN].spawnprotect 100
		setav[RETURN].FEMKILLCOUNT 2700
		setav[RETURN].mlevel plevel
		setsprite RETURN savx savy player[].posz
		espawn GLARESTAR
		setsprite RETURN savx savy player[].posz
		
			
		sub savx 1024
		add savy 1024
		
		espawn ARMEDF
		setav[RETURN].monstflags 512 // sideguns
		setav[RETURN].spawnprotect 100
		setav[RETURN].FEMKILLCOUNT 2700
		setav[RETURN].mlevel plevel
		setsprite RETURN savx savy player[].posz
		espawn GLARESTAR
		setsprite RETURN savx savy player[].posz
			
		sub savy 2048
		
		espawn EDFDRONE
		setav[RETURN].spawnprotect 100
		setav[RETURN].FEMKILLCOUNT 2700
		setav[RETURN].mlevel plevel
		setav[RETURN].monstflags 512 // sideguns
		setsprite RETURN savx savy player[].posz
		espawn GLARESTAR
		setsprite RETURN savx savy player[].posz
		
		sub savx 1024
		add savy 1024
		
		espawn EDFTROOP
		seta[RETURN].pal 19
		setav[RETURN].monstflags 128 // multishot
		setav[RETURN].spawnprotect 100
		setav[RETURN].FEMKILLCOUNT 2700
		setav[RETURN].mlevel plevel
		setsprite RETURN savx savy player[].posz
		espawn GLARESTAR
		setsprite RETURN savx savy player[].posz
		
		set spawnprotect 120
		set bigmsgcount 90
		set bigmsg 1087
		set shellyinmap 120
	}
}

ifg secretsfound 0 sub secretsfound 1
ifg ptargeted 0 sub ptargeted 1
ifg forwinput 0 sub forwinput 1
ifg backinput 0 sub backinput 1
ifg gun_nametime 0 sub gun_nametime 1
ifg handicon 0 sub handicon 1
ifg ancients_transport 0 sub ancients_transport 1

ifg bigmsgcount 0 
ifg startmode -1
{
	sub bigmsgcount 1
	ife bigmsgcount 0 ifn buffermsg 0
	{
		set bigmsg buffermsg
		set buffermsg 0
		set bigmsgcount 90
	}
}
ifn combotime 0 { ifg combotime 0 sub combotime 1 else ifl combotime 0 add combotime 1 }
ifg monidtime 0 { sub monidtime 1 ife monidtime 0 set monid -1 }
ifvarand perks 64 ifge rescuecharge RESCUEAMOUNT ifl shellyinmap 10 set shellyinmap 10
ifg shellyinmap 0 
{
	sub shellyinmap 1
	ife shellyinmap 0 
	{
		set myshelly -1
		set cmode 0
	}
	getkeyname 155 11 2
}
ifg sawfleshtime 0
{
	sub sawfleshtime 1
	ife sawfleshtime 0
	{
		stopsound SCRAPE
		stopsound SAWFLESH
	}
}
ifg lastbubble 0
{
	setp[].airleft 390
	sub lastbubble 1
}

ifg damagefade 0
{
	ifl damagefade 4 add damagefade 1 else
	add damagefade 4 // 8
	ifg damagefade 255 set damagefade 0
}

ifvarand perks 1 // sidegun perk
ifn gametype -1
{
	set safecount -1
	ife leftsidegun -1
	{
		espawn SIDEGUN
		ifn myshelly -1 ifn actorvar[myshelly].monstatus 2 setav[RETURN].myspawner myshelly else
		setav[RETURN].myspawner THISACTOR
		setav[RETURN].botclip -384
		set leftsidegun RETURN
		rand safecount 5
		setav[RETURN].mtype safecount
	}
	ife rightsidegun -1
	{
		espawn SIDEGUN
		ifn myshelly -1  ifn actorvar[myshelly].monstatus 2 setav[RETURN].myspawner myshelly else
		setav[RETURN].myspawner THISACTOR
		setav[RETURN].botclip 384
		set rightsidegun RETURN
		ife safecount -1
		rand safecount 5
		setav[RETURN].mtype safecount
	}
}

ife epselect -1
{
	state in_menu
	getplayer[].ang oang
	getplayer[].horiz ohoriz
	
	// ife rendmode 0 { set tempselect -1 break }
	ife startmode -2 { state wesoverride ife startmode -2 break }
	ife rendmode 4 { set tempselect -1 break }
	
	
	
	ife VOLUME 0
	{
		ife tempselect -1
		{
			ifle cursorx 160
			{
				ifle cursory 100
				{
					ifhitspace { set tempselect 0 resetcount }
					ifvarand bits 4 { set tempselect 0 resetcount }
					ife tempselect 0
					ifl cursorx 160 ifg cursorx 101 ifl cursory 21
					{
						set marathon YES
						set bigmsg 3090
						set bigmsgcount 150
					}
				}
				else
				{
					ifhitspace { set tempselect 2 resetcount }
					ifvarand bits 4 { set tempselect 2 resetcount }
				}
			}
			else
			{
				ifle cursory 100
				{
					ifhitspace { set tempselect 1 resetcount }
					ifvarand bits 4 { set tempselect 1 resetcount }
				}
				else
				{
					ifhitspace { set tempselect 3 resetcount }
					ifvarand bits 4 { set tempselect 3 resetcount }
				}
			}
			
			ifg tempselect -1 ifl tempselect 7
			{
				ifl tempselect 4 set switchmode YES
				ife PROGRESSION NO
				{
					set attmode NO
					set vendorupgrade YES
					set credits 1000
					set lastcredits 1000
				}
				else
				{
					set attmode 2				
					set vendorupgrade YES
					set credits 10000
					set lastcredits 10000
				}
			}
			break
		}
	}
	else
	ife VOLUME 1 // new episodes
	{
		ife tempselect -1
		{
			ifle cursory 100
			{
				ifle cursorx 160
				{
					ifhitspace 
					{ 
						set tempselect 4 
						ifvarand charlocked 4 set startmode -2 else
						set startmode 1 
						resetcount 
					}
					ifvarand bits 4 
					{ 
						set tempselect 4 
						ifvarand charlocked 4 set startmode -2 else
						set startmode 1 
						resetcount 
					}
					
					ife tempselect 4
					{
						ife PROGRESSION NO
						{
							set attmode NO
							set vendorupgrade YES
							set credits 1000
							set lastcredits 1000
						}
						else
						{
							set attmode 2				
							set vendorupgrade YES
							set credits 10000
							set lastcredits 10000
						}
					}
			
				}
				else
				{	
					// SETTINGS FOR GLADIATOR EPISODE
					ifhitspace 
					{ 
						set vendorupgrade NO set radaron YES set tempselect 7 
						ifvarand charlocked 4 set startmode -2 else
						set startmode 3 
						resetcount 
					}
					ifvarand bits 4 
					{ 
						set vendorupgrade NO set radaron YES set tempselect 7 
						ifvarand charlocked 4 set startmode -2 else
						set startmode 3 
						resetcount 
					}
					// note we set startmode here to prevent character menu from coming up
				}
			}
			else
			{
				set temp NO
				ifhitspace set temp YES
				ifvarand bits 4 set temp YES
				ife temp YES
				{
/*
					ifle cursorx 40
					ifge cursory 165
					{
						// SETTINGS FOR FINAL EPISODE
						resetcount
						set attmode 2
						set switchmode NO
						set tempselect 9
						set vendorupgrade NO
						set PROGRESSION YES
						set credits 5000
						set lastcredits 5000
						// set LOGO_FLAGS 522495
						set NEWENEMIES NO
						set radaron NO
						set startmode 4 // 3
					}
					else
*/
					ifle cursorx 160
					{
						// SETTINGS FOR WES EPISODE
						resetcount
						set attmode 2
						set switchmode NO
						set tempselect 9
						set vendorupgrade YES
						set PROGRESSION YES
						set credits 5000
						set lastcredits 5000
						// set LOGO_FLAGS 522495
						ifn radaron -1
						set radaron YES
						set startmode 4
						set charsel 4
					}
					else
					ifge cursorx 160
					{
						resetcount
						// SETTINGS FOR WAR OF ATTRITION EPISODE
						ifg cursory 180 ifl cursorx 212 
						{
							set challenge YES
							set checkpoints YES
							set bigmsg 3097
							set bigmsgcount 150
							ifl userdef[].player_skill 3
							{
								setuserdef[].player_skill 3
								set SKILL 3
							}
						}
						set attmode YES
						set switchmode YES
						set tempselect 8
						set vendorupgrade YES
						state next_att_map
						al ATTVOLUME al ATTLEVEL
						set credits 10000
						set lastcredits 10000
						set LOGO_FLAGS 522495
						set NEWENEMIES YES
					}
					
				}
			}
			break
		}
	}
	else
	ife VOLUME 2 // expansion episodes
	{
		ife tempselect -1
		{
			ifle cursorx 160
			{
				ifhitspace { set tempselect 5 resetcount }
				ifvarand bits 4 { set tempselect 5 resetcount }	
			}
			else
			{	
				ifhitspace { set tempselect 6 resetcount }
				ifvarand bits 4 { set tempselect 6 resetcount }
			}
			ifg tempselect -1 ifl tempselect 7
			{
				ife PROGRESSION NO
				{
					set attmode NO
					set vendorupgrade YES
					set credits 1000
					set lastcredits 1000
				}
				else
				{
					set attmode 2				
					set vendorupgrade YES
					set credits 10000
					set lastcredits 10000
				}
			}
			break
		}
	}
	ife startmode -2 break
	ifl startmode 0 { state startmodecode break }
	set epselect tempselect
	setarray visited[LEVEL] 0
	set init_picnums 0 

	set mirror_thismap NO
	
	ife epselect 0 startlevel 0 1 // bumped up by 1 due to menu code

	ife epselect 1 startlevel 0 8 // episode 2 the space episode
	ife epselect 2 startlevel 0 19 // episode 3 starts in raw meat
	ife epselect 3 startlevel 0 30 // episode 4 starts in impossible
	
	ife epselect 4 startlevel 4 0
	ife epselect 5 startlevel 5 0
	ife epselect 6 { set altcostume 34 startlevel 6 0 }
	ife epselect 7 { setuserdef[].show_level_text NO startlevel 6 11 }
	ife epselect 8 startlevel ATTVOLUME ATTLEVEL
	ife epselect 9 startlevel 6 38
	ife epselect 10 startlevel 4 10
 
	break
}

ife startmode -1 state startmodecode

ifn vendor_screen 0 state vendorcode
else 
{
	ife disable_tips YES set gametips 0
	ife reset_options YES
	{
		set radaron YES
		set MONHUD YES
		set SHOWPOINTS YES
		set AUTOSAVE YES
		set STEPSOUNDS YES
		set NEWENEMIES YES
		set MAXRANGE 65536
		set disable_doubletap NO
		set disable_kickheads NO
		set jibs_duration 1800
		set avoid_melee NO
		set mirror_maps NO
		set reset_options NO
		set disable_tips NO
		savegamevar radaron
		savegamevar MONHUD
		savegamevar SHOWPOINTS
		savegamevar AUTOSAVE
		savegamevar STEPSOUNDS
		savegamevar disable_tips
		set gametips 32767
		savegamevar mirror_maps
		savegamevar jibs_duration
		savegamevar disable_kickheads
		savegamevar RANDOMENEMIES
		savegamevar disable_doubletap
	}
	// ife mirror_thismap -1
	// {
		// state mirror
		// ife mirror_maps YES
		// set mirror_thismap YES else
		// set mirror_thismap NO
	// }
}

ifn award_screen 0 state awardcode

ifn matchmenu 0 state matchmenucode

ife vrmenu YES state vrmenucode


ife bonus_screen GAMEOVERSCREEN
{
	state in_menu
	setp[].fta 0
	setp[].ftq 285
	set z player[].player_par
	sub z lastclock
	ifg z 150 
	{
		quote 13
		ifhitspace
		resetplayer // cmenu 15000
	}
	setp[].timebeforeexit 50 
	getplayer[].ang oang
	getplayer[].horiz ohoriz
	break
}

ifn cutscene_ready 0
{
	ife player[].ftq 102 setp[].fta 0
	set temp NO
	ife player[].timebeforeexit 0 set temp YES
	else
	ifl player[].timebeforeexit 15 set temp YES
	ife temp YES
	{
		stopallsounds
		stopallmusic
		switch cutscene_ready
		case 1252 // episode 1 ending
			screensound EP1_END
			screensound EP1_END
			screensound EP1_END
			screensound EP1_END
			screensound EP1_END
		break
		case 1253 // episode 2 ending 	
			screensound EP2_END
			screensound EP2_END
			screensound EP2_END
			screensound EP2_END
			screensound EP2_END
		break
		case 1254 // episode 3 ending
			screensound EP3_END
			screensound EP3_END
			screensound EP3_END
			screensound EP3_END
			screensound EP3_END
		break
		case 1255 // episode 4 ending
			screensound EP4_END
			screensound EP4_END
			screensound EP4_END
			screensound EP4_END
			screensound EP4_END
		break
		endswitch
		
		startcutscene cutscene_ready
		ife marathon YES
		{
			add mlevel_bonus 1
			seta[].extra player[].max_player_health
			setuserdef[].display_bonus_screen YES
			ife cutscene_ready 1252
			{
				set cutscene_ready 0
				setuserdef[].level_number 7
				set epselect 1
				// startlevel 0 8
				state clearpweapons
				setp[].firstaid_amount 0
				setp[].scuba_amount 0
				setp[].holoduke_amount 0
				setp[].shield_amount 0
			}
			ife cutscene_ready 1253
			{
				set cutscene_ready 0
				setuserdef[].level_number 18
				set epselect 2
				// startlevel 0 19
				state clearpweapons
				setp[].firstaid_amount 0
				setp[].scuba_amount 0
				setp[].holoduke_amount 0
				setp[].shield_amount 0
			}
			ife cutscene_ready 1254
			{
				set cutscene_ready 0
				setuserdef[].level_number 29
				set epselect 3
				// startlevel 0 30
				state clearpweapons
				setp[].firstaid_amount 0
				setp[].scuba_amount 0
				setp[].holoduke_amount 0
				setp[].shield_amount 0
			}	
		}
		set cutscene_ready 0
		
	}
	
}

// fake bonus screen code
ifg gametype 0
ifg player[].timebeforeexit 10 ifl player[].timebeforeexit 60
ifl bonus_screen 4
{
	setuserdef[].display_bonus_screen NO
	state in_menu
	setp[].fta 0
	setp[].ftq 285
	ife bonus_screen 0 
	{
		stopallmusic
		setp[].timebeforeexit 0
		ifg bluescore redscore
		screensound BONUSMUSIC
		setp[].timebeforeexit 50 
		set bonus_screen 1 
		set timebonus endgametime
		// shiftr timebonus 1
		ife gametype SURVIVAL set timebonus 0
		add credits timebonus
		switch LEVEL
		case 11 set winbonus 4000 break
		case 13 set winbonus 7000 break
		case 14 set winbonus 6500 break
		case 15 set winbonus 8000 break
		case 16 set winbonus 8000 break
		case 17 set winbonus 7000 break
		case 18 set winbonus 6500 break
		case 21 set winbonus 9000 break
		case 25 set winbonus 10000 break
		case 26 set winbonus 12000 break
		default set winbonus 6500 break
		endswitch
		ife unbalanced YES add credits 3000
		add credits winbonus
		set pstarts 0
		set lastcredits credits
	}
	else
	ife bonus_screen 1 // just a buffer screen
	{
		ifle player[].timebeforeexit 20
		{
			set bonus_screen 2
			setp[].timebeforeexit 0 // otherwise sound will not play
			
			ife gametype SURVIVAL 
			{
				ife survivor_winner NO { set bluescore 0 set redscore 1000 }
				else { set bluescore 1000 set redscore 0 }
			}
			
			ifl bluescore redscore
			{
				rand temp 3
				ife temp 0 sound DUKE_KILLED5 else
				ife temp 1 sound DUKE_KILLED3 else
				ife temp 2 sound DUKE_KILLED1 else
				ife temp 3 sound DUKE_KILLED2
			}
			else
			{
				rand temp 3
				ife temp 0 sound BONUS_SPEECH1 else
				ife temp 1 sound BONUS_SPEECH2 else
				ife temp 2 sound BONUS_SPEECH3 else
				ife temp 3 sound BONUS_SPEECH4
			}
			
			
			screensound SHOTGUN_COCK
			setp[].timebeforeexit 50
		}
	}
	else
	{
		ife bonus_screen 2
		{
			ifl player[].timebeforeexit 20
			{
				set bonus_screen 3
				setp[].timebeforeexit 50
			}
		}
		else
		ife bonus_screen 3
		{
			set temp NO
			ifhitspace set temp YES
			ifvarand bits 1 set temp YES
			ifvarand bits 4 set temp YES
			ifn bits oldbits set temp YES
			ife temp YES
			{
				setp[].timebeforeexit 0
				screensound PIPEBOMB_EXPLODE
				ife gametype SURVIVAL 
				{
					ife survivor_winner NO { set bluescore 0 set redscore 1000 }
					else { set bluescore 1000 set redscore 0 }
				}
				ifl bluescore redscore 
				{ 
					set bonus_screen GAMEOVERSCREEN 
					getp[].player_par lastclock 
					stopsound BONUSMUSIC
					screensound GAMEOVERMUS
					getplayer[].ang oang
					getplayer[].horiz ohoriz
					break 
				}
				else
				{
					setp[].timebeforeexit 50
					set bonus_screen 4
				}
				
			}
			else
			{
				setp[].timebeforeexit 30
			}
		}
	}
}

 ife player[].fist_incs 32
 ife attmid 3
 ife attmode YES
	{
		endofgame 2
		set attmid 4
	}

ifg gametype 0
{
	ifg player[].timebeforeexit 0 ifl player[].timebeforeexit 5
	{
		startlevel 6 12
	}
}
else 
ifvarand player[].gm 8
{
	ifn attmode YES
	{
		readgamevar NEWENEMIES ife NEWENEMIES NO set NEWENEMIES RANDOMENEMIES
	}
	set mirror_thismap NO
	ife challenge YES set checkpoints YES else
	set checkpoints NO
	ife attmode YES
	{
		ife attmid 4
		{
		// add attbosses 1, ifge attbosses 5 set attbosses 0
		add attbeaten 1
		
		// savegamevar attbosses
		savegamevar attbeaten
		ifvarand charsel 4 orvar charlocked 4
		savegamevar charlocked
		screensound BIGCHEER
		starttrackslot 0 0
		set midscreen 16880
		set cutend totalclock
		add cutend 2000
		set cutmash 4
		startscreen
		stopsound BIGCHEER
		set midscreen 16881
		set cutmash 4
		set cutend totalclock
		add cutend 2000
		startscreen
		set midscreen 16882
		set cutmash 3
		set cutend totalclock
		add cutend 2000
		startscreen
		state writehighscores
		}
	}
	// else
	// ife VOLUME 0 ifge LEVEL 8 ifle LEVEL 18
	// {
		// setuserdef[].volume_number 1
		// set FAKEVOLUME 1
	// }
}




ifinwater 
{
	// horiz based movement code
	// 299 all the way up, -99 all the way down
	ifp palive
	{
		ifvarand bits 1 nullop else
		ifvarand bits 2 nullop else
		ifg extbits 0 ifl extbits 4
		{
			getp[].horiz z
			sub z 100 // 100 horiz equals straight ahead, so take away 100 and make 0 'straight ahead' for this
			
			set tempb z
			abs tempb
			div tempb 3
			set temp 100
			sub temp tempb
			
			getp[].posxv x
			mul x temp
			div x 100
			setp[].posxv x
			
			getp[].posyv y
			mul y temp
			div y 100
			setp[].posyv y
			
			mul z -19
			ifvarand extbits 2 mul z -1
			ifl z -2304 set z -2304
			setp[].poszv z
	
		}
	}
}
else
{
	ifg o2damage 0
	ifl sprite[player[].i].extra player[].max_player_health
	{
		// geta[player[].i].extra temp
		// add temp o2damage
		// ifg temp MAXPLAYERHEALTH set temp MAXPLAYERHEALTH
		// seta[player[].i].extra temp
		addphealth 1
		sub o2damage 1
	}

	
	ifp palive ifp prunning ifp ponground
	ife player[].quick_kick 0 ife player[].last_quick_kick 0 ife player[].knee_incs 0
	ife qk_proxy 0
	ife slidekick 0
	ife sidekick 0
	ife saberdash 0
	ifl PLAYERONTHEBIKE 1
	{
		set temp YES
		ifonwater ifn player[].spritebridge 1 set temp NO
		else
		ifn player[].kickback_pic 0
		{
			switch player[].curr_weapon
			case KNEE_WEAPON ife WEAPON0_SHOOTS KNEE set temp NO break
			case TRIPBOMB_WEAPON set temp NO break
			endswitch
		}
		ife temp YES
		{
			ifvarand bits 2 // pressing crouch
			ifg forwinput 5 // pressed forward for at least 6 tics
			ifvarand extbits 1 // and still pressing forward
			{
				set slidekick 1
				sound SLIDESOUND
				set slidehit NO
				setp[].weapon_pos -1
			}
			// see EVENT_KICKQUICK for starting a sidekick (NOT slidekick)
		}
	}
}

ifp ponground 
{
	set jumpkickhit NO
	ifl jumpkick 0 add jumpkick 1
	else
	ifg jumpkick 0 { set sidekick jumpkick set jumpkick 0 }
}
// see EVENT_QUICKKICK for jump kick trigger

ifg jumpkick 0
{
	ifl jumpkick 16
	iffloordistl 32
	{
		getp[].poszv z
		sub z 384
		setp[].poszv z
	}
	ifl jumpkick 18 
	setp[].weapon_pos -7
	setp[].quick_kick 0
	getp[].rotscrnang temp
	add temp 36
	ifg temp 60 set temp 60
	setp[].rotscrnang temp
	add jumpkick 1
	ife jumpkick 3 sound KICKOUT
	ifg jumpkick 5 ifl jumpkick 15 ife jumpkickhit NO shoot KNEE
	ifg jumpkick 23 { set jumpkick -10 set jumpkick NO }
	
	ifl jumpkick 20
	{
		cos kickfvel player[].ang
		sin kicksvel player[].ang
			
		mul kicksvel 160
		mul kickfvel 160
		
		ifg backinput 0 set jumpkick -10
		ifinwater set jumpkick -10
	}
}

ifg slidekick 0
{
	ifl slidekick 20 ifl player[].weapon_pos -8 
	{
		ife player[].curr_weapon KNEE_WEAPON
		ifg gotsaber 0 nullop else
		setp[].weapon_pos -8
	}
	getp[].rotscrnang temp
	add temp 36
	ifg temp 90 set temp 90 // 60
	setp[].rotscrnang temp
	add slidekick 1
	ife slidekick 5 sound KICKOUT
	ife slidekick 12 ife slidehit NO shoot KNEE
	ifg slidekick 26 { set slidekick 0 set slidehit NO }
	
	ifl slidekick 20
	{
		geta[].cstat temp
		ifvarand temp 256 { xorvar temp 256 seta[].cstat temp }
		cos kickfvel player[].ang
		sin kicksvel player[].ang
		ifvarand perks 4
		{
			mul kicksvel 200
			mul kickfvel 200
		}
		else
		{
			mul kicksvel 160
			mul kickfvel 160
		}
		ife sector[].lotag 1 { div kickfvel 2 div kicksvel 2 }
		headspritesect spriteid player[].cursectnum
		whilevarn spriteid -1
		{
			ife sprite[spriteid].picnum SECTOREFFECTOR
			ife sprite[spriteid].lotag 24 
			{
				set kicksvel 0
				set kickfvel 0
			}
			nextspritesect spriteid spriteid
		}
		ifg backinput 0 { set slidekick 0 cstator 256 }
		// ifinwater { set slidekick 0 cstator 256 }
		ifinwater cstator 256
	}
	else cstator 256
}
else ifp palive cstator 256

ifl sidekick 0 add sidekick 1
ifg sidekick 0
{
/*
	ife pchar 2
	{
		// switch sidekick
		// case 1 getp[].ang initkickang set kickang initkickang add kickang 342 break
		// case 2 add kickang 342 setp[].ang kickang break
		// case 3 add kickang 342 setp[].ang kickang break
		// case 4 add kickang 342 setp[].ang kickang break
		// case 5 add kickang 342 setp[].ang kickang break
		// case 6 add kickang 342 setp[].ang kickang break
		// case 7 setp[].ang initkickang break
		// endswitch
		ife sidekick 1 
		{
			ife player[].over_shoulder_on YES set over_shoulder YES else set over_shoulder NO
			setp[].over_shoulder_on YES
		}
		ife sidekick 10
		{
			ife over_shoulder NO setp[].over_shoulder_on NO
		}
	}
*/	
	setp[].quick_kick 0
	set qk_proxy 0
	ifl player[].weapon_pos -8 
	{
		// ifl sidekick 16 
		ife player[].curr_weapon KNEE_WEAPON
		ifg gotsaber 0 nullop else
		setp[].weapon_pos -8
	}
	getp[].rotscrnang temp
	ifge sidekick 51 ifle sidekick 99 sub temp 36 else
	add temp 36
	ifg temp 75 set temp 75
	ifl temp -75 set temp -75
	setp[].rotscrnang temp
	add sidekick 1
	
	set tempb NO
	ifvarand perks 4 set tempb YES
	ifg fastfire 0 set tempb YES
	// ife pchar 2 set tempb YES
	
	ifg sidekick 3 ife tempb YES ifvarand sidekick 1 
	ifn sidekick 23
	ifn sidekick 15
	ifn sidekick 31 ifn sidekick 37 ifn sidekick 45
	ifn sidekick 43 ifn sidekick 47
	ifn sidekick 55 ifn sidekick 63
	ifn sidekick 61
	ifn sidekick 69
	ifl sidekick 100
	ifn sidekick 127
		add sidekick 1
	
	ife sidekick 3 sound KICKOUT // start sidekick
	ife sidekick 34 sound KICKOUT // start roundhouse kick
	ife sidekick 52 sound KICKOUT // start of LEFT roundhouse
	
	ifge sidekick 15 ifle sidekick 16
	{
		ifvarand bits 4194304
		{
			set sidekick 30 // start of roundhouse kick
			set slidehit NO
		}
	}
	
	ifge sidekick 7 ifle sidekick 14 ife slidehit NO shoot KNEE
	
	ifge sidekick 40 ifle sidekick 43 
		ife slidehit NO shoot KNEE
		
	ifge sidekick 58 ifle sidekick 61
		ife slidehit NO shoot KNEE
	
	ife sidekick 50 
	{ 
	    set slidehit NO
		ifvarand bits 4194304 ifn kicktarg -1
		{
			set qk_proxy 15
			set sidekick 0
		}
		else
		{
			set kicktarg -1 set sidekick -6
		}
	}
	
	ife sidekick 69 
	{
		ifn kicktarg -1 
		ifvarand bits 4194304
		{
			set sidekick 100 getp[].ang kickang set initkickang kickang
		}
		else
		{
			set sidekick -6
			set kicktarg -1
		}
		set slidehit NO 
	}
	
	ife sidekick 23 { set kicktarg -1 set sidekick -6 set slidehit NO }
	
	set kicksvel 0
	set kickfvel 0
	
	ifge sidekick 100
	{
		set tempb NO
		ifvarand perks 4 set tempb YES
		ifg fastfire 0 set tempb YES
		ife pchar 2 set tempb YES
		ife tempb YES
		{
			switch sidekick
			case 101 case 103 case 105 case 107
				add sidekick 1
				add kickang 190
			break
			endswitch
		}
		ife sidekick 104 sound KICKOUT
		ifle sidekick 108 add kickang 190 else
		ifle sidekick 115 add kickang 76 else
		ifle sidekick 121 add kickang 32
		setp[].ang kickang
		ifge sidekick 108 ifl sidekick 123
		{
			shoot KNEE
			ifge sidekick 109
			ifle sidekick 115
			{
				getp[].ang angvar
				sub angvar 40
				setp[].ang angvar
				shoot KNEE
				add angvar 80
				setp[].ang angvar
				shoot KNEE
				setp[].ang kickang
			}
		}
		ifle sidekick 116
		{
			ife player[].curr_weapon KNEE_WEAPON
			ifg gotsaber 0 nullop else
			setp[].weapon_pos -8
		}
		
		cos kickfvel initkickang
		sin kicksvel initkickang
		
		ifle sidekick 123
		{
			ifvarand perks 4
			{
				mul kicksvel 160
				mul kickfvel 160
			}
			else
			{
				mul kicksvel 120
				mul kickfvel 120
			}
		}
	}
	ife sidekick 127 { set kicktarg -1 set sidekick -6 set slidehit NO setp[].ang initkickang }
	
	
	ifl sidekick 100
	{
		cos kickfvel player[].ang
		sin kicksvel player[].ang
		ifvarand perks 4
		{
			mul kicksvel 200
			mul kickfvel 200
		}
		else
		{
			mul kicksvel 160
			mul kickfvel 160
		}
		ifge sector[].lotag 1 ifle sector[].lotag 2 { div kickfvel 2 div kicksvel 2 }
		headspritesect spriteid player[].cursectnum
		whilevarn spriteid -1
		{
			ife sprite[spriteid].picnum SECTOREFFECTOR
			ife sprite[spriteid].lotag 24 
			{
				set kicksvel 0
				set kickfvel 0
			}
			nextspritesect spriteid spriteid
		}
		
	}
	
}
else
ife player[].quick_kick 0
ife qk_proxy 0
set kicktarg -1

ifn kicktarg -1
{
	geta[kicktarg].x x2
	geta[kicktarg].y y2
	sub x2 player[].posx
	sub y2 player[].posy
	getangle angvar x2 y2
	ifl sidekick 100
	setp[].ang angvar
	else set initkickang angvar
	ife actorvar[kicktarg].monstatus 2 set kicktarg -1 else
	ife sprite[kicktarg].statnum 1024 set kicktarg -1 else
	{
		ldist xydist THISACTOR kicktarg
		ifl xydist 640 { set kickfvel 0 set kicksvel 0 }
	}
}

ifn slidekick 0
{
	ifn kickfvel 0 setp[].posxv kickfvel
	ifn kicksvel 0 setp[].posyv kicksvel
}
else ifg jumpkick 0 ifl jumpkick 20
{
	setp[].posxv kickfvel
	setp[].posyv kicksvel
}
else
ifg sidekick 0
{
	ifn kickfvel 0 setp[].posxv kickfvel
	ifn kicksvel 0 setp[].posyv kicksvel
}

ifl kneecharge FULLKNEE add kneecharge 1

ife LASERMODE -4 // switching to comm gun FROM laser pistol
{
	ife player[].weapon_pos -9
	{
		set LASERMODE 3
		sound SELECT7
		setp[].ammo_amount PISTOL_WEAPON COMMAMMO 
	}
}
ife LASERMODE -2 // switching to comm gun
{
	ife player[].weapon_pos -9
	{
		set LASERMODE 3
		sound SELECT7
		setp[].ammo_amount PISTOL_WEAPON COMMAMMO 
	}
}
ife LASERMODE -3 // switching to laser pistol FROM comm gun
{
	ife player[].weapon_pos -9
	{
		set LASERMODE YES
		sound SWITCHTOLASER
		set WEAPON1_SELECTSOUND SWITCHTOLASER
		setp[].ammo_amount PISTOL_WEAPON LASERAMMO 
	}
}
ife LASERMODE -1 // switching to laser pistol
{
	ife player[].weapon_pos -9
	{
		set LASERMODE YES
		sound SWITCHTOLASER
		set WEAPON1_SELECTSOUND SWITCHTOLASER
		setp[].ammo_amount PISTOL_WEAPON LASERAMMO 
	}
}

set temp NO
ife LASERMODE 2 set temp YES
ife LASERMODE 4 set temp YES
ife temp YES // switching from laser pistol or comm gun to regular
{
	ife player[].weapon_pos -9
	{
		set LASERMODE NO
		ife pchar 0
		{
			// set WEAPON1_SELECTSOUND INSERT_CLIP
			ifvarand dukeupgrades[PISTOL_WEAPON] 8 sound GLOCKMAGIN
			else sound INSERT_CLIP
		}
		else 
		{
			set WEAPON1_SELECTSOUND DEAGLE_SLIDE
			sound DEAGLE_SLIDE
			
		}
		setp[].ammo_amount PISTOL_WEAPON pistolammo
	}
}


ife LASERAMMO 0
{
	ife LASERMODE YES
	{
		ife player[].curr_weapon PISTOL_WEAPON
		{
			ife player[].weapon_pos 0 setp[].weapon_pos -1
			else ife player[].weapon_pos -9 set LASERMODE NO
		}
		else set LASERMODE NO
	}
}
ife COMMAMMO 0
{
	ife LASERMODE 3
	{
		ife player[].curr_weapon PISTOL_WEAPON
		{
			ife player[].weapon_pos 0 setp[].weapon_pos -1
			else ife player[].weapon_pos -9 set LASERMODE NO
		}
		else set LASERMODE NO
	}
}

ifg LASERFIRE 0
{
	add LASERFIRE 1
	
	ife LASERMODE 1 // laser pistol
	{
		ife LASERFIRE 2 state firelaserpistol
		ifg LASERFIRE 8 set LASERFIRE 0
	}
	else
	ife LASERMODE 3 // comm gun
	{
		ife LASERFIRE 10 state firecommgun
		ifg LASERFIRE 18 set LASERFIRE 0
	}
	else
	set LASERFIRE 0
}

ife player[].curr_weapon PISTOL_WEAPON
{
	ife LASERMODE YES
	{
		set WEAPON1_SELECTSOUND SWITCHTOLASER 
		ifactorsound THISACTOR INSERT_CLIP
		{
			stopactorsound THISACTOR INSERT_CLIP globalsound SWITCHTOLASER
		}
		else
		ifactorsound THISACTOR GLOCKMAGIN
		{
			stopactorsound THISACTOR GLOCKMAGIN globalsound SWITCHTOLASER
		}
		else
		ifactorsound THISACTOR DEAGLE_SLIDE
		{
			stopactorsound THISACTOR DEAGLE_SLIDE globalsound SWITCHTOLASER
		}
	}
	else ife LASERMODE 3
	{
		set WEAPON1_SELECTSOUND SELECT7
		ifactorsound THISACTOR INSERT_CLIP
		{
			stopactorsound THISACTOR INSERT_CLIP globalsound SELECT7
		}
		else
		ifactorsound THISACTOR GLOCKMAGIN
		{
			stopactorsound THISACTOR GLOCKMAGIN globalsound SELECT7
		}
		else
		ifactorsound THISACTOR DEAGLE_SLIDE
		{
			stopactorsound THISACTOR DEAGLE_SLIDE globalsound SELECT7
		}
	}
	else
	{
		ife pchar 0
		{
			ifvarand dukeupgrades[PISTOL_WEAPON] 8 set WEAPON1_SELECTSOUND GLOCKMAGIN else
			set WEAPON1_SELECTSOUND INSERT_CLIP
		}
		else ife pchar 2 set WEAPON1_SELECTSOUND GLOCKMAGIN
		else set WEAPON1_SELECTSOUND DEAGLE_SLIDE
	}
}

ife rpgchange YES
{
	ifg player[].kickback_pic 20 set rpgchange NO
	ifn player[].curr_weapon RPG_WEAPON set rpgchange NO
}

ifvarand shellyupgrades[RPG_WEAPON] 1 nullop else
ife pchar 1
ife player[].curr_weapon RPG_WEAPON
ife player[].kickback_pic 18 sound RPGLOAD

ife player[].gotweapon DEVISTATOR_WEAPON 0 
{
	ifvarand gotrailgun 2 
	{
		set gotrailgun 0
		state switchrailgun
	}
}

ifvarand gotrailgun 4 nullop else
ifvarand gotrailgun 8 nullop else
ife player[].ammo_amount DEVISTATOR_WEAPON 0
ife player[].weapon_pos 0
ife player[].kickback_pic 0
{
	ifvarand gotrailgun 2
	{
		ifg railgunammo 0
		{
			ife player[].curr_weapon DEVISTATOR_WEAPON
			{
				orvar gotrailgun 8
				setp[].weapon_pos -1
			}
			else
			{
				xorvar gotrailgun 2
				state switchrailgun
				setp[].ammo_amount DEVISTATOR_WEAPON railgunammo
				set railgunammo 0
			}
		}
	}
	else
	{
		ifg railgunammo 0
		ifvarand gotrailgun 1
		{
			ife player[].curr_weapon DEVISTATOR_WEAPON
			{
				orvar gotrailgun 4
				setp[].weapon_pos -1
			}
			else
			{
				orvar gotrailgun 2
				state switchrailgun
				setp[].ammo_amount DEVISTATOR_WEAPON railgunammo
				set railgunammo 0
			}
		}
	}
}

ife player[].gotweapon FREEZE_WEAPON 0 
{
	ifvarand gotplasma 2 
	{
		set gotplasma 0
		state switchplasma
	}
}

ifvarand gotplasma 4 nullop else
ifvarand gotplasma 8 nullop else
ife player[].ammo_amount FREEZE_WEAPON 0
ife player[].weapon_pos 0
ife player[].gotweapon FREEZE_WEAPON YES
ife player[].kickback_pic 0
{
	ifvarand gotplasma 2
	{
		ifg plasmammo 0
		{
			ife player[].curr_weapon FREEZE_WEAPON
			{
				orvar gotplasma 8
				setp[].weapon_pos -1
			}
			else
			{
				xorvar gotplasma 2
				state switchplasma
				setp[].ammo_amount FREEZE_WEAPON plasmammo
				set plasmammo 0
			}
		}
	}
	else
	{
		ifg plasmammo 0
		ifvarand gotplasma 1
		{
			ife player[].curr_weapon FREEZE_WEAPON
			{
				orvar gotplasma 4
				setp[].weapon_pos -1
			}
			else
			{
				orvar gotplasma 2
				state switchplasma
				setp[].ammo_amount FREEZE_WEAPON plasmammo
				set plasmammo 0
			}
		}
	}
}

// switch to nuke if available and RPG empty
ife player[].ammo_amount RPG_WEAPON 0
ifg nukeamount 0
ife nukeselect NO
ifn player[].curr_weapon RPG_WEAPON
ife player[].weapon_pos 0
ife player[].kickback_pic 0
{
	set nukeselect YES
	setp[].ammo_amount RPG_WEAPON nukeamount
	set weap4ammo 0
	state switchnuke
}

ifvarand gotshock 4 // switching to EXECUTIONER
{
	ife player[].weapon_pos 10
	{
		setp[].curr_weapon CHAINGUN_WEAPON
		xorvar gotshock 4
		orvar gotshock 2	
		sound SWITCHTOLASER
		ife pchar 0 state dukeweapons else ife pchar 1 state shellyweapons
		else ife pchar 2 state wesweapons
	}
} 
else
ifvarand gotshock 8 // switching back to CHAINGUN
{
	ifn player[].curr_weapon CHAINGUN_WEAPON xorvar gotshock 8
	else
	ife player[].weapon_pos 10
	{
		xorvar gotshock 8
		xorvar gotshock 2
		
		ife pchar 1 { sound M4READY state shellyweapons } else
		ife pchar 2 { state wesweapons sound SELECT_WEAPON } else
		{
			state dukeweapons
			sound SELECT_WEAPON
		}
		
	}
}

ife nukeselect -1 // switching to nuke
{
	ife player[].weapon_pos 10
	{
		setp[].curr_weapon RPG_WEAPON
		set tempb player[].ammo_amount RPG_WEAPON
		ife tempb 1 set tempb 0
		setp[].ammo_amount RPG_WEAPON nukeamount
		set weap4ammo tempb
		// sound NUKEREADY
		set nukeselect YES
		state switchnuke
	}
}
ife nukeselect -2 // switching back to RPG
{
	ife player[].curr_weapon RPG_WEAPON
	{
		ife player[].weapon_pos 0
		ifg player[].kickback_pic 20
		{
			setp[].weapon_pos -1
		}
		ife player[].curr_weapon RPG_WEAPON
		ife player[].weapon_pos 10
		{
			set nukeselect NO
			setp[].ammo_amount RPG_WEAPON weap4ammo
			state switchnuke
			
		}
	}
	else
	{
		set nukeselect NO
		setp[].ammo_amount RPG_WEAPON weap4ammo
		state switchnuke
	}
}

ifvarand gotrailgun 4 // switching to railgun
{
	ife switchnew NO
	ifn player[].curr_weapon DEVISTATOR_WEAPON xorvar gotrailgun 4
	else
	ife player[].weapon_pos 10
	{
		setp[].curr_weapon DEVISTATOR_WEAPON
		xorvar gotrailgun 4
		orvar gotrailgun 2
		set tempb player[].ammo_amount DEVISTATOR_WEAPON
		setp[].ammo_amount DEVISTATOR_WEAPON railgunammo
		set railgunammo tempb
		sound RIFLEREADY
		state switchrailgun
		ife switchnew YES set switchnew NO
	}
} 
else
ifvarand gotrailgun 8 // switching back to devastator
{
	ife player[].weapon_pos 10
	{
		setp[].curr_weapon DEVISTATOR_WEAPON
		xorvar gotrailgun 8
		xorvar gotrailgun 2
		set tempb player[].ammo_amount DEVISTATOR_WEAPON
		setp[].ammo_amount DEVISTATOR_WEAPON railgunammo
		set railgunammo tempb
		sound SELECT_WEAPON
		state switchrailgun
	}
}

ife pchar 0
{
	ifvarand gotDB 4 // switching to DB shotty
	{
		ife player[].weapon_pos 10
		{
			setp[].curr_weapon SHOTGUN_WEAPON
			xorvar gotDB 4
			orvar gotDB 2
			
			sound DBCLOSE
			state dukeweapons
		}
	} 
	else
	ifvarand gotDB 8 // switching back to other shotgun
	{
		ifn player[].curr_weapon SHOTGUN_WEAPON xorvar gotDB 8
		else
		ife player[].weapon_pos 10
		{
			xorvar gotDB 8
			xorvar gotDB 2
			
			sound SHOTGUN_COCK
			state dukeweapons
		}
	}
}
else
{
	ifvarand gotDB 8 xorvar gotDB 8
	ifvarand gotDB 4 xorvar gotDB 4
}

ifge pchar 1 ifle pchar 2
{
	ifvarand gotbow 4 // switching to bow
	{
		ife player[].weapon_pos 10
		{
			setp[].curr_weapon SHOTGUN_WEAPON
			xorvar gotbow 4
			orvar gotbow 2
			
			sound SELECTBOW
			ife pchar 1 state shellyweapons else
			ife pchar 2 state wesweapons
		}
	} 
	else
	ifvarand gotbow 8 // switching back to shotgun
	{
		ifn player[].curr_weapon SHOTGUN_WEAPON xorvar gotbow 8
		else
		ife player[].weapon_pos 10
		{
			xorvar gotbow 8
			xorvar gotbow 2
			
			sound SHOTGUN_COCK
			ife pchar 1 state shellyweapons else
			ife pchar 2 state wesweapons
		}
	}
}
else
{
	ifvarand gotbow 8 xorvar gotbow 8
	ifvarand gotbow 4 xorvar gotbow 4
}

ifl combotime 0 
{
	getp[].weapon_pos temp
	ifl temp 0 ifg temp -8 set temp -8
	else
	ifg temp 1 ifl temp 8 set temp 1
	setp[].weapon_pos temp
	
}

ifvarand gotplasma 4 // switching to plasma
{
	ife player[].weapon_pos 10
	{
		setp[].curr_weapon FREEZE_WEAPON
		xorvar gotplasma 4
		orvar gotplasma 2
		set tempb player[].ammo_amount FREEZE_WEAPON
		setp[].ammo_amount FREEZE_WEAPON plasmammo
		set plasmammo tempb
		sound RIFLEREADY
		state switchplasma
	}
} 
else
ifvarand gotplasma 8 // switching back to freezer or incinerator
{
	ifn player[].curr_weapon FREEZE_WEAPON xorvar gotplasma 8
	else
	ife player[].weapon_pos 10
	{
		// setp[].curr_weapon FREEZE_WEAPON
		xorvar gotplasma 8
		xorvar gotplasma 2
		set tempb player[].ammo_amount FREEZE_WEAPON
		setp[].ammo_amount FREEZE_WEAPON plasmammo
		set plasmammo tempb
		sound SELECT_WEAPON
		state switchplasma
	}
}

ife player[].curr_weapon TRIPBOMB_WEAPON
{
	ife player[].weapon_pos 10
	{
		ifvarand gotspider 4 // switching to spider mines
		{
			ife pchar 0
			{
				set temp dukeupgrades[TRIPBOMB_WEAPON]
				orvar temp 1
				setarray dukeupgrades[TRIPBOMB_WEAPON] temp
				state dukeweapons
			}
			else
			ife pchar 1
			{
				set temp shellyupgrades[TRIPBOMB_WEAPON]
				orvar temp 1
				setarray shellyupgrades[TRIPBOMB_WEAPON] temp
				state shellyweapons
			}
			else 
			ife pchar 2
			{
				set temp wesupgrades[TRIPBOMB_WEAPON]
				orvar temp 1
				setarray wesupgrades[TRIPBOMB_WEAPON] temp
				state wesweapons
			}
			xorvar gotspider 4
		} 
		else
		ifvarand gotspider 8 // switching to tripbombs
		{
			ife pchar 0
			{
				set temp dukeupgrades[TRIPBOMB_WEAPON]
				ifvarand temp 1 xorvar temp 1
				setarray dukeupgrades[TRIPBOMB_WEAPON] temp
				state dukeweapons
			}
			else
			ife pchar 1
			{
				set temp shellyupgrades[TRIPBOMB_WEAPON]
				ifvarand temp 1 xorvar temp 1
				setarray shellyupgrades[TRIPBOMB_WEAPON] temp
				state shellyweapons
			}
			else
			ife pchar 2
			{
				set temp wesupgrades[TRIPBOMB_WEAPON]
				ifvarand temp 1 xorvar temp 1
				setarray wesupgrades[TRIPBOMB_WEAPON] temp
				state wesweapons
			}
			xorvar gotspider 8
		}
	}
}
else
{
	ifvarand gotspider 4 xorvar gotspider 4
	ifvarand gotspider 8 xorvar gotspider 8
}

ife player[].curr_weapon DEVISTATOR_WEAPON
	ifvarand gotrailgun 2 
{
	set temp NO
	ifn zoomin NO set temp YES
	ife pchar 0 ifvarand dukeupgrades[DEVISTATOR_WEAPON] 4 set temp YES
	ife pchar 1 ifvarand shellyupgrades[DEVISTATOR_WEAPON] 4 set temp YES
	ife pchar 2 ifvarand wesupgrades[DEVISTATOR_WEAPON] 4 set temp YES
	
	ife temp YES
	ife player[].kickback_pic 3
	{
		rand tempb 3
		add tempb 5
		set horizfall tempb
		set savedhoriz player[].horiz
		add tempb player[].horiz
		setp[].horiz tempb
	}
	ifn player[].weapon_pos 0 set zoomin NO
}
else
ife pchar 1
ife player[].curr_weapon CHAINGUN_WEAPON
{
	ifn player[].weapon_pos 0 set zoomin NO
}
else
 ifn zoomcount 7 set zoomin NO
 

ifvarand gotplasma 2 stopactorsound THISACTOR SAWBLADE_LOOP else
ife player[].curr_weapon FREEZE_WEAPON
ife pchar 2
{
	ifl sawpic 19920 set sawpic 19920

	ifaction APWESFROZEN nullop else
	ife player[].kickback_pic 0
	{
		// stopactorsound THISACTOR SAWATTACK
		
		ifactorsound THISACTOR SAWBLADE_LOOP nullop else ife idleanim 0 sound SAWBLADE_LOOP
		set B sawspeed, sub B 1, mul B 50
		setactorsoundpitch THISACTOR SAWBLADE_LOOP B
		// sawpic advancement code in the display code
		ifvarand extbits 64 add sawspeed 1 else 
		{
			ifge sawspeed 30 setp[].kickback_pic 1
			ifg sawspeed 1 sub sawspeed 1
		}
		ifg sawspeed 30 set sawspeed 30
	}
	else 
	{
		stopactorsound THISACTOR SAWBLADE_LOOP
		ifg sawspeed 25
		ifvarand wesupgrades[FREEZE_WEAPON] 1 ife player[].kickback_pic 5
		ifg player[].ammo_amount FREEZE_WEAPON 0
		{
			sound BLADE_FIRE
			shoot BLADEPROJ
			getp[].ammo_amount FREEZE_WEAPON temp
			sub temp 1
			setp[].ammo_amount FREEZE_WEAPON temp
		}
		ifg player[].kickback_pic 6 set sawspeed 1
	}
	
}
else
{
	// stopactorsound THISACTOR SAWATTACK
	stopactorsound THISACTOR SAWBLADE_LOOP
}

ifn player[].weapon_pos 0 { set zoomin NO set zoomcount 0 }

ife pchar 0 ife player[].curr_weapon CHAINGUN_WEAPON ife zoomin YES
{ set zoomin NO set zoomcount 0 }

ifg sub_maxactors 0
{
	getp[].max_actors_killed temp
	sub temp sub_maxactors
	setp[].max_actors_killed temp
	set sub_maxactors 0
}

ifvarand oldextbits 64
{
	ifn player[].kickback_pic 0 xorvar oldbits 268435456
	else
	ifn player[].weapon_pos 0 xorvar oldbits 268435456
}

ife attmode YES
{
	ifvarand player[THISACTOR].gm 8
	ifvare GMCHECK 0
	{
		setvar GMCHECK 1
		// state savestatus
		// state resetammo
		setactor[THISACTOR].extra player[THISACTOR].max_player_health
		setplayer[THISACTOR].jetpack_amount 0
		addvar attfinished 1
		set temp attfinished
		mul temp 1000
		add totalxp temp
		addvar leveltoken 1
	}
	// following code moved to end of player actor because otherwise it breaks the game
	// if any music files are missing or any paths are incorrect since
	// eduke32 idiotically aborts the rest of the actor on any error
	// ifn attmusic -1
	// {
		// ife userdef[].music_episode 0
		// ife userdef[].music_level attmusic
		// nullop
		// else starttrackslot 0 attmusic
	// }
}

ifn SAVEDANGCOUNT 0
	sub SAVEDANGCOUNT 1

ifp palive
{
	ifg player[].falling_counter 62 set falldeath YES
	else ife player[].hard_landing 0 
	{
		ifinouterspace nullop else
		ifsquished nullop else
		set falldeath NO
	}
	
	ifg player[].secret_rooms secrets
	{
		ifn attmode 0 add totalxp 500
		ifsound SECRETFOUND nullop else
		screensound SECRETFOUND
		set secrets player[].secret_rooms
	}
	// add wakecount 1
	// ifg wakecount 10
	// {
		// ifg player[].cursectnum -1
		// {
			// getp[].cursectnum mysector
			// set tempc YES
			// headspritesect spriteid mysector
			// whilevarn spriteid -1
			// {
				// ife sprite[spriteid].picnum SECTOREFFECTOR
				// ife sprite[spriteid].lotag 7 set tempc YES
				// nextspritesect spriteid spriteid
			// }
			
			// ife tempc NO spawn WAKEY
		// }
		// set wakecount 0
	// }
	
	ifaction PFROZEN nullop else
	ifaction ALTDUKEFROZEN nullop else
	ifaction APSHELLYFROZEN nullop else
	ifaction APWESFROZEN nullop else
	ife player[].curr_weapon KNEE_WEAPON
	ifn pchar 2
	ife gotsaw YES
	ife WEAPON0_SHOOTS SAWPROJ
	{
		ife pchar 0 ifg sawpic 7644 set sawpic DUKESAWSTART
		ife pchar 1 ifl sawpic SAWSTART set sawpic SAWSTART
		ife player[].kickback_pic 0
		{
			stopactorsound THISACTOR SAWATTACK
			ifactorsound THISACTOR SAWIDLE nullop else sound SAWIDLE
			add sawpic_count 1
			ifge sawpic_count 2
			{
				set sawpic_count 0
				add sawpic 1
				ife pchar 1 ifg sawpic 8861 set sawpic SAWSTART
				ife pchar 0 ifg sawpic 7644 set sawpic DUKESAWSTART
			}
		}
		else
		{
			stopactorsound THISACTOR SAWIDLE
			ifactorsound THISACTOR SAWATTACK nullop else sound SAWATTACK
		}
	}
	else
	{
		stopactorsound THISACTOR SAWATTACK
		stopactorsound THISACTOR SAWIDLE
	}
	
	ife player[].rapid_fire_hold YES // pipebomb ready to be thrown
	{
		ifl pipehold 192 add pipehold 8
		ifp pducking nullop else
		ife pchar 0
		{
			set pipecount 0
			set xvel 192
			add xvel pipehold
			getp[].horiz zdist
			sub zdist 100
			mul zdist -2048
			div zdist 56
			getp[].posx x
			getp[].posy y
			getp[].posz z
			getp[].ang angvar
			whilevarn pipecount 130
			{
				set x2 x
				add x2 xvel
				sub xvel 5
				ifl xvel 0 set xvel 0
				rotatepoint x y x2 y angvar x y
				espawn LOBTRAIL
				set temp player[].cursectnum
				updatesectorz x y z temp
				ife temp -1 set pipecount 129 else
				changespritesect RETURN temp
				seta[RETURN].x x
				seta[RETURN].y y
				seta[RETURN].z z
				seta[RETURN].htbposx x
				seta[RETURN].htbposy y
				seta[RETURN].htbposz z
				setav[RETURN].countvar pipecount
				add z zdist
				add zdist 264
				add pipecount 1
			}
		}
	}
	else ife player[].kickback_pic 0 set pipehold 0
	ifn player[].curr_weapon HANDBOMB_WEAPON set pipehold 0
	
	// breadcrumb code
	
	add breadcount 1
	ifg breadcount 5
	{
		set breadcount 0
		espawn BREADCRUMB
		setav[RETURN].mtype player[].player_par
		seta[RETURN].xrepeat 32
		seta[RETURN].yrepeat 32
		seta[RETURN].z player[].posz
		changespritestat RETURN 999
	}

	ifg burning 0 state imonfire
	else ifl burning 0 add burning 1
	ifg stun 0 
		sub stun 1
		
	ifvarn player[].cursectnum -1
	{
		getp[].cursectnum mysector
		ifn sector[mysector].floorslope 0
		{
			getflorzofslope mysector player[].posx player[].posy z
			// posz is normally 9748 higher (less z) than surface
			// the diff is reduced by about 512 for 1st tic of jump, then increases
			// after landing, the diff is reduced again for a few tics
			// when fully crouched, the diff is 4609
			getp[].posz temp
			add temp 9748
			sub temp z
			// we want to allow jumping when temp is slightly negative
			
			ifvarand bits 1
			ife player[].jumping_counter 0
			ifg temp -3804
			ife player[].jumping_toggle 0
			ifn sector[].lotag 1
			ifn sector[].lotag 2
			{
				setp[].jumping_counter 1
			}
			
		}
	}
	ife player[].ftq 80 setp[].fta 0
	
	set temp NO
	ife pchar 1 ifvarand shellyupgrades[TRIPBOMB_WEAPON] YES set temp YES
	ife pchar 0 ifvarand dukeupgrades[TRIPBOMB_WEAPON] YES set temp YES
	ife pchar 2 ifvarand wesupgrades[TRIPBOMB_WEAPON] YES set temp YES
	ife temp YES
	{
		ife player[].weapon_pos 0
		set WEAPON8_WORKSLIKE 6
		else set WEAPON8_WORKSLIKE 8
	}
	
	// AIMBOT CODE
	ife aimbot_on YES
	{
		set bluetimer 0
		set safecount bottarget
		state targetsearch
		ife bottarget myshelly set bottarget -1 // failsafe
		ifn bottarget -1
		{
			ifn bottarget safecount sound AIMBOT_LOCK
			state turntotarget
			state turntotarget
			
			geta[bottarget].z zdist
			
			
			set TMP_A tiledata[sprite[bottarget].picnum].ysize
			mul TMP_A sprite[bottarget].yrepeat
			shiftl TMP_A 1
			add TMP_A 2048
			// TMP_A is now overall z size of target; how far up from the feet to strike
			// for comparison a standard liztroop would have a TMP_A of 78*40*2+2048==8228
			sub zdist TMP_A
			
			sub zdist player[].posz
			
			ldist xydist THISACTOR bottarget
			mul zdist -8
			div zdist xydist
			add zdist 100
			setp[].horiz zdist
		}
		getp[].heat_amount temp
		sub temp 1
		ifl temp 0 set temp 0
		setp[].heat_amount temp
		ifl temp 1 { set aimbot_on NO sound NITEVISION_ONOFF quote 710 }
		
	}

	// DOUBLE JUMP CODE
	ifvarand oldbits 1 nullop else
	// ifg player[].boot_amount 0
	// ifvarand inven_upgrades 8
	ife pchar 3 // Mando
	ifvarand bits 1
	ifn player[].poszv 0
	ife doublejump NO
	{
		iffloordistl 2 nullop else
		ifinwater nullop else
		{
			set doublejump 1
			ifl player[].poszv 0 setp[].poszv -1024
			sound DOUBLEJUMPSND
			// getp[].boot_amount temp
			// sub temp 2
			// ifl temp 0 set temp 0
			// setp[].boot_amount temp
		}
		
	}
	
	ifn doublejump 0
	{
		ifl doublejump 0 
		{
			sub doublejump 1
			ifg doublejump -15 setp[].falling_counter 0
		}
		
		ifl doublejump 45
		ifg doublejump 0
		{
			ifvarand bits 1
			{
				getp[].poszv z
				sub z 416
				set temp doublejump
				ifg temp 30 set temp 30
				mul temp 12
				add z temp
				setp[].poszv z
			}
			// else add doublejump 2
			
			add doublejump 1
			ifle doublejump 10 iffloordistl 2 { getp[].posz z sub z 512 setp[].posz z }
			setp[].falling_counter 0
			ifge doublejump 45 set doublejump -1
		}
		iffloordistl 2 
		{
			set temp NO
			ifg doublejump 10 set temp YES
			ifl doublejump 0 set temp YES
			ife temp YES
			{
				set doublejump NO
				stopsound DOUBLEJUMPSND
			}
		}
	}

	ifn triphack -1
	{
		ifn player[].curr_weapon 8 set triphack -1
		else
		{
			ife player[].kickback_pic 4
			{
				// getp[].ammo_amount 8 temp
				// sub temp 1
				// setp[].ammo_amount 8 temp
				espawn TRIPBOMBSPRITE
				setsprite RETURN tripx tripy tripz
				seta[RETURN].cstat 32
				seta[RETURN].ang player[].ang
				seta[RETURN].mdflags 16
				seta[RETURN].yoffset -10
				setav[RETURN].mtype 1
				sound LASERTRIP_ONWALL
				set triphack -1
			}
		}
	}
	ifg drinkcola 0
	{
		add drinkcola 1
		
		set temp NO
		ifg sprite[].htextra 0 set temp YES
		ifand bits 4 set temp YES
		ifand extbits 64 set temp YES
		
		ife temp YES
		{
			set drinkcola 0
			espawn COLACANSIDE
			seta[RETURN].pal snackpal
			setav[RETURN].droptile snackpic
			geta[RETURN].z z, sub z 5120, seta[RETURN].z z
			stopsound SODA_OPEN
		}
		
		ife drinkcola 4 sound SODA_OPEN
		ifg drinkcola 12 soundonce DUKE_TAKEPILLS
		ife drinkcola 40 
		{
			set tempb healthbuff
			div tempb 15
			
			geta[].extra temp
			add temp tempb
			
			set tempb healthbuff
			add tempb 20
			ifg temp tempb set temp tempb
			seta[].extra temp
			
			palfrom 16 0 32 
			set drinkcola 0 
			set snackpic 0
			ifrnd 64 sound DUKE_USEMEDKIT
		}
	}
	ifg eatsnack 0
	{
		add eatsnack 1
		set temp NO
		ifg sprite[].htextra 0 set temp YES
		ifand bits 4 set temp YES
		ifand extbits 64 set temp YES
		
		ife temp YES
		{
			set eatsnack 0
			espawn SNACKSPRITE
			seta[RETURN].pal snackpal
			ife snackpic SNACKSPRITE setav[RETURN].droptile 1 else
			setav[RETURN].droptile snackpic
			geta[RETURN].z z, sub z 5120, seta[RETURN].z z
			stopsound EAT_SNACK
		}
		ife eatsnack 2 sound EAT_SNACK
		ife eatsnack 40 
		{
			set tempb healthbuff
			div tempb 15
			
			geta[].extra temp
			add temp tempb
			
			set tempb healthbuff
			add tempb 20
			ifg temp tempb set temp tempb
			seta[].extra temp
			
			palfrom 16 0 32 
			set eatsnack 0 
			set snackpic 0
			ifrnd 64 sound DUKE_USEMEDKIT
		}
	}
	
	

	ife player[].player_par 2 
	{
		set ATTLEVEL -1
		setvar GMCHECK 0
		setuserdef[].display_bonus_screen 1
		set gun_nametime 100
		set init_picnums 0 
		set raining rainstart 
		set wantrain raining
		set rainstart 0 
		set prevsawtime 0
		ifn AUTOSAVE YES set lastsave 999999 else
		set lastsave 2
		ifn mynavsprite -1 ife sprite[mynavsprite].picnum NAVSPRITE
			setav[mynavsprite].monstatus 2
		set mynavsprite -1
		ife VOLUME 6 ifg LEVEL 11 ifl LEVEL 38
		{
			strength MAXPLAYERHEALTH
			ifg gametype 0 set radaron YES
			else ife gametype 0 ifvarand perks 2 ifn radaron -1 set radaron YES
			else set radaron NO
		}
		else
		{
			ifvarand perks 2 ifn radaron -1 set radaron YES else
			set radaron NO
		}
		
		ife wesreplace 1 // wes replaces duke
		{
			ife pchar 0 set pchar 2
			ifvarand charsel 1
			{
				xorvar charsel 1
				orvar charsel 4
			}
			ifvarand startmode 1
			{
				xorvar startmode 1
				orvar startmode 4
			}
		}
		ife wesreplace 2 // wes replaces bombshell
		{
			ife pchar 1 set pchar 2
			ifvarand charsel 2
			{
				xorvar charsel 2
				orvar charsel 4
			}
			ifvarand startmode 2
			{
				xorvar startmode 2
				orvar startmode 4
			}
		}

		ife pchar 0 { setp[].palookup dukepal seta[].pal dukepal setuserdef[].color dukepal }
		ife pchar 1 { setp[].palookup shellypal seta[].pal shellypal setuserdef[].color shellypal }
		ife pchar 2 
		{ 
			setp[].palookup wespal seta[].pal wespal setuserdef[].color wespal 
			ifn startguns 0 ife gotsaber 0 set gotsaber 1
		}
		
		ife startmode 1
		{
			set pchar 0
			set numchars 1
			state dukeweapons
		}
		else
		ife startmode 2
		{
			set pchar 1
			set numchars 1
			state shellyweapons
		}
		else ife startmode 3
		{
			set numchars 2
			ife pchar 0
			{
				state dukeweapons
				ife VOLUME 6 ife LEVEL 12 ifg visited[LEVEL] 1 nullop else
				{
					set temp YES
					headspritestat spriteid 1
					whilevarn spriteid -1
					{
						ife sprite[spriteid].picnum SHELLY set temp NO
						ife sprite[spriteid].picnum SHELLYCROUCH set temp NO
						nextspritestat spriteid spriteid
					}
					ife temp YES
					spawn SHELLY
				}
			}
			else 
			{
				ife pchar 2 state wesweapons else
				ife pchar 1 state shellyweapons
				ife VOLUME 6 ife LEVEL 12 ifg visited[LEVEL] 1 nullop else
				{
					set temp YES
					headspritestat spriteid 1
					whilevarn spriteid -1
					{
						ife sprite[spriteid].picnum DUKEBOT set temp NO
						ife sprite[spriteid].picnum DUKEBOTCROUCH set temp NO
						nextspritestat spriteid spriteid
					}
					ife temp YES
					spawn DUKEBOT
				}
			}
		}
		else
		ifg startmode 0
		{
			// all other player combos that are not D&B
			ifvarand startmode 1 // spawn DUKEBOT
			{
				ife pchar 0 state dukeweapons else
				ifl visited[LEVEL] 2
				{ espawn DUKEBOT set myshelly RETURN }
			}
			
			ifvarand startmode 2 // spawn SHELLY
			{
				ife pchar 1 state shellyweapons else 
				ifl visited[LEVEL] 2
				{ espawn SHELLY set myshelly RETURN }
			}
			ifvarand startmode 4 // spawn WESBOT
			{
				ife startmode 4 set pchar 2
				ife pchar 2 state wesweapons else 
				ifl visited[LEVEL] 2
				{ espawn WESBOT set myshelly RETURN }
			}
			ifvarand startmode 8 // spawn MANDOFETT
			{
				ife startmode 8 set pchar 3
				ife pchar 3 nullop else 
				ifl visited[LEVEL] 2
				{ espawn MANDOFETT set myshelly RETURN seta[RETURN].pal 3 }
			}
			ifvarand startmode 16 // spawn DEANOVA
			{
				ife startmode 16 set pchar 4
				ife pchar 4 nullop else 
				ifl visited[LEVEL] 2
				{ espawn DEANOVA set myshelly RETURN }
			}
		}
		ife gametype -1 // this should only happen in the gladitorium
		{
			getp[].player_par curr_tick
			add curr_tick 1
			headspritestat spriteid 980
			whilevarn spriteid -1
			{
				setav[spriteid].redflagval 0
				setav[spriteid].rediteration 99999
				setav[spriteid].redtimer curr_tick
				nextspritestat spriteid spriteid
			}
			rand countvar 4
			set spriteid 0
			whilevarn spriteid 16384
			{
				ife sprite[spriteid].picnum NAVSPRITE
				ifn sprite[spriteid].statnum 1024
				ifn actorvar[spriteid].mtype 6
				{
					add countvar 1
					ifg countvar 4
					{
						set countvar 0
						espawn DUMCIV
						setsprite RETURN sprite[spriteid].x sprite[spriteid].y sprite[spriteid].z
					}
				}
				ife sprite[spriteid].picnum DEANOVA
				ifl actorvar[spriteid].SPRITELOTAG 0
					setav[spriteid].monstatus 2
				add spriteid 1
			}
			seta[].extra player[].max_player_health
		}
		ifn vrtrip 0 seta[].extra player[].max_player_health
		
		// ife VOLUME 4
		// ifge LEVEL 10
		// {
			// set attmode 2
			// set switchmode NO
			// set vendorupgrade NO
			// set PROGRESSION YES
			// set NEWENEMIES NO
			// set radaron YES
		// }
		
		ife attmode YES
		{
			setp[].jetpack_amount 0
			ifstrength MAXPLAYERHEALTH strength MAXPLAYERHEALTH
			set NEWENEMIES YES
			// ife attfinished 0
				// set vendor_screen -20
				
			// state clearpweapons
			
			// 1 = pistol
			// 2 = shotgun
			// 4 = chaingun
			// 8 = RPG
			// 16 = pipebombs
			// 32 = shrinker or bmfg
			// 64 = devastator
			// 128 = spider-bombs or tripbombs
			// 256 = freezer or incinerator
			// 512 = babifier or shock rifle
			// 1024 = terminator gun
			// 2048 = light saber
			// 4096 = chainsaw
			// 8192 = alien blaster
			// 16384 = railgun or penetrator
			
			// start with two weapons
			set startguns 0
			// rand temp 5
			rand temp 5
			add temp 1
			switch temp
			// case 0 orvar startguns 1 break
			case 1 orvar startguns 2 break
			case 2 orvar startguns 4 break
			case 3 orvar startguns 256 break
			case 4 orvar startguns 512 break
			case 5 orvar startguns 1024 break
			case 6 orvar startguns 32768 break
			endswitch
			rand temp 6
			switch temp
			case 0 orvar startguns 8 break
			case 1 orvar startguns 16 break
			case 2 orvar startguns 32 break
			case 3 orvar startguns 64 break
			case 4 orvar startguns 128 break
			case 5 orvar startguns 2048 break
			case 6 orvar startguns 16384 break
			endswitch
			ife attmid 1 ife VOLUME 5 ife LEVEL 11 set startguns 0 
			state applystartguns
			ife VOLUME 5 ife LEVEL 11 setp[].ammo_amount PISTOL_WEAPON 0
			ife attmid 3
			{
				set bigmsg 1154
				set bigmsgcount 90
				mul leveltoken 1000
				add credits leveltoken
				add lastcredits leveltoken
				set leveltoken 0
				globalsound GETCOINS
			}
		}
		state wakeupcivs // for kill counter accuracty

	}
	// else ife myshelly -1
	// ifg numchars 1
	// {
		// ifvarand startmode 1 // spawn DUKEBOT
		// {
			// ifn pchar 0
			// ifl visited[LEVEL] 2
			// { espawn DUKEBOT set myshelly RETURN }
		// }
		
		// ifvarand startmode 2 // spawn SHELLY
		// {
			// ifn pchar 1 
			// ifl visited[LEVEL] 2
			// { espawn SHELLY set myshelly RETURN }
		// }
		// ifvarand startmode 4 // spawn WESBOT
		// {
			// ifn pchar 2
			// ifl visited[LEVEL] 2
			// { espawn WESBOT set myshelly RETURN }
		// }
		// ifvarand startmode 8 // spawn MANDOFETT
		// {
			
			// ifn pchar 3
			// ifl visited[LEVEL] 2
			// { espawn MANDOFETT set myshelly RETURN seta[RETURN].pal 3 }
		// }
		// ifvarand startmode 16 // spawn DEANOVA
		// {
			
			// ifn pchar 4
			// ifl visited[LEVEL] 2
			// { espawn DEANOVA set myshelly RETURN }
		// }
	// }
}
else
{
	// setp[].runspeed RUNNINGSPEED
	set triphack -1
	set drinkcola 0
	stopactorsound THISACTOR SAWATTACK
	stopactorsound THISACTOR SAWIDLE
}

ife input[].fvel 0 ife input[].svel 0
{
	rand stepcount 32000
	// ife player[].transporter_hold 0
	// {
		// ifg decay 1
		// {
			// cos xvel moveang
			// sin yvel moveang
			// mul xvel decay
			// mul yvel decay
			// setp[].posxv xvel
			// setp[].posyv yvel
		// }
		// else { setp[].posxv 0 setp[].posyv 0 }
		// mul decay 5 div decay 6
	// }
}
// else 
// {
	// getp[].posxv logxv getp[].posyv logyv
	// getangle moveang logxv logyv
	// abs logxv abs logyv
	// add logxv logyv
	// sqrt logxv decay
	// shiftr decay 4
	// ifn player[].transporter_hold 0 set decay 0
// }

ife STEPSOUNDS YES ifp palive 
ifl PLAYERONTHEBIKE 1
state stepsoundstuff	 

ife startmode -1 set gamespeed 120 else
{
	ifp ponsteroids ife player[].timebeforeexit 0 
	{
		set gamespeed 80 
		set fastfire 3
	}
	else
	set gamespeed 120
	
	// ife SKILL 5 // GDTD
	// {
		// ife gametype 0
		// {
			// mul gamespeed 3
			// div gamespeed 2
		// }
		// else
		// {
			// mul gamespeed 4
			// div gamespeed 3
		// }
	// }
}

inittimer gamespeed

ife player[].timebeforeexit 0 ifn exit 0 { setp[].timebeforeexit exit set exit 0 }

state checkhitscan

ifn shootswitch 0 
{ 
	getp[].posz savz sub savz 256 setp[].posz savz shoot SWITCHBULLET
	add savz 256 setp[].posz savz
}

ifg shootswitch 0 sub shootswitch 1

// ife player[].heat_on YES
ife zoomin YES
{
	ife vr -1
	{
		set vrhi viewingrange
		set vrlo vrhi
		ife zoomlevel 2 { mul vrlo 2 div vrlo 3 }
		else div vrlo zoomlevel
		set vr vrhi
	}
	
	ifg vr vrlo 
	{
		sub vr 4096 // 3072
		ifl vr vrlo set vr vrlo
		ife player[].curr_weapon CHAINGUN_WEAPON set vr vrlo
	}

	set temp MAPVISIBILITY, sub temp 96  // vis range
	set tempc vrhi, sub tempc vrlo  // vr range, we could just take vrlo...

	set tempb vr, sub tempb vrlo  // vr-vrlo
	mul tempb temp, div tempb tempc  // ((vr-vrlo)*(hivis-lovis))/(vrhi-vrlo)
	add tempb 96

	setuserdef[].const_visibility tempb
	
	// getp[].ohoriz temp
	set temp ohoriz
	getp[].horiz tempb
	sub tempb temp
	ifn cameraoffset 0
	{
		ifl tempb 0
		add cameraoffset tempb
		ifl cameraoffset 0 set cameraoffset 0
	}
/*
	ifn tempb 1 ifn tempb -1
	{
		shiftvarr tempb 1
		add temp tempb
		setp[].horiz temp
	}
	
	// getp[].oang temp

	getp[].ang tempb
	set temp oang
	getincangle tempb temp tempb
	ifn tempb 1 ifn tempb -1
	{
		shiftvarr tempb 1
		add temp tempb
		setp[].ang temp
	}
*/
}
else
{
	
	ife player[].heat_on YES
	{
		set temp DEFAULTVISIBILITY
		div temp 2
		setuserdef[].const_visibility temp
	}
	else
	ife aimbot_on YES
	{
		set temp DEFAULTVISIBILITY
		div temp 2
		setuserdef[].const_visibility temp
	}
	else
	setuserdef[].const_visibility MAPVISIBILITY
	
	ifg vr 0 set vr vrhi else
	ife vr vrhi set vr -1
}

getplayer[].ang oang
getplayer[].horiz ohoriz



// ifvarand inven_upgrades 2 nullop else
ife player[].heat_on NO
ifl player[].heat_amount 180
ifand player[].player_par 4
{
	getp[].heat_amount temp
	add temp 1
	setp[].heat_amount temp
	ife player[].inven_icon 1 ife player[].firstaid_amount 0 setp[].inven_icon 5
}

// new inventory item hack
// 8 is the temporary cover item

ifg iframes 0 sub iframes 1
ifg iframehit 0 sub iframehit 1


// DAMAGE CODE
state predamage
geta[].htextra temp
ife pdown YES { set temp -1 seta[].htextra -1 }
ifg temp 0
ifn sprite[].htpicnum SHRINKSPARK
{
	geta[].htowner spriteid
	
	set mykiller spriteid
	ife actorvar[spriteid].team team
	ifn spriteid THISACTOR
	{
		shiftr temp 1 
		ife spriteid myshelly shiftr temp 1
		ifl temp 1 set temp 1
		ife gametype DM set temp -1
		seta[].htextra temp
	}
	getav[spriteid].shrunken tempb
	ifg tempb 20 ifl tempb SHRUNKCOUNT
	{
		ifg temp 1 { set temp 1 seta[].htextra 1 }
	}
	
	
	ifg temp 0
	{
		ifg iframes 0
		{
			ifn sprite[].htpicnum BURNING
			ifn sprite[].htpicnum RADWOUND
			{
				set temp -1
				seta[].htextra -1
				screensound IFRAMEHIT
				set iframehit 3
			}
		}
		else
		ifg iframes_max 0
		ifn sprite[].htpicnum BURNING
		ifn sprite[].htpicnum RADWOUND
			set iframes iframes_max

	}

	seta[].htextra temp
	ifg player[].shield_amount 0
	{
		getp[].shield_amount tempb
		ifg sprite[].htextra 1
		{
			div temp 2
			sub tempb temp
			ifl tempb 0 set tempb 0
			ifl temp 1 set temp 1
			seta[].htextra temp
			setp[].shield_amount tempb
		}
		
	}
	
	ifg sprite[].htextra 0
	// ife radaron YES
	{
		set damagefade 1
		
		geta[spriteid].x x
		geta[spriteid].y y
		sub x sprite[].x
		sub y sprite[].y
		getangle angvar x y
		
		getincangle tempd player[].ang angvar
		
		ifg tempd 0 set damagesprite 18532 else set damagesprite 18531
		abs tempd
		ifg tempd 640 set damagesprite 18533 else
		ifl tempd 128 set damagesprite 18530
	}
}

ifn es_type 0
{
	ifg es_lasthit player[].player_par set es_pic -1
	ifge es_pic 18832
	{
		set temp player[].player_par
		sub temp es_lasthit
		ifg es_hp 0
		{
			ifge temp 4 set es_pic -1
		}
		else
		{
			modvar temp 6
			ife temp 0 add es_pic 1
			ifg es_pic 18836 set es_pic -1
		}
	}
	set es_batterymax es_hpmax[es_type]
	add es_batterymax 25
	set temp 10
	set tempb es_speed[es_type]
	div tempb 2
	add temp tempb
	mul es_batterymax temp
	set tempb es_delay[es_type]
	mul tempb 3
	sub es_batterymax tempb
	div es_batterymax 2
	ifg es_battery es_batterymax set es_battery es_batterymax
	
	ifn gametype 0 set es_battery es_batterymax
	ife es_battery -1 set es_battery es_batterymax

	setp[].shield_amount 0
	ifg es_hp 0
	{
		ifg sprite[].htextra 0
		ifn sprite[].htpicnum SHRINKSPARK
		{
			set es_delaycount 0
			set es_speedcount 0
			
			setp[].pals_time sprite[].htextra
			ifg player[].pals_time 42 setp[].pals_time 42 else
			ifl player[].pals_time 16 setp[].pals_time 16
			sub es_hp sprite[].htextra
			ife sprite[].htpicnum SHOCKPROJ
			{
				sub es_hp sprite[].htextra
				ifl es_hp 0 set es_hp 0
			}
			set es_lasthit player[].player_par
			set es_pic 18832
			set es_alpha -1
			ifle es_hp 0 
			{
				stopactorsound THISACTOR HITSHIELD
				// palfrom 45 63 63 63
				set tempb es_hp abs tempb
				
				seta[].htextra tempb 
				set es_hp 0
				set tempe player[].posz add tempe 1024
				set x player[].posx
				add x 384
				rotatepoint player[].posx player[].posy x player[].posy player[].ang savx savy
				
				espawn SPARKFALL setsprite RETURN savx savy tempe
				espawn SPARKFALL setsprite RETURN savx savy tempe
				espawn SPARKFALL setsprite RETURN savx savy tempe
				espawn SPARKFALL setsprite RETURN savx savy tempe
				espawn SPARKFALL setsprite RETURN savx savy tempe
				espawn SPARKFALL setsprite RETURN savx savy tempe
				
				ife novatype 0 screensound SHIELDBREAK
				else ife novareset NO screensound SHIELDBREAK
				else
				{
					
					screensound SHIELDNOVA
					
					set novareset NO
					
					headspritestat tempI 1
					whilevarn tempI -1
					{
						ife actorvar[tempI].monstatus 1
						ifn actorvar[tempI].team team
						{
							ife novatype 2 set xydist 4096 else set xydist 5120
							dist xydist2 THISACTOR tempI
							ifle xydist2 xydist
							{
								// apply effects
								switch novatype
								case 1 // electric
									espawn SHOCK_ACTOR
									setsprite RETURN sprite[tempI].x sprite[tempI].y sprite[tempI].z
									setav[RETURN].myspawner tempI
									seta[tempI].htowner player[].i
									set tempb es_hpmax[es_type]
									shiftl tempb 1
									setav[tempI].stun tempb
									shiftr tempb 1
									add tempb 10
									seta[tempI].htextra tempb
									seta[tempI].htpicnum RPG
									seta[tempI].htowner player[].i
								break
								
								case 2 // frost
									espawn TRANSPORTERSTAR
									
									set z sprite[tempI].z
									sub z 8192
									setsprite RETURN sprite[tempI].x sprite[tempI].y z
									setav[RETURN].mtype 2
									seta[RETURN].xrepeat 32
									seta[RETURN].yrepeat 32
									seta[RETURN].pal 1
									seta[RETURN].cstat 2
									set tempb es_hpmax[es_type]
									add tempb 10
									shiftl tempb 1
									
									seta[tempI].htextra tempb
									seta[tempI].htpicnum FREEZEBLAST
									seta[tempI].htowner player[].i
								break
								
								case 3 // burning
									ifrnd 128 espawn BURNING else espawn BURNING2
									setsprite RETURN sprite[tempI].x sprite[tempI].y sprite[tempI].z
									set tempb es_hpmax[es_type]
									shiftl tempb 2
									setav[tempI].burning tempb
									shiftr tempb 4
									add tempb 10
									seta[tempI].htextra tempb
									seta[tempI].htpicnum SHOTSPARK1
									seta[tempI].htowner player[].i
								break
								
								case 4 // explosive
								break
								
								case 5 // babifier
								break
								endswitch
								
							}
						}
						nextspritestat tempI tempI
					}
					
				}
			}
			else 
			{
				// palfrom 40 63 63 63
				ifactorsound THISACTOR HITSHIELD nullop else ifactorsound THISACTOR HITSHIELD2 nullop else
				{
					ifrnd 128
					sound HITSHIELD else
					sound HITSHIELD2
				}
				seta[].htpicnum HITSHIELD
				seta[].htextra -1
			}
		}
	}
	else
	ifg sprite[].htextra 0
	{
		set es_delaycount 0
		set es_speedcount 0
	}
	
	ifp palive
	ife pdown NO
	{
		add es_delaycount 1
		ifge es_hp es_hpmax[es_type] ifn novatype 0 set novareset YES
		set shield_delay es_delay[es_type]
		
		// ife gametype 0 shiftl shield_delay 1 // time penalty for singleplayer
		
		ifn novatype 0 { mul shield_delay 4 div shield_delay 3 }
		ifge es_delaycount shield_delay // es_delay[es_type]
		{
			add es_speedcount 1
			ifge es_speedcount es_speed[es_type]
			{
				ifl es_hp es_hpmax[es_type]
				ifg es_battery 0
				{
					add es_hp 1
					sub es_battery 1
					set es_chargepal player[].player_par
					set es_speedcount 0
				}
			}
		}
	}
	else
	{
		ife sprite[].htpicnum SHRINKSPARK
		ifg es_hp 0 add es_battery es_hp
		
		set es_hp 0
		// set es_battery 0
		set es_delaycount 0
		set es_speedcount 0
	}
}
else set es_pic -1

ifg sprite[].htextra 0
ife pdown NO
{
	set temp NO
	ife sprite[].htpicnum SHOCKPROJ set temp YES
	ifvarand actorvar[sprite[].htowner].monstflags 1048576 set temp YES
	ife temp YES
	{
		add pshocked sprite[].htextra
		sub pshocked plevel
		ifl pshocked 15 set pshocked 15
		ifg pshocked 120 set pshocked 120
		ifactorsound THISACTOR BOS4_ATTACK nullop else sound BOS4_ATTACK
	}
}

ifg pshocked 0
{
	sub pshocked 1
	ife pshocked 0 { ifactorsound THISACTOR BOS4_ATTACK stopactorsound THISACTOR BOS4_ATTACK }
	set slidekick 0
	set sidekick 0
	set jumpkick 0
	setp[].jumping_counter 0
	set x player[].posxv
	div x 2 
	setp[].posxv x
	set y player[].posyv
	div y 2 
	setp[].posyv y
	set saberpos 0
	
	ifvarand player[].player_par 1
	{
		add shockframe 1
		ifg shockframe 21169 set shockframe 21167
	}
}



ifl sprite[].extra player[].max_player_health
{
	// make threshold depend on life percentage??
	ifge leach 50
	{
		set leach_hudtime 60
		// set temp leach
		// div temp 50
		// ifg leach_hud 0 add temp 1
		// ifg temp leach_hud set leach_hud temp
		sub leach 50
		addphealth 1
		add leach_hud 1
		ifsound HEARTBEAT nullop else { screensound HEARTBEAT screensound HEARTBEAT screensound HEARTBEAT }
	}
}
else { set leach 0 set leach_hud 0 set leach_hudtime 0 }
ifg leach_hudtime 0 
{
	sub leach_hudtime 1
	ife leach_hudtime 0 set leach_hud 0
}

ifg regenmax 0
{
	ifp palive
	{
		ifg sprite[].htextra 0 set regendelay 0
		
		ifl sprite[].extra regenmax
		{
			add regendelay 1
			ifg regendelay 150
			{
				set temp player[].player_par
				modvar temp 8
				ife temp 0 addphealth 1
			}
		}
		else set regendelay 0
	}
	else set regendelay 0
}

  ifaction 0
  {
    ife pchar 1 action APSHELLYSTAND else
	ife pchar 2 action APWESSTAND else
	ifvarand altcostume 2 action ALTDUKESTAND else
    action PSTAND
  }
  
  ife pchar 0
  ifvarand altcostume 8
  ifn player[].quick_kick 0
  ife qk_proxy 0
  {
		set qk_proxy player[].quick_kick
		setp[].quick_kick 0
  }
  

  ifg sprite[].htextra 0
  {
	  geta[].htowner spriteid
	  
	  ifvarand shellyupgrades[RPG_WEAPON] 1 nullop else
	  ife spriteid THISACTOR
	  ife sprite[].htpicnum RPG
	  ife rpgtype 1
	  ife pchar 1
		seta[].htpicnum FREEZEBLAST
	  
	  ife sprite[].htpicnum RANGERPROJ
	  ifn spriteid -1
	  ife userdef[].god NO
	  {
		geta[].htextra temp
		dist xydist THISACTOR spriteid
		ifg xydist 10240 // damage reduction on long range
		{
			geta[].htextra temp
			mul temp 10240
			div temp xydist
			seta[].htextra temp
		}
	  }
	  ifg gametype 0
	  ife userdef[].god NO
	  ifge sprite[].htextra sprite[].extra
	  {
		ife bluecarrier THISACTOR set bluecarrier -1
		ife redcarrier THISACTOR set redcarrier -1
		set monstatus 2
	  }
  }
  
set oldbits bits
set oldextbits extbits
set lastframerate framerate
  
  // ifaction PFROZEN
   set temp NO
  ifaction PFROZEN set temp YES
  ifaction APSHELLYFROZEN set temp YES
  ifaction ALTDUKEFROZEN set temp YES
  ifaction APWESFROZEN set temp YES
  
  ife temp YES
  {
    cstat 257

    fall

    palfrom 20 0 0 24

    ifmove 0
    {
      ifhitweapon
      {
        ifwasweapon FREEZEBLAST
          break
        state standard_pjibs
        ifrnd 84
          spawn BLOODPOOL2

        sound GLASS_BREAKING
        spawn ATOMICHEALTH

        getlastpal

        move 1
		set deathtime totalclock
		ifg gametype 0
		{
			ifn gametime -1
			{
				ife gametype DM { ife team 1 add redscore 1 else ife team 0 add bluescore 1 }
				else
				{
				ife team 1 add redscore 5 else
				ife team 0 add bluescore 5
				}
			}
			state playerscorecheck
		}
        break
      }
    }
    else
    {
      cstat 32768
	  state resetplayerstuff
      break
    }

    ifactioncount THAWTIME
    {
      getlastpal
      strength 1
      move 0
	  ife pchar 2 action APWESSTAND else
	  ife pchar 1 action APSHELLYSTAND else
	  ifvarand altcostume 2 action ALTDUKESTAND else
      action PSTAND 
    }
    else
      ifactioncount FROZENDRIPTIME
    {
      ifrnd 32
      spawn WATERDRIP
    }

    ifp pfacing   // assumes another other player  (multiplayer)
      ifpdistl FROZENQUICKKICKDIST
        state pkick_check

    break
  }

  ifdead
  {
    set temp NO
	ifaction PGROWING set temp YES
	ifaction APSHELLYGROWING set temp YES
	ifaction APWESGROWING set temp YES
	
    // ifaction PGROWING
	ife temp YES
    {
      ifmove PGROWINGPOP
      {
        state resetplayerstuff
        break
      }
      else
      {
        ifcount 32
        {
          sound SQUISHED
          palfrom 48 64

          state standard_pjibs

          guts JIBS4 20
          guts JIBS6 20
          move PGROWINGPOP
		  set deathtime totalclock
		    ifg gametype 0
			{
				ifn gametime -1
				{
					ife gametype DM { ife team 1 add redscore 1 else ife team 0 add bluescore 1 }
					else
					{
					ife team 1 add redscore 5 else
					ife team 0 add bluescore 5
					}
				}
				state playerscorecheck
			}
          cstat 32768
          ifmultiplayer tossweapon

          hitradius 2048 60 70 80 90

        }
        else
          sizeto MAXXSTRETCH MAXYSTRETCH
      }
      break
    }

    ifsquished
      palfrom 32 63 63 63
    else
      fall

    ifactioncount 7
      move 0
    else
      ifactioncount 6
    {
      ifmultiplayer nullop
      else
      {
	    ife VOLUME 6 ifl LEVEL 11 rand temp 7 else rand temp 5
		// temp 0 and temp 1 no death sound
		ife temp 2 sound DUKE_KILLED5 else
		ife temp 3 sound DUKE_KILLED3 else
		ife temp 4 sound DUKE_KILLED1 else
		ife temp 5 sound DUKE_KILLED2 else
		ife temp 6 sound VACA_DIE1 else
		ife temp 7 sound VACA_DIE2

      }
    }

    ifaction PLYINGDEAD
    {
      ifactioncount 3
        move PSTOPED
	  state resetplayerstuff
      break
    }
	
	ifaction ALTDUKELYINGDEAD
	{
	  ifactioncount 3
        move PSTOPED
	  state resetplayerstuff
      break
	}

    ifaction PTHROWNBACK
    {
      ifactioncount 5
      {
        spawn BLOODPOOL2
        action PLYINGDEAD
		set deathtime totalclock
		ifg gametype 0
		{
			ifn gametime -1
			{
				ife gametype DM { ife team 1 add redscore 1 else ife team 0 add bluescore 1 }
				else
				{
				ife team 1 add redscore 5 else
				ife team 0 add bluescore 5
				}
			}
			state playerscorecheck
		}
      }
      else
        ifactioncount 1
          move 0
      break
    }
	
	ifaction ALTDUKETHROWNBACK
    {
      ifactioncount 5
      {
        spawn BLOODPOOL2
		// ifvarand altcostume 2 xorvar altcostume 2
        action ALTDUKELYINGDEAD
		set deathtime totalclock
		ifg gametype 0
		{
			ifn gametime -1
			{
				ife gametype DM { ife team 1 add redscore 1 else ife team 0 add bluescore 1 }
				else
				{
				ife team 1 add redscore 5 else
				ife team 0 add bluescore 5
				}
			}
			state playerscorecheck
		}
      }
      else
        ifactioncount 1
          move 0
      break
    }
	
	

    ifaction PEXPLODEAD
    {
	  state resetplayerstuff
      break
    }
    ifaction PEXPLODE
    {
      ifactioncount 5
      {
        action PEXPLODEAD
        spawn BLOODPOOL2
		set deathtime totalclock
		ifg gametype 0
		{
			ifn gametime -1
			{
				ife gametype DM { ife team 1 add redscore 1 else ife team 0 add bluescore 1 }
				else
				{
				ife team 1 add redscore 5 else
				ife team 0 add bluescore 5
				}
			}
			state playerscorecheck
		}
      }
      break
    }
	
	ifaction ALTDUKEEXPLODEAD
    {
	  state resetplayerstuff
      break
    }
    ifaction ALTDUKEEXPLODE
    {
      ifactioncount 5
      {
        action ALTDUKEEXPLODEAD
        spawn BLOODPOOL2
		set deathtime totalclock
		ifg gametype 0
		{
			ifn gametime -1
			{
				ife gametype DM { ife team 1 add redscore 1 else ife team 0 add bluescore 1 }
				else
				{
				ife team 1 add redscore 5 else
				ife team 0 add bluescore 5
				}
			}
			state playerscorecheck
		}
      }
      break
    }
	
	
	
	ifaction APSHELLYLYINGDEAD
    {
      ifactioncount 3
        move PSTOPED
	  state resetplayerstuff
      break
    }
	
	ifaction APWESLYINGDEAD
    {
      ifactioncount 3
        move PSTOPED
	  state resetplayerstuff
      break
    }

    ifaction APSHELLYTHROWNBACK
    {
      ifactioncount 5
      {
        spawn BLOODPOOL2
        action APSHELLYLYINGDEAD
		set deathtime totalclock
		ifg gametype 0
		{
			ifn gametime -1
			{
				ife gametype DM { ife team 1 add redscore 1 else ife team 0 add bluescore 1 }
				else
				{
				ife team 1 add redscore 5 else
				ife team 0 add bluescore 5
				}
			}
			state playerscorecheck
		}
      }
      else
        ifactioncount 1
          move 0
      break
    }
	
	ifaction APWESTHROWNBACK
    {
      ifactioncount 6
      {
        spawn BLOODPOOL2
        action APWESLYINGDEAD
		set deathtime totalclock
		ifg gametype 0
		{
			ifn gametime -1
			{
				ife gametype DM { ife team 1 add redscore 1 else ife team 0 add bluescore 1 }
				else
				{
				ife team 1 add redscore 5 else
				ife team 0 add bluescore 5
				}
			}
			state playerscorecheck
		}
      }
      else
        ifactioncount 1
          move 0
      break
    }

    ifaction APSHELLYEXPLODEAD
    {
	  state resetplayerstuff
      break
    }
    ifaction APSHELLYEXPLODE
    {
      ifactioncount 5
      {
        action APSHELLYEXPLODEAD
        spawn BLOODPOOL2
		set deathtime totalclock
		ifg gametype 0
		{
			ifn gametime -1
			{
				ife gametype DM { ife team 1 add redscore 1 else ife team 0 add bluescore 1 }
				else
				{
				ife team 1 add redscore 5 else
				ife team 0 add bluescore 5
				}
			}
			state playerscorecheck
		}
      }
      break
    }
	
	ifaction APWESEXPLODEAD
    {
	  state resetplayerstuff
      break
    }
    ifaction APWESEXPLODE
    {
      ifactioncount 6
      {
        action APWESEXPLODEAD
        spawn BLOODPOOL2
		set deathtime totalclock
		ifg gametype 0
		{
			ifn gametime -1
			{
				ife gametype DM { ife team 1 add redscore 1 else ife team 0 add bluescore 1 }
				else
				{
				ife team 1 add redscore 5 else
				ife team 0 add bluescore 5
				}
			}
			state playerscorecheck
		}
      }
      break
    }

    ifp pshrunk
    {
      state standard_pjibs
      spawn BLOODPOOL2
	  // setp[].runspeed RUNNINGSPEED
      sound SQUISHED
      sound DUKE_DEAD

      cstat 32768         // Hide the sprite

	  ife pchar 2 action APWESLYINGDEAD else
	  ife pchar 1 action APSHELLYLYINGDEAD else
	  ifvarand altcostume 2 action ALTDUKELYINGDEAD else
      action PLYINGDEAD
    }
    else
    {
      ifinwater
      {
		ife pchar 2 action APWESLYINGDEAD else
	    ife pchar 1 action APSHELLYLYINGDEAD else
		ifvarand altcostume 2 action ALTDUKELYINGDEAD else
        action PLYINGDEAD
        spawn WATERBUBBLE
        spawn WATERBUBBLE
      }
      else
      {
	    ife pchar 2 action APWESEXPLODE else
	    ife pchar 1 action APSHELLYEXPLODE 
		else
        { 
			action PEXPLODE 
			ifvarand altcostume 2 action ALTDUKEEXPLODE
		}
        state standard_pjibs
        cstat 32768
        sound SQUISHED
        sound DUKE_DEAD
      }
	  
    }

    ifmultiplayer tossweapon

    break
  }
  

  ifsquished
  {
    strength -1
    sound SQUISHED
    state random_ooz
	set falldeath YES
    break
  }
  
  ife pdown YES
  {
	state resetplayerstuff
	break
  }

  ifp ponsteroids
  {
    ifp pstanding nullop
    else
      spawn FRAMEEFFECT1
  }


  /*
  ifmove PSHRINKING
  {
    ifcount 32
    {
      ifcount 304 // SHRUNKDONECOUNT
      {
        move 0
        cstat 257
      }
      else
        ifcount 270 // SHRUNKCOUNT
      {
        sizeto 42 36
        ifgapzl 24
        {
          strength 0
          sound SQUISHED
          palfrom 48 64
          break
        }
      }
      else
        ifp ponsteroids
		  count 270
          //count SHRUNKCOUNT
    }
    else
    {
      ifp ponsteroids
	    count 270
        // count SHRUNKCOUNT
      else
      {
        sizeto 8 9
        spawn FRAMEEFFECT1
      }
    }
  }
  */

ifg pchar 1 set selfshrink YES else set selfshrink NO
ife selfshrink YES
{
	ife PSHRINKING 0 
	ifp palive
	ife player[].inven_icon 6 // scuba
	ifvarand bits 1073741824
	ife sprite[].htextra -1
	ife shrinkcooldown 0
	ifp ponground
	{
		// self-shrinker
		seta[].htextra 0
		seta[].htpicnum SHRINKSPARK
		seta[].htowner THISACTOR
		
		set shrinkcooldown 900
	}
	ifinwater 
	{ 
		ife player[].scuba_amount 1 
		{
			getp[].inven_icon temp
			setp[].scuba_amount 0 
			setp[].inven_icon temp
		}
	} 
	else
	ife player[].scuba_amount 0 setp[].scuba_amount 1
}
  ife PSHRINKING 0 ifg shrinkcooldown 0 sub shrinkcooldown 1
  ifg PSHRINKING 0
  {
    add PSHRINKING 1
    ifg PSHRINKING 32
    {
	  ifl PSHRINKING 270
	  ife selfshrink YES
		ife player[].inven_icon 6 // scuba or self-shrink
		ifvarand bits 1073741824
		   set PSHRINKING 271
		   
		   
      ifg PSHRINKING 304 // SHRUNKDONECOUNT
      {
        move 0
		set PSHRINKING 0
		sizeat 42 36
        cstat 257
      }
      else
        ifg PSHRINKING 270 // SHRUNKCOUNT
      {
        sizeto 42 36
		seta[].htpicnum SHOTSPARK1 // to prevent re-shrinking from stored shrinker hit
        ifgapzl 24
        {
          strength 0
          sound SQUISHED
          palfrom 48 64
          break
        }

      }
      else
	  {
		setp[].falling_counter 0
        ifp ponsteroids
		  set PSHRINKING 270
          //count SHRUNKCOUNT
	  }
    }
    else
    {
      ifp ponsteroids
	    set PSHRINKING 270
      else
      {
        sizeto 8 9
        spawn FRAMEEFFECT1
      }
    }
  }
  else ifhitweapon
  {
	set idleanim 0
    ifdead
    {
	  ifactorsound THISACTOR LASERLOOP stopactorsound THISACTOR LASERLOOP 
		ifactorsound THISACTOR FREEZELOOP stopactorsound THISACTOR FREEZELOOP 
      ifmultiplayer
        sound DUKE_KILLED4

      ifwasweapon GROWSPARK
      {
        palfrom 48 48
		ife pchar 2 action APWESGROWING else
		ife pchar 1 action APSHELLYGROWING else
		ifvarand altcostume 2 action ALTDUKEGROWING else
        action PGROWING
        count 0
        move 0
        sound ACTOR_GROWING
        cstat 0
        break
      }
	  ifwasweapon FREEZEBLAST
		{
		  palfrom 48 0 0 48
		  set burning 0
		  
			sound NEWFREEZE
			spritepal 1
			move 0
			ife pchar 2 action APWESFROZEN else
			ife pchar 1 action APSHELLYFROZEN else
			ifvarand altcostume 2 action ALTDUKEFROZEN else
			action PFROZEN
			state freezeme
			break
		}
    }
    else
    {
	  state playerpainsounds
	  
	  // ife pchar 1 state playerpainsounds
	  // else ife pchar 2 state playerpainsounds
	  // else
      // ifmultiplayer
      // {
        // ifphealthl YELLHURTSOUNDSTRENGTHMP
        // {
          // ifrnd 64
            // sound DUKE_LONGTERM_PAIN2
          // else
            // ifrnd 64
              // sound DUKE_LONGTERM_PAIN3
          // else
            // ifrnd 64
              // sound DUKE_LONGTERM_PAIN4
          // else
            // sound DUKE_DEAD
        // }
        // else
        // {
          // ifrnd 64
            // sound DUKE_LONGTERM_PAIN5
          // else ifrnd 64
            // sound DUKE_LONGTERM_PAIN6
          // else ifrnd 64
            // sound DUKE_LONGTERM_PAIN7
          // else
            // sound DUKE_LONGTERM_PAIN8
        // }
      // }
      // else
      // {
        // ifphealthl YELLHURTSOUNDSTRENGTH
        // {
          // ifrnd 74
            // sound DUKE_LONGTERM_PAIN2
          // else
            // ifrnd 8
              // sound DUKE_LONGTERM_PAIN3
          // else
            // sound DUKE_LONGTERM_PAIN4
        // }
        // ifrnd 128
          // sound DUKE_LONGTERM_PAIN
      // }
    }
    ifstrength TOUGH
    {
      state headhitstate
	  ife pchar 2 sound WESPAIN2 else
	  ife pchar 1 sound B_GRUNT else
      sound DUKE_GRUNT
      ifp pstanding
	  {
	    ife pchar 2 action APWESFLINTCH else
	    ife pchar 1 action APSHELLYFLINTCH else
		ifvarand altcostume 2 action ALTDUKEFLINTCH else
        action PFLINTCHING
	  }
    }

    ifwasweapon RPG
    {
      ifrnd 32
        spawn BLOOD
	  palfrom 48 52
      ifdead
	  {
        state standard_pjibs
		break
	  }
    }
    ifwasweapon RADIUSEXPLOSION
    {
      ifrnd 32
        spawn BLOOD
	  palfrom 48 52
	  
      ifdead
	  {
        state standard_pjibs
        break
	  }
    }
    ifwasweapon FIREEXT
    {
	  palfrom 48 52
      ifrnd 32
        spawn BLOOD
      ifdead
	  {
        state standard_pjibs
        break
	  }
    }
    ifwasweapon GROWSPARK
    {
      palfrom 48 52
      sound SPARKLESOUND
    }
    ifwasweapon SHRINKSPARK
    {
      palfrom 48 0 48
      move PSHRINKING // used as a var only.
	  set PSHRINKING 1
      sound ACTOR_SHRINKING
      cstat 256 // 0
      break
    }
    ifwasweapon SHOTSPARK1
      palfrom 24 48
	ifwasweapon POMPROJ
	  palfrom 20 48
    ifwasweapon FREEZEBLAST
    {
      palfrom 48 0 0 48
	  set burning 0
      ifdead
      {
        sound NEWFREEZE
        spritepal 1
        move 0
		ife pchar 2 action APWESFROZEN else
		ife pchar 1 action APSHELLYFROZEN else
		ifvarand altcostume 2 action ALTDUKEFROZEN else
        action PFROZEN
		state freezeme
        break
      }
    }
    ifwasweapon COOLEXPLOSION1
      palfrom 48 48 0 48
    ifwasweapon KNEE
      palfrom 16 32
	ifwasweapon KICKPROJ
      palfrom 16 32
	  
    ifwasweapon FIRELASER
      palfrom 32 32
	ifwasweapon MEGAPROJ
      palfrom 40 32 0 16
	ifwasweapon SHOCKPROJ
      palfrom 20 63 63 63
	ifwasweapon PLASMAPROJ
	  palfrom 36 20 0 32
	ifwasweapon SHOCKBALL
	  palfrom 48 16 16 60
	ifwasweapon PLAYERPLASMA
	  palfrom 36 20 0 32 
	ifwasweapon GREENLASER
	  palfrom 28 16 40 16
	ifwasweapon BIGBOIPROJ
	  palfrom 40 40 40 0
	ifwasweapon FIRELASER2
	  palfrom 40 32
	ifwasweapon SWIRLPROJ
	  palfrom 40 32
	ifwasweapon FIRELASER3
	  palfrom 40 32
	ifwasweapon BIGPLASMA
	  palfrom 40 32
	ifwasweapon EDFLASER
	  palfrom 40 32
	ifwasweapon FLAKPROJ
	  palfrom 40 32
	ifwasweapon CBPROJ
	  palfrom 40 32
	ifwasweapon FLAMEPROJ
	  palfrom 48 24
	ifwasweapon FTPROJ
	  { palfrom 48 24 add burning 40 }
	ifwasweapon RANGERPROJ
	  palfrom 52 40
	ifwasweapon SPIKEPROJ
	  palfrom 32 8 40 0
	ifwasweapon SCUBAPROJ
	  palfrom 32 32
	ifwasweapon ARCBALLPROJ2
	  palfrom 40 63 0 63
	ifwasweapon MORTER2
	  palfrom 40 32
	ifwasweapon COMETPROJ
	  palfrom 42 32 8 8
	ifwasweapon PURPPROJ
	  palfrom 32 48 0 48
	ifwasweapon NEWPLASMA
	  palfrom 36 63 63 0
	ifwasweapon EGGJIBPROJ
	{
	  palfrom 24 8 63 12
	  stopsound PISTOL_BODYHIT
	}

    ifdead
    {
	  ife pchar 2 action APWESTHROWNBACK else
	  ife pchar 1 action APSHELLYTHROWNBACK else
	  ifvarand altcostume 2 action ALTDUKETHROWNBACK else
      action PTHROWNBACK
      ifmultiplayer tossweapon
    }
	else ifg player[].pals_time 0 { getp[].pals_time temp mul temp 2 div temp 3 setp[].pals_time temp }

    state random_wall_jibs

    break
  }

  ifaction PFLINTCHING
  {
    ifactioncount 2
      action PSTAND
    break
  }
  
  ifaction APSHELLYFLINTCH
  {
    ifactioncount 2
      action APSHELLYSTAND
    break
  }
  
  ifaction APWESFLINTCH
  {
    ifactioncount 2
      action APWESSTAND
    break
  }

  ifinwater
  {
    ife pchar 2
	{
		ifaction APWESTREDWATER
		{
		  ifp pwalking prunning
			action APWESSWIMMINGGO
		}
		else
		  ifp pstanding pwalkingback prunningback
			action APWESTREDWATER
		else
		{
		  ifaction APWESSWIMMING
		  {
			ifrnd 4
			  spawn WATERBUBBLE
			ifactioncount 4
			  action APWESSWIMMINGWAIT
		  }
		  else
			ifaction APWESSWIMMINGWAIT
		  {
			ifactioncount 2
			  action APWESSWIMMINGGO
		  }
		  else
			ifaction APWESSWIMMINGGO
		  {
			ifactioncount 2
			  action APWESSWIMMING
		  }
		  else
			action APWESTREDWATER
		}
	}
	else
    ife pchar 1
	{
		ifaction APSHELLYTREDWATER
		{
		  ifp pwalking prunning
			action APSHELLYSWIMMINGGO
		}
		else
		  ifp pstanding pwalkingback prunningback
			action APSHELLYTREDWATER
		else
		{
		  ifaction APSHELLYSWIMMING
		  {
			ifrnd 4
			  spawn WATERBUBBLE
			ifactioncount 4
			  action APSHELLYSWIMMINGWAIT
		  }
		  else
			ifaction APSHELLYSWIMMINGWAIT
		  {
			ifactioncount 2
			  action APSHELLYSWIMMINGGO
		  }
		  else
			ifaction APSHELLYSWIMMINGGO
		  {
			ifactioncount 2
			  action APSHELLYSWIMMING
		  }
		  else
			action APSHELLYTREDWATER
		}
	}
	else ifvarand altcostume 2
	{
		ifaction ALTDUKETREDWATER
		{
		  ifp pwalking prunning
			action ALTDUKESWIMMINGGO
		}
		else
		  ifp pstanding pwalkingback prunningback
			action ALTDUKETREDWATER
		else
		{
		  ifaction ALTDUKESWIMMING
		  {
			ifrnd 4
			  spawn WATERBUBBLE
			ifactioncount 4
			  action ALTDUKESWIMMINGWAIT
		  }
		  else
			ifaction ALTDUKESWIMMINGWAIT
		  {
			ifactioncount 2
			  action ALTDUKESWIMMINGGO
		  }
		  else
			ifaction ALTDUKESWIMMINGGO
		  {
			ifactioncount 2
			  action ALTDUKESWIMMING
		  }
		  else
			action ALTDUKETREDWATER
		}
	}
	else
	{
		ifaction PTREDWATER
		{
		  ifp pwalking prunning
			action PSWIMMINGGO
		}
		else
		  ifp pstanding pwalkingback prunningback
			action PTREDWATER
		else
		{
		  ifaction PSWIMMING
		  {
			ifrnd 4
			  spawn WATERBUBBLE
			ifactioncount 4
			  action PSWIMMINGWAIT
		  }
		  else
			ifaction PSWIMMINGWAIT
		  {
			ifactioncount 2
			  action PSWIMMINGGO
		  }
		  else
			ifaction PSWIMMINGGO
		  {
			ifactioncount 2
			  action PSWIMMING
		  }
		  else
			action PTREDWATER
		}
	}

    ifrnd 4
      spawn WATERBUBBLE // For effect
    break
  }
  else ifp pjetpack
  {
    ifaction PJPHOUVER
    {
      ifactioncount 4
        resetactioncount
    }
    else
      action PJPHOUVER
	  
	ife pchar 1 state shellyactions
	else ife pchar 2 state wesactions
	else ifvarand altcostume 2 state altdukeactions
    break
  }
  else
  {
    ifaction PTREDWATER
      action PSTAND
    ifaction PSWIMMING
      action PSTAND
    ifaction PSWIMMINGWAIT
      action PSTAND
    ifaction PSWIMMINGGO
      action PSTAND
    ifaction PJPHOUVER
      action PFALLING
	  
	ifaction ALTDUKETREDWATER
      action ALTDUKESTAND
    ifaction ALTDUKESWIMMING
      action ALTDUKESTAND
    ifaction ALTDUKESWIMMINGWAIT
      action ALTDUKESTAND
    ifaction ALTDUKESWIMMINGGO
      action ALTDUKESTAND
    ifaction ALTDUKEJPHOUVER
      action ALTDUKEFALLING
	  
	ifaction APSHELLYTREDWATER
      action APSHELLYSTAND
    ifaction APSHELLYSWIMMING
      action APSHELLYSTAND
    ifaction APSHELLYSWIMMINGWAIT
      action APSHELLYSTAND
    ifaction APSHELLYSWIMMINGGO
      action APSHELLYSTAND
    ifaction APSHELLYHOUVER
      action APSHELLYFALLING
	  
    ifaction APWESTREDWATER
      action APWESSTAND
    ifaction APWESSWIMMING
      action APWESSTAND
    ifaction APWESSWIMMINGWAIT
      action APWESSTAND
    ifaction APWESSWIMMINGGO
      action APWESSTAND
    ifaction APWESHOUVER
      action APWESFALLING
	  
	ife pchar 1 state shellyactions
	else ife pchar 2 state wesactions
	else ifvarand altcostume 2 state altdukeactions
  }

  set temp NO
  ifaction PFALLING set temp YES
  ifaction APSHELLYFALLING set temp YES
  ifaction ALTDUKEFALLING set temp YES
  ifaction APWESFALLING set temp YES
  
  //ifaction PFALLING
  ife temp YES
  {
    set stepcount -32768
    ifp ponground
      {
		  ife pchar 2 action APWESSTAND else
		  ife pchar 1 action APSHELLYSTAND else
		  ifvarand altcostume 2 action ALTDUKESTAND else
	      action PSTAND 
		  ifl PLAYERONTHEBIKE 1
	      state landsounds
	  }
    else
    {
      ifp pfalling
        break
      else
        state check_pstandard
    }
  }
  ife pchar 2
  {
	  ifaction APWESDUCKING
	  {
		ifgapzl 48
		{
		  ifp pwalking pwalkingback prunning prunningback
			action APWESCRAWLING
		}
		else ifp pducking
		{
		  ifp pwalking pwalkingback prunning prunningback
			action APWESCRAWLING
		}
		else
		{
		  ifp pstanding
			action APWESSTAND
		  else
			state check_pstandard
		}
	  }
	  else ifaction APWESCRAWLING
	  {
		ifgapzl 48
		{
		  ifp pstanding
			action APWESCRAWLING
		}
		else
		  ifp pducking
		{
		  ifp pstanding
			action APWESDUCKING
		}
		else
		{
		  ifp pstanding
			action APWESSTAND
		  else
			state check_pstandard
		}
	  }
	  else
		ifgapzl 48
		  action APWESDUCKING
	  else
		ifaction APWESJUMPING
	  {
		ifp ponground
		  action APWESSTAND
		else
		  ifactioncount 4
			ifp pfalling
			{
			  ifaction APWESGLIDING ifvarand bits 1 nullop else
			  action APWESFALLING
			}
	  }
  }
  else
  ife pchar 1
  {
	  ifaction APSHELLYDUCKING
	  {
		ifgapzl 48
		{
		  ifp pwalking pwalkingback prunning prunningback
			action APSHELLYCRAWLING
		}
		else ifp pducking
		{
		  ifp pwalking pwalkingback prunning prunningback
			action APSHELLYCRAWLING
		}
		else
		{
		  ifp pstanding
			action APSHELLYSTAND
		  else
			state check_pstandard
		}
	  }
	  else ifaction APSHELLYCRAWLING
	  {
		ifgapzl 48
		{
		  ifp pstanding
			action APSHELLYCRAWLING
		}
		else
		  ifp pducking
		{
		  ifp pstanding
			action APSHELLYDUCKING
		}
		else
		{
		  ifp pstanding
			action APSHELLYSTAND
		  else
			state check_pstandard
		}
	  }
	  else
		ifgapzl 48
		  action APSHELLYDUCKING
	  else
		ifaction APSHELLYJUMPING
	  {
		ifp ponground
		  action APSHELLYSTAND
		else
		  ifactioncount 4
			ifp pfalling
			  action APSHELLYFALLING
	  }
  }
  else
  ifvarand altcostume 2
  {
	  ifaction ALTDUKEDUCKING
	  {
		ifgapzl 48
		{
		  ifp pwalking pwalkingback prunning prunningback
			action ALTDUKECRAWLING
		}
		else ifp pducking
		{
		  ifp pwalking pwalkingback prunning prunningback
			action ALTDUKECRAWLING
		}
		else
		{
		  ifp pstanding
			action ALTDUKESTAND
		  else
			state check_pstandard
		}
	  }
	  else ifaction ALTDUKECRAWLING
	  {
		ifgapzl 48
		{
		  ifp pstanding
			action ALTDUKECRAWLING
		}
		else
		  ifp pducking
		{
		  ifp pstanding
			action ALTDUKEDUCKING
		}
		else
		{
		  ifp pstanding
			action ALTDUKESTAND
		  else
			state check_pstandard
		}
	  }
	  else
		ifgapzl 48
		  action ALTDUKEDUCKING
	  else
		ifaction ALTDUKEJUMPING
	  {
		ifp ponground
		  action ALTDUKESTAND
		else
		  ifactioncount 4
			ifp pfalling
			  action ALTDUKEFALLING
	  }
  }
  else
  {
	  ifaction PDUCKING
	  {
		ifgapzl 48
		{
		  ifp pwalking pwalkingback prunning prunningback
			action PCRAWLING
		}
		else ifp pducking
		{
		  ifp pwalking pwalkingback prunning prunningback
			action PCRAWLING
		}
		else
		{
		  ifp pstanding
			action PSTAND
		  else
			state check_pstandard
		}
	  }
	  else ifaction PCRAWLING
	  {
		ifgapzl 48
		{
		  ifp pstanding
			action PCRAWLING
		}
		else
		  ifp pducking
		{
		  ifp pstanding
			action PDUCKING
		}
		else
		{
		  ifp pstanding
			action PSTAND
		  else
			state check_pstandard
		}
	  }
	  else
		ifgapzl 48
		  action PDUCKING
	  else
		ifaction PJUMPING
	  {
		ifp ponground
		  action PSTAND
		else
		  ifactioncount 4
			ifp pfalling
			  action PFALLING
	  }
  }
  ife pchar 2
  {
	  ifp pfalling
	  {
	    ifaction APWESGLIDING ifvarand bits 1 nullop else
		action APWESFALLING
	  }
	  else
		ifaction APWESSTAND
		  state check_pstandard
	  else
	    ifaction APWESGUNDOWN
		  state check_pstandard
	  else
		ifaction APWESKICKING
	  {
		ifactioncount 5
		  action APWESSTAND
		break
	  }
	  else
		ifaction APWESWALK
	  {
		ifp pfalling
		  action APWESFALLING
		else
		  ifp pstanding
			action APWESSTAND
		else
		  ifp prunning
			action APWESRUN
		else
		  ifp pwalkingback
			action APWESWALKBACK
		else
		  ifp prunningback
			action APWESRUNBACK
		else
		  ifp pjumping
			action APWESJUMPING
		else
		  ifp pducking
			action APWESDUCKING
	  }
	  else
		ifaction APWESRUN
	  {
		ifp pstanding
		  action APWESSTAND
		else
		  ifp pwalking
			action APWESWALK
		else
		  ifp pwalkingback
			action APWESWALKBACK
		else
		  ifp prunningback
			action APWESRUNBACK
		else
		  ifp pjumping
			action APWESJUMPING
		else
		  ifp pducking
			action APWESDUCKING
	  }

	  else
		ifaction APWESWALKBACK
	  {
		ifp pstanding
		  action APWESSTAND
		else
		  ifp pwalking
			action APWESWALK
		else
		  ifp prunning
			action APWESRUN
		else
		  ifp prunningback
			action APWESRUNBACK
		else
		  ifp pjumping
			action APWESJUMPING
		else
		  ifp pducking
			action APWESDUCKING
	  }

	  else
		ifaction APWESRUNBACK
	  {
		ifp pstanding
		  action APWESSTAND
		else
		  ifp pwalking
			action APWESWALK
		else
		  ifp prunning
			action APWESRUN
		else
		  ifp pwalkingback
			action APWESWALKBACK
		else
		  ifp pjumping
			action APWESJUMPING
		else
		  ifp pducking
			action APWESDUCKING
	  }
  }
  else
  ife pchar 1
  {
	  ifp pfalling
		action APSHELLYFALLING
	  else
		ifaction APSHELLYSTAND
		  state check_pstandard
	  else
		ifaction APSHELLYKICKING
	  {
		ifactioncount 2
		  action APSHELLYSTAND
		break
	  }
	  else
		ifaction APSHELLYWALK
	  {
		ifp pfalling
		  action APSHELLYFALLING
		else
		  ifp pstanding
			action APSHELLYSTAND
		else
		  ifp prunning
			action APSHELLYRUN
		else
		  ifp pwalkingback
			action APSHELLYWALKBACK
		else
		  ifp prunningback
			action APSHELLYRUNBACK
		else
		  ifp pjumping
			action APSHELLYJUMPING
		else
		  ifp pducking
			action APSHELLYDUCKING
	  }
	  else
		ifaction APSHELLYRUN
	  {
		ifp pstanding
		  action APSHELLYSTAND
		else
		  ifp pwalking
			action APSHELLYWALK
		else
		  ifp pwalkingback
			action APSHELLYWALKBACK
		else
		  ifp prunningback
			action APSHELLYRUNBACK
		else
		  ifp pjumping
			action APSHELLYJUMPING
		else
		  ifp pducking
			action APSHELLYDUCKING
	  }

	  else
		ifaction APSHELLYWALKBACK
	  {
		ifp pstanding
		  action APSHELLYSTAND
		else
		  ifp pwalking
			action APSHELLYWALK
		else
		  ifp prunning
			action APSHELLYRUN
		else
		  ifp prunningback
			action APSHELLYRUNBACK
		else
		  ifp pjumping
			action APSHELLYJUMPING
		else
		  ifp pducking
			action APSHELLYDUCKING
	  }

	  else
		ifaction APSHELLYRUNBACK
	  {
		ifp pstanding
		  action APSHELLYSTAND
		else
		  ifp pwalking
			action APSHELLYWALK
		else
		  ifp prunning
			action APSHELLYRUN
		else
		  ifp pwalkingback
			action APSHELLYWALKBACK
		else
		  ifp pjumping
			action APSHELLYJUMPING
		else
		  ifp pducking
			action APSHELLYDUCKING
	  }
  }
  else
  ifvarand altcostume 2
  {
	  ifp pfalling
		action ALTDUKEFALLING
	  else
		ifaction ALTDUKESTAND
		  state check_pstandard
	  else
		ifaction ALTDUKEKICKING
	  {
		ifactioncount 2
		  action ALTDUKESTAND
		break
	  }
	  else
		ifaction ALTDUKEWALK
	  {
		ifp pfalling
		  action ALTDUKEFALLING
		else
		  ifp pstanding
			action ALTDUKESTAND
		else
		  ifp prunning
			action ALTDUKERUN
		else
		  ifp pwalkingback
			action ALTDUKEWALKBACK
		else
		  ifp prunningback
			action ALTDUKERUNBACK
		else
		  ifp pjumping
			action ALTDUKEJUMPING
		else
		  ifp pducking
			action ALTDUKEDUCKING
	  }
	  else
		ifaction ALTDUKERUN
	  {
		ifp pstanding
		  action ALTDUKESTAND
		else
		  ifp pwalking
			action ALTDUKEWALK
		else
		  ifp pwalkingback
			action ALTDUKEWALKBACK
		else
		  ifp prunningback
			action ALTDUKERUNBACK
		else
		  ifp pjumping
			action ALTDUKEJUMPING
		else
		  ifp pducking
			action ALTDUKEDUCKING
	  }

	  else
		ifaction ALTDUKEWALKBACK
	  {
		ifp pstanding
		  action ALTDUKESTAND
		else
		  ifp pwalking
			action ALTDUKEWALK
		else
		  ifp prunning
			action ALTDUKERUN
		else
		  ifp prunningback
			action ALTDUKERUNBACK
		else
		  ifp pjumping
			action ALTDUKEJUMPING
		else
		  ifp pducking
			action ALTDUKEDUCKING
	  }

	  else
		ifaction ALTDUKERUNBACK
	  {
		ifp pstanding
		  action ALTDUKESTAND
		else
		  ifp pwalking
			action ALTDUKEWALK
		else
		  ifp prunning
			action ALTDUKERUN
		else
		  ifp pwalkingback
			action ALTDUKEWALKBACK
		else
		  ifp pjumping
			action ALTDUKEJUMPING
		else
		  ifp pducking
			action ALTDUKEDUCKING
	  }
  }
  else
  {
	  ifp pfalling
		action PFALLING
	  else
		ifaction PSTAND
		  state check_pstandard
	  else
		ifaction PAKICKING
	  {
		ifactioncount 2
		  action PSTAND
		break
	  }
	  else
		ifaction PWALK
	  {
		ifp pfalling
		  action PFALLING
		else
		  ifp pstanding
			action PSTAND
		else
		  ifp prunning
			action PRUN
		else
		  ifp pwalkingback
			action PWALKBACK
		else
		  ifp prunningback
			action PRUNBACK
		else
		  ifp pjumping
			action PJUMPING
		else
		  ifp pducking
			action PDUCKING
	  }
	  else
		ifaction PRUN
	  {
		ifp pstanding
		  action PSTAND
		else
		  ifp pwalking
			action PWALK
		else
		  ifp pwalkingback
			action PWALKBACK
		else
		  ifp prunningback
			action PRUNBACK
		else
		  ifp pjumping
			action PJUMPING
		else
		  ifp pducking
			action PDUCKING
	  }

	  else
		ifaction PWALKBACK
	  {
		ifp pstanding
		  action PSTAND
		else
		  ifp pwalking
			action PWALK
		else
		  ifp prunning
			action PRUN
		else
		  ifp prunningback
			action PRUNBACK
		else
		  ifp pjumping
			action PJUMPING
		else
		  ifp pducking
			action PDUCKING
	  }

	  else
		ifaction PRUNBACK
	  {
		ifp pstanding
		  action PSTAND
		else
		  ifp pwalking
			action PWALK
		else
		  ifp prunning
			action PRUN
		else
		  ifp pwalkingback
			action PWALKBACK
		else
		  ifp pjumping
			action PJUMPING
		else
		  ifp pducking
			action PDUCKING
	  }
  }
  ife attmode YES
  ifn attmusic -1
	{
		ife userdef[].music_episode 0
		ife userdef[].music_level attmusic
		nullop
		else starttrackslot 0 attmusic
	}
enda

defstate checksquished
  ifsquished
  {
	ifn team 1 ifn team 3
		addkills 1
	state enemy_death
    sound SQUISHED
    state standard_jibs
    state random_ooz
    killit
  }
ends

defstate deadsquished
	ifsquished
	{
		sound SQUISHED
		state standard_jibs
		state random_ooz
		killit
	}
ends

state rf
  ifrnd 128
    cstat 4
  else
    cstat 0
ends

action ABAGGERSTAND -1  0  5  1  10
action ABAGGERCROUCH 85  0  5  1  10
useractor notenemy HOLOBAGGER 0 ABAGGERSTAND

ife mtype -1 killit
else
ifn mtype 0
{
	cstat 2
	ife player[].holoduke_on -1 killit
	ifcount 4
	{
		ifaction ABAGGERSTAND action ABAGGERCROUCH else
		action ABAGGERSTAND
		resetcount
	}
	setsprite THISACTOR sprite[mtype].x sprite[mtype].y sprite[mtype].z
}

enda


// CANNONBALL for Pirates of the Carribean
define CANNONBALLSTRENGTH 400
move CANNONBALL1 512 0
move CANNONBALL2 512 10
move CANNONBALL3 512 20
move CANNONBALL4 512 40
move CANNONBALL5 512 80

useractor notenemy CANNONBALL CANNONBALLSTRENGTH

  ifaction 0
  {
    sizeat 32 32
    cstat 257         // Force actor to block
    action ANULLACTION
  }

    ifactioncount 46
    {
      ifactioncount 47 nullop
      else
        move CANNONBALL5 geth getv
    }
    else
      ifactioncount 44
    {
      ifactioncount 45 nullop
      else
        move CANNONBALL4 geth getv
    }
    else
      ifactioncount 40
    {
      ifactioncount 41 nullop
      else
        move CANNONBALL3 geth getv
    }
    else
      ifactioncount 32
    {
      ifactioncount 33 nullop
      else
        move CANNONBALL2 geth getv
    }
    else
      ifactioncount 16
    {
      ifactioncount 17 nullop
      else move CANNONBALL1 geth getv
    }

  ifnotmoving
  {
    spawn EXPLOSION2
    sound PIPEBOMB_EXPLODE
    hitradius 4096 WEAKEST WEAK MEDIUMSTRENGTH TOUGH
    killit
  }

  ifhitweapon
  {
    ifdead
    {
      spawn EXPLOSION2
      hitradius 4096 WEAKEST WEAK MEDIUMSTRENGTH TOUGH
      killit
    }
    else
      debris SCRAP1 3
  }

enda


define CANNONBALLS 1818
define CANNONBALLSSTRENGTH 10
move CANNONBALLSVEL

useractor notenemy CANNONBALLS CANNONBALLSSTRENGTH
  ifaction 0
  {
    cstator 257
    action ANULLACTION
  }
  ifhitweapon
  {
    ifdead
    {
      spawn EXPLOSION2
      hitradius 4096 WEAKEST WEAK MEDIUMSTRENGTH TOUGH
      killit
    }
    else
      debris SCRAP1 3
  }
enda


define CANNON 1810
define CANNONSTRENGTH 400
action ACANNONWAIT 0 1 7 1 1
action ACANNONSHOOTING 0 1 7 1 1
move CANNONSTOP

useractor enemy CANNON CANNONSTRENGTH // fall

  ifaction 0
  {
//    sizeat 64 64
    action ACANNONWAIT
  }
  else
    ifaction ACANNONSHOOTING
  {
    spawn CANNONBALL
    action ACANNONWAIT
  }
  else
    ifaction ACANNONWAIT
  {
    ifactioncount 64
    {
      ifrnd 128
        action ACANNONSHOOTING
      else
        resetactioncount
    }
  }

  ifhitweapon
  {
    ifdead
    {
      addkills 1
      hitradius 4096 WEAKEST WEAK MEDIUMSTRENGTH TOUGH
      spawn EXPLOSION2
      killit
    }
    else debris SCRAP1 3
  }

  ifpdistl 1024
    ifhitspace
  {
    ifp pfacing
      ifcanshoottarget
        spawn CANNONBALL
      else break
  }
enda


action ALAVABUBBLE
action ALAVABUBBLEANIM 0 5 1 1 16

useractor notenemy LAVABUBBLE
  ifaction 0
  {
    cstat 32768
    action ALAVABUBBLE
  }
  else
    ifaction ALAVABUBBLE
  {
    ifcount 72
      ifrnd 2
    {
      cstat 0
      action ALAVABUBBLEANIM
    }
  }
  else
  {
    ifactioncount 5
    {
      cstat 32768
      action ALAVABUBBLE
    }
  }
enda


move GASDRIFTSLOW 16
move GASDRIFT 24
move GASDRIFTFAST 32
action GASFRAMES -1 5 1 1 18
useractor notenemy POISONGAS 0 GASFRAMES

ifmove 0
{
	ifrnd 85 move GASDRIFTSLOW randomangle
	else
	ifrnd 128 move GASDRIFT randomangle else
	move GASDRIFTFAST randomangle
	geta[].z z
	sub z 4096
	seta[].z z
	cstator 130
	ifrnd 128 cstator 4
	sizeat 24 48
	spritepal 8
	seta[].xoffset 48
}

sizeto 80 160
ifcount 90 cstator 512
ifcount 120 killit

ifcount 91 nullop else
ifcount 10
{
	ifpdistl 1024
	{
		palfrom 50 20 63 24
		ifvarand player[].player_par 1
		ifrnd 32 addphealth -1
	}
}

enda

action JIBSTILL3 -2 1 1 1 1
action JIBSTILL2 0 1 1 1 1
action JIBSTILL -1 1 1 1 1

state jibcode

ife initsprite 1
{
	ifspritepal 1 
	{
		ifrnd 128
		{
			ifsound ICE_BOUNCE { ifrnd 32 sound ICE_BOUNCE } else
			soundonce ICE_BOUNCE
		}
		else
		{
			ifsound GLASSTINK { ifrnd 32 sound GLASSTINK } else
			soundonce GLASSTINK
		}
		
	}
	else
	{
		ifrnd 64
		{
			ifrnd 96 soundonce STEPNIT else
			soundonce JIBLAND
		}
	}
	seta[].pitch 0
	seta[].roll 0
	clipdist 4
	// insertspriteq
	ifactor 1770 action JIBSTILL3 else
	ifactor 1774 { set yoffset -256 action JIBSTILL3 } else
	ifactor 1778 action JIBSTILL3 else
	ifactor 2203 action JIBSTILL3 else
	ifactor 2207 action JIBSTILL3 else
	ifactor 2211 action JIBSTILL3 else
	action JIBSTILL2
	cstat 256
	seta[].mdflags 16
	ifactor 1770 { set yoffset 256 ifn sprite[].pal 1 spawn BLOODPOOL2 } else
	ifactor 2203 { set yoffset 256 ifn sprite[].pal 1 spawn BLOODPOOL2 } else
	ifactor 2254 { set yoffset -384 } else
	ife yoffset 0
	set yoffset 512
	ifrnd 128 cstator 4
	strength 0
	ifg THISACTOR 14000 killit
}

	ifl framerate 15 killit
	add initsprite 1
	ifge initsprite jibs_duration
	{
		geta[].alpha temp
		add temp 1
		seta[].alpha temp
	}
	ifg sprite[].alpha 250 killit

fall

ifhitweapon
{
	guts JIBS6 2 
	killit 
}

ends

useractor notenemy 2203 ifvarn initsprite 0 state jibcode enda // LIZMANHEAD
useractor notenemy 2207 ifvarn initsprite 0 state jibcode enda // LIZMANARM
useractor notenemy 2211 ifvarn initsprite 0 state jibcode enda // LIZMANLEG


useractor notenemy 2249 ifvarn initsprite 0 state jibcode enda // JIBS1 = spine
useractor notenemy 2254 ifvarn initsprite 0 state jibcode enda // JIBS2 = eyeball
useractor notenemy 2259 ifvarn initsprite 0 state jibcode enda // JIBS3 = heart
useractor notenemy 2264 ifvarn initsprite 0 state jibcode enda // JIBS4 = guts
useractor notenemy 2269 ifvarn initsprite 0 state jibcode enda // JIBS5 = ribcage

useractor notenemy 1770 ifvarn initsprite 0 state jibcode enda

useractor notenemy 1774 ifvarn initsprite 0 state jibcode enda // TROOPARM
useractor notenemy 1778 ifvarn initsprite 0 state jibcode enda // TROOPLEG

state jibgroundcode

ifmove 0
{
	move STOPPED
	ifl sprite[].xrepeat 8
	{
		sizeat 48 48

		switch sprite[].picnum
		
		case PIGARMGROUND 
		case NEWCOMMHEADGROUND
			sizeat 32 32 
		break
			
		case RANGERARMGROUND
		case BEASTARMGROUND
		case BEASTLEGGROUND 
			sizeat 40 40 
		break
		
		case RANGERLEGGROUND 
			sizeat 42 38 
		break
		
		case ARMPIGARMGROUND
		case ARMPIGFOOTGROUND
		case ARMPIGLEGGROUND
			sizeat 46 40 
		break
		
		case ZOMBIEHEADGROUND 
		case CRAZYHEADGROUND
			sizeat 30 28
		break
		
		case ANTHEADGROUND 
			sizeat 36 36
		break
		
		case BULLHEADGROUND 
		case BULLLEGGROUND 
		case BULLARMGROUND
		case MANDOARMGROUND
		case MANDOLEGGROUND
		case MANDOCHESTGROUND
		case MANDOHEADGROUND
		
			 sizeat 26 26 
		break
		
		case PIGLEGGROUND 
			sizeat 28 28
		break
		
		default	sizeat 48 48 
		break
		
		endswitch
	
	}
	ifrnd 128 cstat 0 else cstat 4
	ifrnd 64
	{
		ifrnd 96 soundonce STEPNIT else
		soundonce JIBLAND
	}
	cstator 256
	strength 0
	clipdist 4
	ifn sprite[].pal 1
	{
	ifactor MANDOCHESTGROUND spawn BLOODPOOL2 else
	ifactor BULLHEADGROUND spawn BLOODPOOL2 else
	ifactor BBHEADJIBGROUND { spritepal 6 spawn BLOODPOOL getlastpal } else
	ifactor ANTHEADGROUND { spritepal 6 spawn BLOODPOOL getlastpal } else
	ifactor BEASTHEADGROUND { spritepal 6 spawn BLOODPOOL getlastpal } else
	ifactor BEASTLEGGROUND { spritepal 6 spawn BLOODPOOL getlastpal } else
	ifactor BEASTARMGROUND { spritepal 6 spawn BLOODPOOL getlastpal } else
	ifactor BBARMJIBGROUND nullop else
	ifactor ZOMBIEHEADGROUND nullop else
	ifrnd 128 spawn BLOODPOOL2
	}
	ifg THISACTOR 14000 killit
	
}

fall

	ifl framerate 15 killit
	add initsprite 1
	ifge initsprite jibs_duration
	{
		geta[].alpha temp
		add temp 1
		seta[].alpha temp
	}
	ifg sprite[].alpha 250 killit

ifhitweapon
{
	ifactor ZOMBIEHEADGROUND spritepal 8
	guts JIBS6 2 
	killit 
}

ends

defstate shoothead

	set picnum -1
	switch sprite[].picnum
	case PIGHEADGROUND set picnum PIGHEADPROJ break
	case TROOPHEADGROUND set picnum TROOPHEADPROJ break
	case NEWTROOPHEADGROUND set picnum NEWTROOPHEADPROJ break
	case LIZHEADGROUND set picnum LIZHEADPROJ break
	case COMMHEADGROUND set picnum COMMHEADPROJ break
	case NEWCOMMHEADGROUND set picnum NEWCOMMHEADPROJ break
	case CRAZYHEADGROUND set picnum CRAZYHEADPROJ break
	case ZOMBIEHEADGROUND set picnum ZOMBIEHEADPROJ break
	case LIZRANGERHEAD set picnum RANGERHEADPROJ break
	case BEASTHEADGROUND set picnum BEASTHEADPROJ break
	case ANTHEADGROUND set picnum ANTHEADPROJ break
	case BULLHEADGROUND set picnum BULLHEADPROJ break
	case MANDOHEADGROUND set picnum MANDOHEADPROJ break
	endswitch
	
	ifn picnum -1 
	{
		ifpdistl 4096 screensound KICKIMPACT2
		rand zdist 1024
		sub zdist 3072
		ezshootvar zdist picnum
		setav[RETURN].countvar countvar
		seta[RETURN].ang sprite[].ang
		seta[RETURN].pal sprite[].pal
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		add countvarc 1
		setav[RETURN].countvarc countvarc
		killit
	}
ends


defstate headgroundcode

ifmove 0
{
	move STOPPED
	ifl sprite[].xrepeat 8
	{
		sizeat 48 48

		switch sprite[].picnum
		
		
		case NEWCOMMHEADGROUND
			sizeat 32 32 
		break

		case ZOMBIEHEADGROUND 
		case CRAZYHEADGROUND
			sizeat 30 28
		break
		
		case ANTHEADGROUND 
			sizeat 36 36
		break
		
		case BULLHEADGROUND 
		case MANDOHEADGROUND
		
			 sizeat 26 26 
		break
		
		case PIGLEGGROUND 
			sizeat 28 28
		break
		
		default	sizeat 48 48 
		break
		
		endswitch
	
	}
	ifrnd 128 cstat 0 else cstat 4
	ifrnd 64
	{
		ifrnd 96 soundonce STEPNIT else
		soundonce JIBLAND
	}
	cstator 256
	strength 100
	clipdist 4
	ifn sprite[].pal 1
	{
		ifactor BBHEADJIBGROUND { ifrnd 64 { spritepal 6 spawn BLOODPOOL getlastpal } } else
		ifactor ANTHEADGROUND { ifrnd 64 { spritepal 6 spawn BLOODPOOL getlastpal } } else
		ifactor BEASTHEADGROUND { ifrnd 64 { spritepal 6 spawn BLOODPOOL getlastpal } } else
		ifactor ZOMBIEHEADGROUND nullop else
		ifrnd 64 spawn BLOODPOOL2
	}
}

fall

ifp pfacing
ifp ponground
ifp palive
ifpdistl 1024
ifcansee
ifn disable_kickheads YES
{
	seta[].ang player[].ang
	state shoothead
}

ifg countvarc 1
{
	strength 1
	seta[].htextra 10
}
ifhitweapon
{
	ifdead
	{
		ifrnd 128 guts JIBS2 1
		ifactor ZOMBIEHEADGROUND spritepal 8
		guts JIBS6 2 
		spawn BLOODEXP
		killit 
	}
	else
	{
		seta[].ang sprite[].htang
		state shoothead
	}
}

ends

state canarmcode

ifmove 0
{
	move STOPPED
	insertspriteq
	ifl sprite[].xrepeat 4
	sizeat 64 64
	ifrnd 128 cstat 0 else cstat 4
}
fall

ends

useractor notenemy REDARMGROUND 0 state canarmcode enda

useractor notenemy BLUEARMGROUND 0 state canarmcode enda

useractor notenemy PIGHEADGROUND 0 state headgroundcode enda

useractor notenemy TROOPHEADGROUND 0 state headgroundcode enda

useractor notenemy NEWTROOPHEADGROUND 0 state headgroundcode enda

useractor notenemy LIZHEADGROUND 0 state headgroundcode enda

useractor notenemy COMMHEADGROUND 0 state headgroundcode enda

useractor notenemy NEWCOMMHEADGROUND 0 state headgroundcode enda

useractor notenemy ZOMBIEHEADGROUND 0 state headgroundcode enda

useractor notenemy CRAZYHEADGROUND 0 state headgroundcode enda

useractor notenemy LIZRANGERHEAD 0 state headgroundcode enda

useractor notenemy COMMARMGROUND 0 state jibgroundcode enda

useractor notenemy PIGLEGGROUND 0 state jibgroundcode enda

useractor notenemy PIGARMGROUND 0 state jibgroundcode enda

useractor notenemy RANGERLEGGROUND 0 state jibgroundcode enda

useractor notenemy RANGERARMGROUND 0 state jibgroundcode enda

useractor notenemy BEASTHEADGROUND 0 state headgroundcode enda

useractor notenemy ANTHEADGROUND 0 state headgroundcode enda

useractor notenemy BEASTARMGROUND 0 state jibgroundcode enda

useractor notenemy BEASTLEGGROUND 0 state jibgroundcode enda

useractor notenemy ARMPIGARMGROUND 0 state jibgroundcode enda

useractor notenemy ARMPIGFOOTGROUND 0 state jibgroundcode enda

useractor notenemy ARMPIGLEGGROUND 0 state jibgroundcode enda

useractor notenemy BULLHEADGROUND 0 state headgroundcode enda

useractor notenemy BULLLEGGROUND 0 state headgroundcode enda

useractor notenemy BULLARMGROUND 0 state jibgroundcode enda

useractor notenemy BBHEADJIBGROUND 0 state headgroundcode enda

useractor notenemy BBARMJIBGROUND 0 state jibgroundcode enda

useractor notenemy MANDOCHESTGROUND 0 state jibgroundcode enda

useractor notenemy MANDOLEGGROUND 0 state jibgroundcode enda

useractor notenemy MANDOHEADGROUND 0 state headgroundcode enda

useractor notenemy MANDOARMGROUND 0 state jibgroundcode enda

useractor notenemy EGGJIBGROUND 0 

	ifmove 0
	{
		move STOPPED
		sizeat 40 40
		ifrnd 128 cstat 0 else cstat 4
		cstator 256
		strength 0
		
		espawn BLOODPOOL
		seta[RETURN].pal 6
	}

	fall
	
	ifcount 30
	{
		geta[].alpha temp
		add temp 1
		seta[].alpha temp
		ifge temp 254 killit
	}

	ifhitweapon
	{
		spritepal 6
		guts JIBS6 2 
		killit 
	}

enda

move JIBDROP 132
useractor enemy COMMJIB 100

ifmove 0
	move JIBDROP geth

ifmove JIBDROP iffloordistl 2
{
	move STOPPED
	cstator 256
	soundonce JIBLAND
	spawn BLOODPOOL2
	spriteflags 4194304
	getp[].max_actors_killed temp
	sub temp 1
	setp[].max_actors_killed temp
	geta[].yrepeat y
	sub y 4
	seta[].yrepeat y
}

fall

ifhitweapon
{
	ifdead
	{
		sound SQUISHED
		state lite_jibs
		killit
	}
}

enda

spritenoshade ELEC_EXP
action ELECFRAMES 0 6 1 1 8
move ELECMOV
useractor notenemy ELEC_EXP 0 ELECFRAMES

	ifmove 0
	{
		ifspawnedby SCUBAPROJ { spritepal 23 sizeat 32 32 }
		else
		ifspawnedby INFERNO { spritepal 83 sizeat 64 64 }
		else
		sizeat 48 48
		move ELECMOV
		ifrnd 84 { stopsound MEGAIMPACT1 sound MEGAIMPACT2 }
		ifspawnedby BIGSHOCKER sizeat 64 64
		cstat 128
		seta[].blend 1
		cstator 2
		ifrnd 128 cstator 4
		
		seta[].shade -127
	}
	ifactioncount 6 killit
enda

spritenoshade LASERHALO
useractor notenemy LASERHALO 0

ife initsprite 0 break

seta[].shade -127
// seta[].blend 255
cstat 642
sizeat 18 18
ifrnd 128 { cstator 4 geta[].xoffset temp mul temp -1 seta[].xoffset temp }
ifrnd 128 cstator 8
spritepal 2

ifcount 1 killit

enda

spritenoshade ROCKETHALO
useractor notenemy ROCKETHALO 0

seta[].blend 1
seta[].shade -127
ife initsprite 0 break

seta[].xrepeat initsprite
seta[].yrepeat initsprite

cstat 642
ifrnd 128 cstator 4
ifrnd 128 cstator 8
ife mtype 1 spritepal 1 else
spritepal 2

ifcount 1 killit

enda

spritenoshade SHRINKHALO
useractor notenemy SHRINKHALO 0

seta[].blend 1
seta[].shade -127
ife initsprite 0 break

cstat 642

sizeat 24 24
ifrnd 128 cstator 4
ifrnd 128 cstator 8
spritepal 8
geta[].x x sub x 10 seta[].x x
geta[].y y sub y 10 seta[].y y

ifcount 1 killit

enda

action FREEZEFRAME2 1 1 1
action FREEZEFRAME3 2 1 1
spritenoshade FREEZEHALO
useractor notenemy FREEZEHALO 0

ife initsprite 0 break

ifmove 0
{
	ifrnd 170
	{
		ifrnd 128 action FREEZEFRAME2 else
		action FREEZEFRAME3
	}
	move STOPPED
	sizeat 192 192
	cstator 642
	ifrnd 128 cstator 4
	ifrnd 128 cstator 8
	spritepal 1
}

ifcount 1 killit

enda

move WAKEMOVE 256 -4
useractor notenemy WAKEY 0
ifmove 0 { geta[].z z sub z 4096 seta[].z z sizeat 4 4 cstat 32768 move WAKEMOVE geth getv }
ifcount 10 killit
enda

action SPLASHFRAMES -1 5 1 1 20
useractor notenemy WATERSPLASH 0 SPLASHFRAMES
ifactioncount 5 killit
enda

action DRIPSPLASHFRAMES 0 9 1 1 3
useractor notenemy WATERDRIPSPLASH 0 DRIPSPLASHFRAMES
ifmove 0 { move STOPPED state checkfloordist geta[].z z add z temp seta[].z z }
ifactioncount 9 killit
enda

// action SPARKFRAME -1 1 1 1 1
action CONCRETEFRAMES -2 3 1 1 4

spritenoshade SHOCK_ACTOR
useractor notenemy SHOCK_ACTOR 0
ifmove 0
{
	ifn mtype 0 add mtype THISACTOR
	move STOPPED
	sound SPARKING3
	setactor[THISACTOR].shade -127
	setactor[THISACTOR].pitch 512
	ifspawnedby ARROWPROJ spritepal 117
	ifvarn myspawner -1
	{
		ifn mtype 0 add TOTALSHOCKS 1
		getactor[myspawner].picnum picnum
		set starty tiledata[picnum].ysize
		set z2 sprite[myspawner].yrepeat
		mul starty z2
		shiftr starty 7
		ife rendmode 0 shiftr starty 2
		ifg starty 255 set starty 255
		seta[].yrepeat starty
		
		set startx tiledata[picnum].xsize
		set x2 sprite[myspawner].xrepeat
		mul startx x2
		shiftr startx 5
		ife rendmode 0 shiftr startx 2
		ifg startx 255 set startx 255
		seta[].xrepeat startx
	}
	else 
	{
		sizeat 80 24
		ife rendmode 0 sizeat 20 12
	}
	cstat 0
	
	ife rendmode 0
	{
		cstator 128
		seta[].blend 1
	}
}
randvar angvar 2047
// failsafe cstat check due to myserious bug that can make them solid
geta[].cstat temp
ifvarand temp 256 xorvar temp 256
ifvarand temp 1 xorvar temp 1
seta[].cstat temp

ife rendmode 0
{
	geta[].cstat temp
	ifvarand temp 512 xorvar temp 512
	ifvarand temp 2 xorvar temp 2
	ife temp 128 set temp 132 else
	ife temp 132 set temp 136 else
	ife temp 136 set temp 140 else
	ife temp 140 set temp 128
	seta[].cstat temp
}
setactor[THISACTOR].ang angvar
ifvarn myspawner -1
{
	geta[myspawner].z z
	sub z 6144
	setsprite THISACTOR sprite[myspawner].x sprite[myspawner].y z
	geta[].x x add x 2 seta[].x x
	geta[].y y add y 2 seta[].y y
	ifl actorvar[myspawner].stun 6 
	ifvarand player[].player_par 1
	{
		getav[myspawner].stun stun
		add stun 2 ifg stun 6 set stun 6
		setav[myspawner].stun stun
	}
	ifl sprite[myspawner].htextra 1
	ifrnd 36
	{
		seta[myspawner].htextra 2
		seta[myspawner].htpicnum RPG
	}
	ifn mtype 0
	ifle TOTALSHOCKS 160
	{
		set team 1
		// shoot all other visible enemies within 6144 units with weak shockbeam
		set temp player[].player_par
		add temp 16384
		sub temp mtype
		modvar temp 13
		ife temp 0
		{
			set x startx
			div x 3
			seta[].xrepeat x
			set y starty
			div y 3
			seta[].yrepeat y
			set safecount 0 // max 3 targets
			
			headspritestat myvictim 1 // 990
			whilevarn myvictim -1
			{
				ife sprite[myvictim].picnum SHOCK_ACTOR
				ifn myvictim THISACTOR
				ife actorvar[myvictim].myspawner myspawner
					cstat 32768
					
				ife actorvar[myvictim].monstatus 1
				// ife actorvar[myvictim].team 0
				ifn actorvar[myvictim].team 1
				ifn actorvar[myvictim].team 3
				ifle safecount 2
				ife sprite[myvictim].htextra -1
				{
					set target myvictim // actorvar[myvictim].mysignpost
					state targetcheck
					ifn target -1
					ifn target myspawner
					// ife actorvar[target].monstatus 1
					{
						ifl xydist 10240
						{
							geta[myspawner].xrepeat init_xrepeat
							geta[myspawner].yrepeat init_yrepeat
							
							seta[myspawner].xrepeat 0
							seta[myspawner].yrepeat 0
							
							set spriteid target
							state facesprite
							set bottarget target
							state hitscan_targetprep
							setprojectile[SHOCKBEAM].trail -1
							setprojectile[SHOCKBEAM].spawns -1
							ife botclip YES 
							{
								ifrnd 128 setprojectile[SHOCKBEAM].extra 4 else
								setprojectile[SHOCKBEAM].extra 3
								geta[bottarget].x x2
								geta[bottarget].y y2
								sub x2 sprite[].x
								sub y2 sprite[].y
								getangle angvar x2 y2
									
								add angvar 1024
								cos xvel angvar
								sin yvel angvar
									  
								shiftvarr xvel 6
								shiftvarr yvel 6
								
								movesprite bottarget xvel yvel 0 CLIPMASK0 RETURN
								set RETURN -1
							}
							else
							setprojectile[SHOCKBEAM].extra 1
							zshoot zdist SHOCKBEAM
							setprojectile[SHOCKBEAM].extra 52
							setprojectile[SHOCKBEAM].trail LIGHTNING_TRAIL1
							setprojectile[SHOCKBEAM].spawns ELEC_EXP

							seta[myspawner].xrepeat init_xrepeat
							seta[myspawner].yrepeat init_yrepeat

							// spawn trail sprites
							ifl actorvar[bottarget].stun 6
							{
								set zdist sprite[bottarget].z
								sub zdist 6144 // this actor is 6144 off the ground
								sub zdist sprite[].z
								set z zdist
								
								ldist xydist3 bottarget THISACTOR
								ifvare xydist3 0 setvar xydist3 1 
								shiftl zdist 8
								divvarvar zdist xydist3

								set countvarb xydist3
								div countvarb 256
								ifg countvarb 32 set countvarb 32
								ifl countvarb 1 set countvarb 1
								
								shiftvarr z 4
								getangle shotpitch xydist3 z
								ifvarg shotpitch 1023 subvar shotpitch 2048

								geta[].x x
								geta[].y y
								geta[].z z sub z 2048
								
								set countvar 0
								mul zdist 3 div zdist 2
								whilevarvarn countvar countvarb
								{
									setvarvar x2 x
									addvar x2 384 // 256
									rotatepoint x y x2 y sprite[].ang x y
									set temp sprite[].sectnum
									updatesectorz x y z temp
									ifn temp -1 		
									ifle Numsprites 15000
									{
										espawn LIGHTNING_TRAIL1
										ifn RETURN -1
										{
											setsprite RETURN x y z
											seta[RETURN].pitch shotpitch
											setav[RETURN].shotpitch shotpitch
											setav[RETURN].mtype 1
											seta[RETURN].ang sprite[].ang
										}
									}
									addvarvar z zdist
									
									addvar countvar 1
								}
							}
							set bottarget -1
							add safecount 1
							
							ifrnd 16
							ife player[].curr_weapon 3
							ifg player[].ammo_amount 3 0
							{
								getp[].ammo_amount 3 temp
								sub temp 1
								setp[].ammo_amount 3 temp
							}
						}
					}
				}
				nextspritestat myvictim myvictim
			}
			seta[].xrepeat startx
			seta[].yrepeat starty
		}
		
	}
}
ifcount 14 cstator 2
ifcount 22 { ife myspawner player[].i killit cstator 512 }
ifcount 30 
{
	stopactorsound THISACTOR SPARKING3
	killit
}

enda

gamevar LGtrail_pic 15650 1
state lightningtrailcode

ifle framerate 20 ifpdistg 3072 killit
	
ifmove 0
{
	
	ife rendmode 0 { cactor 13052 break }
	move STOPPED
	cstat 0
	sizeat 18 18
	addvar LGtrail_pic 1
	ifrnd 128 addvar LGtrail_pic 1
	ifvarg LGtrail_pic 15655 setvar LGtrail_pic 15650
	setactor[].picnum LGtrail_pic
	getactor[].owner spriteid	
	
	ifvare mtype NO
	{
		getactorvar[spriteid].shotpitch shotpitch
		setactor[].pitch shotpitch
	}
	setactor[].shade -127
	
	// ifvare rendmode 0 { cstator 128 sizeat 8 8 }
	
}
ifvare mtype YES 
{
	setactor[].pitch shotpitch
	sizeat 12 12
}
ifcount 8 killit
ends

useractor notenemy 13052 0

	ifmove 0
	{
		move STOPPED
		sizeat 16 16
		cstat 642
		seta[].blend 1
	}
	sizeto 0 0

enda

spritenopal LIGHTNING_TRAIL1
spritenopal LIGHTNING_TRAIL2
spritenopal LIGHTNING_TRAIL3
spritenopal LIGHTNING_TRAIL4
spritenopal LIGHTNING_TRAIL5
spritenopal LIGHTNING_TRAIL6
spritenoshade LIGHTNING_TRAIL1
useractor notenemy LIGHTNING_TRAIL1 0 state lightningtrailcode enda
spritenoshade LIGHTNING_TRAIL2
useractor notenemy LIGHTNING_TRAIL2 0 state lightningtrailcode enda
spritenoshade LIGHTNING_TRAIL3
useractor notenemy LIGHTNING_TRAIL3 0 state lightningtrailcode enda
spritenoshade LIGHTNING_TRAIL4
useractor notenemy LIGHTNING_TRAIL4 0 state lightningtrailcode enda
spritenoshade LIGHTNING_TRAIL5
useractor notenemy LIGHTNING_TRAIL5 0 state lightningtrailcode enda
spritenoshade LIGHTNING_TRAIL6
useractor notenemy LIGHTNING_TRAIL6 0 state lightningtrailcode enda

spritenoshade SPARKFALL
move DRIFT 64
move SLOWSPARK 96

useractor notenemy SPARKFALL 0 // SPARKFRAME

ifmove 0
{
	ifspawnedby GRENADEPROJ ifpdistl 2048 killit
	geta[].ang angvar
	add angvar 768
	rand temp 512
	add angvar temp
	seta[].ang angvar
	move DRIFT geth
	
	sizeat 3 3
	seta[].shade -127
	seta[].blend 255
	randvar mtype 512
	sub mtype 1024
	seta[].htflags 2048
	ifrnd 128 cstator 8
	ifrnd 128 cstator 4
	ife initsprite 2 { geta[].z z add z 2048 seta[].z z add mtype 768 }
	ife initsprite -2 { geta[].z z sub z 1024 seta[].z z sub mtype 512 }
	ifspawnedby FIRELASER spritepal 2 else
	ifspawnedby ARROWPROJ spritepal 117
	else
		spritepal 12
}
ifceilingdistl 16 fall

movesprite THISACTOR 0 0 mtype CLIPMASK0 RETURN
ife initsprite -2 { ifg mtype 1560 killit }
else
iffloordistl 8
{
	ife monstatus 2 killit
	ifrnd 128 killit else
	{
		set monstatus 2
		geta[].z z
		sub z 1024
		seta[].z z
		seta[].zvel -1024
		set mtype 0
	}
}
add mtype 160
ifg mtype 3072 ifrnd 16 killit
ifcount 4 { resetcount sizeto 1 1 }
ifnotmoving ifcount 3 { resetcount move SLOWSPARK randomangle ifrnd 64 killit }

enda

useractor notenemy WOODFALL 0

ifn initsprite 0
{
	ifmove 0
	{
		ifrnd 32
		{
			rand zdist 844
			sub zdist 2560
			ezshoot zdist WOODDEBRIS
			rand zdist 2048
			seta[RETURN].ang zdist
			rand zdist 3
			ife zdist 0 seta[RETURN].cstat 128 else
			ife zdist 1 seta[RETURN].cstat 132 else
			ife zdist 2 seta[RETURN].cstat 136 else
			ife zdist 3 seta[RETURN].cstat 140
			killit
		}
		geta[].ang angvar
		add angvar 768
		rand temp 512
		add angvar temp
		seta[].ang angvar
		move DRIFT geth
		sizeat 8 8
		randvar mtype 512
		sub mtype 1024
		ife initsprite 2 { geta[].z z add z 2048 seta[].z z add mtype 768 }
		ife initsprite -2 { geta[].z z sub z 1024 seta[].z z sub mtype 512 }
		seta[].htflags 2048
		ifrnd 128 cstator 8
		ifrnd 128 cstator 4
		spritepal 15
	}
	ifceilingdistl 16 fall
	
	ifrnd 32
	{
		ifrnd 64 cstat 0 else
		ifrnd 128
		{
			ifrnd 128 cstat 12
			else cstat 4
		}
		else cstat 8
	}

	movesprite THISACTOR 0 0 mtype CLIPMASK0 RETURN
	ife initsprite -2 { ifg mtype 2048 killit }
	else
	iffloordistl 8
	{
		ife botclip 1 killit
		ifrnd 128 killit else
		{
			set botclip 1
			geta[].z z
			sub z 1024
			seta[].z z
			seta[].zvel -1024
			set mtype 0
		}
	}
	add mtype 160
	ifg mtype 3072 ifrnd 16 killit
	ifnotmoving ifcount 3 { resetcount move SLOWSPARK randomangle ifrnd 64 killit }
}

enda

useractor notenemy CONCRETEFALL 0 CONCRETEFRAMES

ifn initsprite 0
{
	ifmove 0
	{
		action CONCRETEFRAMES
		geta[].ang angvar
		add angvar 768
		rand temp 512
		add angvar temp
		seta[].ang angvar
		move DRIFT geth
		// sizeat 16 16
		sizeat 8 8
		set init_xrepeat 8
		set init_yrepeat 8
		randvar mtype 512
		sub mtype 1024
		ife initsprite 2 { geta[].z z add z 2048 seta[].z z add mtype 768 }
		ife initsprite -2 { geta[].z z sub z 1024 seta[].z z sub mtype 512 }
		seta[].htflags 2048
		ifrnd 128 cstator 8
		ifrnd 128 cstator 4
	}
	ifceilingdistl 16 fall
	
	ifrnd 32
	{
		ifrnd 64 cstat 0 else
		ifrnd 128
		{
			ifrnd 128 cstat 12
			else cstat 4
		}
		else cstat 8
	}

	movesprite THISACTOR 0 0 mtype CLIPMASK0 RETURN
	ife initsprite -2 { ifg mtype 2048 killit }
	else
	iffloordistl 8
	{
		ife botclip 1 killit
		ifrnd 128 killit else
		{
			set botclip 1
			geta[].z z
			sub z 1024
			seta[].z z
			seta[].zvel -1024
			set mtype 0
		}
	}
	add mtype 160
	ifg mtype 3072 ifrnd 16 killit
	ifnotmoving ifcount 3 { resetcount move SLOWSPARK randomangle ifrnd 64 killit }
}

enda

action SCRAPFRAMES 1  4  1  1  5
useractor notenemy LILSCRAP 0


	ifmove 0
	{
		action SCRAPFRAMES
		geta[].ang angvar
		add angvar 768
		rand temp 512
		add angvar temp
		seta[].ang angvar
		move DRIFT geth
		// sizeat 12 12
		sizeat 6 6
		randvar mtype 512
		sub mtype 1024
		ife initsprite 2 { geta[].z z add z 2048 seta[].z z add mtype 768 }
		ife initsprite -2 { geta[].z z sub z 1024 seta[].z z sub mtype 512 }
		seta[].htflags 2048
		ifrnd 128 cstator 8
		ifrnd 128 cstator 4
	}
	ifceilingdistl 16 fall
	
	ifrnd 32
	{
		ifrnd 64 cstat 0 else
		ifrnd 128
		{
			ifrnd 128 cstat 12
			else cstat 4
		}
		else cstat 8
	}

	movesprite THISACTOR 0 0 mtype CLIPMASK0 RETURN
	ife initsprite -2 { ifg mtype 2048 killit }
	else
	iffloordistl 8
	{
		ife botclip 1 killit
		ifrnd 128 killit else
		{
			set botclip 1
			geta[].z z
			sub z 1024
			seta[].z z
			seta[].zvel -1024
			set mtype 0
		}
	}
	add mtype 160
	ifg mtype 3072 ifrnd 16 killit
	ifnotmoving ifcount 3 { resetcount move SLOWSPARK randomangle ifrnd 64 killit }


enda

useractor notenemy CLIPFALL 0

	
	ifmove 0
	{
		move DRIFT geth
		sizeat 24 24
		randvar mtype 512
		sub mtype 1024
		set countvar 0
	}
	ifceilingdistl 16 fall
	
	add countvar 1

	iffloordistl 8 fall
	else
	{
		geta[].z savz
		movesprite THISACTOR 0 0 mtype CLIPMASK0 RETURN
		ife sprite[].z savz fall
	}

	iffloordistl 2
	{
		move 0
		cactor CLIPGROUND
		getflorzofslope sprite[].sectnum sprite[].x sprite[].y z // z is the return var
		setsprite THISACTOR sprite[].x sprite[].y z
		insertspriteq
		sound MAGFALL
		break
	}
	add mtype 160

	ifnotmoving ifcount 3 ifl countvar 60 { resetcount move SLOWSPARK randomangle }
	
	ifinwater nullop else
	ifg countvar 150
	{
		move 0
		cactor CLIPGROUND
		getflorzofslope sprite[].sectnum sprite[].x sprite[].y z // z is the return var
		setsprite THISACTOR sprite[].x sprite[].y z
		insertspriteq
		sound MAGFALL
	}
	

enda

action STICKYBURN -30 14 1 1 2
action STICKYBURN2 -70 14 1 1 2

spritenoshade STICKYFIRE
useractor notenemy STICKYFIRE 0

ifcount 1 nullop
  else 
    ifcount 0
	{
		seta[].shade -127
		seta[].blend 1
		cstator 514
		ifrnd 128 action STICKYBURN else action STICKYBURN2
    	ifrnd 128 soundonce FIRE_CRACKLE
    	cstat 130
    	ifrnd 128 cstator 4
		randvar temp 10
		switch temp
		case 0 sizeat 2 2 break
    	case 1 sizeat 2 3 break
		case 2 sizeat 3 3 break
		case 3 sizeat 3 4 break
		case 4 sizeat 4 5 break
		case 5 sizeat 4 6 break
		case 6 sizeat 5 6 break
		case 7 sizeat 5 7 break
		case 8 sizeat 6 7 break
		case 9 sizeat 6 8 break
		case 10 sizeat 7 8 break
		default break
    	endswitch
    	
    	
    	ifrnd 96
    	{
	    	geta[].xrepeat x
	    	mul x 2
	    	seta[].xrepeat x
	    	geta[].yrepeat y
	    	mul y 2
	    	seta[].yrepeat y
    	}

		ifvarn myspawner -1
		{
			geta[myspawner].z lastang
			geta[myspawner].yrepeat y
			
			set y2 tiledata[mtype].ysize
			mul y y2
			mul y 3

			randvarvar tempb y
			// add tempb mtype
		  	geta[myspawner].z z
		  	ife sprite[myspawner].picnum COMMANDER subvar z 3072
			ife sprite[myspawner].picnum NEWCOMM subvar z 3072
		   	sub z tempb
		  	seta[].z z
	  	}
	}

ifvarn myspawner -1 
{
	geta[myspawner].z z
	sub z lastang
	geta[].z temp
	add temp z
	seta[].z temp
	ifg countvar 8
	{
		set countvar 0
		geta[myspawner].statnum temp
		ife temp 1024 set myspawner -1 else
		{
			geta[myspawner].xrepeat tempb
			set x2 tiledata[mtype].xsize
			mul tempb x2
			div tempb 12
			
			geta[myspawner].x x
			geta[myspawner].y y
			randvarvar temp tempb
			ifrnd 128 add x temp else sub x temp
			randvarvar temp tempb
			ifrnd 128 add y temp else sub y temp
			seta[].x x
			seta[].y y
		}
	}
	ifn myspawner -1
	geta[myspawner].z lastang
}
add countvar 1

ifcount 30 sizeto 0 0

seta[].htbposx sprite[].x
seta[].htbposy sprite[].y
seta[].htbposz sprite[].z

enda

action ASHELLROLL  0  2  1  1  8
move SHELLROLL1 48
move SHELLBOUNCE 48 -20
move SHELLBOUNCE2 48
move SHELLROLL2	32
move SHELLROLL3 16
move SHELLSTOP

state shellcode
fall

ifinwater
{
	ifmove SHELLSTOP nullop else
	{
		ifmove SHELLROLL3 nullop else
		move SHELLROLL3 geth
	}
}

ifmove 0
{
  clipdist 8
  geta[].ang angvar
  randvar temp 256
  ifrnd 128 mulvar temp -1
  add angvar temp
  seta[].ang angvar
  move SHELLBOUNCE geth getv
  cstat 32
  action ASHELLROLL
}

ifmove SHELLBOUNCE ifcount 6
{
	move SHELLBOUNCE2 geth
	resetcount
}

ifmove SHELLBOUNCE2
{
	geta[].zvel temp
	ifg temp 96 seta[].zvel 96
	set tempb 0
	iffloordistl 1 set tempb 1
	ifcount 8 set tempb 1
	ifvare tempb 1
	{
		ifrnd 128 move SHELLROLL3 geth else
	  	move SHELLROLL2 geth
	    resetcount
    }
}

ifmove SHELLROLL1 ifcount 22 { move SHELLROLL2 geth resetcount }
ifmove SHELLROLL2 ifcount 16 { move SHELLROLL3 geth resetcount }
ifmove SHELLROLL3 
  ifcount 12
    ifrnd 32 
{
	 action ANULLACTION
	 ifactor NEWSHELL cactor NEWSHELL2
	 seta[].mdflags 2
     move SHELLSTOP
	 seta[].mdflags 0
     geta[].htflags temp
	 orvar temp 128
	 seta[].htflags temp
     geta[].x x
     geta[].y y
     geta[].sectnum mysector
	 ifn mysector -1
	 {
     getflorzofslope mysector x y z // z is the return var
     seta[].z z
	 }
}

ifnotmoving
{
	geta[].ang angvar
	add angvar 1024
	randvar temp 256
	ifrnd 128 mulvar temp -1
	add angvar temp
	seta[].ang angvar
}

ifcount 780 killit

ends

useractor notenemy NEWSHOTGUNSHELL 0 state shellcode enda
useractor notenemy NEWSHELL 0 state shellcode enda
useractor notenemy NEWSHELL2 0 fall ifcount 780 killit enda

move CANROLL
move SNACKVELS 64


action CANCRUSHED 2 1 1
action ACANROLL1 2 6 1 1 5
action ACANROLL2 2 6 1 1 7
action ACANROLL3 2 6 1 1 9
action ACANROLL4 2 6 1 1 12

action ABLUEBALLSTAND 10022 1 1
action ABLUEBALLCRUSHED 10023 1 1
action ABLUEBALLSIDE 10015 1 1
action ABLUEBALLROLL1 10015 6 1 1 5
action ABLUEBALLROLL2 10015 6 1 1 7
action ABLUEBALLROLL3 10015 6 1 1 9
action ABLUEBALLROLL4 10015 6 1 1 12

action AENERGYSTAND 10030 1 1
action AENERGYCRUSHED 10031 1 1
action AENERGYSIDE 10023 1 1
action AENERGYROLL1 10023 6 1 1 5
action AENERGYROLL2 10023 6 1 1 7
action AENERGYROLL3 10023 6 1 1 9
action AENERGYROLL4 10023 6 1 1 12

action APEASTAND 10038 1 1
action APEACRUSHED 10039 1 1
action APEASIDE 10031 1 1
action APEAROLL1 10031 6 1 1 5
action APEAROLL2 10031 6 1 1 7
action APEAROLL3 10031 6 1 1 9
action APEAROLL4 10031 6 1 1 12

state canrollingcode

ifmove CANROLL
{
	getactor[THISACTOR].ang angvar
	cos xvel angvar
	sin yvel angvar
	mulvarvar xvel mtype
	mulvarvar yvel mtype
	divvarvar xvel startx
	divvarvar yvel starty
	setvar temp 0
	ifinwater 
	{
		shiftvarr xvel 2
		shiftvarr yvel 2
	}
	addvar startx 2
	addvar starty 2
	movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN
	ifvare RETURN 0
	{
		ifvarg startx 1024 
		{ 
			move STOPPED 
			ife droptile ENERGYCAN action AENERGYSIDE else
			ife droptile BLUEBALLCAN action ABLUEBALLSIDE else
			ife droptile PEACAN action APEASIDE else
			action 0 
		}
		ifvarl xvel 0 mulvar xvel -1
		ifvarl yvel 0 mulvar yvel -1
		addvarvar xvel yvel
		
		ifaction ACANROLL1 ifl xvel 200 action ACANROLL2
		ifaction ACANROLL2 ifl xvel 150 action ACANROLL3
		ifaction ACANROLL3 ifl xvel 100 action ACANROLL4
		
		ifaction ABLUEBALLROLL1 ifl xvel 200 action ABLUEBALLROLL2
		ifaction ABLUEBALLROLL2 ifl xvel 150 action ABLUEBALLROLL3
		ifaction ABLUEBALLROLL3 ifl xvel 100 action ABLUEBALLROLL4
		
		ifaction AENERGYROLL1 ifl xvel 200 action AENERGYROLL2
		ifaction AENERGYROLL2 ifl xvel 150 action AENERGYROLL3
		ifaction AENERGYROLL3 ifl xvel 100 action AENERGYROLL4
		
		ifaction APEAROLL1 ifl xvel 200 action APEAROLL2
		ifaction APEAROLL2 ifl xvel 150 action APEAROLL3
		ifaction APEAROLL3 ifl xvel 100 action APEAROLL4
		
		shiftvarl xvel 2
		getactor[THISACTOR].pitch temp
		mulvarvar xvel mtype
		addvarvar temp xvel
		setactor[THISACTOR].pitch temp
	}
	else 
	{
		mulvar mtype -1
		shiftvarl startx 2
		shiftvarl starty 2
	}

}

ends

useractor notenemy BLUEBALLCAN

ifmove 0
{
	ifspawnedby COLAMACHINE
	move SNACKVELS randomangle else
	move STOPPED
	sizeat 12 10
	cstat 256
	clipdist 8
}
ifmove SNACKVELS iffloordistl 2
{
	move STOPPED
}

set tempb healthbuff
add tempb 20

fall
set monstatus 100 strength 1 strength 1
ife drinkcola 0
ife eatsnack 0
 // ifphealthl 120
 ifl sprite[player[].i].extra tempb
  iffloordistl 2
	ifp palive
	 ifcansee
	   ifpdistl 844
	     ife player[].kickback_pic 0
		   ife player[].weapon_pos 0
	   {
		 set drinkcola 1
		 set snackpic BLUEBALLCAN
		 set snackpal sprite[].pal
		 setp[].weapon_pos -1
		 killit
       }
	   

ifhitweapon
{
	ifaction CANCRUSHED
	{
		debris SCRAP1 1
		killit
	}
	else
	{
		set monstatus 2
		cactor COLACANSTAND
		sizeat 20 20
		action CANCRUSHED
		espawn BLOODPOOL
		ifspritepal 0
		setactor[RETURN].pal 1
		else setactor[RETURN].pal 2
		seta[RETURN].cstat 34
		ifspritepal 0
		spritepal 46
	}
}
enda

useractor notenemy COLACANSTAND 5
ifmove 0
{
	cstator 257
	sizeat 10 8
	clipdist 8
	move STOPPED
	ife droptile BLUEBALLCAN action ABLUEBALLSTAND
	ife droptile ENERGYCAN action AENERGYSTAND
	ife droptile PEACAN action APEASTAND
}

fall

set tempb healthbuff
add tempb 20

ifaction CANCRUSHED nullop else
ifaction ABLUEBALLCRUSHED nullop else
ifaction AENERGYCRUSHED nullop else
ifaction APEACRUSHED nullop else
{
	set monstatus 100 strength 1
	ife drinkcola 0
	ife eatsnack 0
	 // ifphealthl 120
	 ifl sprite[player[].i].extra tempb
	  iffloordistl 2
		ifp palive
		 ifcansee
		   ifpdistl 844
			 ife player[].kickback_pic 0
		   {
			 set drinkcola 1
			 set snackpal sprite[].pal
			 ife droptile 0 set snackpic 6607
			 // ifn droptile 0 
			 set snackpic droptile
			 setp[].weapon_pos -1
			 killit
		   }
}   

ifhitweapon
{
	ifaction CANCRUSHED
	{
		debris SCRAP1 1
		killit
	}
	else
	ifaction ABLUEBALLCRUSHED
	{
		debris SCRAP1 1
		killit
	}
	else
	ifaction AENERGYCRUSHED
	{
		debris SCRAP1 1
		killit
	}
	else
	ifaction APEACRUSHED
	{
		debris SCRAP1 1
		killit
	}
	else
	{
		ife droptile BLUEBALLCAN action ABLUEBALLCRUSHED
		else
		ife droptile ENERGYCAN action AENERGYCRUSHED
		else
		ife droptile PEACAN action APEACRUSHED
		else
		action CANCRUSHED
		sizeat 24 20
		espawn BLOODPOOL
		ifaction ABLUEBALLCRUSHED seta[RETURN].pal 1
		else
		ifaction APEACRUSHED seta[RETURN].pal 7
		else
		setactor[RETURN].pal 2
		seta[RETURN].cstat 34
		set monstatus 2
	}
}
enda

useractor notenemy COLACANSIDE 5
ifmove 0
{
	cstator 257
	sizeat 24 20
	clipdist 8
	// setactor[THISACTOR].roll 512
	move STOPPED
	ifspawnedby COLACANSIDE nullop else 
	{
		move CANROLL geth
		action ACANROLL1
		ife droptile BLUEBALLCAN action ABLUEBALLROLL1
		ife droptile ENERGYCAN action AENERGYROLL1
		ife droptile PEACAN action APEAROLL1
		ifrnd 128 { cstator 4 seta[].mdflags 16 }
		
	}
	setvar startx 64
	setvar starty 64
	
	ifrnd 128 setvar mtype 1 else
	{
		getactor[THISACTOR].ang angvar
		addvar angvar 1024
		setactor[THISACTOR].ang angvar
		setvar mtype -1
	}
	
}

fall
set monstatus 100 strength 1


getactor[THISACTOR].xvel xvel

ifhitweapon
{
	ifaction CANCRUSHED
	{
		debris SCRAP1 1
		killit
	}
	else ifaction ABLUEBALLCRUSHED
	{
		debris SCRAP1 1
		killit
	}
	else ifaction AENERGYCRUSHED
	{
		debris SCRAP1 1
		killit
	}
	else ifaction APEACRUSHED
	{
		debris SCRAP1 1
		killit
	}
	else
	{
		cactor COLACANSTAND
		move STOPPED
		setactor[THISACTOR].roll 0
		setactor[THISACTOR].pitch 0
		ife droptile BLUEBALLCAN action ABLUEBALLCRUSHED else
		ife droptile ENERGYCAN action AENERGYCRUSHED else
		ife droptile PEACAN action APEACRUSHED else
		action CANCRUSHED
		set monstatus 2
		espawn BLOODPOOL
		ife droptile BLUEBALLCAN seta[RETURN].pal 1 else
		ife droptile PEACAN seta[RETURN].pal 7 else
		setactor[RETURN].pal 2
		seta[RETURN].cstat 34
	} 
}

state canrollingcode

ifand bits 4 break
ifand extbits 64 break

set tempb healthbuff
add tempb 20

ife drinkcola 0
ife eatsnack 0
// ifphealthl 120
 ifl sprite[player[].i].extra tempb
  iffloordistl 2
	ifp palive
	 ifcansee
	   ifpdistl 844
	   ife player[].kickback_pic 0
	{
	   set temp NO
	   ifspawnedby COLAMACHINE set temp YES
	   
	   ifcount 15
	   ifhitspace set temp YES
	   
	   ife temp YES
	   {
		 set drinkcola 1
		 set snackpal sprite[].pal
		 ifn droptile 0 set snackpic droptile
		 setp[].weapon_pos -1
		 killit
       }
	   else
	   ifcount 15
	   ifl player[].fta 30 { quote 1180 setp[].fta 40 }
	}

enda

action ACOOKIESNACK 23
action APORKSNACK 24

useractor notenemy SNACKSPRITE
fall
set monstatus 100 strength 1
ifmove 0
{
	ifspawnedby COLAMACHINE
	move SNACKVELS geth else
	move STOPPED
	sizeat 12 10
	ife droptile 6577 { action ACOOKIESNACK sizeat 14 12 } else
	ife droptile 6578 { action APORKSNACK sizeat 14 12 } else
	ife droptile 1 action ANULLACTION else
	ifrnd 128
	{
		sizeat 14 12
		ifrnd 128 action ACOOKIESNACK else
		action APORKSNACK
	}
}
ifmove SNACKVELS iffloordistl 2
ifcount 16
{
	sound SNACKDROP
	move STOPPED
}

ifand bits 4 break
ifand extbits 64 break

set tempb healthbuff
add tempb 20

ife eatsnack 0
ife drinkcola 0
 // ifphealthl 120
 ifl sprite[player[].i].extra tempb
  iffloordistl 2
	ifp palive
	 ifcansee
	   ifpdistl 844
	     ife player[].kickback_pic 0
	{
	   set temp NO
	   ifspawnedby COLAMACHINE set temp YES
	   
	   ifcount 15
	   ifhitspace set temp YES
	   
	   ife temp YES
	   {
		 set eatsnack 1
		 set snackpal sprite[].pal
		 ifaction 0 set snackpic SNACKSPRITE else
		 ifaction ACOOKIESNACK set snackpic 6577 else
		 ifaction APORKSNACK set snackpic 6578
		 setp[].weapon_pos -1
		 killit
       }
	   else
	   ifcount 15
	   ifl player[].fta 30 { quote 1180 setp[].fta 40 }
	}
enda

state EJECTCOLA
	espawn COLACANSIDE
	ife mtype BLUEBALLVEND setav[RETURN].droptile BLUEBALLCAN
	else
	{
		rand temp 3
		ife temp 1 setav[RETURN].droptile BLUEBALLCAN else ife temp 2
		setav[RETURN].droptile ENERGYCAN else ife temp 3
		setav[RETURN].droptile PEACAN
	}

	getactor[RETURN].z z
	subvarvar z initsprite
	setactor[RETURN].z z
	setvar countvar 0
	getactor[THISACTOR].ang angvar
	randvar temp 48
	ifrnd 128 mulvar temp -1
	addvarvar angvar temp
	setactor[RETURN].ang angvar
	set pal 0
	ifrnd 192 
	{ 
		rand temp 6 
		ife temp 0 set pal 10 else
		ife temp 1 set pal 14 else
		ife temp 2 set pal 16 else
		ife temp 3 set pal 20 else
		ife temp 4 set pal 21 else
		ife temp 5 set pal 22 else
		set pal 23
	}
	setactor[RETURN].pal pal
	addvar countvarb 1 // how many cans have spawned
	// ifvarg countvarb 12 killit
ends

state EJECTSNACK

	espawn SNACKSPRITE
	getactor[RETURN].z z
	subvarvar z initsprite
	setactor[RETURN].z z
	setvar countvar 0
	getactor[THISACTOR].ang angvar
	randvar temp 256
	sub temp 128
	addvarvar angvar temp
	setactor[RETURN].ang angvar
	rand pal 9
	add pal 10
	ife pal 19 set pal 23
	ife pal 18 set pal 22
	ife pal 17 set pal 21
	seta[RETURN].pal pal
	
	addvar countvarb 1 // how many snacks have spawned
	// ifvarg countvarb 12 killit

ends

state broken_vender
	ifcount 12
	{
		ifg botclip 0
		{
			set value 4
			state spawnimpcoins
			sub botclip 1
		}
		
		addvar countvarb 1
		ifle countvarb 8
		{
			ife mtype VENDMACHINE state EJECTSNACK else
			state EJECTCOLA 
		}
		resetcount
		// ifrnd 8 killit
		
		ifvarg countvarb 8
		ifl botclip 1 killit
	}
	ifrnd 16 stopsound DISPENSE_CAN
	soundonce DISPENSE_CAN
ends

useractor notenemy COLAMACHINE 0

ifmove 0
{
	cstator 16
	move STOPPED
	ifvarg initsprite 0 divvar initsprite  4 else setvar initsprite 4096
	// failsafe deletion check
	cactor SMALLSMOKE 
	findnearspritez COLAMACHINE 384 4096 spriteid
	ifn spriteid -1 killit // TOO CLOSE TOGETHER
	cactor COLAMACHINE
	ife mtype SNACKVEND set mtype VENDMACHINE
	
	set botclip 2
}

ifpdistl 1280
  ifp pfacing
      ifcount 12
        ifvarl countvar 2
			ifl countvarb 12
{
	set handicon 3
	ifhitspace
	{
		ifge credits 50
		{
			resetcount
			addvar countvar 1
			sound COINSLOT
			add botclip 1
			sub credits 50
			sub lastcredits 50
		}
		else quote 361
	}
}

ifvarg countvar 0
{
	stopsound DUKE_GRUNT
	stopsound B_GRUNT2
	addvar countvar 1
	
	ifl countvarb 12
	ifvare countvar 34 { ife mtype VENDMACHINE sound DISPENSE_SNACK else sound DISPENSE_CAN }
	
	ifvare countvar 60 
	{
		ifl countvarb 12
		{
			ife mtype VENDMACHINE state EJECTSNACK else
			state EJECTCOLA 
		}
		else set countvar 0
		
	}
}
ife myspawner -1
{
	quote 1084
	state broken_vender
	break
}
getwall[myspawner].picnum picnum
ifvarn picnum COLAMACHINE // if the wall has changed picnum, the machine is broken
ifvarn picnum VENDMACHINE
ifvarn picnum BLUEBALLVEND
ifvarn picnum SNACKVEND
ifvarn picnum ASIANVEND
	state broken_vender
	

enda

useractor notenemy BLOODPOOL2 0

ifmove 0
{
	ife sprite[].sectnum -1 killit
	ifvarand sector[].floorstat 1 killit
	
	ifawayfromwall
	{
		move STOPPED
		cstat 32
		
		getzrange sprite[].x sprite[].y sprite[].z sprite[].sectnum temp temp z spriteid 192 CLIPMASK0
		ifge spriteid 49152
		{
			sub spriteid 49152
			ifvarand sprite[spriteid].cstat 32 nullop else killit
		}
		else
		ifn sector[].floorslope 0 killit
		
		insertspriteq
		iffloordistl 8
		{
			insertspriteq
			sizeat 16 16
		}
		else killit
		ifrnd 128 cstator 4
		ifrnd 128 cstator 8
	}
	else { spawn BLOODPOOL killit }
}

ifp ponground
ifpdistl 408
{
	setp[].footprintcount 10
	ifspritepal 0 setp[].footprintpal 2 else
	setp[].footprintpal sprite[].pal
	setp[].footprintshade sector[].floorshade
}

iffloordistl 8 cstat 32 else cstat 32768

sizeto 40 40
fall

enda

useractor notenemy RECONWRECK 100

	ifmove 0
	{
		move STOPPED
		sizeat 64 60
		ifrnd 128 cstator 4
		ifrnd 128
		{
			ifrnd 128 spawn BURNING else spawn BURNING2
		}
	}
	fall
	ifrnd 8
		spawn BIGSMOKE
	
	ifcount 240 cstator 256
	ifhitweapon
	{
		debris SCRAP1 2
		debris SCRAP2 2
		debris SCRAP5 2
		ifdead
		{
			set countvarb 0
			whilevarn countvarb 8
			{
			   rand z 3072
			   add z 2048
			   mul z -1
			   ezshoot z CARXPLODE
			   randvar temp  2047
			   setactor[RETURN].ang temp 
			   randvar temp  192 add temp 128
			   setactor[RETURN].xvel temp 
			   add countvarb 1
			}
			sound VENT_BUST
			killit
		}
	}

enda

state tankwreckcode
	ifmove 0
	{
		move STOPPED
		ifl sprite[].xrepeat 8
		sizeat 60 60
		ifrnd 128 cstator 4
	}
	fall
	ifrnd 8
	{
		geta[].z savz
		sub savz 4096
		seta[].z savz
		espawn BIGSMOKE
		seta[RETURN].htpicnum TANKWRECK
		add savz 4096
		seta[].z savz
	}
	
	ifactor TANKWRECK
	{	ifcount 240 cstator 256 }
	else
	cstator 256
	
	ifhitweapon
	{
		debris SCRAP1 1
		debris SCRAP2 1
		debris SCRAP5 1
		ifdead
		{
			set countvarb 0
			whilevarn countvarb 3
			{
			   rand z 3072
			   add z 2048
			   mul z -1
			   ezshoot z CARXPLODE
			   randvar temp  2047
			   setactor[RETURN].ang temp 
			   randvar temp  192 add temp 128
			   setactor[RETURN].xvel temp 
			   add countvarb 1
			}
			state tech_debris
			sound VENT_BUST
			ifactor TANKWRECK2 state lite_jibs
			killit
		}
	}
ends

useractor notenemy TANKWRECK 150 state tankwreckcode enda
useractor notenemy TANKWRECK2 150 state tankwreckcode enda
useractor notenemy TANKWRECK3 120 state tankwreckcode enda

action RAINFRAME 0 1 1 1 1

action RAINSPLASH -3188 9 1 1 3

move SNOWFALL 16 16
move SNOWFALL2 16 20

spritenopal RAINSPRITE
useractor notenemy RAINSPRITE 0
fall

ifinwater killit 

ifaction RAINFRAME
{
	// sizeto 8 42
	sizeto 16 64
	iffloordistl 2 action RAINSPLASH else
	ifnotmoving action RAINSPLASH
} else
ifaction RAINSPLASH 
{
	sizeat 16 16
	ifactioncount 9 killit
}
else
ifaction 0
{
	cstat 0
	cstator 8192
	setactor[THISACTOR].mdflags 1
	spriteflags 16
	
	ifoutside nullop else killit
	action RAINFRAME
	sizeat 8 15
	setactor[THISACTOR].zvel 2048
	setactor[THISACTOR].pal rainpal
	ifvarand raincstat 512 cstator 514 else
	ifvarand raincstat 2 cstator 2
	ifg sprite[].pal 9
	{
		geta[].htflags temp
		orvar temp 4
		seta[].htflags temp
		seta[].shade -100
	}
}
else
{
	ifnotmoving killit
	iffloordistl 4 
	{
		gets[].floorbunch temp
		ife temp -1
		killit
	}
	ifvarvarg sprite[THISACTOR].z player[THISACTOR].posz
	ifpdistg 16384 killit
}

enda

action SCRAP2FALLFRAMES -26 4 1 1 8
action SCRAP4FALLFRAMES -18 4 1 1 8
action SCRAP5FALLFRAMES -14 3 1 1 8

move SCRAPBOUNCE  84

state scrapfallcode

	fall
	
	ifaction 0
	{
		cstator 8192
		setactor[THISACTOR].mdflags 1
		spriteflags 16
		ifrnd 84 action SCRAP2FALLFRAMES else
		ifrnd 128 action SCRAP4FALLFRAMES else
		action SCRAP5FALLFRAMES
		ifrnd 128 cstator 4
		ifrnd 128 cstator 8
		rand x 20 add x 20 { seta[].xrepeat x seta[].yrepeat x }
		setactor[THISACTOR].zvel 2048
		ifvarand raincstat 512 cstator 514 else
		ifvarand raincstat 2 cstator 2
	}
	else
	{
		// floor bouncing, killing conditions
		iffloordistl 2
		{
			ife mtype 0
			{
				set mtype 1
				move SCRAPBOUNCE randomangle
				geta[].z z
				sub z 1024
				seta[].zvel -2048
				ifpdistl 3072 ifrnd 96 { ifrnd 128 sound ROCKHIT else sound CRUMBLE }
			}
			else ifcount 20
			killit
		}
	}

ends

useractor notenemy SCRAPFALL 0 state scrapfallcode enda


spritenopal SNOWSPRITE
useractor notenemy SNOWSPRITE 0 

fall
ifinwater killit 

ifmove 0
{	
	cstat 0
	cstator 8192
	spriteflags 16
	setactor[THISACTOR].mdflags 1
	ifoutside nullop else killit
	ifrnd 128
	move SNOWFALL geth getv randomangle
	else move SNOWFALL2 geth getv randomangle
	ifrnd 128 cstator 4
	ifrnd 128 cstator 8
	ifvarand raincstat 2 cstator 2
	randvar x 3 addvar x 3
	randvar y 3 addvar y 3
	setactor[THISACTOR].xrepeat x
	setactor[THISACTOR].yrepeat y
	seta[].pal rainpal
}
ifl framerate 50 ifrnd 4 killit
ifnotmoving killit
iffloordistl 4 killit
ifvarvarg sprite[THISACTOR].z player[THISACTOR].posz
ifpdistg 16384 killit

enda

action PUFFRAMES  0  5  1  1  6
useractor notenemy LILPUFF 0 PUFFRAMES

ifmove 0
{
	move STOPPED
	spritepal 12
	lotsofglass 1
	getlastpal
	ifrnd 64 sound GLASSTINK
	sizeat 40 40
	cstator 128
}
ifactioncount 5 killit

enda

spritenoshade LASERHIT
action LASHITFRAMES  0  6  1  1  8
useractor notenemy LASERHIT 0 LASHITFRAMES

ifmove 0
{
	move STOPPED
	sizeat 32 32
	cstator 128
	ifrnd 128 cstator 4
	seta[].shade -100
	spawn SPARKFALL
	// ifrnd 32 sound LASERHIT1 else
	// ifrnd 32 sound LASERHIT2
}
ifactioncount 6 killit

enda

spritenoshade GLAREANIM
spritenopal GLAREANIM
action GLAREFRAMES 0 13 1 1 8
useractor notenemy GLAREANIM 0 GLAREFRAMES

ifmove 0
{
	move STOPPED
	ifspawnedby LARGEMAN sizeat 36 36 else
	sizeat 16 16
	cstat 130
	seta[].blend 1
	seta[].alpha 96
	seta[].shade -50
}
ifactioncount 13 killit

enda

spritenoshade GLARESTAR
action GLSTARBACK 0 11 1 -1 3
action GLSTARFORW -11 11 1 1 3
useractor notenemy GLARESTAR 0 GLSTARBACK

ifmove 0
{
	move STOPPED
	cstat 130
	ifspawnedby TRANSPORTERSTAR sizeat 24 24 else
	{
		geta[].z z, sub z 8192, seta[].z z
		sizeat 26 26
	}
	seta[].blend 1
	seta[].alpha 96
	seta[].shade -50
}
ifaction GLSTARBACK
{
	ifactioncount 11
	action GLSTARFORW
} else
ifaction GLSTARFORW
{
	ifactioncount 11 killit
}

enda

useractor notenemy HIGHSOUND 0

	ifmove 0
	{
		move STOPPED
		set startx initflags
		sub startx 1024
		ifn mtype 0 ife initflags 0 set initflags SPRITELOTAG
	}
	
	ifl mtype 3 // distance based
	{
		findplayer xydist
		ifl xydist startx
		{
			ifactorsound THISACTOR SPRITELOTAG nullop else soundvar SPRITELOTAG
			resetcount
		}
		else
		ifg xydist initflags
		ifcount 20
		{
			ifactorsound THISACTOR SPRITELOTAG stopactorsound THISACTOR SPRITELOTAG
		}
	}
	else // activation based
	{
		// botclip 0 means not moving, initial state
		// botclip 1 means moving, play first sound
		
		ife botclip 0
		{
			gets[].floorz angvel
			gets[].ceilingz countvar
			ifn angvel lastangvel { set botclip 1 soundvar SPRITELOTAG } else
			ifn countvar countvarb { set botclip 1 soundvar SPRITELOTAG }
			set lastangvel angvel
			set countvarb countvar
		}
		else
		ife botclip 1
		{
			gets[].floorz angvel
			gets[].ceilingz countvar
			ife angvel lastangvel ife countvar countvarb
			{
				set botclip 0
				ifactorsound THISACTOR SPRITELOTAG stopactorsound THISACTOR SPRITELOTAG
				soundvar initflags
			}
			set lastangvel angvel
			set countvarb countvar
		}	
	}
enda

/*
ife actorvar[spriteid].countvar 0 // not currently active
{
	setav[spriteid].countvar 1
	// al SPRITELOTAG
	
	ife actorvar[spriteid].countvarb 0 // in starting position
		setav[spriteid].countvarc 1 // start animation forward
	else
		setav[spriteid].countvarc -1 // start animation backward
}
SPRITELOTAG activates this sprite
initflags matches hitag on the walls it animates when active
initsprite is channel it triggers when it is done
*/

state animopencode

	ifn countvar 0
	{
		ifg droptile 0 { sub droptile 1 break }
		ifg countvarc 0 
		{
			ife countvarc 1 screensound NEWDOOR1
			add countvarc 1
			set tempb countvarc
			modvar tempb 5
			ife tempb 0 // advance wall tile
			{
				set target 0
				set B 0
				whilevarvarn target NUMWALLS
				{
					ife wall[target].hitag initflags
					{
						getw[target].picnum picnum
						add picnum 1
						
						ifactor ANIMOPEN1 set temp 18700 else
						ifactor ANIMOPEN2 set temp 18709 else
						ifactor ANIMOPEN3 set temp 18718
						ifg picnum temp
						{
							ife botclip NO
								set botclip YES
						}
						else setw[target].picnum picnum
					}
					add target 1
				}
				ife botclip YES // finished forward animation
				{
					operateactivators initsprite 0
					operatemasterswitches initsprite
					operaterespawns initsprite
					
					set spriteid 0
					whilevarn spriteid 16384 // Numsprites
					{
						ife sprite[spriteid].picnum MULTIPLATE
						ife actorvar[spriteid].mtype 2
						ife actorvar[spriteid].SPRITELOTAG initsprite
						{
							setav[spriteid].droptile YES
						}
						
						ifge sprite[spriteid].picnum 18719
						ifle sprite[spriteid].picnum 18721
						{
							// al spriteid
							ife initsprite actorvar[spriteid].SPRITELOTAG
							ife actorvar[spriteid].countvar 0 // not currently active
							{
								setav[spriteid].countvar 1
								// al SPRITELOTAG
								
								ife actorvar[spriteid].countvarb 0 // in starting position
									setav[spriteid].countvarc 1 // start animation forward
								else
									setav[spriteid].countvarc -1 // start animation backward
							}
						}
						add spriteid 1
					}
					
					
					set countvarb countvarc
					set countvarc 0
					set countvar 0
					set botclip NO
				}
			}
		}
	}

ends

useractor notenemy ANIMOPEN1 0 state animopencode enda
useractor notenemy ANIMOPEN2 0 state animopencode enda
useractor notenemy ANIMOPEN3 0 state animopencode enda

defstate coinsget
  
  ifspritepal 8 set B 25 else
  ifspritepal 1 set B 125 else
  ifspritepal 23 set B 250 else
  ifspritepal 10 set B 500 else
  ifspritepal 49 set B 1250 else
  set B 125
  
  ifactor BIGSTACK mul B 3
  
  add credits B
  set lastcredits credits
  rand temp 3
  ife temp 0 globalsound DUKE_GETWEAPON1 else
  ife temp 1 globalsound DUKE_GETWEAPON3 else
  ife temp 2 globalsound DUKE_GETWEAPON5 else
  ife temp 3 globalsound VACA_GETWEAP1
  palfrom 20 0 32
  globalsound DUKE_GET
  globalsound GETCOINS
  killit
ends

eventloadactor LASERWALL cstat 33041 geta[].lotag SPRITELOTAG seta[].lotag 0 enda


useractor notenemy LASERWALL 9999

ife mtype 1
cstat 32768
else
cstat 33041 

ifn countvar 0
{
	ife countvar 1 // player damage
	{
		palfrom 48 63
		state playerpainsounds
		set spriteid player[].i
		geta[spriteid].htextra temp
		add temp 15
		seta[spriteid].htextra temp
		seta[spriteid].htpicnum FIRELASER3
		seta[spriteid].htowner THISACTOR
		rand temp 5
		ife temp 0 screensound SABCLSH1 else
		ife temp 1 screensound SABCLSH2 else
		ife temp 2 screensound SABCLSH3 else
		screensound SABCLSH4
	}
	add countvar 1
	ifge countvar 30 set countvar 0
}

ifhitweapon
{
	strength 1000
	ifrnd 128 sound SPARKING1 else sound SPARKING2
}

enda

eventloadactor NEWLASERLINE geta[].lotag SPRITELOTAG seta[].lotag 0 

geta[].cstat temp
ifvarand temp 1 xorvar temp 1
ifvarand temp 256 xorvar temp 256
seta[].cstat temp

set initflags temp

enda



eventloadactor SMALLSTACK geta[].lotag SPRITELOTAG seta[].lotag 0 cstat 32768 enda
eventloadactor SMALLSTACK geta[].lotag SPRITELOTAG seta[].lotag 0 cstat 32768 enda

spriteshadow SMALLSTACK
useractor notenemy SMALLSTACK 0

	ifl wave SPRITELOTAG break
	
	cstat 0
	fall
	sizeat 20 16
	ifp palive
	ifpdistl RETRIEVEDISTANCE
	ifcansee
	{
		state coinsget
	}

enda

spriteshadow BIGSTACK
useractor notenemy BIGSTACK 0

	ifl wave SPRITELOTAG break
	
	cstat 0
	fall
	sizeat 20 16
	ifp palive
	ifpdistl RETRIEVEDISTANCE
	ifcansee
	{
		state coinsget
	}

enda

/*
state aim_bottarget

	// ife shellyinmap 0 break
	
	ifn bottarget -1 break
	ife bottarget player[].i break
	
	geta[].owner spriteid
	ifn spriteid -1
	ifn actorvar[spriteid].bottarget -1
	ifn actorvar[spriteid].bottarget player[].i
	{
		getav[spriteid].bottarget bottarget
			
		geta[bottarget].x x2
		geta[bottarget].y y2
		sub x2 sprite[].x
		sub y2 sprite[].y
		getangle angvar x2 y2
		seta[].ang angvar
		
		seta[].ang sprite[spriteid].ang
		
		geta[bottarget].z zdist
		sub zdist 5120
		sub zdist sprite[].z
		ldist xydist THISACTOR bottarget
		ife xydist 0 setvar xydist 1
		mul zdist sprite[].xvel
		div zdist xydist
		seta[].zvel zdist
	}
	

ends
*/

defstate aim_bottarget

	ifn bottarget -1 break
	ifactor FLAKPROJ break
	
	geta[].owner spriteid
	ifn spriteid -1
	ifn actorvar[spriteid].bottarget -1
	ifn sprite[].htpicnum ROLLYTURRET
	{
		getav[spriteid].bottarget bottarget
		
		geta[bottarget].x x2
		geta[bottarget].y y2
		sub x2 sprite[].x
		sub y2 sprite[].y
		getangle angvar x2 y2
		seta[].ang angvar
		
		geta[bottarget].z zdist
		ifactor MORTER sub zdist 8192
		sub zdist sprite[].z 
		
		geta[bottarget].picnum picnum
		
		set z2 tiledata[picnum].ysize
		mul z2 sprite[bottarget].yrepeat
		shiftl z2 1
		// z2 is proportional to height of enemy sprite
		
		sub zdist z2

		mul zdist sprite[].xvel
		ldist xydist THISACTOR bottarget
		ifvare xydist 0 setvar xydist 1 
		divvarvar zdist xydist
		
		seta[].zvel zdist
	}
ends

/*
state aim_holoduke
	dist temp THISACTOR player[].i
	dist tempc THISACTOR player[].holoduke_on
	ifvarvarl tempc temp
	{
		getp[].holoduke_on spriteid
		geta[].z z
		subvar z 8192
		seta[].z z
		geta[spriteid].z tempb
		sub tempb 8192
		seta[spriteid].z tempb
		canseespr THISACTOR spriteid temp
		add z 8192
		seta[].z z
		add tempb 8192
		seta[spriteid].z tempb
		ifvare temp 1
		{
			geta[spriteid].x x
			geta[spriteid].y y
			sub x sprite[].x
			sub y sprite[].y
			getangle angvar x y
			seta[].ang angvar
		}
	}
ends
*/

state randtraj

	geta[].ang angvar
	rand temp 32
	sub temp 16
	ifspawnedby CANHEAD { rand temp 64 sub temp 32 }
	sub angvar temp
	seta[].ang angvar
	geta[].xvel xvel
	randvarvar zdist xvel
	geta[].zvel z
	ifrnd 128 add z zdist else sub z zdist
	seta[].zvel z
	
ends

state randtraj2
	geta[].ang angvar
	rand temp 16
	sub temp 8
	sub angvar temp
	seta[].ang angvar
	geta[].xvel xvel
	randvarvar zdist xvel
	shiftr zdist 1
	geta[].zvel z
	ifrnd 128 add z zdist else sub z zdist
	seta[].zvel z
ends

state checkrandtraj

	set B NO
	ifp prunning ifg forwinput 5 set B YES
	ifp prunningback ifg backinput 5 set B YES
	ifp pfalling set B YES
	ife B NO break
	
	// randomize trajectory
	state randtraj
ends

defstate upscaleme

// for 2X upscaled sprites
	
ifg sprite[].xrepeat 4
{
	geta[].xrepeat init_xrepeat
	geta[].yrepeat init_yrepeat
	shiftr init_xrepeat 1
	shiftr init_yrepeat 1
	seta[].xrepeat init_xrepeat
	seta[].yrepeat init_yrepeat
}
set upscaled YES

ends

state upscale_visual

	geta[].mdflags temp
	orvar temp 16
	seta[].mdflags temp
	set upscaled 2

ends

defstate add_ant_code
	set antcount 0
	add sub_maxactors 1
	espawn ARMYANT
	ifrnd 64 ifg plevel 3 seta[RETURN].pal 40
	seta[RETURN].xrepeat 24
	seta[RETURN].yrepeat 24
	seta[RETURN].cstat 257
	seta[RETURN].extra ARMYANTSTRENGTH
	ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
	
	ifoutside nullop else
	{
		getceilzofslope sprite[].sectnum sprite[].x sprite[].y z
		geta[RETURN].z zdist
		sub zdist z
		ifle z 262144
		{
			add z 9728
			seta[RETURN].z z
			seta[RETURN].cstat 265
			setav[RETURN].initsprite YES
			seta[RETURN].picnum ARMYANTCRAWL
		}
	}
ends

onevent EVENT_EGS

ifn sprite[].owner -1
{
	ife sprite[].statnum 4
	ifg sprite[].xvel 256
	{
		ifn sprite[].picnum SHOCKPROJ
		ifvarand actorvar[sprite[].owner].monstflags 64 // double shot power
		{
			orvar monstflags 64
			seta[].mdflags 16
		}
		ifvarand actorvar[sprite[].owner].monstflags 1048576 // electric
		{
			orvar monstflags 1048576
			seta[].mdflags 16
		}
		ifvarand actorvar[sprite[].owner].monstflags 128 // multishot
		ife mid_spawn NO
		{
			set mid_spawn YES
			eshootvar sprite[].picnum
			ife RETURN -1 set mid_spawn NO
			else
			{
			geta[sprite[].owner].ang angvar 
			ifg actorvar[sprite[].owner].targetdist 8192 sub angvar 14 else sub angvar 24
			seta[RETURN].ang angvar
			seta[RETURN].extra sprite[].extra
			seta[RETURN].xvel sprite[].xvel
			seta[RETURN].zvel sprite[].zvel
			seta[RETURN].yvel sprite[].yvel
			seta[RETURN].owner sprite[].owner
			seta[RETURN].pal sprite[].pal
			setthisprojectile[RETURN].pal sprite[].pal
			seta[RETURN].xrepeat sprite[].xrepeat
			seta[RETURN].yrepeat sprite[].yrepeat
			seta[RETURN].z sprite[].z
			}
			
			set mid_spawn YES
			eshootvar sprite[].picnum
			ife RETURN -1 set mid_spawn NO
			else
			{
			geta[sprite[].owner].ang angvar 
			ifg actorvar[sprite[].owner].targetdist 8192 add angvar 14 else add angvar 24
			seta[RETURN].ang angvar
			seta[RETURN].extra sprite[].extra
			seta[RETURN].xvel sprite[].xvel
			seta[RETURN].zvel sprite[].zvel
			seta[RETURN].yvel sprite[].yvel
			seta[RETURN].owner sprite[].owner
			seta[RETURN].pal sprite[].pal
			setthisprojectile[RETURN].pal sprite[].pal
			seta[RETURN].xrepeat sprite[].xrepeat
			seta[RETURN].yrepeat sprite[].yrepeat
			seta[RETURN].z sprite[].z
			}
			set mid_spawn NO
			
		}
		ifvarand actorvar[sprite[].owner].monstflags 256 // gigantism
		{
			orvar monstflags 256
			seta[].mdflags 16
		}
		ifvarand actorvar[sprite[].owner].monstflags 4096 // radioactive
		{
			orvar monstflags 4096
		}
		// 128 == multi shots and shot angle randomization
		// 256 == guided shots with limited tracking
	}
	else
	ifvarand actorvar[sprite[].owner].monstflags 64 // double shot power
	ife sprite[sprite[].owner].statnum 4
	{
		orvar monstflags 524288 // double size rendering flag
		seta[].mdflags 16
	}
}

ifspawnedby RESPAWN
{
	ifn sprite[].picnum BOSS1
	{
	geta[].owner spriteid
	ifvarn spriteid -1 seta[].pal sprite[spriteid].pal
	}
	geta[].owner spriteid
	ifn spriteid -1
	{
		getav[spriteid].SPRITELOTAG SPRITELOTAG
		getav[spriteid].monstflags monstflags
	}
		
	ifactor TEAMSPAWNER
	{
		set mtype 2
		cstat 32768
		set SPRITELOTAG 0
		sizeat 32 32
	}
}

switch sprite[].picnum

case 1068
    set value 10
	state spawnimpcoins
	sound VENT_BUST
break

case APLAYER
	ife mirror_thismap YES
		state mirrorplayer
	
break

case JIBS1
case JIBS2
case JIBS3
case JIBS4
case JIBS5
case JIBS6



case 2246 case 2247 case 2248 case 2249
case 2251 case 2252 case 2253 case 2254
case 2256 case 2257 case 2258 case 2259
case 2261 case 2262 case 2263 case 2264
case 2266 case 2267 case 2268 case 2269
case 2287 case 2288 case 2289 case 2290 case 2291 case 2292 case 2293
	geta[].xrepeat init_xrepeat
	div init_xrepeat 2
	seta[].xrepeat init_xrepeat
	geta[].yrepeat init_yrepeat
	div init_yrepeat 2
	seta[].yrepeat init_yrepeat

	geta[].owner spriteid
	ifn spriteid -1
	{
		getav[spriteid].shrunken shrunken
		seta[].pal sprite[spriteid].pal

		
		randvar lastang 128 // angle change per tic
		sub lastang 64

		ifactor JIBS6
		{
			ife sprite[spriteid].picnum BEASTHEADPROJ spritepal 6
			ife sprite[spriteid].picnum BEASTARMPROJ spritepal 6
			ife sprite[spriteid].picnum BEASTLEGPROJ spritepal 6
			ife sprite[spriteid].picnum ANTHEADPROJ spritepal 6
			ife sprite[spriteid].picnum BBHEADJIBPROJ spritepal 6
			ife sprite[spriteid].picnum BBARMJIBPROJ spritepal 6
			ife sprite[spriteid].picnum BBLEGJIBPROJ spritepal 6
			ife sprite[spriteid].picnum DEVOURER spritepal 6
			ife sprite[spriteid].picnum ARMYANT spritepal 6
			ife sprite[spriteid].picnum ARMYANTCRAWL spritepal 6
			
			ifg shrunken 20 ifl shrunken SHRUNKCOUNT cstat 32768
			geta[spriteid].picnum picnum
			ife picnum SHOTSPARK1
			{
				geta[spriteid].htg_t 8 hitsprite
				ife sprite[hitsprite].picnum EGG spritepal 6
				ife sprite[hitsprite].picnum NEWBEAST spritepal 6
				ife sprite[hitsprite].picnum CYBERBEAST spritepal 6
				ife sprite[hitsprite].picnum ARMYANT spritepal 6
				ife sprite[hitsprite].picnum ARMYANTCRAWL spritepal 6
			}
			ifn sprite[].pal 6 seta[].blend 130
			
			ife sprite[spriteid].picnum DEANOVA
			ife actorvar[spriteid].mtype 1 cstat 32768
			
			ife sprite[spriteid].picnum BLOODEXP
			{
				geta[].z z
				add z 8192
				seta[].z z
				seta[].htbposz z
				spritepal 61
			}
		}
		ife sprite[spriteid].picnum BOSS4 spritepal 6
	}

break

case HEADJIB1
case ARMJIB1
case LEGJIB1

	geta[].owner spriteid
	getav[spriteid].shrunken shrunken
	seta[].pal sprite[spriteid].pal
	randvar lastang 128 // angle change per tic
	sub lastang 64
	// ife actorvar[spriteid].upscaled YES
	//	state upscaleme
break

case LIZMANHEAD1
	geta[].owner spriteid
	getav[spriteid].shrunken shrunken
	seta[].pal sprite[spriteid].pal
	randvar lastang 128 // angle change per tic
	sub lastang 64
break
case LIZMANARM1
case LIZMANLEG1

	geta[].owner spriteid
	getav[spriteid].shrunken shrunken
	seta[].pal sprite[spriteid].pal
	randvar lastang 128 // angle change per tic
	sub lastang 64
	// ife actorvar[spriteid].upscaled YES
	//	state upscaleme
break

case PIGHEADPROJ case ANTHEADPROJ
case BULLHEADPROJ
geta[].owner spriteid
	getav[spriteid].shrunken shrunken
	seta[].pal sprite[spriteid].pal
ifrnd 128 cstator 4
break

case PIGARMGROUND case PIGLEGGROUND case PIGHEADGROUND
case BULLHEADGROUND case BULLLEGGROUND case BULLARMGROUND
case EGGJIBGROUND case TROOPHEADGROUND case NEWTROOPHEADGROUND
case COMMHEADGROUND case COMMARMGROUND case NEWCOMMHEADGROUND
case LIZRANGERHEAD case LIZHEADGROUND
case RANGERLEGPROJ case RANGERLEGGROUND
case ANTHEADGROUND case ARMPIGARMGROUND case ARMPIGFOOTGROUND case ARMPIGLEGGROUND
case BEASTHEADGROUND case BEASTLEGGROUND case BEASTARMGROUND
case ZOMBIEHEADGROUND case CRAZYHEADGROUND case MANDOCHESTGROUND case MANDOLEGGROUND
case MANDOARMGROUND case MANDOHEADGROUND
case TERMLEGPART1GROUND case TERMLEGPART2GROUND case TERMLEGPART3GROUND
case REDARMGROUND case BLUEARMGROUND

	geta[].owner spriteid
	getav[spriteid].shrunken shrunken
	getav[spriteid].countvarc countvarc
	seta[].pal sprite[spriteid].pal
	seta[].xrepeat sprite[spriteid].xrepeat
	seta[].yrepeat sprite[spriteid].yrepeat
	geta[spriteid].cstat temp
	ifvarand temp 4 cstator 4

break

case FIRSTGUNSPRITE
case FREEZESPRITE
case RPGSPRITE
case SHOTGUNSPRITE
case CHAINGUNSPRITE
case SHRINKERSPRITE
case DEVISTATORSPRITE
	ifspawnedby APLAYER ifg gametype 0 { cactor SMALLSMOKE sizeat 0 0 cstat 32768 }
break

case ICEBEAMTRAIL case BEAMTRAIL 
case RAINSPRITE case SNOWSPRITE
cstat 32768 break


case SHOTSPARK1 

ifspawnedby APLAYER
ifn player[].curr_weapon FREEZE_WEAPON
// ifn player[].curr_weapon GROW_WEAPON
{

	ifn shootswitch 0
		cstat 32768
	else
	{
		ldist xydist3 THISACTOR player[].i
		ifg xydist3 3584 // 4608
		{
			ife player[].curr_weapon CHAINGUN_WEAPON
			ife zoomin YES
			espawn TRACER2
			else
			ife player[].curr_weapon SHOTGUN_WEAPON
			ife zoomin YES
			espawn TRACER2
			else
			ifn onturret -1
			espawn TRACER2
			else
			ife player[].curr_weapon DEVISTATOR_WEAPON
			{
				set RETURN -1
				ife WEAPON7_SHOOTS BARRETPROJ
				{
					ife zoomin YES
						espawn TRACER2
					else
						espawn TRACER
				}
				ife WEAPON7_SHOOTS EXPBULLET
				espawn TRACER
			}
			else
			ife player[].curr_weapon GROW_WEAPON
			{
				set RETURN -1
				ife pchar 2 
				{
					espawn TRACER
					seta[RETURN].blend 1
					seta[RETURN].pal 1
				}
			}
			else
			espawn TRACER
			
			ifn RETURN -1
			{
				ife player[].curr_weapon PISTOL_WEAPON
				ifg player[].kickback_pic 4 seta[RETURN].cstat 4
				
				ife pchar 2
				{
					ife player[].curr_weapon CHAINGUN_WEAPON
					ifvarand wesupgrades[CHAINGUN_WEAPON] 1
					ifrnd 128 seta[RETURN].cstat 4
					
					ife player[].curr_weapon DEVISTATOR_WEAPON
					{
						ife player[].hbomb_hold_delay 0 seta[RETURN].cstat 4
					}
				}
				
				geta[].z z
				getp[].posz zdist
				sub zdist z
				// negative numbers mean lower than player, positive mean higher
				
				// 3584 is a certain percentage of xydist3
				// we want that percentage and we want to multiply zdist by it
				set temp 35840000 // 40960000
				div temp xydist3
				
				mul zdist temp
				div zdist 10000
				getp[].posz z
				sub z zdist
				seta[RETURN].z z
				geta[].x x2
				geta[].y y2
				sub x2 player[].posx
				sub y2 player[].posy
				getangle angvar x2 y2
				// this is the angle to make player face the shotspark1
				// we can't assume it is the current player angle due to autoaim
				
				set x player[].posx
				add x 3584 // 4096
				rotatepoint player[].posx player[].posy x player[].posy angvar tempb tempc
				seta[RETURN].x tempb
				seta[RETURN].y tempc
				changespritesect RETURN player[].cursectnum
			}
		}
		
	}
	
}

	geta[].z z
	geta[].owner spriteid
	ifn spriteid -1 
	{
		set team actorvar[spriteid].team
		geta[spriteid].z z2
		sub z2 8192
		sub z z2
		ldist xydist3 THISACTOR spriteid
		shiftvarr z 4
		getangle shotpitch xydist3 z	
		ifg shotpitch 1023 sub shotpitch 2048
	}
	ifspawnedby APLAYER
	{
		getp[].i spriteid
		ifn spriteid -1
		setav[spriteid].shotpitch shotpitch
	}
	
break

case PLASMEXPB
	ifspawnedby SHOTSPARK1	
	{
		geta[].owner myspawner
		cstat 32768
	}

break

case TRANSPORTERSTAR
	set tempe sprite[].owner
	ifn tempe -1
	ife sprite[tempe].statnum 4
	{
		ifn sprite[tempe].picnum PLAYERPLASMA 
		ifn sprite[tempe].picnum PLASMAPROJ 
		ifn sprite[tempe].picnum FREEZEBLAST 
		ifn sprite[tempe].picnum FIRELASER 
		ifn sprite[tempe].picnum FIRELASER2 
		ifn sprite[tempe].picnum FIRELASER3 
		ifn sprite[tempe].picnum EDFLASER 
			set mtype 3
	}
break

case BULLETHOLE
getactor[].owner myspawner
ifn myspawner -1
{
	ife sprite[myspawner].picnum SHOTSPARK1
		state changetodecal	
}
break

case KNEE operate break

case HEAVYHBOMB
ifspawnedby APLAYER
{
  set myspawner player[].i
  geta[].xvel xvel
  ife pchar 2
  {
	  cactor WESBOMB
	  set team 1
	  
	  sizeat 8 8
	  action 0
	  cstat 256
	  changespritestat THISACTOR 1
	  
	  
	  geta[].ang angle2
	  add angle2 1024
	  seta[].ang angle2
	  getp[].horiz mtype
	  sub mtype 100
	  mul mtype -64
	  sub mtype 512
	  ifl mtype -20000 set mtype -20000
	  ifg mtype 4069 set mtype 4096
	  set dodgetime pipehold
	  
	  ifg burstfired 0
	  {
	    geta[].z z
		add z 1024
		seta[].z z
		seta[].htbposz z
		add dodgetime 30
		sub burstfired 1
		ifg burstfired 0
		{
			set temp player[].kickback_pic
			sub temp 2
			setp[].kickback_pic temp
			getp[].ammo_amount HANDBOMB_WEAPON temp
			add temp 1
			setp[].ammo_amount HANDBOMB_WEAPON temp
		}
	  }
	  else
	  {
	  espawn WESBOMB
	  set angle2 player[].ang
	  sub angle2 48
	  seta[RETURN].ang angle2
	  setav[RETURN].team 1
	  rand B 512
	  sub B 256
	  add B mtype
	  setav[RETURN].mtype B
	  setav[RETURN].dodgetime dodgetime
	  
	  espawn WESBOMB
	  set angle2 player[].ang
	  add angle2 48
	  seta[RETURN].ang angle2
	  setav[RETURN].team 1
	  rand B 512
	  sub B 256
	  add B mtype
	  setav[RETURN].mtype B
	  setav[RETURN].dodgetime dodgetime
	  set pipehold 0
	  }
  }
  else
  ife pchar 1
  {
	  getp[].ammo_amount HANDBOMB_WEAPON temp
	  sub temp 1
	  ifl temp 1
	  {
		set temp 0
		add turret_leftover 75
	  }
	  setp[].ammo_amount HANDBOMB_WEAPON temp
	  cactor ROLLYTURRET
	  set myspawner player[].i
	  set team 1
	  ifvarand shellyupgrades[HANDBOMB_WEAPON] 1 set initsprite 1
	  sizeat 30 26
	  action 0
	  cstat 256
	  changespritestat THISACTOR 1
	  ifp pducking nullop else
	  {
		  geta[].z z
		  add z 3072
		  seta[].z z
	  }
	  geta[].ang angvar
	  add angvar 1024
	  seta[].ang angvar
	  getp[].horiz mtype
	  sub mtype 100
	  mul mtype -64
	  sub mtype 512
	  ifl mtype -12800 set mtype -12800
	  ifg mtype 4069 set mtype 4096
	  clipdist 48
	  set dodgetime pipehold
	  set pipehold 0
  }
  else
  {
	  set temp pipehold
	  mul temp 9 div temp 5
	  ifinwater shiftvarr temp 1
	  add xvel temp
	  seta[].xvel xvel
	  set pipehold 0
	  ifvarand dukeupgrades[HANDBOMB_WEAPON] 1
		seta[].mdflags 16
  }
}
break

case RPG
ifspawnedby APLAYER 
{
	ife player[].curr_weapon RPG_WEAPON
	{
		set temp NO
		ife pchar 0 ifvarand dukeupgrades[RPG_WEAPON] 1 set temp YES
		ife pchar 1 ifvarand shellyupgrades[RPG_WEAPON] 1 set temp YES
		ife temp YES
			strength 175
	}
		
	ife player[].curr_weapon RPG_WEAPON
	ife nukeselect 1
	{
		state checkrandtraj
		sizeat 64 64
		spritepal 47
		sound NUKEFIRE
		strength 1000
		sub nukeamount 1
		ifle nukeamount 0 
		{
			set nukeamount 0
			set nukeselect -2
			setp[].ammo_amount RPG_WEAPON 1
		}
	}
	else
	ifn player[].curr_weapon DEVISTATOR_WEAPON 
	{
		state checkrandtraj 
		ife pchar 2
		ife zoomin NO
		{
			sizeat 48 48
			spritepal 11
			sound NUKEFIRE
			strength 500
		}
		else
		sizeat 32 32
		ifvarand shellyupgrades[RPG_WEAPON] 1 nullop else
		ife pchar 1
		{
			ife rpgtype 0 spritepal 2
			ife rpgtype 1 spritepal 1
		}
		ife pchar 0 ifvarand dukeupgrades[RPG_WEAPON] 2
		{
			geta[].xvel xvel mul xvel 3 div xvel 2 seta[].xvel xvel
			geta[].zvel z mul z 3 div z 2 seta[].zvel z
		}
		ife pchar 1 ifvarand shellyupgrades[RPG_WEAPON] 2
		{
			geta[].xvel xvel mul xvel 3 div xvel 2 seta[].xvel xvel
			geta[].zvel z mul z 3 div z 2 seta[].zvel z
		}
	}
	ifn targetlock[0] -1 
	{
		set targetwait 20
		set mtype TARGETLOCK
		set bottarget targetlock[0]
		setarray targetlock[0] -1
	}
	else
	ifn targetlock[1] -1 
	{
		set targetwait 20
		set mtype TARGETLOCK
		set bottarget targetlock[1]
		setarray targetlock[1] -1
	}
	else
	ifn targetlock[2] -1 
	{
		set targetwait 20
		set mtype TARGETLOCK
		set bottarget targetlock[2]
		setarray targetlock[2] -1
	}
	ifg loadrox 0
	{
		ife player[].kickback_pic WEAPON4_FIREDELAY
		{
			// FIRST ROCKET
			ife loadrox 4 set loadrox 8
			ife loadrox 3 set loadrox 7
			ife loadrox 2 { geta[].zvel z add z 512 seta[].zvel z }
		}
		ife loadrox 7 { geta[].ang angvar sub angvar 16 seta[].ang angvar }
		ife loadrox 6 { geta[].ang angvar add angvar 16 seta[].ang angvar set loadrox 2 }
		sub loadrox 1
	}
	ife player[].curr_weapon DEVISTATOR_WEAPON
	ife pchar 0
	{
		ifvarand dukeupgrades[DEVISTATOR_WEAPON] 2
		{
			ife devside 0
			{
				getp[].ammo_amount 7 temp
				add temp 1
				setp[].ammo_amount 7 temp
				geta[].z z, sub z 2048 seta[].z z
				set devside 1
			}
			else set devside 0
		}
		
		ifvarand dukeupgrades[DEVISTATOR_WEAPON] 1
		{
			cstat 32768
			set initsprite 666
		}
	}
	
}
else
{
	geta[].owner spriteid
	ifn spriteid -1
	{
		// ifn sprite[spriteid].pal 0 ifg sprite[].extra 50 seta[].extra 50
		getav[spriteid].shrunken shrunken
		ifg shrunken 20 ifl shrunken SHRUNKCOUNT
		{
			seta[].mdflags 16
			seta[].extra 1
			geta[].z z
			add z 1024
			seta[].z z
			seta[].x sprite[spriteid].x
			seta[].y sprite[spriteid].y
		}
		ifspawnedby CANHEAD
		{
			set mtype CANHEAD
			sizeat 36 36
		}
		ifspawnedby BOSS2
		{
			ife actorvar[spriteid].initsprite 1996
			{
				cactor CBPROJ
				seta[].extra 160
				setthisprojectile[].extra 160
				setthisprojectile[].spawns CBPROJEXP
				setthisprojectile[].isound BREAKROCK
				setthisprojectile[].workslike 32770
				setthisprojectile[].hitradius 1816
				sizeat 64 64
				setthisprojectile[].xrepeat 64
				setthisprojectile[].yrepeat 64
				geta[].xvel xvel mul xvel 3 div xvel 2 seta[].xvel xvel
				geta[].zvel yvel mul yvel 3 div yvel 2 seta[].zvel yvel
			}
		}
		state aim_bottarget
		// ifvarn player[].holoduke_on -1
		// state aim_holoduke
		
		
	}
}
break

// case FIREBOLT
// ifspawnedby APLAYER
// {
	// geta[].z z
	// add z 512
	// seta[].z z
// }
// break

case PLAYERPLASMA
ifspawnedby APLAYER
{
	state randtraj2
	geta[].xvel xvel
	geta[].zvel z2	
	shiftr z2 4
	getangle tempb xvel z2
	seta[].pitch tempb
}
break

case BLADEPROJ

	ifg sawspeed 25
	{
		geta[].xvel xvel
		mul xvel 3, div xvel 2
		seta[].xvel xvel
		geta[].zvel z
		mul z 3, div z 2
		seta[].zvel z
	}

	geta[].z z
	add z 2048
	seta[].z z
	geta[].xvel xvel
	geta[].zvel z2	
	shiftr z2 4
	getangle tempb xvel z2
	seta[].pitch tempb
break

case ARCBALLPROJ
case FTPROJ
case RADPROJ
case BLOODBULLET
case SHOCKPROJ
	seta[].blend 1
break

case FLAMEPROJ
	state randtraj
	ifrnd 128 cstator 4
	ifrnd 128 cstator 8
	cstator 512
	seta[].alpha 128
	seta[].blend 1
break

case MEGAPROJ
	seta[].blend 1
	state aim_bottarget
break

case PURPPROJ
	seta[].blend 1
	state aim_bottarget
	state randtraj
break

case COOLEXPLOSION1
	seta[].blend 1
	cstator 2
	// state aim_bottarget
break

case ARCBALLPROJ2
	ifspawnedby APLAYER set myspawner player[].i
	seta[].blend 1
break

case GREENLASER

	state aim_bottarget
	state randtraj2
	geta[].xvel xvel
	geta[].zvel z2	
	shiftr z2 4
	getangle tempb xvel z2
	seta[].pitch tempb
break

case BIGBOIPROJ
	geta[].xvel xvel
	geta[].zvel z2	
	shiftr z2 4
	getangle tempb xvel z2
	seta[].pitch tempb
	ifspawnedby SMALLMAN { geta[].z z add z 512 seta[].z z }
	ifspawnedby APLAYER { set myspawner player[].i geta[].z z sub z 2048 seta[].z z cstat 0 }
	ifspawnedby NEWTRIPBOMB 
	{ 
		seta[].owner player[].i 
		seta[].htpicnum APLAYER 
		seta[].mdflags 16	
	}
	ife rendmode 0 { cstator 2 seta[].blend 1 spritepal 23 }
break

case GRENADEPROJ
case WESGRENADE
	geta[].zvel z
	sub z 1280
	seta[].zvel z
	ifspawnedby APLAYER 
		set team 1
break

case FLAKPROJ
	ifspawnedby APLAYER getp[].i myspawner
	state randtraj
break

case STICKYPROJ
	ifspawnedby CHEERBOT getav[sprite[].owner].myspawner myspawner
	else
	ifspawnedby APLAYER getp[].i myspawner
	else 
	{
		geta[].owner myspawner
		geta[].z z
		add z 2048
		seta[].z z
		geta[].zvel z
		sub z 1024
		seta[].zvel z
	}
	state randtraj
	ifn sprite[].htowner -1
	getav[sprite[].htowner].team team
break

case SCUBAPROJ
	state aim_bottarget
	ifspawnedby NEWBOSS1 state randtraj
break

case FREEZEBOLT
	state randtraj2
	state aim_bottarget
break

case BIGPLASMA
	state aim_bottarget
	// ifvarn player[].holoduke_on -1
	// state aim_holoduke
	state randtraj
break

case BMFGPROJ
    set team 1
	geta[].owner spriteid
	ifn spriteid -1
		getav[spriteid].team team
break

case BMFGIMPACT
	geta[].owner spriteid
	ifn spriteid -1
	{
		getav[spriteid].team team
		seta[].pal sprite[spriteid].pal
	}
break

case COMETEXP
	geta[].owner spriteid
	ifn spriteid -1
		seta[].pal sprite[spriteid].pal
break

case TANKSHELL
	state aim_bottarget
break

case ARROWPROJ
 
 ifspawnedby APLAYER
 {
	
	ifrnd 84 sound BOWSHOOT else ifrnd 128 sound BOWSHOOT2
	else sound BOWSHOOT3
	set droptile APLAYER
	geta[].zvel z
	sub z 512
	seta[].zvel z
	getp[].player_par last_fired
	ife arrowtype 5 set arrowview THISACTOR
	// 0 = regular; 1 = burning; 2 = explosive; 3 = multi; 4 = freeze; 5 = spy; 6 = electric
	// 7 = blood; 8 = radioactive
 }
 
break

case STAKEPROJ
 
	ifspawnedby APLAYER set droptile APLAYER
	geta[].zvel z
	sub z 512
	seta[].zvel z
	
	geta[].xvel xvel
	geta[].zvel z2	
	shiftr z2 4
	getangle tempb xvel z2
	seta[].pitch tempb
 
break

case TRIPBOMB
	ifspawnedby APLAYER
	{
		ife pchar 0 ifvarand dukeupgrades[TRIPBOMB_WEAPON] 4 { cactor NEWTRIPBOMB changespritestat THISACTOR 1 sizeat 12 12 }
		ife pchar 1 ifvarand shellyupgrades[TRIPBOMB_WEAPON] 4 { cactor NEWTRIPBOMB changespritestat THISACTOR 1 sizeat 12 12 }
		ife pchar 2 ifvarand wesupgrades[TRIPBOMB_WEAPON] 4 { cactor NEWTRIPBOMB changespritestat THISACTOR 1 sizeat 12 12 }
	}
break

case EXPLOSION2
case EXPLOSION2BOT

	ifspawnedby RPG
	{
		geta[].owner spriteid
		ifn spriteid -1
		{
			ife sprite[spriteid].pal 1
			{
				spritepal 1
				set mtype 1
				ifactor EXPLOSION2
				{
					headspritestat spriteid 1
					whilevarn spriteid -1
					{
						dist xydist THISACTOR spriteid
						ifl xydist 5120
						ifn sprite[spriteid].htpicnum RPG
						{
							set xydist2 5120
							sub xydist2 xydist
							shiftr xydist2 6
							ifl xydist2 10 set xydist2 10
							ifg xydist2 120 set xydist2 120
							seta[spriteid].htpicnum FREEZEBLAST
							geta[spriteid].htextra temp
							add temp xydist2
							seta[spriteid].htextra temp
							ifn myshelly -1 ife pchar 0
							seta[spriteid].htowner myshelly
							else
							seta[spriteid].htowner player[].i
						}
						nextspritestat spriteid spriteid
					}
					set B 0
					set x sprite[].x
					add x 1024
					whilevarn B 8
					{
						espawn BIGSMOKE
						setav[RETURN].mtype 1
						seta[RETURN].pal 89
						rotatepoint sprite[].x sprite[].y x sprite[].y angvar x2 y2
						setsprite RETURN x2 y2 sprite[].z
						add angvar 256
						add B 1
					}
					lotsofglass 30
				}
			}
			else
			ife sprite[spriteid].pal 2
			{
				set mtype 1
				ifactor EXPLOSION2
				{
					headspritestat spriteid 1
					whilevarn spriteid -1
					{
						dist xydist THISACTOR spriteid
						ifl xydist 5120
						ifn sprite[spriteid].htpicnum RPG
						ife actorvar[spriteid].monstatus 1
						{
							set xydist2 5120
							sub xydist2 xydist
							shiftr xydist2 4
							ifl xydist2 30 set xydist2 10
							ifg xydist2 120 set xydist2 120
							getav[spriteid].burning temp
							add temp xydist2
							setav[spriteid].burning xydist2
						}
						nextspritestat spriteid spriteid
					}
					set B 0
					set x sprite[].x
					add x 640
					set z sprite[].z
					add z 1024
					whilevarn B 8
					{
						espawn QUICKFLAME
						rotatepoint sprite[].x sprite[].y x sprite[].y angvar x2 y2
						setsprite RETURN x2 y2 z
						add angvar 256
						add B 1
					}
					
					set B 0
					set x sprite[].x
					add x 1280
					whilevarn B 16
					{
						espawn QUICKFLAME
						rotatepoint sprite[].x sprite[].y x sprite[].y angvar x2 y2
						setsprite RETURN x2 y2 z
						add angvar 128
						add B 1
					}
				}
			}
			else
			ife sprite[spriteid].pal 11
				set mtype WESBOT
			
		}
	}
	ifspawnedby HEAVYHBOMB
	{
		geta[].htowner spriteid
		ifn spriteid -1 
		getav[spriteid].myspawner myspawner // should be a player sprite
		ife pchar 0
		ifvarand dukeupgrades[HANDBOMB_WEAPON] 1
		{
			set countvar 18
			set angvel 0
			whilevarn countvar 0
			{
				seta[].ang angvel
				rand zdist 2048
				sub zdist 6144
				ezshoot zdist BOMBLET
				add angvel 113
				set xvel sprite[RETURN].xvel
				rand temp 384
				sub xvel temp
				seta[RETURN].xvel xvel
				sub countvar 1
				setav[RETURN].team 1
			}
		}
	}
	geta[].owner spriteid
	ifn spriteid -1
	{
		ife sprite[spriteid].picnum TRIPBOMB
		{
			geta[spriteid].owner temp
			ifn temp -1
			ife sprite[temp].picnum APLAYER
			{
				ife actorvar[spriteid].mtype 1 setav[spriteid].mtype 2 else
				{
					seta[].ang sprite[spriteid].ang
					setprojectile[FLAKPROJ].velmult 2
					shoot FLAKPROJ shoot FLAKPROJ shoot FLAKPROJ shoot FLAKPROJ
					shoot FLAKPROJ shoot FLAKPROJ shoot FLAKPROJ shoot FLAKPROJ
					shoot FLAKPROJ shoot FLAKPROJ shoot FLAKPROJ shoot FLAKPROJ
					shoot FLAKPROJ shoot FLAKPROJ shoot FLAKPROJ shoot FLAKPROJ
					setprojectile[FLAKPROJ].velmult 1
					eshoot RPG
					seta[RETURN].xvel 1024
					seta[RETURN].ang sprite[spriteid].ang
				}
			}
		}
	}
	

break

case EXPLOSION5
ifn sprite[].owner -1
ife sprite[sprite[].owner].pal 1 spritepal 1
break

case FREEZEBLAST

	ifspawnedby LIZRANGER 
	{
		cstat 32768 set mtype 1 
		geta[].owner spriteid
		ifn spriteid -1
		ifn actorvar[spriteid].bottarget -1
			getav[spriteid].bottarget bottarget
		else set bottarget player[].i
	}
	else
	ifspawnedby LIZRANGERDUCKING 
	{ 
		cstat 32768 set mtype 1 
		geta[].owner spriteid
		ifn spriteid -1
		ifn actorvar[spriteid].bottarget -1
			getav[spriteid].bottarget bottarget
		else set bottarget player[].i
	} 
	else
	ifspawnedby APLAYER state checkrandtraj
	else
	state aim_bottarget

break

case SHRINKSPARK

seta[].blend 1
seta[].mdflags 16
spritepal 11
cstator 2
ifspawnedby APLAYER state checkrandtraj
else
state aim_bottarget

break

case FIRELASER2
ifspawnedby APLAYER 
{
	state checkrandtraj
	set myspawner player[].i
}
else
	state aim_bottarget
break

case FIRELASER
case FIRELASER3
	seta[].blend 1
	cstator 2
ifspawnedby APLAYER state checkrandtraj else
	state aim_bottarget
break

case EDFLASER state randtraj
break

case RANGERPROJ
case MORTER2
case CBPROJ
case PLASMAPROJ
	state aim_bottarget
break

case NEWPLASMA
	seta[].blend 1
	state aim_bottarget
break

case RANGERTRAIL 
case BOLT_TRAIL 
case BIGSMOKE2
cstat 32768
break

case LASERLINE
geta[].owner myspawner
geta[myspawner].picnum mtype
break

case MORTER
	geta[].owner spriteid
	ifn spriteid -1
	{
		getav[spriteid].shrunken shrunken
		ifg shrunken 20 ifl shrunken SHRUNKCOUNT
		{
			seta[].mdflags 16
			seta[].extra 1
		}
		geta[].xvel xvel
		add xvel 128
		seta[].xvel xvel
		geta[].zvel z
		sub z 1024
		shiftr z 1
		seta[].zvel z
		state aim_bottarget
		// ifvarn player[].holoduke_on -1
		// state aim_holoduke
	}
break

case SPIT
	geta[].owner spriteid
	ifn spriteid -1
	{
		getav[spriteid].shrunken shrunken
		ifg shrunken 20 ifl shrunken SHRUNKCOUNT
		{
			seta[].mdflags 16
			seta[].extra 1
			geta[].z z
			add z 1024
			seta[].z z
		}
		getav[spriteid].initflags initflags
		ifvarand initflags 8
		{
			geta[].xvel xvel
			add xvel 128
			seta[].xvel xvel
			geta[].zvel z
			sub z 1024
			shiftr z 1
			seta[].zvel z
		}
	}

break


case GREENSLIME set monstatus 1 break

case TANK // Fix tank and newbeast attributes when spawn
  cstat 257
  sizeat 60 60
  clipdist 100
break

case NEWBEAST
case NEWBEASTCROUCH
	cstator 257
    sizeat 32 30
break

case SPACEBULL
	sizeat 26 26
	cstator 257
break

case DEANOVA
	sizeat 28 25
	cstator 257
break

case LIZELITE
	sizeat 23 23
	cstator 257
break

case NEWCOMM 
	sizeat 30 28
	cstator 257
break

case SYTH
case SITH
	sizeat 30 27
	cstator 257
break

case MANDOFETT
	sizeat 26 24
	cstator 257
break

case CYBERBEAST
	sizeat 32 28
	cstator 257
break

case COMBINEDMEN
	sizeat 50 48
	cstator 257
break

case CANHEAD
	sizeat 42 40
	cstator 257
break

case QUEEN
	ifspritepal 0 sizeat 96 80 else
	sizeat 42 40
	cstator 257
break

case NEWBATLORD
	// sizeat 36 30
	cstator 257
break

case SISTERS
sizeat 42 40
break

case MARIO
case LUIGI
sizeat 40 40
break

case SERIOUSBOMB
sizeat 32 32
break

case SAMUS
case TIFA
sizeat 29 28
break

case LARATOWEL
sizeat 34 32
break

case EGG // Possibility to spawn egg using RESPAWN
ifspawnedby RESPAWN
	{ sizeat 40 40 ifrnd 128 cstator 4 }
ifspawnedby APLAYER
	{ sizeat 40 40 ifrnd 128 cstator 4 }
ifspawnedby DEVOURER
	{ geta[].z z sub z 8192 seta[].z z sizeat 42 42 ifrnd 128 cstator 4 }
break

case RECON // Possibility to spawn RECON using RESPAWN (fixes E1L2 missing monster)
      ifspawnedby RESPAWN
      { cstat 257
        sizeat 24 24
        clipdist 32
        changespritestat THISACTOR 1
        sound RECO_RECOG
      }
break

case WATERDRIP
	state checkfloordist
	ifl temp 8192 set initsprite 1
break

case PIGCOP
case NEWPIG
	geta[].owner spriteid
	getav[spriteid].shrunken shrunken
	break
	
case AIRFLASH1
	cstat 32768
	geta[].owner spriteid
	geta[spriteid].ang angvar
	geta[].z z
	sub z 8192
	ife sprite[spriteid].picnum SHELLY sub z 512
	ife sprite[spriteid].picnum DUKEBOT sub z 512
	ife sprite[spriteid].picnum ROLLYTURRET add z 4300
	ife sprite[spriteid].picnum LIZELITE sub z 1024
	seta[].z z
	set x sprite[].x
	ife sprite[spriteid].picnum ROLLYTURRET add x 192 else
	add x 384
	rotatepoint sprite[].x sprite[].y x sprite[].y angvar x2 y2
	seta[].x x2
	seta[].y y2
break

// case BEACHBALL
// case BEACHBALLPROJ
	// ifn sprite[].owner -1 
	// { 
		// geta[].owner spriteid 
		// seta[].xrepeat sprite[spriteid].xrepeat seta[].yrepeat sprite[spriteid].yrepeat
		// seta[].pal sprite[spriteid].pal
	// }
// break
	
case IMPCOIN
	geta[].owner spriteid
	ifn spriteid -1 seta[].pal sprite[spriteid].pal
break

case SHOCK_ACTOR
case LIGHTNING_TRAIL1
	cstat 32768
	sizeat 1 1
break

case CBPROJEXP
case MOLTENROCK
	geta[].owner spriteid
	ifn spriteid -1 
	{ 
		seta[].xrepeat sprite[spriteid].xrepeat 
		seta[].yrepeat sprite[spriteid].yrepeat
		seta[].pal sprite[spriteid].pal
	}
break

case SHOCKBALL_EXP
	ifn sprite[].owner -1
	getav[sprite[].owner].myspawner myspawner
break

case GLAREANIM
	cstat 130
	seta[].blend 1
	seta[].alpha 96
break

case AIRSHOCK
	geta[].owner spriteid
	ifn spriteid -1
	{
		set myspawner sprite[spriteid].owner
		seta[].pal sprite[spriteid].pal
		ife sprite[spriteid].pal 0
		set mtype 1
		
		ife sprite[spriteid].picnum RADPROJ
		ife sprite[spriteid].pal 10
		set mtype 2
	}
break


default
	ifn sprite[].owner -1
	{
		getav[sprite[].owner].shrunken shrunken
		ifg shrunken 20 ifl shrunken SHRUNKCOUNT
		{
			ifn sprite[].picnum AMMO
			// ifn sprite[].picnum SHOTGUNSPRITE
			// ifn sprite[].picnum SHOTGUNAMMO
			// ifn sprite[].picnum CHAINGUNSPRITE
			// ifn sprite[].picnum BATTERYAMMO
			seta[].mdflags 16
			ife sprite[].statnum 4 
			{
				seta[].extra 1
				geta[].z z
				add z 1024
				seta[].z z
				seta[].x sprite[sprite[].owner].x
				seta[].y sprite[sprite[].owner].y
			}
		}
	}
break

endswitch
endevent

defstate stayput_replace
	
	set upscaled NO
	rand pal 13
	add pal 10
	ifge pal 17 ifle pal 20 set pal 0
	rand temp 2
	ifle temp 2
		set picnum LIZRANGERSTAYPUT
	else
	ifle temp 4
		set picnum TERMINATORSTAYPUT
	else
	ifle temp 6
	{
		set picnum MECHBRAINSTAYPUT
		ifrnd 84 set pal 0
		else ifrnd 128 set pal 3 else
		set pal 14
	}
	ifle temp 8
		set picnum SPACEBULLSTAYPUT
	else
		set picnum NEWCOMMSTAYPUT
ends

defstate select_water_enemy

	set upscaled NO
	rand pal 13
	add pal 10
	ifge pal 17 ifle pal 20 set pal 0

		set picnum SCUBATROOP
		
	ifrnd 40 
	{
		set picnum DEVOURER
		ife pal 0 set pal 21
	}

ends

defstate select_norm_enemy

	ifn sprite[].htactorstayput -1 { state stayput_replace break }
	
	ife challenge YES ifactor NEWPIG ifspritepal 21
	{
		set pal 19
		set picnum SPACEBULL
		set upscaled NO
		break
	}

	rand temp 11
	ifl plevel 4 set temp 1
	else ifle temp 2
	{
		set picnum SPACEBULL
		// 40, 51, 16, 21, 13, 14, 19
		rand temp 6
		ife temp 0 set pal 13 else ife temp 1 set pal 14 else
		ife temp 2 set pal 16 else ife temp 3 set pal 21 else
		ife temp 4 set pal 40 else ife temp 5 set pal 19 else set pal 51
		set upscaled NO
	} 
	else ifle temp 4
	{
		set picnum LIZELITE
		ifrnd 128 set pal 21 else set pal 12
		set upscaled NO
	} 
	else ife temp 5
	{
		set pal 0
		set picnum NEWCOMM 
		set upscaled NO
	}
	else ife temp 6
	{
		set picnum MECHBRAIN
		ifrnd 64 set pal 14
		ifrnd 64 set pal 3
		set upscaled NO
	}
	else ife temp 7
	{
		ifrnd 128 set picnum SITH else
		set picnum SYTH
		ifrnd 128 set pal 21 else set pal 15
		set upscaled NO
	} 
	else ife temp 8
	{
		set picnum MANDOFETT
		set pal 21
		set upscaled NO
	} 
	else ife temp 9
	{
		set picnum CYBERBEAST
		set pal 24
		set upscaled NO
	} 
	else ife temp 10
	{
		set picnum DEANOVA
		set pal 17
		set upscaled NO
	}
	else ife temp 11
	{
		set picnum CHEERBOT
		set pal 21
		set upscaled NO
	}


ends

state select_tough_enemy

	ifge attbeaten 3 set tempb 8 else set tempb 7
	
	ifvarand charlocked 4 add tempb 1
	
	rand temp tempb
	
	ifvarand charlocked 4 sub temp 1
	
	switch temp
	case -1
		ifactornotstayput
		set picnum BATBOSS
		else set picnum CANHEAD
		set pal 10
		rand tempc 10
		add pal tempc
		ife picnum BATBOSS
		ife pal 21 set pal 19
	break
	case 0
		ifactornotstayput
		set picnum PSPIDER
		else
		set picnum BOSS2STAYPUT
		ifrnd 128 set pal 3 else set pal 46
		set upscaled NO
	break
	case 1
		set picnum CANHEAD
		set pal 21
		set upscaled NO
	break
	case 2
		ifactornotstayput
		set picnum COMBINEDMEN
		else set picnum BOSS3STAYPUT
		set pal 21
		set upscaled NO
	break
	case 3
		set picnum QUEEN
		set pal 3
		ifrnd 64 set pal 21
		set upscaled NO
	break
	case 4
		set picnum BOSS2
		ifactornotstayput ifvarand charlocked 4 ifrnd 128 { set picnum BATBOSS set pal 15 } else
		{
			set pal 3
			ifrnd 64 set pal 21
		}
		set upscaled NO
	break
	case 5
		set picnum BOSS3
		set pal 3
	break
	case 6
		ifactornotstayput
		set picnum LIZDOG
		else set picnum PIGBOSS
		set pal 104
	break
	case 7
		ifactornotstayput
		{ set picnum LIZDOG set pal 104 }
		else { set picnum CHEERBOT set pal 43 }
	break
	case 8
		ifactornotstayput
		set picnum NURGLE
		else set picnum PIGBOSS
		ifrnd 128 set pal 24 else
		ife picnum PIGBOSS set pal 21 else
		set pal 0
	break
	default
		al temp
		set picnum BOSS3
		set pal 3
	break
	endswitch
ends

defstate rand_monst_replace

	ifge SPRITELOTAG 10 break

	ifge SKILL 5 ife attmode 2 ifg plevel 4 nullop else
	ife marathon YES ifg plevel 5 nullop else
	ifn attmode YES break
	ife mid_spawn YES break // don't run another instance if already spawning
	ife VOLUME 6 ifg LEVEL 10 ifl LEVEL 38 break
	// ife vendorupgrade NO break
	
	add replacecount 1
	ifn monstflags 0 break // don't replace if already flagged
	
	set TMP_B 45 // highest possible interval between replacements
	set TMP_A plevel
	// shiftl TMP_A 2
	mul TMP_A 3
	ifg TMP_A 36 set TMP_A 36
	sub TMP_B TMP_A
	
	ifactor BOSS1 ifrnd 85 ifge plevel 3 set TMP_B 0
	ifactor NEWBATLORD ifrnd 85 ifge plevel 3 set TMP_B 0
	ifactor NEWBATLORDSTAYPUT ifrnd 85 ifge plevel 3 set TMP_B 0
	
	ifactor NEWPIG ifspritepal 21 ife challenge YES set TMP_B 0
	
	ifge replacecount TMP_B
	{
		set picnum -1
		switch sprite[].picnum
		case BOSS1STAYPUT case NEWBATLORDSTAYPUT
		case BOSS1 case BOSS2 case BOSS3 case BOSS4
		case NEWBATLORD case PIGBOSS case LIZBOSS
			ifspritepal 0 set picnum -1 // abort
			else state select_tough_enemy
		break
		case DEVOURER case DRPROTON case CANHEAD case CANHEADNOARMS 
		case PIGSUV case ROLLYTURRET case RECON case NEWRECON case GREENSLIME
		case ROTATEGUN case MEGABRAIN
		case MECHBRAIN case MANDOFETT case LIZELITE case LIZTURRET case EDFTURRET
		case NEWBOSS1 case BOSS2FLY case CYCLOIDMAX case DUKEBOT case WESBOT
		case SHELLY case EDFTROOP case EDFSNIPER case EDFDRONE
		case ARMEDF case GUARD case NEWCOMM case NEWCOMMSTAYPUT
		case ARMPIG case EDFPIG case QUEEN
		set picnum -1
		break
		
		case DRONE
			set picnum NEWSENTRY
			set pal 0
		break
		
		case COMMANDER case COMMANDERSTAYPUT

			ifrnd 160 set picnum NEWSENTRY else
			set picnum MEGABRAIN
			set pal 0
		break
		
		default 
			
			set pal 3
			ifinwater state select_water_enemy else
			ifgapzl 128 state select_norm_enemy else
			ifg plevel 4 
			iffloordistl 64
			{
				add toughcount 1
				
				set temp 9
				sub temp SKILL
				
				
				ifge toughcount temp // 5
				ifge prating 300
				{
					set toughcount 0
					set droptile SIXPAK
					state select_tough_enemy
				}
				else
				state select_norm_enemy 
			}
			else
			state select_norm_enemy 
		break
		
		endswitch
		
		ife picnum -1 break // abort process
		set mid_spawn YES
		espawnvar picnum
		ife RETURN -1 set mid_spawn NO
		else
		{
			ife picnum SCUBATROOP { ifrnd 32 set replacecount 0 } else
			set replacecount 0
			seta[RETURN].htactorstayput sprite[].htactorstayput
			seta[RETURN].pal pal
			ifn droptile 0 setav[RETURN].droptile droptile
			ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
			changespritestat RETURN 1
			seta[RETURN].cstat 257
			add sub_maxactors 1
			set mid_spawn NO
			spawn GLARESTAR
			killit
		}
		
	}

ends

state randomturn
	geta[].angoff angvar
	add angvar lastang
	seta[].angoff angvar
	// geta[].pitch angvar
	// add angvar wounded
	// seta[].pitch angvar
	// geta[].roll angvar
	// add angvar wounded
	// seta[].roll angvar
ends

onevent EVENT_SPAWN

	ife do_upscale YES
	{
		// upscale size hack on old enemies

		
		ifge sprite[].picnum 1822 ifle sprite[].picnum 1877
		{
			ifn sprite[].picnum OCTADEADSPRITE
			{
				set x sprite[].xrepeat, mul x 3, div x 4, seta[].xrepeat x
				set x sprite[].yrepeat, div x 2 seta[].yrepeat x
			}
		}
		else
		ifge sprite[].picnum 1890 ifle sprite[].picnum 1910
		state upscale_visual
		else
		ifge sprite[].picnum 1915 ifle sprite[].picnum 1955
		{
			set x sprite[].xrepeat, mul x 3, div x 4, seta[].xrepeat x
			set x sprite[].yrepeat, mul x 3, div x 4, seta[].yrepeat x
		}
		else
		ifge sprite[].picnum 2066 ifle sprite[].picnum 2079
		state upscale_visual
		else
		ifge sprite[].picnum 2122 ifle sprite[].picnum 2199
		{
			ifn sprite[].picnum LIZMANDEADSPRITE
			ifn sprite[].picnum LIZMANGUARD
			{
				set x sprite[].xrepeat, mul x 3, div x 4, seta[].xrepeat x
				set x sprite[].yrepeat, mul x 3, div x 4, seta[].yrepeat x
			}
		}
		else
		ifge sprite[].picnum 2270 ifle sprite[].picnum 2299
		state upscale_visual
		else
		ifge sprite[].picnum 2301 ifle sprite[].picnum 2308
		state upscale_visual
		else
		ifge sprite[].picnum 2310 ifle sprite[].picnum 2323
		state upscale_visual
		else
		ifge sprite[].picnum 2711 ifle sprite[].picnum 2758
		{
			set x sprite[].yrepeat, mul x 2, div x 3, seta[].yrepeat x
		}
		else
		ifge sprite[].picnum 4740 ifle sprite[].picnum 4804
		state upscaleme
		else
		ifge sprite[].picnum 9231 ifle sprite[].picnum 9245
		state upscaleme
	}
	switch sprite[].picnum
	
	case FIRSTGUNSPRITE
	case SHOTGUNSPRITE
	case CHAINGUNSPRITE
	case RPGSPRITE
	case HBOMBAMMO
	case FREEZESPRITE
	case SHRINKERSPRITE
	case BMFGSPRITE
	case GROWSPRITEICON
	// case HEAVYHBOMB
	case TRIPBOMBSPRITE
	case DEVISTATORSPRITE
	case AMMO
	case SHOTGUNAMMO
	case BATTERYAMMO
	case RPGAMMO
	case GROWAMMO
	case BLOODAMMO
	case CRYSTALAMMO
	case DEVISTATORAMMO
	case FREEZEAMMO
	case JOLLYMEAL
	case COLACANSTAND
	case BLUEBALLCAN
	case SNACKSPRITE
	case COLA
	case SIXPAK
	case ATOMICHEALTH
	case FIRSTAID
	case SHIELD
	case STEROIDS
	case HOLODUKE
	case AIRTANK
	case JETPACK
	case HEATSENSOR
	case NUKECOIN
	case IMPCOIN
	case RAILGUNAMMO
	case LASERPISTOL
	case SAWAMMO
	case SAWSPRITE
	case PLASMASPRITE
	case PLASMAAMMO
	case NUKESPRITE
	case CHAINGUNUPGRADE
	case M4UPGRADE
	case PISTOLUPGRADE
	case DEUPGRADE
	case SHOTGUNUPGRADE
	case TRIPBOMBUPGRADE
	case SPIDERMINESPRITE
	case SABERSPRITE
	case BOWSPRITE
	case QUIVERSPRITE
	case DBSPRITE
	case DBAMMO
	case SHOCKRIFLESPRITE
		// ifspritepal 0
		set monstatus 100 strength 1
		changespritestat THISACTOR 1
	break
	
	case ACCESSCARD
		set monstatus 100
		geta[].pal initsprite
	break
	
	case BOX
	case TIRE
	case BMWM4 case COPCAR case TAXI case CRUZ case CIVIC case PORSCHE case LAMBO90
	case BEETLE case HUMMER case JEEP case LIMO case PICKUP case PICKUP2 case VAN1
	case VAN2 case WRECKEDCAR case DODGECAR case FORD case ROVER
	case BMWM3 case NANOCOOPER case TOWTRUCK case CHEVELLE case OLDCAR
	case MICROBUS case AUDIA
	
	case EDFTANKWRECK
		ifvarand initflags 4
		{
			geta[].htflags temp
			orvar temp 4
			seta[].htflags temp
			seta[].shade droptile
		}
	break

	case NAVSPRITE
		seta[].htpicnum NAVSPRITE
		changespritestat THISACTOR 979 
		// change to 980 after base value trails are set
		cstat 32768
		geta[].z z
		sub z 6144 // 8192
		seta[].z z
		set countvar nav_init
		sub nav_init 1
		ife nav_init -1 set nav_init 5
		
	break
	
	case SHELL
	ifspawnedby APLAYER
	ife pchar 2
	{
		ife player[].curr_weapon PISTOL_WEAPON
		{
			geta[].xvel xvel
			ifrnd 128 mul xvel -1
			seta[].xvel xvel
		}
	}
	break
	
	case CAMTRACK
		changespritestat THISACTOR 991
	break
	
	case JIBS6
		geta[].owner spriteid
	
		ife sprite[spriteid].statnum 4
		{
			seta[].zvel 0
			seta[].xvel 24
			randvar temp 2047
			seta[].ang temp	
			ife sprite[spriteid].picnum EGGJIBPROJ spritepal 8
		}
		ifspawnedby SHOTSPARK1
		{	
			geta[].htowner spriteid
			geta[spriteid].htg_t 8 temp
			ife sprite[temp].picnum ZOMBIE spritepal 8
			ife sprite[temp].picnum CRONEN spritepal 8
			ife sprite[temp].picnum ARMYANT spritepal 8
			ife sprite[temp].picnum ARMYANTCRAWL spritepal 8
		}
	break
	
	case BLOODPOOL
	ifspawnedby EGGJIBGROUND ifn sprite[].pal 1 spritepal 6
	ifspawnedby ZOMBIE ifn sprite[].pal 1 spritepal 6
	ifspawnedby CRONEN ifn sprite[].pal 1 spritepal 6
	ifspawnedby ARMYANT ifn sprite[].pal 1 spritepal 6
	insertspriteq
	break
	case GREENSLIME seta[].mdflags 16 
	set spawnprotect 0
	set monstatus -1
	break
	case SHARK
		ifrnd 32 
		cactor DOPEFISH
		else 
		ifg sprite[].xrepeat 4 sizeat 40 40
	break
	case DOPEFISH
		sizeat 60 60
		cstator 257
	break
	
	case PIGCOPDEADSPRITE cactor 17109
		sizeat 28 28	
	break
	
	case OCTADEADSPRITE cactor 1870
		sizeat 24 24
	break
	
	case LIZMANDEADSPRITE sizeat 26 26
	break
	
	case PODFEM1
		ifg sprite[].xrepeat 4 
		{ 
			action ANEWFEMANG5 cactor NEWPODFEM1 strength TOUGH 
			geta[].xrepeat x, mul x 3 div x 4 seta[].xrepeat x
			geta[].yrepeat y, mul y 3 div y 4 seta[].yrepeat y
		}
	break
	case NAKED1
		ifg sprite[].xrepeat 4 { action ANEWFEMANG5 cactor NEWNAKED1 strength TOUGH }
	break
	case FEM5
		ifg sprite[].xrepeat 4 { action ANEWFEMANG8 cactor NEWFEM5 strength TOUGH }
	break
	case FEM6
		ifg sprite[].xrepeat 4 { action ANEWFEMANG8 cactor NEWFEM6 strength TOUGH }
	break
	
	
	case PIGCOP
	case PIGCOPDIVE
	case PIGCOPSTAYPUT
		set monstatus -1
		ifspawnedby RECON
		{
			cactor NEWPIG ai 0 sizeat 28 26 
			ife NEWENEMIES YES ifrnd 32 spritepal 21
			set upscaled NO 
			ifg shrunken 10 ifl shrunken SHRUNKCOUNT
			{ sizeat 6 5 strength 25 }
			else
			set burning 100
		}
		else
		ifspawnedby TANK
		{
			cactor NEWPIG ai 0 sizeat 28 26 
			ife NEWENEMIES YES ifrnd 32 spritepal 21
			set upscaled NO 
			ifg shrunken 10 ifl shrunken SHRUNKCOUNT
			{ sizeat 6 5 strength 25 }
			else
			set burning 100
		}
		else
		ifspawnedby PIGSUV
		{
			cactor NEWPIG ai 0 sizeat 28 26 
			ife NEWENEMIES YES ifrnd 32 spritepal 21
			set upscaled NO 
			ifg shrunken 10 ifl shrunken SHRUNKCOUNT
			{ sizeat 6 5 strength 25 }
			else
			set burning 100
		}
		else
		ifn sprite[].htpicnum APLAYER
		ifg sprite[].xrepeat 4
		{
			ifactor PIGCOP 
			{ 
				cstator 257
				cactor NEWPIG ai 0 sizeat 28 26
				ife monstflags 0
				ife NEWENEMIES YES ifrnd 32 spritepal 21
				set upscaled NO 
			}
			ifactor PIGCOPSTAYPUT
			{
				cactor NEWPIGSTAYPUT ai 0
				ife monstflags 0
				ife NEWENEMIES YES ifrnd 32 spritepal 21
				cstator 257
				sizeat 28 26
				set upscaled NO
				seta[].htactorstayput sprite[].sectnum
			}
			ifactor PIGCOPDIVE 
			{
				cstator 257
				cactor NEWPIGDIVE ai 0 sizeat 28 26 
				ife monstflags 0
				ife NEWENEMIES YES ifrnd 32 spritepal 21
				set upscaled NO 
				seta[].htactorstayput sprite[].sectnum
			}
			state rand_monst_replace
			ife NEWENEMIES YES
			ife monstflags 0
			{
				add termcount 1
				ifg termcount 8
				{
					set termcount 0
					ifactornotstayput espawn TERMINATOR
					else
					espawn TERMINATORSTAYPUT
					seta[RETURN].xrepeat 28 // 42
					seta[RETURN].yrepeat 24 // 36
					seta[RETURN].cstat 257
					add sub_maxactors 1
					ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
					killit
				}
				else
				{
					ifn attmode NO ifl plevel 2 set pigcount 0
					add pigcount 1
					ifg pigcount 4
					{
						set pigcount 0 
						ifrnd 160
						espawn ARMPIG
						else espawn EDFPIG
						seta[RETURN].htactorstayput sprite[].htactorstayput
						seta[RETURN].xrepeat 26
						seta[RETURN].yrepeat 24
						seta[RETURN].cstat 257
						seta[RETURN].extra EDFPIGSTRENGTH
						seta[RETURN].pal sprite[].pal
						ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
						ifn attmode 0
						ifn sprite[].pal 21
						ifg plevel 4
						ifrnd 64
						{
							seta[RETURN].pal 21
							setav[RETURN].initflags 32
						}
						add sub_maxactors 1
						killit
					}
					else
					{
						ifl plevel 4 set commcount 0
						ifn attmode YES set commcount 0
						add commcount 1
						
						ifgapzl 128 nullop else
						ifg commcount 6
						{
							set commcount 0 
							{
								ifactornotstayput espawn PIGBOSS
								else
								espawn PIGBOSSSTAYPUT
								seta[RETURN].pal 21
								seta[RETURN].xrepeat 33
								seta[RETURN].yrepeat 30
								setav[RETURN].droptile SIXPAK
								seta[RETURN].extra 1000
								seta[RETURN].cstat 257
								ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
								add sub_maxactors 1
								killit
							}
						}
						ifn attmode NO add dogcount 1
						ifg dogcount 11
						ifactornotstayput
						{
							set dogcount 0
							espawn LIZDOG
							seta[RETURN].xrepeat 28
							seta[RETURN].yrepeat 26
							seta[RETURN].cstat 257
							seta[RETURN].extra LIZDOGSTRENGTH
							ifrnd 64 seta[RETURN].pal 17 else
							ifrnd 96 seta[RETURN].pal 3
							ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
							{
								set x sprite[].x
								add x 512
								set y sprite[].y
								add y 512
								set mysector sprite[].sectnum
								updatesector x y mysector
								ife mysector sprite[].sectnum
								{
									seta[RETURN].x x
									seta[RETURN].y y
								}
								else
								{
									sub x 1024
									sub y 1024
									set mysector sprite[].sectnum
									updatesector x y mysector
									ife mysector sprite[].sectnum
									{
										seta[RETURN].x x
										seta[RETURN].y y
									}
								}
							}
						}
						
					}
				}
				
			}
			
		}

	break
	

	case LIZTROOP
	case LIZTROOPSTAYPUT
	case LIZTROOPDUCKING
	case LIZTROOPJETPACK
	case LIZTROOPSHOOT
	case LIZTROOPRUNNING
	set monstatus -1
	ifn sprite[].htpicnum APLAYER
	ife gametype 0
	ifg sprite[].xrepeat 4
	{
		ifactor LIZTROOP 
		{
			cstator 257
			cactor NEWTROOP ai 0 sizeat 24 22 
			strength NEWTROOPSTRENGTH set upscaled NO 
			ife monstflags 0
			ife monstflags 0
			ife NEWENEMIES YES ifg plevel 2 ifrnd 24 spritepal 24
		}
		ifactor LIZTROOPSTAYPUT 
		{
			ifoutside
			{
				cactor LIZTURRET
				cstator 257
				ai 0 sizeat 24 22
				set upscaled NO
				strength LIZTURRETSTRENGTH 
			}
			else
			{
				cstator 257
				ai 0 sizeat 24 22
				set upscaled NO
				ifceilingdistl 256
				{
					cactor NEWTROOPSTAYPUT
					strength NEWTROOPSTRENGTH 
					ife monstflags 0
					ife monstflags 0
					ife NEWENEMIES YES ifg plevel 2 ifrnd 24 spritepal 24
				}
				else
				{
					cactor LIZTURRET
					strength LIZTURRETSTRENGTH 
				}
			} 
			set upscaled NO 
		}
		ifactor LIZTROOPSHOOT
		{
			cstator 257
			cactor NEWTROOPDUCKING ai 0 sizeat 24 22 
			strength NEWTROOPSTRENGTH set upscaled NO
			ife monstflags 0
			ife NEWENEMIES YES ifg plevel 2 ifrnd 24 spritepal 24
		}
		ifactor LIZTROOPDUCKING 
		{
			cstator 257
			cactor NEWTROOPDUCKING ai 0 sizeat 24 22 
			strength NEWTROOPSTRENGTH set upscaled NO 
			ife monstflags 0
			ife NEWENEMIES YES ifg plevel 2 ifrnd 24 spritepal 24
		}
		ifactor LIZTROOPJETPACK
		{
			cstator 257
			cactor NEWTROOPJETPACK ai 0 sizeat 24 22
			strength NEWTROOPSTRENGTH set upscaled NO 
			ife monstflags 0
			ife NEWENEMIES YES ifg plevel 2 ifrnd 24 spritepal 24
		}
		ifactor LIZTROOPRUNNING
		{
			cstator 257
			cactor NEWTROOP ai 0 sizeat 24 22 
			strength NEWTROOPSTRENGTH set upscaled NO 
			ifspritepal 21
            addstrength NEWTROOPSTRENGTH
			set dodgetime 8
		}
		ife monstflags 0
		state rand_monst_replace
		ife NEWENEMIES YES
		ifn sprite[].picnum NEWTROOPJETPACK
		ife monstflags 0
		{
			ifn attmode NO ifl plevel 2 set troopcount 0
			add troopcount 1
			ifn attmode NO add dogcount 1
			ifg troopcount 4
			{
				ifactor NEWTROOPSTAYPUT espawn LIZRANGERSTAYPUT else
				espawn LIZRANGER
				seta[RETURN].xrepeat 30
				seta[RETURN].yrepeat 28
				seta[RETURN].cstat 257
				seta[RETURN].extra RANGERSTRENGTH
				ifrnd 128 { setav[RETURN].initflags 32 seta[RETURN].pal 19 }
				ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				set troopcount 0
				add sub_maxactors 1
				killit
			}
			else
			ifspritepal 21
			{
				add antcount 1
				ifg antcount 3
				{
					state add_ant_code
					ifge SKILL 4 { state add_ant_code state add_ant_code }
					killit
				}
				ifg dogcount 7
				{
					set dogcount 0
					espawn LIZDOG
					seta[RETURN].xrepeat 28
					seta[RETURN].yrepeat 26
					seta[RETURN].cstat 257
					seta[RETURN].extra LIZDOGSTRENGTH
					ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
					ifawayfromwall
					{
						set x sprite[].x
						add x 512
						seta[RETURN].x x
						set y sprite[].y
						add y 512
						seta[RETURN].y y
					}
					
				}
			}
			else ifn attmode NO
			{
				ifg plevel 1 ifrnd 32 spritepal 16
				else
				ifg plevel 2
				{
					ifg dogcount 11
					ifactornotstayput
					{
						set dogcount 0
						espawn LIZDOG
						seta[RETURN].xrepeat 28
						seta[RETURN].yrepeat 26
						seta[RETURN].cstat 257
						seta[RETURN].extra LIZDOGSTRENGTH
						ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
						add sub_maxactors 1
						ifrnd 128 seta[RETURN].pal 17
						killit
					}
					else
					{
						add cronencount 1
						ifge cronencount 8
						ifactornotstayput
						iffloordistl 32
						{
							set cronencount 0
							cactor CRONEN
							sizeat 28 28
							ai 0
							action 0
							orvar initflags 32
						}
					}
				}
			}
		}
	}
	break

	case LIZTROOPONTOILET
	set monstatus -1
	ife gametype 0
	ifg sprite[].xrepeat 4
	{
		cstator 257
		cactor NEWTROOPONTOILET ai 0 sizeat 24 22
		strength NEWTROOPSTRENGTH set upscaled NO
		ifn sprite[].pal 21
		ife monstflags 0
			ifg plevel 1 ifrnd 32 spritepal 16
	}
	break
	
	case LIZTROOPJUSTSIT
	set monstatus -1
	ife gametype 0
	ifg sprite[].xrepeat 4
	{
		cstator 257
		cactor NEWTROOPJUSTSIT ai 0 sizeat 24 22
		strength NEWTROOPSTRENGTH set upscaled NO
		ifn sprite[].pal 21
		ife monstflags 0
			ifg plevel 1 ifrnd 32 spritepal 16
	}
	break
	
	case LIZMANJUMP
	set monstatus -1
	ife gametype 0
	ifg sprite[].xrepeat 4
	{
		sizeat 28 26
		ife monstflags 0
		state rand_monst_replace
		ife NEWENEMIES YES
		ife monstflags 0
		{
			add antcount 1
			ifg antcount 3
			{
				set antcount 0
				espawn ARMYANTJUMP
				ifrnd 64 ifg plevel 3 seta[RETURN].pal 40
				seta[RETURN].xrepeat 24
				seta[RETURN].yrepeat 24
				seta[RETURN].cstat 257
				seta[RETURN].extra ARMYANTSTRENGTH
				ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				add sub_maxactors 1
				killit
			}
			else
			ifrnd 32 ifg plevel 2 spritepal 20
		}
	}
	break

	case LIZMAN
	case LIZMANSPITTING
	set monstatus -1
	
	ifn sprite[].htpicnum APLAYER
	ifn sprite[].htpicnum LIZGROPE
	ife gametype 0
	ifg sprite[].xrepeat 4
	{
		sizeat 28 26
		ife monstflags 0
		state rand_monst_replace
		ife NEWENEMIES YES
		ife monstflags 0
		{
			ifrnd 32 ifg plevel 2 spritepal 20
			ifn attmode NO ifl plevel 2 set termcount 0
			add termcount 1
			add antcount 1
			ifn attmode NO add dogcount 1
			ifg termcount 9
			{
				set termcount 0
				ifactornotstayput espawn TERMINATOR
				else
				espawn TERMINATORSTAYPUT
				seta[RETURN].xrepeat 28 // 42
				seta[RETURN].yrepeat 24 // 36
				seta[RETURN].cstat 257
				seta[RETURN].extra TERMINATORSTRENGTH
				ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				add sub_maxactors 1
				killit
			}
			else
			ifg antcount 4
			{
				state add_ant_code
				ifge SKILL 4 { state add_ant_code state add_ant_code }
				killit
			}
			ifg dogcount 11
			ifactornotstayput
			{
				set dogcount 0
				espawn LIZDOG
				seta[RETURN].xrepeat 28
				seta[RETURN].yrepeat 26
				seta[RETURN].cstat 257
				seta[RETURN].extra LIZDOGSTRENGTH
				ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				ifrnd 96 seta[RETURN].pal 17
				ifawayfromwall
				{
					set x sprite[].x
					add x 512
					seta[RETURN].x x
					set y sprite[].y
					add y 512
					seta[RETURN].y y
				}
			}
			else
			{
				add lizcount 1
				ifg lizcount 6
				ife attmode YES
				ifge plevel 3
				{
					set lizcount 0 
					ifgapzl 160
					{
						spritepal 42 orvar initflags 8 
					}
					else
					{
						espawn LIZBOSS
						seta[RETURN].pal 3
						ifg plevel 4 ifrnd 64 seta[RETURN].pal 20
						seta[RETURN].extra LIZBOSSPALSTRENGTH
						seta[RETURN].xrepeat 32
						seta[RETURN].yrepeat 28
						seta[RETURN].cstat 257
						setav[RETURN].droptile SIXPAK
						ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
						add sub_maxactors 1
						killit
					}
					
				}
			}
		}
		
	}
	break
	
	case LIZMANSTAYPUT
		ifg sprite[].xrepeat 4 
		{
			sizeat 28 26
			cstator 256
			ife monstflags 0
			ife NEWENEMIES YES ifg plevel 2 ifrnd 32 spritepal 20
			ife attmode YES
			ife monstflags 0
			{
				state rand_monst_replace
				ifrnd 32 { spritepal 42 orvar initflags 8 }
			}
		}
	break
	
	case DRONE
	set monstatus -1
	ifg sprite[].xrepeat 4
	ife monstflags 0
	{
		state rand_monst_replace
		ifactor DRONE
		{
			add dronecount 1
			ife NEWENEMIES YES ife dronecount 2
			{
				cactor NEWSENTRY
				sizeat 24 22
				action 0
				ai 0
				cstator 257
				spritepal 0
				set upscaled NO
			}
			else
			ifg dronecount 3 { set dronecount 0 spritepal 19 orvar initflags 8 }
		}
	}
	break

	case OCTABRAIN
	ifg sprite[].xrepeat 4 sizeat 24 22
	set monstatus -1
	ifn sprite[].owner -1
	ifvarand actorvar[sprite[].owner].initflags 16
	nullop
	else
	ife gametype 0
	ifg sprite[].xrepeat 4
	ifn sprite[].htpicnum OCTACAVEGIRL
	ife monstflags 0
	{
		state rand_monst_replace
		ife NEWENEMIES YES
		{
			add octacount 1
			ifn attmode NO ifl plevel 3 set octacount 0
			ifgapzl 128 nullop else
			ifg octacount 5
			{ 
				set octacount 0 
				ifinwater ifrnd 128
				{
					espawn DEVOURER
					seta[RETURN].pal 21
					seta[RETURN].xrepeat 18
					seta[RETURN].yrepeat 16
					seta[RETURN].cstat 257
					seta[RETURN].extra 150
					ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				}
				else
				{
					espawn MEGABRAIN
					seta[RETURN].xrepeat 48
					seta[RETURN].yrepeat 40
					seta[RETURN].cstat 257
					seta[RETURN].extra MEGASTRENGTH
					ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				}
				add sub_maxactors 1
				killit
			}
			ifn attmode NO
			ifrnd 48
			{
				spritepal 17 
				orvar initflags 16 
				sizeat 36 32
			}
		}
	}
	break
	
	case OCTABRAINSTAYPUT 
		set monstatus -1
		ifg sprite[].xrepeat 4
		{
			sizeat 24 22
			ife monstflags 0
			state rand_monst_replace
		}
	break

	case FIRE
	case FIRE2
	case SHRINKEREXPLOSION
	case TRANSPORTERSTAR
	case FORCERIPPLE
	case NATURALLIGHTNING
	case LIGHTNING2
		cstator 2
		seta[].blend 1
	break

	case NEWBEAST
	case NEWBEASTCROUCH
	// case NEWBEASTSTAYPUT
	case NEWBEASTJUMP
	// case NEWBEASTHANG
	set monstatus -1
	ifspawnedby BOSS4 nullop else
	ifspawnedby QUEEN nullop else
	ifn attmode NO
	ife monstflags 0
	{
		ifoutside 
		ife mid_spawn NO
		{
			add nurgcount 1
			ifg nurgcount 12
			ifge attbeaten 3
			ifge plevel 5
			{
				set nurgcount 0
				espawn NURGLE
				seta[RETURN].extra NURGLESTRENGTH
				seta[RETURN].xrepeat 32
				seta[RETURN].yrepeat 28
				seta[RETURN].cstat 257
				setav[RETURN].droptile SIXPAK
				ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				add sub_maxactors 1
				ifrnd 128 seta[RETURN].pal 24
				killit	
			}
		}
		ifrnd 32
		ife NEWENEMIES YES
		{
			spritepal 21 
			orvar initflags 4 
		}
	}
	
	ife gametype 0
	ifn sprite[].htpicnum APLAYER
	ifg sprite[].xrepeat 4
	ife monstflags 0
	{
		state rand_monst_replace
		ife NEWENEMIES YES
		{
			ifn attmode NO ifl plevel 3 set beastcount 0
			add beastcount 1
			ifg beastcount 2
			{
				set beastcount 0
				espawn CYBERBEAST
				seta[RETURN].xrepeat 32
				seta[RETURN].yrepeat 28
				ifn attmode NO ifrnd 64 { seta[RETURN].pal 24 seta[RETURN].xrepeat 34 seta[RETURN].yrepeat 30 }
				seta[RETURN].cstat 257
				ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				add sub_maxactors 1
				killit
			}	
		}
	}
	break
	
	case RECON
		ifg sprite[].xrepeat 4
		sizeat 24 24
		set spawnprotect 0
		set monstatus -1
	break
	
	case NEWRECON
		ifg sprite[].xrepeat 4
		sizeat 24 24
		set spawnprotect 0
		set monstatus -1
	break
	
	case COMMANDER case COMMANDERSTAYPUT
	case NEWCOMM case NEWCOMMSTAYPUT
		set monstatus -1
		ifg sprite[].xrepeat 4
		ifn sprite[].htpicnum APLAYER
		ife monstflags 0
		ife mid_spawn NO
		{
			ifn attmode NO add nurgcount 1
			ifg nurgcount 12
			ifge attbeaten 3
			ifge plevel 5
			iffloordistl 64
			ife sprite[].htactorstayput -1
			{
				set nurgcount 0
				espawn NURGLE
				seta[RETURN].extra NURGLESTRENGTH
				seta[RETURN].xrepeat 32
				seta[RETURN].yrepeat 28
				seta[RETURN].cstat 257
				setav[RETURN].droptile SIXPAK
				add sub_maxactors 1
				ifrnd 128 seta[RETURN].pal 24
				ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				killit	
			}
			else
			{
				state rand_monst_replace
				ifrnd 128
				ife NEWENEMIES YES
				{
					ifactor COMMANDER 
					{ 
						set upscaled NO cactor NEWCOMM 
						sizeat 30 28 cstator 257 strength MECHBRAINSTRENGTH ai 0 
					}
					ifactor COMMANDERSTAYPUT { set upscaled NO cactor NEWCOMMSTAYPUT sizeat 30 28 cstator 257 strength MECHBRAINSTRENGTH ai 0 }
				}
				else 
				{
					strength COMMANDERSTRENGTH
					ife NEWENEMIES YES ifrnd 32 spritepal 24
				}
			}
		}
	break
	
	case LIZRANGER case LIZRANGERSTAYPUT case LIZRANGERSIT
	case EGG case EGGYOUNG case SIDEGUN
	case ARMPIG case EDFPIG case ARMPIGSTAYPUT case PIGSUV
	case MECHBRAIN
	case MEGABRAIN case DRPROTON case PSPIDER
	break
	
	case TERMINATOR case TERMINATORSTAYPUT
	ifg sprite[].xrepeat 4 ife NEWENEMIES YES 
	ife monstflags 0
	ifrnd 32 ifg plevel 2 
	{
		spritepal 57
		sizeat 36 32
	}
	break
	
	case BOSS1 case BOSS1STAYPUT
		set monstatus -1
		ifn sprite[].htpicnum APLAYER
		// ife gametype 0
		// ifspritepal 21
		ifg sprite[].xrepeat 4
		{
			ifactor BOSS1 cactor NEWBATLORD
			ifactor BOSS1STAYPUT cactor NEWBATLORDSTAYPUT
			ifspritepal 0 { strength 6000 sizeat 72 60 } else 
			{ 
				sizeat 36 30 strength 1200 
				ife monstflags 0
				ife attmode YES ifrnd 70 ifg plevel 4 spritepal 42
			}
			
			set upscaled NO
			ai 0
			ifn sprite[].htpicnum RESPAWN seta[].htpicnum sprite[].picnum
			ife monstflags 0
			ifn attmode NO ifn sprite[].pal 0 state rand_monst_replace
		}
	
	break
	
	case CYBERBEAST 
		set monstatus -1
		ifg sprite[].xrepeat 4
		ife monstflags 0
		state rand_monst_replace
	break
	
	
	case BOSS2
	case BOSS2STAYPUT
		set monstatus -1
		ifg sprite[].xrepeat 4
		{
			ifspritepal 0 sizeat 80 64 else sizeat 40 32
		}
	break
	
	case BOSS3
	case BOSS3STAYPUT
	set monstatus -1
		ifg sprite[].xrepeat 4
		{
			ifspritepal 0 sizeat 64 60 else sizeat 44 38
		}
	break
	
	case CANHEAD case CYCLOIDMAX case BOSS4
	case PIGBOSS case PIGBOSSSTAYPUT case LIZBOSS case LIZBOSSSTAYPUT
	case ARMEDF case EDFSNIPER case EDFSNIPERCROUCH
	case CORRUPT
		set monstatus -1
	break
	
	case ZOMBIE case ZOMBIEGIDUP
		set monstatus -1
		ifg sprite[].xrepeat 4
		{	
			rand temp 4
			add temp 26
			seta[].xrepeat temp
			rand temp 2
			add temp 24
			seta[].yrepeat temp
			rand temp 4
			ife temp 1 spritepal 17 else
			ife temp 2 spritepal 19 else
			ife temp 3 spritepal 27 else
			ife temp 4 spritepal 28
		}
	break
	
	case CRONEN
		set monstatus -1
		ifg sprite[].xrepeat 4
		{	
			rand temp 4
			add temp 26
			seta[].xrepeat temp
			rand temp 2
			add temp 24
			seta[].yrepeat temp
			ifspritepal 0
			{
				rand temp 13
				ifrnd 224 { add temp 10 seta[].pal temp }
			}
		}
	break
	
	case NEWSENTRY
		sizeat 24 22
		cstat 257
	break
	
	case PATROLSENTRY
		sizeat 32 30
		cstat 257
	break
	
	
	case TANK
		set monstatus -1
		
		ifn sprite[].htpicnum APLAYER
		ife gametype 0
		ifg sprite[].xrepeat 4
		ife monstflags 0
		{
			state rand_monst_replace
			ifrnd 32 spritepal 24
			ife NEWENEMIES YES
			{
				ifn attmode NO ifl plevel 4 set mechcount 0
				add mechcount 1
				
				ifn attmode NO add nurgcount 1
				ifg nurgcount 12
				ifge attbeaten 3
				ifge plevel 5
				{
					set nurgcount 0
					espawn NURGLE
					seta[RETURN].extra NURGLESTRENGTH
					seta[RETURN].xrepeat 32
					seta[RETURN].yrepeat 28
					seta[RETURN].cstat 257
					setav[RETURN].droptile SIXPAK
					add sub_maxactors 1
					ifrnd 128 seta[RETURN].pal 24
					ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
					killit	
				}
				else
				ifg mechcount 3
				{
					set mechcount 0
					espawn MECHBRAIN
					seta[RETURN].xrepeat 40
					seta[RETURN].yrepeat 38
					seta[RETURN].cstat 257
					add sub_maxactors 1
					ifrnd 84 seta[RETURN].pal 3 else
					ifrnd 128 seta[RETURN].pal 14 else
					seta[RETURN].pal 21
					ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
					killit
				}
			}
		}

	break
	
	case LITBIGSTATUE changespritestat THISACTOR 1
	sleeptime -1
	break
	
	// case BOSS1 case BOSS2 case BOSS3 case BOSS4
	// ifn sprite[].pal 0 sizeat 40 40
	// break
	
	default
		geta[].cstat temp
		andvar temp 48

		ife temp 32  // if it's floor-aligned
		{
			geta[].mdflags temp
			orvar temp 1  // SPREXT_NOTMD
			seta[].mdflags temp
		}

	break
	
	case COPTERPATH
	changespritestat THISACTOR 978
	break
	
	case SPYPATH
	changespritestat THISACTOR 977
	break
	
	endswitch
	
	ifvarand monstflags 256
	ifg sprite[].xrepeat 4
	ife init_xrepeat 0
	{
		geta[].xrepeat init_xrepeat
		geta[].xrepeat x, mul x 3, div x 2, ifg x 255 set x 255
		seta[].xrepeat x
		geta[].yrepeat init_yrepeat
		geta[].yrepeat y, mul y 3, div y 2, ifg y 255 set y 255
		seta[].yrepeat y
	}
	
endevent

onevent EVENT_SETDEFAULTS
	setuserdef[].default_volume 1
	setuserdef[].textscale 300
	setuserdef[].screen_size 0
	setuserdef[].userbyteversion 5
endevent

// RETURN is 50 when changing from game to Esc menu
// RETURN is -2 when changing from Esc menu back to game
onevent EVENT_CHANGEMENU

getp[].auto_aim autoaim

ifn vrtrip 0 
{
	ife RETURN 50
	{
		ife vrmenu NO
		{
			set vrmenu YES
			set RETURN -2
		}
		else
		ife vrmenu YES
		{
			set RETURN -2
			set vrmenu NO
			setp[].movement_lock 0
		}
	}	
		
	ife vrmenu -1
	ifn RETURN 50
	{
		set RETURN 50
		set vrmenu -2
	}
	ife vrmenu -2
	{
		ife RETURN -2 set vrmenu NO
	}
}

endevent



onevent EVENT_GETMENUTILE
 
 ifvarn rendmode 0
 {
	setvarvar temp xdim
	shiftvarl temp 3
	divvarvar temp ydim
	ifvarg temp 12 setvar RETURN 10233
	else
	setvar RETURN 10234
 }
 ifge current_menu 100 ifle current_menu 110 
	set RETURN 10487
 
endevent


onevent EVENT_ANIMATESPRITES

gettspr[].tsprowner spriteid

ife player[].player_par actorvar[spriteid].damflash
{
	settspr[].tsprpal 121
	settspr[].tsprshade -100
}

ife actorvar[spriteid].upscaled 2
{
	geta[spriteid].xrepeat x
	shiftr x 1
	settspr[].tsprxrepeat x
	geta[spriteid].yrepeat y
	shiftr y 1
	settspr[].tspryrepeat y
}

ife targetlock[0] spriteid
{
	getp[].player_par temp
	modvar temp 3
	ife temp 1 settspr[].tsprpal 125
	else ife temp 2 settspr[].tsprpal 33
	settspr[].tsprshade -127
} else
ife targetlock[1] spriteid
{
	getp[].player_par temp
	modvar temp 3
	ife temp 1 settspr[].tsprpal 125
	else ife temp 2 settspr[].tsprpal 33
	settspr[].tsprshade -127
} else
ife targetlock[2] spriteid
{
	getp[].player_par temp
	modvar temp 3
	ife temp 1 settspr[].tsprpal 125
	else ife temp 2 settspr[].tsprpal 33
	settspr[].tsprshade -127
}

ifvarand actorvar[spriteid].monstflags 524288
{
	geta[spriteid].xrepeat x
	shiftl x 1
	settspr[].tsprxrepeat x
	geta[spriteid].yrepeat y
	shiftl y 1
	settspr[].tspryrepeat y
}
	
ife sprite[spriteid].statnum 4
{
	ifvarand actorvar[spriteid].monstflags 64
	{
		geta[spriteid].xrepeat x
		shiftl x 1
		settspr[].tsprxrepeat x
		geta[spriteid].yrepeat y
		shiftl y 1
		settspr[].tspryrepeat y
	}
	ifvarand actorvar[spriteid].monstflags 1048576
	{
		settspr[].tsprpal 119
		settspr[].tsprshade -127
	}
	ifvarand actorvar[spriteid].monstflags 256
	{
		geta[spriteid].xrepeat x
		mul x 3 div x 2
		settspr[].tsprxrepeat x
		geta[spriteid].yrepeat y
		mul y 3 div y 2
		settspr[].tspryrepeat y
	}
	ife sprite[spriteid].picnum BIGBOIPROJ
	{
		gettspr[].tsprz z sub z 2816 settspr[].tsprz z
	}
}

gettspr[].tsprpal pal

getav[spriteid].shrunken temp
ifn temp 0
{
	ife pal 4 { settspr[].tsprxrepeat 0 settspr[].tspryrepeat 0 }
	else 
	{ 
		gettspr[].tsprxrepeat tempb
		ifg tempb 6 { settspr[].tsprxrepeat 6 settspr[].tspryrepeat 6 }
	}
}

getav[spriteid].burning temp
ifn temp 0 
ifn pal 4
{
	ifg temp 0
	{
	settspr[].tsprpal 96
	ifg sprite[spriteid].extra 1
	settspr[].tsprshade -50
	}
	else
	{
		set tempb sprite[spriteid].extra
		mul tempb -1
		ifl temp tempb
		settspr[].tsprpal 1
	}
}

getav[spriteid].yoffset temp
ifn temp 0
{
	gettspr[].tsprz z
	add z temp
	settspr[].tsprz z
}

ifl actorvar[spriteid].bleeding 0
ife actorvar[spriteid].monstatus 1
	settspr[].tsprpal 76

switch sprite[spriteid].picnum

case TOILET
	ife actorvar[spriteid].initsprite NEWTOILET
	settspr[].tsprpicnum NEWTOILET
break
case TOILETBROKE
	ife actorvar[spriteid].initsprite NEWTOILET
	settspr[].tsprpicnum NEWTOILETBROKE
break

case APLAYER
	ifn player[].newowner -1 
	{
		settspr[].tsprxrepeat 0
		settspr[].tspryrepeat 0
	}
	else
	ifn spriteid player[].holoduke_on
	{
		ife pdown YES settspr[].tsprcstat 257
		ife pchar 2
		{
			settspr[].tsprpal wespal
			gettspr[].tsprxrepeat x
			gettspr[].tspryrepeat y
			// default 42x 36x
			// shadow is 4y
			mul x 53
			div x 100
			mul y 57
			div y 100
			settspr[].tsprxrepeat x
			settspr[].tspryrepeat y
			// sizeat 22 20
		}
		else
		ife pchar 1
		{
			settspr[].tsprpal shellypal
			ifn player[].cursectnum -1
			ifg sector[player[].cursectnum].floorpal 0
			ifl sector[player[].cursectnum].floorpal 10
			settspr[].tsprpal sector[player[].cursectnum].floorpal
			
			gettspr[].tsprxrepeat x
			gettspr[].tspryrepeat y
			// default 42x 36x
			// shadow is 4y
			mul x 55
			div x 100
			mul y 59
			div y 100
			settspr[].tsprxrepeat x
			settspr[].tspryrepeat y
			// sizeat 23 21
			ifvarand altcostume 32 // bikini
			{
				gettspr[].tsprpicnum picnum
				add picnum 9984
				settspr[].tsprpicnum picnum
			}
			else
			ifvarand altcostume 4 // gladiator
			{
				gettspr[].tsprpicnum picnum
				add picnum 7018
				settspr[].tsprpicnum picnum
			}
			else
			ifvarand altcostume 1 // EDF
			{
				gettspr[].tsprpicnum picnum
				add picnum 2304
				ife pdown YES add picnum 83
				settspr[].tsprpicnum picnum
			}
			ifp pducking
			{
				gettspr[].tsprz z
				sub z 2048
				settspr[].tsprz z
			}
		}
		else ife pchar 0
		{
			settspr[].tsprpal dukepal
			ifn player[].cursectnum -1
			ifg sector[player[].cursectnum].floorpal 0
			ifl sector[player[].cursectnum].floorpal 10
			settspr[].tsprpal sector[player[].cursectnum].floorpal
			
			ifvarand altcostume 8
			{
				gettspr[].tsprpicnum picnum
				add picnum 6084
				settspr[].tsprpicnum picnum
				gettspr[].tsprxrepeat x
				gettspr[].tspryrepeat y
				// default 42x 36x
				// shadow is 4y
				mul x 60
				div x 100
				mul y 62
				div y 100
				settspr[].tsprxrepeat x
				settspr[].tspryrepeat y
				
				ifp pducking
				{
					gettspr[].tsprz z
					sub z 2048
					settspr[].tsprz z
				}
			}
			else
			ifvarand altcostume 16
			{
				gettspr[].tsprpicnum picnum
				add picnum 7298
				settspr[].tsprpicnum picnum
				gettspr[].tsprxrepeat x
				gettspr[].tspryrepeat y
				// default 42x 36x
				// shadow is 4y
				mul x 60
				div x 100
				mul y 62
				div y 100
				settspr[].tsprxrepeat x
				settspr[].tspryrepeat y
				
				ifp pducking
				{
					gettspr[].tsprz z
					sub z 2048
					settspr[].tsprz z
				}
			}
		}
	}
break

case BOWLINGPIN // correct displayed angle
	gettspr[].tsprang angvar
	add angvar 512
	settspr[].tsprang angvar
break
case SHELLYDUMMY
	
	ife pchar 1
	{
		gettspr[].tsprxrepeat x
		gettspr[].tspryrepeat y
		// default 42x 36x
		// shadow is 4y
		mul x 68 // 72
		div x 100
		mul y 66 // 72
		div y 100 // 100
		settspr[].tsprxrepeat x
		settspr[].tspryrepeat y
		// sizeat 30 26
		
		ifvarand altcostume 32
		{
			gettspr[].tsprpicnum picnum
			add picnum 9984
			settspr[].tsprpicnum picnum
		}
		else
		ifvarand altcostume 4
		{
			gettspr[].tsprpicnum picnum
			add picnum 7018
			settspr[].tsprpicnum picnum
		}
		else
		ifvarand altcostume 1
		{
			gettspr[].tsprpicnum picnum
			add picnum 2304
			ife pdown YES add picnum 83
			settspr[].tsprpicnum picnum
		}
		ifp pducking
		{
			gettspr[].tsprz z
			sub z 2048
			settspr[].tsprz z
		}
	}
	else
	ife pchar 2
	{
		gettspr[].tsprpicnum picnum
		add picnum 12795
		settspr[].tsprpicnum picnum
		gettspr[].tsprxrepeat x
		gettspr[].tspryrepeat y
		// default 42x 36x
		// shadow is 4y
		mul x 53
		div x 100
		mul y 57
		div y 100
		settspr[].tsprxrepeat x
		settspr[].tspryrepeat y
		
		ifp pducking
		{
			gettspr[].tsprz z
			sub z 2048
			settspr[].tsprz z
		}
	}
	else
	ifvarand altcostume 8
	{
		gettspr[].tsprpicnum picnum
		add picnum 8484
		settspr[].tsprpicnum picnum
		gettspr[].tsprxrepeat x
		gettspr[].tspryrepeat y
		// default 42x 36x
		// shadow is 4y
		mul x 70
		div x 100
		mul y 68
		div y 100
		settspr[].tsprxrepeat x
		settspr[].tspryrepeat y
		
		ifp pducking
		{
			gettspr[].tsprz z
			sub z 2048
			settspr[].tsprz z
		}
	}
	else
	ifvarand altcostume 16
	{
		gettspr[].tsprpicnum picnum
		add picnum 9698
		settspr[].tsprpicnum picnum
		gettspr[].tsprxrepeat x
		gettspr[].tspryrepeat y
		// default 42x 36x
		// shadow is 4y
		mul x 70
		div x 100
		mul y 68
		div y 100
		settspr[].tsprxrepeat x
		settspr[].tspryrepeat y
		
		ifp pducking
		{
			gettspr[].tsprz z
			sub z 2048
			settspr[].tsprz z
		}
	}
	else
	ifvarand altcostume 2
	{
		gettspr[].tsprpicnum picnum
		add picnum 2400
		settspr[].tsprpicnum picnum
	}
	else
	{
		gettspr[].tsprpicnum picnum
		add picnum 784
		settspr[].tsprpicnum picnum
	}
	
break

case SHRINKSPARK
	gettspr[].tsprpicnum picnum
	add picnum 13860
	settspr[].tsprpicnum picnum
	gettspr[].tsprxrepeat x
	div x 2
	settspr[].tsprxrepeat x
	gettspr[].tspryrepeat y
	div y 2
	settspr[].tspryrepeat y
	
break

case SHOTGUNSPRITE
ifn rendmode 4 // voxel shade adjustment
{
	gettspr[].tsprshade shade
	ifg shade 12 set shade 12
	add shade 12
	settspr[].tsprshade shade
}

case GREENSLIME
case 2371 case 2372 case 2373 case 2374
case 2375 case 2376 case 2377
	gettspr[].tsprxrepeat x div x 2 add x 1
	settspr[].tsprxrepeat x
	gettspr[].tspryrepeat x div x 2 add x 1
	settspr[].tspryrepeat x
break

// case NEWSHOTGUNSHELL
// case NEWSHELL

	// geta[spriteid].ang angvar
	// getav[spriteid].lastang temp
	// add angvar temp
	// settspr[].tsprang angvar
	
// break
case ICESPRITE
	ifn rendmode 0
	{
		geta[spriteid].x x
		geta[spriteid].y y
		ifl camerax x add x -4
		else sub x -4
		ifl cameray y add y -4
		else sub y -4
		settspr[].tsprx x
		settspr[].tspry y
	}
break

case SPEEDBLUR
	getav[spriteid].mtype temp
	ife temp 0 { settspr[].tsprxrepeat 0 settspr[].tspryrepeat 0 al spriteid }
	else
	settspr[].tsprpicnum temp
break

case TRIPBOMBSPRITE
	settspr[].tsprpicnum TRIPBOMB
	gettspr[].tsprxrepeat x div x 4
	settspr[].tsprxrepeat x
	gettspr[].tspryrepeat y div y 4
	settspr[].tspryrepeat y
break

case LASERLINE2 settspr[].tsprshade -127 seta[].blend 1 break

case STALL
	ifn actorvar[spriteid].droptile 0
		settspr[].tsprpicnum actorvar[spriteid].droptile

break

case OUTLINE
	settspr[].tsprpicnum actorvar[spriteid].initsprite

break

case LASERHALO
	geta[spriteid].owner temp
	settspr[].tsprx sprite[temp].x
	settspr[].tspry sprite[temp].y
	settspr[].tsprz sprite[temp].z
break

case CHEERLEADER

	ifvarand sprite[spriteid].cstat 4
	{
		gettspr[].tsprcstat temp
		orvar temp 4
		settspr[].tsprcstat temp
	}
break

case EDFTROOP
case EDFTROOPCROUCH
	getav[spriteid].lastang temp
	settspr[].tsprang temp
break

case TEAMSPAWNER
	getav[spriteid].initsprite temp
	settspr[].tsprpicnum temp
break

// case LASERDOT // oh boy here we go

// ife dotsprite spriteid
// {
	// getp[].i B
	// geta[B].cstat safecount
	// seta[B].cstat 32768

	// ifg scandist 0
	// {
		// set x camerax
		// set y cameray

		// set angvar cameraang
		// set zdist camerahoriz
		// sub zdist 135 // 100

		// getp[].weapon_pos temp
		// abs temp
		// mul temp 3
		// sub zdist temp
		
		// set temp gun_pos
		// div temp -2
		// sub zdist temp
		
		// ifp pstanding nullop else
		// {
		// set temp weapon_xoffset
		// div temp 2
		// add angvar temp
		// }

		// mul zdist -2048
		// cos mycos angvar
		// sin mysin angvar
		
		// set z cameraz
		// sub z 1024
		// hitscan x y z camerasect mycos mysin zdist hitsector hitwall hitsprite hitx hity hitz CLIPMASK0
		
		
		// ife sprite[dotsprite].cstat 8322
		// {
			// set angvar cameraang
			// add angvar 1024
			// set x hitx
			// set tempb scandist
			// shiftr tempb 3
			// ifg tempb 128 set tempb 128
			// add x tempb
			
			// rotatepoint hitx hity x hity angvar x2 y2
			
			// set hitx x2
			// set hity y2
		// }
		// updatesectorz hitx hity hitz tempb
		// ifvarn tempb -1
		// {
			// getflorzofslope tempb hitx hity temp
			// sub temp 512
			// ifg hitz temp set hitz temp
		// }
		// settspr[].tsprx hitx
		// settspr[].tspry hity
		// settspr[].tsprz hitz
	// }
	// seta[B].cstat safecount
// }
// break

case SIDEGUN
	ife pal 4 settspr[].tsprcstat 34
break


case JIBS1
case JIBS2
case JIBS3
case JIBS4
case JIBS5
getav[spriteid].shrunken temp
ifg temp 20 ifl temp SHRUNKCOUNT
{
	gettspr[].tsprxrepeat x
	div x 4 ifl x MINXSTRETCH set x MINXSTRETCH
	settspr[].tsprxrepeat x
	gettspr[].tspryrepeat y
	div y 4 ifl y MINYSTRETCH set y MINYSTRETCH
	settspr[].tspryrepeat y
}
ife actorvar[spriteid].mtype YES 
{
	settspr[].tsprshade -100
	settspr[].tsprpicnum FIRELASER
}
break

case HEAVYHBOMB
	getav[spriteid].countvar temp
	geta[spriteid].ang angvar
	ifl temp 0 sub angvar 64
	else add angvar 64
	settspr[].tsprang angvar
	ife pchar 0 ifvarand dukeupgrades[HANDBOMB_WEAPON] 1
	{
		geta[spriteid].cstat tempb
		ifl temp 0 settspr[].tsprcstat 0 else
		settspr[].tsprcstat 4
		settspr[].tsprpicnum 13004
	}
	
break

case NEWBEAST
case NEWBEASTCROUCH
	gettspr[].tsprpal pal
	ife pal 0 settspr[].tsprpal 15
break

case MEGABRAIN
case BOSS2FLY
	gettspr[].tsprpal pal
	ifn pal 4
	ifn actorvar[spriteid].float -1
	{
	set temp player[].player_par
	shiftl temp 5
	add temp spriteid
	sin tempb temp
	shiftr tempb 4
	geta[spriteid].z z
	
	sub z tempb
	sub z 1024
	settspr[].tsprz z
	}
break

case SCUBATROOP
	gettspr[].tsprpal pal
	ifn pal 4
	ifn actorvar[spriteid].float -1
	{
	set temp player[].player_par
	shiftl temp 5
	add temp spriteid
	sin tempb temp
	shiftr tempb 4
	geta[spriteid].z z
	
	sub z tempb
	settspr[].tsprz z
	}
break

case SHELLY
case SHELLYCROUCH
	ifvarand altcostume 1
	{
		gettspr[].tsprpicnum picnum
		ife actorvar[spriteid].monstatus 2 
		ifg sprite[spriteid].extra 0
		add picnum 2387
		else
		add picnum 2304
		settspr[].tsprpicnum picnum
	}
	else
	ifvarand altcostume 4
	{
		gettspr[].tsprpicnum picnum
		add picnum 7018
		settspr[].tsprpicnum picnum
	}
	else
	ifvarand altcostume 32
	{
		gettspr[].tsprpicnum picnum
		add picnum 9984
		settspr[].tsprpicnum picnum
	}
	ife sprite[spriteid].pal 33
		settspr[].tsprpal 33
break

case DUKEBOT
case DUKEBOTCROUCH
	ifvarand altcostume 16 // new normal
	{
		gettspr[].tsprpicnum picnum
		ife actorvar[spriteid].monstatus 2 
		ifg sprite[spriteid].extra 0
		add picnum 1627
		else
		add picnum 1616
		
		// add picnum 8914
		add picnum 7298
		
		settspr[].tsprpicnum picnum
		
		gettspr[].tsprxrepeat x
		gettspr[].tspryrepeat y
		// default 42x 36x
		// shadow is 4y
		mul x 60 // 62
		div x 100
		mul y 62 // 66
		div y 100
		settspr[].tsprxrepeat x
		settspr[].tspryrepeat y
		
		
	}
	else
	ifvarand altcostume 8 // gladiator
	{
		gettspr[].tsprpicnum picnum
		ife actorvar[spriteid].monstatus 2 
		ifg sprite[spriteid].extra 0
		add picnum 1627
		else
		add picnum 1616
		
		add picnum 6084
		
		settspr[].tsprpicnum picnum
		
		gettspr[].tsprxrepeat x
		gettspr[].tspryrepeat y
		// default 42x 36x
		// shadow is 4y
		mul x 60 // 62
		div x 100
		mul y 62 // 66
		div y 100
		settspr[].tsprxrepeat x
		settspr[].tspryrepeat y
		
	}
	else
	ifvarand altcostume 2
	{
		gettspr[].tsprpicnum picnum
		ife actorvar[spriteid].monstatus 2 
		ifg sprite[spriteid].extra 0
		add picnum 1627
		else
		add picnum 1616
		settspr[].tsprpicnum picnum
	}
	ife sprite[spriteid].pal 33
		settspr[].tsprpal 33
break

case PIGSUV
	getav[spriteid].lastang temp
	settspr[].tsprang temp
break

case SUVWHEEL
	geta[spriteid].ang angvar
	add angvar 512
	settspr[].tsprang angvar
break

case ARMYANTCRAWL

	gettspr[].tsprsectnum mysector
	ifn mysector -1
	{
		ife tspr[].tsprpal 4
		{
			geta[spriteid].z z
			sub z 8192
			settspr[].tsprz z
			settspr[].tsprxrepeat 0
			settspr[].tspryrepeat 0
		}
	}

break

case MANDOFETT
	ifn actorvar[spriteid].countvarb 0
	{
		gettspr[].tsprpicnum picnum
		sub picnum 25
		settspr[].tsprpicnum picnum
	}

break
case MANDOCROUCH
	ifn actorvar[spriteid].countvarb 0
	{
		gettspr[].tsprpicnum picnum
		add picnum 51
		settspr[].tsprpicnum picnum
	}

break

case BATPROJ
	settspr[].tsprcstat 130
break

case BATBOSS
case BATBOSSSWOOPING
	gettspr[].tsprshade shade
	sub shade 10
	settspr[].tsprshade shade
break

case MONSHADOW
	set picnum actorvar[spriteid].mysignpost
	set temp player[].player_par
	modvar temp 21
	// rand temp 20
	add picnum temp
	seta[spriteid].htdispicnum picnum
	settspr[].tsprpicnum picnum // actorvar[spriteid].mysignpost
	ife player[].heat_on NO
		settspr[].tspryrepeat actorvar[spriteid].damflash
	settspr[].tsprpal 4
break

case THROWNOBJECT
	settspr[].tsprpicnum actorvar[spriteid].mtype
break

default
ifn actorvar[spriteid].upscaled YES
{
	getav[spriteid].shrunken temp
	ifg temp 20 ifl temp SHRUNKCOUNT
	{
		gettspr[].tsprxrepeat x
		div x 4 ifl x MINXSTRETCH set x MINXSTRETCH
		settspr[].tsprxrepeat x
		gettspr[].tspryrepeat y
		div y 4 ifl y MINYSTRETCH set y MINYSTRETCH
		settspr[].tspryrepeat y
	}
}
break

endswitch

endevent


appendevent EVENT_FIRE

ifvarn transition 0 { setvar RETURN -1 break }
ifvare PLAYERONTHEBIKE 1 { setvar RETURN -1 break }
ifn heldobject -1 { set RETURN -1 break }

ife player[].curr_weapon KNEE_WEAPON
{
	ifn gotsaber 0
	{
		ife saberpos 0
		// ife saberdash 0
		{
			randvar temp 4
			ife temp 0 { set saberpos 1 ife pchar 2 sound BLADESWING else sound SABSWING1 } else
			ife temp 1 { set saberpos 15 ife pchar 2 sound BLADESWING else sound SABSWING3 } else
			ife temp 2 { set saberpos 35 ife pchar 2 sound BLADESWING else sound SABSWING4 } else
			ife temp 3 { set saberpos 47 ife pchar 2 sound BLADESWING else sound SABSWING5 } else
			{ set saberpos 60 ife pchar 2 sound BLADESWING else sound SABSWING3 }
		}
	}
	else ife gotsaw NO ifn qk_proxy 0 { set RETURN -1 break }
}

ifvare player[].curr_weapon PISTOL_WEAPON 
{
	ifg LASERFIRE 0 { set RETURN -1 break }
	
	ifg LASERAMMO 0 
	ife LASERMODE YES
	{
		set LASERFIRE 1 
		set RETURN -1 
		break
	}
	
	ifg COMMAMMO 0
	ife LASERMODE 3
	{
		set LASERFIRE 1 
		set RETURN -1 
		break
	}
	
}

ife player[].curr_weapon SHOTGUN_WEAPON
{
	ife pchar 0 ifvarand gotDB 2
	{
		ifl dbammo 2 { set RETURN -1 break }
	} 
	else
	ifge pchar 1 ifle pchar 2 ifvarand gotbow 2
	{
		ifl arrows 1 { set RETURN -1 break }
	} 
	else
	ifl player[].ammo_amount SHOTGUN_WEAPON 2
	{
		set RETURN -1 break
	}
}

ifvarand gotshock 2
ife player[].curr_weapon CHAINGUN_WEAPON
set RETURN -1

endevent

appendevent EVENT_QUICKKICK

ifp ponground nullop else
ife jumpkick 0
// ifvarand bits 4194304
ifvarand extbits 1 
ifp palive 
ifn sector[].lotag 2
ife saberdash 0
ife qk_proxy 0
{
	set jumpkick 1
	setp[].quick_kick 0
	set RETURN -1
}

ifg jumpkick 0 { set RETURN -1 break }
ifn slidekick 0 { set RETURN -1 break }
ifg sidekick 0 { set RETURN -1 break }
ifl sidekick -3 { set RETURN -1 break }

// check for initiating SIDEKICK **NOT SLIDEKICK**

set temp NO

ifp palive ifp ponground
ife player[].knee_incs 0
ife qk_proxy 0
ife slidekick 0
ife sidekick 0
ife jumpkick 0
ife saberdash 0
ife pdown NO
ifl PLAYERONTHEBIKE 1
{
	ifvarand extbits 1 // pressing forward
	set temp YES
	else
	ifvarand extbits 2 // pressing backward
	set temp YES
	
	ifn player[].kickback_pic 0
	ife temp YES
	{
		switch player[].curr_weapon
		case KNEE_WEAPON ife WEAPON0_SHOOTS KNEE set temp NO break
		case PISTOL_WEAPON ifl player[].kickback_pic 3 set temp NO break
		case SHOTGUN_WEAPON ifl player[].kickback_pic 5 set temp NO break
		case CHAINGUN_WEAPON ifl player[].kickback_pic 4 set temp NO else setp[].kickback_pic 0 break
		case RPG_WEAPON ifl player[].kickback_pic 5 set temp NO break
		// case HANDBOMB_WEAPON ifl player[].kickback_pic 7 set temp NO break
		case SHRINKER_WEAPON ifl player[].kickback_pic 11 set temp NO break
		case DEVISTATOR_WEAPON ifl player[].kickback_pic 4 set temp NO break
		case TRIPBOMB_WEAPON set temp NO break
		case FREEZE_WEAPON ifl player[].kickback_pic 4 set temp NO break
		case GROW_WEAPON ifl player[].kickback_pic 4 set temp NO else setp[].kickback_pic 0 break
		endswitch
	}
	ife temp YES
	{
		ifvarand extbits 2 { set sidekick 100 getp[].ang kickang set initkickang kickang }
		else
		{
			ifrnd 160 set sidekick 1 else 
			set sidekick 51
		}
		set slidehit NO
		ife player[].curr_weapon KNEE_WEAPON
		ifg gotsaber 0 nullop else
		setp[].weapon_pos -8
		// setp[].weapon_pos -1
		set RETURN -1
		break
	}
}

set RETURN -1
ifg sprite[player[].i].extra 0
ife qk_proxy 0
set qk_proxy 15

/*
ife pchar 1
{
	switch player[].curr_weapon
	case SHRINKER_WEAPON
	case GROW_WEAPON
		set RETURN -1
		ife qk_proxy 0
		set qk_proxy 15
	break
	endswitch
}
ife pchar 0
// ifvarand altcostume 8
{
	set RETURN -1
	ife qk_proxy 0
	set qk_proxy 15
}
*/
endevent

gamevar BULLETSPREADX 46 0
// gamevar BULLETSPREADY 382 0
var VAR1 0 0
var VAR2 0 0

onevent EVENT_GETSHOTRANGE

rand ANGRANGE BULLETSPREADX
add ANGRANGE 2
set VAR1 ANGRANGE
mul VAR1 VAR1
set VAR2 BULLETSPREADX
mul VAR2 VAR2
sub VAR1 VAR2
mul VAR1 -64
sqrt VAR1 VAR2
set ZRANGE VAR2

// ifp pstanding { div ANGRANGE 2 div ZRANGE 2 } else
// ifp pwalking { div ANGRANGE 2 div ZRANGE 2 } else
// ifp pwalkingback { div ANGRANGE 2 div ZRANGE 2 }

ife player[].curr_weapon KNEE_WEAPON
{
	ife gotsaw YES
	ifg sawammo 0
	ifn pchar 2
	{
		mul ANGRANGE 2
		mul ZRANGE 2
	}
	else
	ifg gotsaber 0
	{
		set ANGRANGE 1
		set ZRANGE 1
	}
}

ife player[].curr_weapon PISTOL_WEAPON
ifn WEAPON1_SHOOTS SHOTSPARK1
{
	div ANGRANGE 2
	div ZRANGE 2
}

ife pchar 0
ife player[].curr_weapon SHOTGUN_WEAPON
ifvarand gotDB 2
{
	mul ANGRANGE 2
	mul ZRANGE 2
}

ife pchar 2
ife player[].curr_weapon GROW_WEAPON
{
	shiftr ANGRANGE 2
	shiftr ZRANGE 2
}

ife zoomin YES
{
	ife player[].curr_weapon CHAINGUN_WEAPON
	{
		shiftr ANGRANGE 1
		shiftr ZRANGE 1
	}
	ife player[].curr_weapon SHOTGUN_WEAPON
	{
		shiftr ANGRANGE 1
		shiftr ZRANGE 1
	}
}

endevent

onevent EVENT_GETAUTOAIMANGLE

	ifn zoomin NO set AUTOAIMANGLE 0 else
	set AUTOAIMANGLE 24

endevent


appendevent EVENT_CHEATGETJETPACK

	// set LASERAMMO 100
	// setp[].ammo_amount PISTOL_WEAPON LASERAMMO
	// set LASERMODE YES
	// ife pchar 0
	// set pistolammo MAXPISTOLAMMO
	// else
	// set pistolammo MAXDEAGLEAMMO
	
	ife gotsaber NO
	ifn pchar 2
	{
		set gotsaw YES
		set sawammo 300
		state sawon
	}
	
	set stakes 50
	setarray weap_owned[203] YES // Wes dual pistol
	setarray wesupgrades[PISTOL_WEAPON] 4
	setarray weap_owned[221] YES // Wes dual uzi
	setarray wesupgrades[CHAINGUN_WEAPON] 1
	set railgunammo MAXRAILAMOUNT
	ife gotrailgun 0 set gotrailgun 1
	ife gotplasma 0 set gotplasma 1
	set plasmammo MAXFREEZEAMMO
	set weap4ammo MAXRPGAMMO
	set cover_amount 1800
	set credits 99999
	set lastcredits 99999
	set arrows 60
	set dbammo 60
	set vendor_used 2
	ifn mynaamah -1 seta[mynaamah].extra player[].holoduke_amount

endevent

onevent EVENT_DOFIRE

ifvarand comboperk 1 ife pchar 0 set combotime -10
ifvarand comboperk 2 ife pchar 1 set combotime -10
ifvarand comboperk 4 ife pchar 2 set combotime -10

ife player[].curr_weapon PISTOL_WEAPON
{
	ifn LASERMODE YES
	{
		ife pchar 0 ifvarand dukeupgrades[PISTOL_WEAPON] 8 nullop else
		ife pchar 1 ifvarand shellyupgrades[PISTOL_WEAPON] 8 nullop else
		sound PISTOLFIRE3
		ife pchar 0 ifvarand dukeupgrades[PISTOL_WEAPON] 1 sound DPCHAINGUN
		sub THISCLIP 1
		ife pistolammo 1 set pistolammo 0
		ifvarand shellyupgrades[PISTOL_WEAPON] 8 nullop else
		ife pchar 1
		{
			getp[].ammo_amount PISTOL_WEAPON temp
			sub temp 1 ifl temp 1 set temp 1 
			setp[].ammo_amount PISTOL_WEAPON temp
		}
		ife player[].ammo_amount PISTOL_WEAPON 1
		ifg LASERAMMO 0
		{
			setp[].weapon_pos -1
			set LASERMODE -1
			set WEAPON1_SELECTSOUND SWITCHTOLASER 
		}
	}
}

ife player[].curr_weapon SHOTGUN_WEAPON
{
	set temp NO
	ife pchar 0 
	{
		ife shotexpduke YES set temp YES
		ifvarand gotDB 2 set temp YES
	}
	ife pchar 1 
	{
		ife shotexpshelly YES set temp YES
		ifvarand shellyupgrades[SHOTGUN_WEAPON] 4 // using bow
		ifvarand gotbow 2 set temp NO
	}
	ife pchar 2
	{
		ife stakefire YES
		{
			getp[].ammo_amount SHOTGUN_WEAPON B
			add B 1
			setp[].ammo_amount SHOTGUN_WEAPON B
		}
		else
		{
			ifvarand wesupgrades[SHOTGUN_WEAPON] 4 // using bow
			ifvarand gotbow 2 set temp NO
		}
	}
	ife temp YES
	{
		getp[].ammo_amount SHOTGUN_WEAPON temp
		
		ife pchar 0 ifvarand gotDB 2 
		{
			ife shotexpduke YES sub dbammo 2
			sub dbammo 2
			ifl dbammo 0 set dbammo 0
			add temp 1
			setp[].ammo_amount SHOTGUN_WEAPON temp
			break
		}
		sub temp 1
		ifl temp 1 set temp 1
		setp[].ammo_amount SHOTGUN_WEAPON temp
	}
	ifge pchar 1 ifle pchar 2
	// ifvarand shellyupgrades[SHOTGUN_WEAPON] 4 // using bow
	ifvarand gotbow 2
	{
		// 0 = regular uses 1 ammo
		// 1 = burning; 4 = freeze; 5 = spy; 6 = electric; 8 = nuclear use 2 ammo
		// 2 = explosive; 3 = multi; use 3 ammo
		// 7 = blood; 0 = regular use 1 ammo
		// getp[].ammo_amount SHOTGUN_WEAPON temp
		
		switch arrowtype
		case 1 case 4 case 5 case 6
		case 8
			sub arrows 2
		break
		case 2 case 3
			sub arrows 3
		break
		default
			ife pchar 2 sub arrows 2 else
			sub arrows 1
		break
		endswitch
		ifl arrows 0 set arrows 0
		
		getp[].ammo_amount SHOTGUN_WEAPON temp
		add temp 1
		setp[].ammo_amount SHOTGUN_WEAPON temp
	}
}

ife player[].curr_weapon RPG_WEAPON
ife pchar 2
ifn nukeselect YES
ife zoomin NO
{
	getp[].ammo_amount RPG_WEAPON temp
	sub temp 4, ifl temp 1 set temp 1
	setp[].ammo_amount RPG_WEAPON temp
}

ife player[].curr_weapon SHRINKER_WEAPON
{
	getp[].ammo_amount SHRINKER_WEAPON temp
	ife pchar 1 ifvarand shellyupgrades[SHRINKER_WEAPON] 1 
	{
		sub temp 4 
		ifvarand shellyupgrades[SHRINKER_WEAPON] 2 ife bmfgaltfire YES 
		{
			setprojectile[BMFGPROJ].pal 22
			setprojectile[BMFGPROJ].hitradius 0
		}
	}
	else
	ife pchar 0 ifvarand dukeupgrades[SHRINKER_WEAPON] 1 
	{
		sub temp 4
		ifvarand dukeupgrades[SHRINKER_WEAPON] 2 ife bmfgaltfire YES
		{
			setprojectile[BMFGPROJ].pal 22
			setprojectile[BMFGPROJ].hitradius 0
		}
	}
	ifl temp 1 set temp 1
	setp[].ammo_amount SHRINKER_WEAPON temp
	ife pchar 2
	ife WEAPON6_SHOOTS BLOODBULLET
	{
		eshoot BLOODBULLET
		getp[].ang angvar
		sub angvar 32
		seta[RETURN].ang angvar
		eshoot BLOODBULLET
		getp[].ang angvar
		add angvar 32
		seta[RETURN].ang angvar
		set RETURN 0
	}
}

ife player[].curr_weapon DEVISTATOR_WEAPON
{
	ifvarand gotrailgun 2 nullop else
	ife pchar 1
	{
		ifvarand shellyupgrades[DEVISTATOR_WEAPON] 1 
		{
			getp[].ammo_amount DEVISTATOR_WEAPON temp
			add temp 1 
			setp[].ammo_amount DEVISTATOR_WEAPON temp 
		}
		else
		{
			getp[].ammo_amount DEVISTATOR_WEAPON temp
			sub temp 1 ifl temp 1 set temp 1 
			setp[].ammo_amount DEVISTATOR_WEAPON temp
		}
	}
	else
	ife pchar 2
	{
		getp[].ammo_amount DEVISTATOR_WEAPON temp
		sub temp 1
		ifl temp 1 set temp 1 
		setp[].ammo_amount DEVISTATOR_WEAPON temp
	}
}

ife player[].curr_weapon GROW_WEAPON
ife WEAPON11_SHOOTS LOVEBOMB
{
	getp[].ammo_amount GROW_WEAPON temp
	sub temp 14
	ifl temp 0 set temp 0
	setp[].ammo_amount GROW_WEAPON temp
}

ifvarand gotshock 2 nullop else
ife player[].curr_weapon CHAINGUN_WEAPON
{
	ife pchar 2
	{
		sub uziclip 1
		ifvarand wesupgrades[CHAINGUN_WEAPON] 2 sound DPCHAINGUN
		ifvarand wesupgrades[CHAINGUN_WEAPON] 1
		{
			espawn SHELL
			set angvar sprite[RETURN].ang
			add angvar 1024
			seta[RETURN].ang angvar
			set xvel sprite[RETURN].xvel
			mul xvel -1
			seta[RETURN].xvel xvel
			set RETURN 0
		}
	}
	ife pchar 1 
	{
		sub m4clip 1
		ifvarand shellyupgrades[CHAINGUN_WEAPON] 1 sound M4FIRE
		ifvarand shellyupgrades[CHAINGUN_WEAPON] 2 sound DPCHAINGUN
	}
	ife pchar 0 
	{
		ifvarand dukeupgrades[CHAINGUN_WEAPON] 2 sound DPCHAINGUN
		ifvarand dukeupgrades[CHAINGUN_WEAPON] 1
		{
			set temp NO
			ife player[].kickback_pic 5 set temp YES
			ife player[].kickback_pic 9 set temp YES
			ife temp YES
			{
				getp[].ammo_amount CHAINGUN_WEAPON B
				add B 1
				setp[].ammo_amount CHAINGUN_WEAPON B
			}
		}
	}
	
}

ife pchar 2
{
	ife player[].curr_weapon GROW_WEAPON
	{
		ife WEAPON11_SHOOTS GRENADEPROJ // WESGRENADE
		{
			getp[].ammo_amount GROW_WEAPON B
			sub B 4, ifl B 1 set B 1
			setp[].ammo_amount GROW_WEAPON B
		}
		else
		sub skarclip 1
	}
	
	ife player[].curr_weapon SHRINKER_WEAPON
	{
		ife WEAPON6_SHOOTS BLOODBOMB
		{
			getp[].ammo_amount SHRINKER_WEAPON B
			sub B 7, ifl B 1 set B 1
			setp[].ammo_amount SHRINKER_WEAPON B
		}
		else
		sub skarclipB 1
	}
	
	ifvarand gotplasma 2 nullop else
	ife player[].curr_weapon FREEZE_WEAPON
	{
		getp[].ammo_amount FREEZE_WEAPON B
		sub B 1, ifl B 1 set B 1
		setp[].ammo_amount FREEZE_WEAPON B
	}
}

ifvarand gotplasma 2 nullop else
ife player[].curr_weapon FREEZE_WEAPON
ife pchar 2
{
	ifg sawspeed 26 setprojectile[BLADEPROJ].extra 60 else setprojectile[BLADEPROJ].extra 40
}



ifvarand gotbow 2 nullop else
ifn pchar 0
ife player[].curr_weapon SHOTGUN_WEAPON
{
	ifvarand shellyupgrades[SHOTGUN_WEAPON] 128
	sub spasclip 1
	else
	ifvarand wesupgrades[SHOTGUN_WEAPON] 128
	sub spasclip 1
}


endevent

defstate next_full_weapon

	set B RETURN
	add B 1
	whilevarvarn B RETURN
	{
		ife player[].gotweapon B YES ifg player[].ammo_amount B 0 set RETURN B
		else
		{
			add B 1
			ife B HANDREMOTE_WEAPON set B GROW_WEAPON
			else
			ife B 12 { set RETURN KNEE_WEAPON set B KNEE_WEAPON }
		}
	}

ends

defstate prev_full_weapon

	set B RETURN
	sub B 1
	ifl B PISTOL_WEAPON set B GROW_WEAPON
	whilevarvarn B RETURN
	{
		ife player[].gotweapon B YES ifg player[].ammo_amount B 0 set RETURN B
		else
		{
			sub B 1
			ife B HANDREMOTE_WEAPON set B FREEZE_WEAPON
			else
			ife B KNEE_WEAPON set RETURN KNEE_WEAPON
		}
	}

ends

onevent EVENT_PREVIOUSWEAPON

ife vendor_screen 7
{
	sub currentoption 1 ifl currentoption FIRSTOPTION set currentoption FIRSTOPTION
	ifl currentoption optionstart set optionstart currentoption
	break
}
		
ifl combotime 0
ifn player[].kickback_pic 0
{
	setp[].kickback_pic 0
	setp[].reloading 0
	set m4reload 0
	set uzireload 0
}

 // make sure that comm gun is selected before laser pistol or regular pistol when switching down
 // make sure that laser pistol is selected before regular pistol when moving down weapons
 ifn player[].curr_weapon PISTOL_WEAPON
 {
	ifg COMMAMMO 0
	{
		ifn LASERMODE 3
		{
			setp[].ammo_amount PISTOL_WEAPON COMMAMMO
			set LASERMODE 3
			set WEAPON1_SELECTSOUND SELECT7
		}
	}
	else
	ifg LASERAMMO 0
	{
		ifn LASERMODE YES
		{
			set LASERMODE YES
			setp[].ammo_amount PISTOL_WEAPON LASERAMMO
			set WEAPON1_SELECTSOUND SWITCHTOLASER
		}
	}
 }
 
 // make sure that bow is selected before shotgun when moving down weapons
 ifge pchar 1 ifle pchar 2
 {
	 ifvarand gotbow 2 nullop else
	 ifn player[].curr_weapon SHOTGUN_WEAPON
	 ifvarand gotbow 1
	 ifg arrows 0
	 {
		orvar gotbow 2
		ife pchar 2 state wesweapons else
		state shellyweapons
	 }
 }
 
  // make sure that DB shotty is selected before reg shotgun when moving down weapons
 ife pchar 0
 {
	 ifvarand gotDB 2 nullop else
	 ifn player[].curr_weapon SHOTGUN_WEAPON
	 ifvarand gotDB 1
	 ifg dbammo 0
	 {
		orvar gotDB 2	
		state dukeweapons
	 }
 }
 
  // make sure that shock is selected before chaingun when moving down weapons
 ifvarand gotshock 2 nullop else
 ifn player[].curr_weapon CHAINGUN_WEAPON
 {
	set temp NO
	ife pchar 0 ifvarand dukeupgrades[CHAINGUN_WEAPON] 8 set temp YES
	ife pchar 1 ifvarand shellyupgrades[CHAINGUN_WEAPON] 8 set temp YES
	ife pchar 2 ifvarand wesupgrades[CHAINGUN_WEAPON] 8 set temp YES
	ife temp YES
	{
		orvar gotshock 2	
		ife pchar 0 state dukeweapons else ife pchar 1 state shellyweapons
		else ife pchar 2 state wesweapons
	}
 }
 
 // make sure that railgun is selected before devastator when moving down weapons
 ifvarand gotrailgun 2 nullop else
 ifn player[].curr_weapon DEVISTATOR_WEAPON
 ifg railgunammo 0
 ifvarand gotrailgun 1
 {
	orvar gotrailgun 2	
	getp[].ammo_amount DEVISTATOR_WEAPON temp
	setp[].ammo_amount DEVISTATOR_WEAPON railgunammo
	set railgunammo temp
	state switchrailgun
 }
 
  // make sure that NUKE is selected before RPG when moving down weapons
 ife nukeselect YES nullop else
 ifn player[].curr_weapon RPG_WEAPON
 ifg nukeamount 0
 {
	set nukeselect YES
	getp[].ammo_amount RPG_WEAPON temp
	setp[].ammo_amount RPG_WEAPON nukeamount
	set weap4ammo temp
	state switchnuke
 }
 
 // make sure that plasma gun is selected before freezer/incinerator when moving down weapons
 ifvarand gotplasma 2 nullop else
 ifn player[].curr_weapon FREEZE_WEAPON
 ifg plasmammo 0
 ifvarand gotplasma 1
 {
	orvar gotplasma 2	
	getp[].ammo_amount FREEZE_WEAPON temp
	setp[].ammo_amount FREEZE_WEAPON plasmammo
	set plasmammo temp
	state switchplasma
 }
	
 set chwep 1

endevent

onevent EVENT_NEXTWEAPON

ife vendor_screen 7
{
	set B optionstart
	add B 7
	ifl currentoption LASTOPTION
	{
		add currentoption 1 ifg currentoption B ifl B LASTOPTION add optionstart 1
	}
	break
}

ifl combotime 0
ifn player[].kickback_pic 0
{
	setp[].kickback_pic 0
	setp[].reloading 0
	set m4reload 0
	set uzireload 0
}
 
 ife player[].curr_weapon KNEE_WEAPON
 ife player[].gotweapon PISTOL_WEAPON YES
 ife player[].ammo_amount PISTOL_WEAPON 0
 ifg LASERAMMO 0
 {
	set LASERMODE -1
	set RETURN PISTOL_WEAPON
	set WEAPON1_SELECTSOUND SWITCHTOLASER
 }
 // make sure that regular pistol is selected before laser pistol when moving up weapons
 ifn LASERMODE 0
 ifn player[].curr_weapon PISTOL_WEAPON
 ife player[].gotweapon PISTOL_WEAPON YES
 ifg player[].ammo_amount PISTOL_WEAPON 0
 {
	set LASERMODE NO
	ife pchar 0
	{
		ifvarand dukeupgrades[PISTOL_WEAPON] 8 set WEAPON1_SELECTSOUND GLOCKMAGIN else
		set WEAPON1_SELECTSOUND INSERT_CLIP
	}
	ife pchar 2 set WEAPON1_SELECTSOUND GLOCKMAGIN
	else set WEAPON1_SELECTSOUND DEAGLE_SLIDE
	setp[].ammo_amount PISTOL_WEAPON pistolammo
 }
 
 // make sure that chaingun is selected before shock when moving up weapons
 ifvarand gotshock 2
 ifn player[].curr_weapon CHAINGUN_WEAPON
 {
    set temp NO
	ife pchar 0 ifvarand dukeupgrades[CHAINGUN_WEAPON] 8 set temp YES
	ife pchar 1 ifvarand shellyupgrades[CHAINGUN_WEAPON] 8 set temp YES
	ife temp YES
	{
		xorvar gotshock 2	
		getp[].ammo_amount CHAINGUN_WEAPON temp
		ife pchar 0 state dukeweapons else ife pchar 1 state shellyweapons
		else ife pchar 2 state wesweapons
	}
 }
 
  // make sure that RPG is selected before NUKE when moving up weapons
 ife nukeselect YES
 ifn player[].curr_weapon RPG_WEAPON
 ifg weap4ammo 0
 {
    set nukeselect NO
	setp[].ammo_amount RPG_WEAPON weap4ammo
	state switchnuke
 }

 // make sure that devastator is selected before railgun when moving up weapons
 ifvarand gotrailgun 2
 ifn player[].curr_weapon DEVISTATOR_WEAPON
 ifg railgunammo 0
 {
    xorvar gotrailgun 2	
	getp[].ammo_amount DEVISTATOR_WEAPON temp
	setp[].ammo_amount DEVISTATOR_WEAPON railgunammo
	set railgunammo temp
	state switchrailgun
 }
 
  // make sure that freezer/incinerator is selected before plasma when moving up weapons
 ifvarand gotplasma 2
 ifn player[].curr_weapon FREEZE_WEAPON
 ifg plasmammo 0
 {
    xorvar gotplasma 2	
	getp[].ammo_amount FREEZE_WEAPON temp
	setp[].ammo_amount FREEZE_WEAPON plasmammo
	set plasmammo temp
	state switchplasma
 }
 
 // make sure that shotgun is selected before bow when moving up weapons
 ifge pchar 1 ifle pchar 2
 {
	 ifvarand gotbow 2
	 ifn player[].curr_weapon SHOTGUN_WEAPON
	 {
		xorvar gotbow 2	
		ife pchar 2 state wesweapons else
		state shellyweapons
	 }
 }
 
  // make sure that shotgun is selected before DB shotty when moving up weapons
 ife pchar 0
 {
	 ifvarand gotDB 2
	 ifn player[].curr_weapon SHOTGUN_WEAPON
	 {
		xorvar gotDB 2	
		state dukeweapons
	 }
 }

 set chwep 2

endevent

state find_gun_name
	switch RETURN
	case 0 ifn pchar 2 ife gotsaw YES ifg sawammo 0 set gun_name SAWSPRITE else 
		   ifg gotsaber 0 set gun_name SABERSPRITE else
		   set gun_name KNEE break
	case 1 ife LASERMODE 2 set gun_name FIRSTGUNSPRITE else ifn LASERMODE NO set gun_name LASERPISTOL else set gun_name FIRSTGUNSPRITE break
	
	case 2 set gun_name SHOTGUNSPRITE break
	case 3 set gun_name CHAINGUNSPRITE break
	case 4 
		// ifg nukeamount 0 set gun_name NUKESPRITE else
		set gun_name RPGSPRITE break
	case 5 set gun_name HEAVYHBOMB break
	case 6 set gun_name SHRINKERSPRITE break
	case 7 
		ifvarand gotrailgun 8 set gun_name DEVISTATORSPRITE else
		ifvarand gotrailgun 4 set gun_name RAILGUNSPRITE else
		ifvarand gotrailgun 2 set gun_name RAILGUNSPRITE else
		set gun_name DEVISTATORSPRITE
	break
	case 8 set gun_name TRIPBOMBSPRITE break
	case 9  
		ifvarand gotplasma 8 set gun_name FREEZESPRITE else
		ifvarand gotplasma 4 set gun_name PLASMASPRITE else
		ifvarand gotplasma 2 set gun_name PLASMASPRITE else
		set gun_name FREEZESPRITE
	break
	case 11 set gun_name GROWSPRITEICON break
	endswitch
	ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
	
	ife pchar 0 state dukeweapons else
	ife pchar 1 state shellyweapons else
	ife pchar 2 state wesweapons
	
ends

onevent EVENT_SELECTWEAPON
	
	set idleanim 0
	setp[].crack_time 0
	set B NO
	ifn pchar 2
	ife gotsaw YES ifg sawammo 0 set B YES
	ifg gotsaber 0 set B YES

	ife B YES
	ifn RETURN 0
	ifn chwep 0
	ife player[].curr_weapon RETURN
	{
		set TMP_A NO
		ifvarand gotbow 2 nullop else
		ife chwep 2
		ifge pchar 1 ifvarand gotbow 1 ifg arrows 0 set TMP_A YES
		
		ifvarand gotbow 2
		ife chwep 1
		ifge pchar 1 ifg player[].ammo_amount SHOTGUN_WEAPON 1 set TMP_A YES
		
		ifvarand gotDB 2 nullop else
		ife chwep 2
		ife pchar 0 ifvarand gotDB 1 ifg dbammo 0 set TMP_A YES
		
		ifvarand gotDB 2
		ife chwep 1
		ife pchar 0 ifg player[].ammo_amount SHOTGUN_WEAPON 1 set TMP_A YES
		
		
		ife RETURN PISTOL_WEAPON ife chwep 2 ifg LASERAMMO 0
		ife LASERMODE NO nullop else
		ife RETURN PISTOL_WEAPON ife chwep 1 ifg pistolammo 0
		ife LASERMODE YES nullop else
		ife RETURN SHOTGUN_WEAPON ife player[].curr_weapon SHOTGUN_WEAPON
		ife TMP_A YES nullop else
		{
			set RETURN 0
			set chwep 0
			ifg gotsaber 0 set gun_name SABERSPRITE else
			set gun_name SAWSPRITE
			ife gun_nametime 0 set gun_nametime 70 else set gun_nametime 50
			break
		}
	}
	ife chwep 1 // previous weapon
	{
		ife B YES
		ifg RETURN player[].curr_weapon
		ifn player[].curr_weapon KNEE_WEAPON
		{
			ife RETURN GROW_WEAPON
			{
				ifl player[].curr_weapon DEVISTATOR_WEAPON 
				set RETURN KNEE_WEAPON
			}
			else
			   ifn player[].curr_weapon KNEE_WEAPON
			   set RETURN KNEE_WEAPON	
		}
		
		ife pchar 0
		{
			ifvarand gotDB 2	
			ife player[].curr_weapon SHOTGUN_WEAPON
			ifg player[].weapon_pos -1
			ifg player[].ammo_amount SHOTGUN_WEAPON 1
			{
				orvar gotDB 8 // switching to shotgun
				setp[].weapon_pos -1
				set RETURN SHOTGUN_WEAPON
			}
		}
		
		ifge pchar 1 ifle pchar 2
		{
			ifvarand gotbow 2	
			ife player[].curr_weapon SHOTGUN_WEAPON
			ifg player[].weapon_pos -1
			ifg player[].ammo_amount SHOTGUN_WEAPON 1
			{
				orvar gotbow 8 // switching to shotgun
				setp[].weapon_pos -1
				set RETURN SHOTGUN_WEAPON
			}
		}
		
		ifvarand gotbow 4 nullop else
		ifvarand gotDB 4 nullop else
		ifn player[].curr_weapon SHOTGUN_WEAPON
		ife RETURN SHOTGUN_WEAPON
		ife player[].ammo_amount SHOTGUN_WEAPON 1
		{
			set temp YES
			ife pchar 0 ifvarand gotDB 1 ifg dbammo 0 set temp NO
			ifge pchar 1 ifle pchar 2 ifvarand gotbow 1 ifg arrows 0 set temp NO
			ife temp YES
			state prev_full_weapon
		}
		
		ife player[].curr_weapon RPG_WEAPON
		ife nukeselect YES
		ifg player[].weapon_pos -1
		ifg weap4ammo 0
		{
			set nukeselect -2
			setp[].weapon_pos -1
			set RETURN RPG_WEAPON
		}
		
		ifvarand gotshock 2	
		ife player[].curr_weapon CHAINGUN_WEAPON
		ifg player[].weapon_pos -1
		{
			orvar gotshock 8 // switching to CHAINGUN
			setp[].weapon_pos -1
			set RETURN CHAINGUN_WEAPON
		}
		
		ifvarand gotrailgun 2	
		ife player[].curr_weapon DEVISTATOR_WEAPON
		ifg railgunammo 0
		ifg player[].weapon_pos -1
		{
			orvar gotrailgun 8 // switching to regular devastator
			setp[].weapon_pos -1
			set RETURN DEVISTATOR_WEAPON
		}
		
		ifvarand gotplasma 2	
		ife player[].curr_weapon FREEZE_WEAPON
		ifg plasmammo 0
		ifg player[].weapon_pos -1
		{
			orvar gotplasma 8 // switching to regular freezer/incinerator
			setp[].weapon_pos -1
			set RETURN FREEZE_WEAPON
		}
		
		ife player[].curr_weapon PISTOL_WEAPON
		ifg pistolammo 0
		ifg player[].weapon_pos -1
		{
			ife LASERMODE 3 // comm gun
			{
				ifg LASERAMMO 0
				set LASERMODE -3
				else set LASERMODE 4
				setp[].weapon_pos -1
				set RETURN PISTOL_WEAPON
			}
			else
			ife LASERMODE YES
			{
				set LASERMODE 2
				setp[].weapon_pos -1
				// set WEAPON1_SELECTSOUND INSERT_CLIP
				set RETURN PISTOL_WEAPON
			}
			
			ife LASERMODE NO
			ife RETURN PISTOL_WEAPON
			{
				ifg COMMAMMO 0
				{
					set LASERMODE -2
					setp[].weapon_pos -1
					set WEAPON1_SELECTSOUND SELECT7 
					set RETURN PISTOL_WEAPON
				}
				else
				ifg LASERAMMO 0
				{
					set LASERMODE -1
					setp[].weapon_pos -1
					set WEAPON1_SELECTSOUND SWITCHTOLASER 
					set RETURN PISTOL_WEAPON
				}
			}
		}
	}
	else
	ife chwep 2 // next weapon
	{
		ife B YES
		ifl RETURN player[].curr_weapon
		{
			ife player[].curr_weapon GROW_WEAPON
			{
				ife player[].gotweapon DEVISTATOR_WEAPON YES
					ifg player[].ammo_amount DEVISTATOR_WEAPON 0
				{ set chwep 0 state find_gun_name break }
				
				ife player[].gotweapon TRIPBOMB_WEAPON YES
					ifg player[].ammo_amount TRIPBOMB_WEAPON 0
				{ set chwep 0 state find_gun_name break }
				
				ife player[].gotweapon FREEZE_WEAPON YES
					ifg player[].ammo_amount FREEZE_WEAPON 0
				{ set chwep 0 state find_gun_name break }
				
				set RETURN KNEE_WEAPON
			}
			else
			set RETURN KNEE_WEAPON
		}
		
		ife player[].curr_weapon PISTOL_WEAPON
		ifg player[].weapon_pos -1
		{
			ifg LASERAMMO 0
			{
				ife LASERMODE NO
				{
					set LASERMODE -1
					setp[].weapon_pos -1
					set WEAPON1_SELECTSOUND SWITCHTOLASER 
					set RETURN PISTOL_WEAPON
				}
				else
				ife LASERMODE YES
				{
					ifg COMMAMMO 0
					{
						set LASERMODE -4
						setp[].weapon_pos -1
						set WEAPON1_SELECTSOUND SELECT7 
						set RETURN PISTOL_WEAPON
					}
					else
					ife RETURN PISTOL_WEAPON
					ifg pistolammo 0
					{
						set LASERMODE 2
						setp[].weapon_pos -1
						set RETURN PISTOL_WEAPON
					}
				}
				else
				ife LASERMODE 3
				{
					ife RETURN PISTOL_WEAPON
					ifg pistolammo 0
					{
						set LASERMODE 2
						setp[].weapon_pos -1
						set RETURN PISTOL_WEAPON
					}
				}
			}
			else
			{
				ifg COMMAMMO 0
				{
					ife LASERMODE NO
					{
						set LASERMODE -2
						setp[].weapon_pos -1
						set WEAPON1_SELECTSOUND SELECT7 
						set RETURN PISTOL_WEAPON
					}
					else
					ife LASERMODE 3
					ife RETURN PISTOL_WEAPON
					ifg pistolammo 0
					{
						set LASERMODE 2
						setp[].weapon_pos -1
						set RETURN PISTOL_WEAPON
					}
				}
			}
		}
		
		ife pchar 0
		{	
			ife RETURN SHOTGUN_WEAPON
			ifn player[].curr_weapon SHOTGUN_WEAPON
			ifvarand gotDB 1
			ife player[].ammo_amount SHOTGUN_WEAPON 1
			ifg dbammo 0
			{
				orvar gotDB 2
				state dukeweapons
			}
			
			ifvarand gotDB 2 nullop else
			ife player[].curr_weapon SHOTGUN_WEAPON
			ifvarand gotDB 1
			ifg player[].weapon_pos -1
			ifg dbammo 0
			{
				orvar gotDB 4 // DB shotty
				setp[].weapon_pos -1
				set RETURN SHOTGUN_WEAPON
			}
		}
		
		ifge pchar 1 ifle pchar 2
		{
			ife RETURN SHOTGUN_WEAPON
			ife player[].ammo_amount SHOTGUN_WEAPON 1
			ifn player[].curr_weapon SHOTGUN_WEAPON
			{
				ifvarand gotbow 1
				ifg arrows 0 
				{
					orvar gotbow 2
					ife pchar 2 state wesweapons else
					state shellyweapons
				}
				else state next_full_weapon
			}
			
			ifvarand gotbow 2 nullop else
			ife player[].curr_weapon SHOTGUN_WEAPON
			ifvarand gotbow 1
			ifg player[].weapon_pos -1
			ifg arrows 0
			{
				orvar gotbow 4 // bow
				setp[].weapon_pos -1
				set RETURN SHOTGUN_WEAPON
			}
		}
		
		ifvarand gotbow 4 nullop else
		ifvarand gotDB 4 nullop else
		ifn player[].curr_weapon SHOTGUN_WEAPON
		ife RETURN SHOTGUN_WEAPON
		ife player[].ammo_amount SHOTGUN_WEAPON 1
		{
			set temp YES
			ife pchar 0 ifvarand gotDB 1 ifg dbammo 0 set temp NO
			ifge pchar 1 ifle pchar 2 ifvarand gotbow 1 ifg arrows 0 set temp NO
			ife temp YES
			state next_full_weapon
		}
		
		ifvarand gotshock 2 nullop else
		ife player[].curr_weapon CHAINGUN_WEAPON
		ifvarand gotshock 1
		{
			set temp NO
			ife pchar 0 ifvarand dukeupgrades[CHAINGUN_WEAPON] 8 set temp YES
			ife pchar 1 ifvarand shellyupgrades[CHAINGUN_WEAPON] 8 set temp YES
			ife pchar 2 ifvarand wesupgrades[CHAINGUN_WEAPON] 8 set temp YES
			ife temp YES
			ifg player[].weapon_pos -1
			{
				orvar gotshock 4 // switching to shock
				setp[].weapon_pos -1
				set RETURN CHAINGUN_WEAPON
			}
		}
		
		ifg nukeamount 0
		ife player[].curr_weapon RPG_WEAPON
		ife nukeselect NO
		ifg player[].weapon_pos -1
		{
			set nukeselect -1
			setp[].weapon_pos -1
			set RETURN RPG_WEAPON
		}
		
		ifvarand gotrailgun 2 nullop else
		ife player[].curr_weapon DEVISTATOR_WEAPON
		ifg railgunammo 0
		ifvarand gotrailgun 1
		ifg player[].weapon_pos -1
		{
			orvar gotrailgun 4 // switching to railgun
			setp[].weapon_pos -1
			set RETURN DEVISTATOR_WEAPON
		}
		
		ifvarand gotplasma 2 nullop else
		ife player[].curr_weapon FREEZE_WEAPON
		ifg plasmammo 0
		ifvarand gotplasma 1
		ifg player[].weapon_pos -1
		{
			orvar gotplasma 4 // plasma rifle
			setp[].weapon_pos -1
			set RETURN FREEZE_WEAPON
		}
	}
	set chwep 0
	
	state find_gun_name
	
	
endevent

onevent EVENT_INVENTORY

ife player[].inven_icon 8
ifg cover_amount 0
{
	ife player[].cursectnum -1 quote 1147 else
	{
		screensound TELEPORTER
		set x2 player[].posx
		add x2 1024
		set savz player[].posz
		add savz 4096
		rotatepoint player[].posx player[].posy x2 player[].posy player[].ang savx savy
		set temp player[].cursectnum
		updatesectorz savx savy savz temp 
		ife temp -1 
		{
			set x2 player[].posx
			add x2 512
			rotatepoint player[].posx player[].posy x2 player[].posy player[].ang savx savy
			set temp player[].cursectnum
			updatesectorz savx savy savz temp 
			ife temp -1 
			quote 1147 
			else
			{
				sub cover_amount 300
				ifl cover_amount 0 set cover_amount 0
				espawn COVERBLOCK
				setsprite RETURN savx savy savz
			}
		}
		else
		{
			sub cover_amount 300
			ifl cover_amount 0 set cover_amount 0
			espawn COVERBLOCK
			setsprite RETURN savx savy sprite[player[].i].z
		}
	}
}

endevent

defstate inven_checkamount

	switch temp
	case 1 ifg player[].firstaid_amount 0 { set TMP_A 1 set RETURN 1 } break
	case 2 ifg player[].steroids_amount 0 { set TMP_A 1 set RETURN 2 } break
	case 3 ifg player[].holoduke_amount 0 { set TMP_A 1 set RETURN 3 } break
	case 4 ifg player[].jetpack_amount 0 { set TMP_A 1 set RETURN 4 } break
	case 5 ifg player[].heat_amount 0 { set TMP_A 1 set RETURN 5 } break
	case 6 ifg player[].scuba_amount 0 { set TMP_A 1 set RETURN 6 } break
	case 7 ifg player[].boot_amount 0 { set TMP_A 1 set RETURN 7 } break
	case 8 ifg cover_amount 0 { set TMP_A 1 set RETURN 8 } break
	endswitch

ends

onevent EVENT_INVENTORYLEFT

getp[].inven_icon temp
set TMP_A 0
set TMP_B 0
whilevarn TMP_A 1
{
	sub temp 1
	ife temp 0 set temp 8
	add TMP_B 1
	state inven_checkamount
	
	ifge TMP_B 9 { set TMP_A 1 setp[].inven_icon 0 }
}
endevent

onevent EVENT_INVENTORYRIGHT

getp[].inven_icon temp
set TMP_A 0
set TMP_B 0
whilevarn TMP_A 1
{
	add temp 1
	ife temp 9 set temp 1
	add TMP_B 1
	state inven_checkamount
	
	ifge TMP_B 9 { set TMP_A 1 setp[].inven_icon 0 }
}

endevent

state chairbrokecode
fall
ifhitweapon ifdead
{
	sound VENT_BUST
	ifactor CHAIRBROKE6
	{
	debris SCRAP3 4
	debris SCRAP4 4
	debris SCRAP5 4
	}
	else
	{
	debris SCRAP1 4
	debris SCRAP2 4
	debris SCRAP3 4
	debris SCRAP4 4
	}
	spawn BIGSMOKE
	killit
}
ends

eventloadactor LIGHTNING2
cstat 32768
enda

defstate start_strike

	set countvar -8
	cstat 2
	ifrnd 128 cstator 4
	rand temp 3
	ife temp 0
	{
		sound LIGHTN_1 sound LIGHTN_1 sound LIGHTN_1 sound LIGHTN_1 sound LIGHTN_1
	}
	else
	ife temp 1
	{
		sound LIGHTN_2 sound LIGHTN_2 sound LIGHTN_2 sound LIGHTN_2 sound LIGHTN_2
	}
	else
	ife temp 2
	{
		sound LIGHTN_3 sound LIGHTN_3 sound LIGHTN_3 sound LIGHTN_3 sound LIGHTN_3
	}
	else
	ife temp 3
	{
		sound LIGHTN_4 sound LIGHTN_4 sound LIGHTN_4 sound LIGHTN_4 sound LIGHTN_4
	}
	set x startx
	rand x2 1024
	sub x2 512
	add x x2
	seta[].x x
	seta[].htbposx x
	
	set y starty
	rand y2 1024
	sub y2 512
	add y y2
	seta[].y y
	seta[].htbposy y

ends

useractor notenemy LIGHTNING2

ifmove 0
{
	move STOPPED
	geta[].x startx
	geta[].y starty
	seta[].blend 1
	seta[].shade -127
	rand countvar 360
	add countvar 30
	seta[].alpha 128
	ifl sprite[].yrepeat 32 sizeat 72 255
	ife countvarb YES state start_strike
}

ifg countvar 0 sub countvar 1
else
ifl countvar 0
{
	add countvar 1
	
	set x startx
	rand x2 512
	sub x2 256
	add x x2
	seta[].x x
	seta[].htbposx x
	
	set y starty
	rand y2 512
	sub y2 256
	add y y2
	seta[].y y
	seta[].htbposy y

	spawn SMALLSMOKE
	flash
	
	ifpdistl 1024
	ifp palive
	{
		set spriteid player[].i
		rand temp 3
		add temp 1
		add temp sprite[spriteid].htextra
		seta[spriteid].htextra temp
		seta[spriteid].htowner THISACTOR
		seta[spriteid].htpicnum FIRELASER
		state playerpainsounds
	}
	
	ife countvar 0 
	{
		cstat 32768
		seta[].x startx
		seta[].y starty
		rand countvar 360
		add countvar 180
		sound THUNDER sound THUNDER sound THUNDER sound THUNDER sound THUNDER
		
		ife countvarb YES killit
	}
}

ifrnd 4
ife countvar 0
{
	state start_strike
}

enda

useractor notenemy CHAIRBROKE1 60 state chairbrokecode enda
useractor notenemy CHAIRBROKE4 60 state chairbrokecode enda
useractor notenemy CHAIRBROKE5 60 state chairbrokecode enda
useractor notenemy CHAIRBROKE6 60 state chairbrokecode enda
useractor notenemy GAMERCHAIRBROKE 60 state chairbrokecode enda

move CHAIRROLLVEL

defstate chaircode

fall
ifmove 0
{
	move STOPPED geth
	sizeat 30 28
	cstator 257
	ifactor SHOPPINGCART clipdist 64 else
	clipdist 40
	geta[].htflags temp, orvar temp 8192, seta[].htflags temp
}

ife heldobject THISACTOR break

state predamage
state damagepush
state playerpush

ifmove STOPPED
ifg dodgetime 0
{
	ifn sprite[].picnum CHAIR6 move CHAIRROLLVEL geth
	geta[].ang angvel
	set countvar 90
}

ifmove CHAIRROLLVEL
{
	cos xvel angvel
	sin yvel angvel
	setvarvar temp countvar
	
	mulvarvar xvel temp
	mulvarvar yvel temp
	shiftvarr xvel 13
	shiftvarr yvel 13
	sub countvar 1, ifl countvar 0 set countvar 0
	movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN 
	
	ifn RETURN 0 
	{	
		set countvar 0
		move STOPPED geth
	}
	ife countvar 0
	{
		set countvar 0
		move STOPPED geth
	}
}
else ifpdistl 768
ife dodgetime 0
ifn sprite[].picnum CHAIR6
ifcansee
{
	move CHAIRROLLVEL geth
	seta[].ang angvel
	set countvar 60
}
	
ifhitweapon
{
	ifdead
	{
		spawn BIGSMOKE
		ifwasweapon RPG nullop else
		ifactor CHAIR1_AA
		{
			debris SCRAP1 5
			cactor CHAIRBROKE1
			move 0
			action 0
			strength 60
			break
		}
		ifactor CHAIR4
		{
			debris SCRAP1 5
			cactor CHAIRBROKE4
			move 0
			action 0
			strength 60
			break
		}
		ifactor CHAIR5
		{
			debris SCRAP1 5
			cactor CHAIRBROKE5
			move 0
			action 0
			strength 60
			break
		}
		ifactor CHAIR6
		{
			debris SCRAP4 5
			cactor CHAIRBROKE6
			move 0
			action 0
			strength 60
			break
		}
		ifactor GAMERCHAIR
		{
			debris SCRAP1 5
			cactor GAMERCHAIRBROKE
			move 0
			action 0
			strength 60
			break
		}
		ifspritepal 0 spritepal 16
		sound VENT_BUST
		debris SCRAP1 5
		debris SCRAP2 5
		debris SCRAP3 5
		debris SCRAP4 5
		
		killit
	}
}

ends

state spawngroundjib
	
	seta[].htflags 128
	ifactor LIZMANHEAD1
		ifspawnedby LIZRANGER
	{
		spawn LIZRANGERHEAD
		seta[RETURN].pal sprite[].pal
	}
	else
	{
		geta[].picnum picnum
		add picnum 2
		espawnvar picnum
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		seta[RETURN].pal sprite[].pal
		setav[RETURN].initsprite 1
	}
ends

defstate projectilehitscan
	
	// ifactor FIRELASER  // hitscan fails
	// {
		// ifn shellyinmap 0
		// {
			// findnearactorz SHELLY 4096 16384 target
			// ife target -1 findnearactorz SHELLYCROUCH 4096 16384 target
			// ife target -1 findnearactorz DUKEBOT 4096 16384 target
			// ife target -1 findnearactorz DUKEBOTCROUCH 4096 16384 target
			// ife target -1 findnearactorz WESBOT  4096 16384 target
			// ife target -1 findnearactorz WESBOTCROUCH  4096 16384 target
			// ife target -1 findnearactorz NAAMAH 4096 16384 target
			// ifn target -1
			// ife actorvar[target].dodgetime 0
			// {
				// geta[].owner spriteid
				// geta[].x x
				// geta[].y y
				// sub x sprite[spriteid].x
				// sub y sprite[spriteid].y
				// getangle angvar x y
				// // projectile angle
				
				// geta[target].x x
				// geta[target].y y
				// sub x sprite[].x
				// sub y sprite[].y
				// getangle temp x y
				// // angle needed to face shelly
				
				// getincangle tempb angvar temp
				// ifg tempb -32 ifl tempb 32
					// setav[target].myspawner THISACTOR
				
			// }
		// }
		// break
	// }

	geta[].ang angvar
	geta[].zvel z
	geta[].xvel x
	shiftl z 14
	ife x 0 setvar x 1
	div z x
	cos mycos angvar
	sin mysin angvar
	hitscan sprite[].x sprite[].y sprite[].z sprite[].sectnum mycos mysin z mysector temp target x2 y2 zdist 4294901809
	
	ifg sprite[].extra 30
	ifg temp -1 // strong projectile hitting a wall
	{
		switch wall[temp].overpicnum
		case GLASS
		case STAINGLASS1
		case 511
			shoot ROCKETBULLET
		break
		endswitch
	}
	else
	ifactor RPG ife target -1 ifg sprite[].zvel 0
	{
		hitscan sprite[].x sprite[].y sprite[].z sprite[].sectnum mycos mysin 0 mysector temp target x2 y2 zdist 4294901809
	}
	
	ifn target -1
	ifn sprite[].owner target
	{
		ife actorvar[target].dodgetime 0
		{
			ifvarand actorvar[target].monstflags YES
			{
				dist xydist THISACTOR target
				ifl xydist 5120
				setav[target].myspawner THISACTOR
			}
			else
			{
				switch sprite[target].picnum
				
				case SPACEBULL
				case NEWPIG
				case LIZMAN
				case NEWBATLORD
				case LIZDOG
				case ARMYANT
				case ARMYANTCRAWL
				case CRAZYLADY
				case BATBOSS
				case CHEERBOT
				case COMMANDER
				case NEWCOMM
				case CYBERBEAST
					dist xydist THISACTOR target
					ifactor HEAVYHBOMB { sub xydist 2560 ifl xydist 2560 set xydist 2560 }
					ifl xydist 8192 ifge xydist 2560
					setav[target].myspawner THISACTOR
					set starty zdist
				break
				case NEWTROOP
				case NEWTROOPDUCKING
				case TERMINATOR
					ifge SKILL 5 
					ife actorvar[target].myspawner -1
					{
						dist xydist THISACTOR target
						ifactor HEAVYHBOMB { sub xydist 2560 ifl xydist 2560 set xydist 2560 }
						ifl xydist 8192 ifge xydist 2560
						setav[target].myspawner THISACTOR
						set starty zdist
					}
				case NEWTROOPGUARD
				case SPACEBULLGUARD
				case NEWPIGGUARD
				case LIZMANGUARD
				case LIZRANGERGUARD
					ife sprite[target].htextra -1 seta[target].htextra 0
				break
				default break
				endswitch
			}
		}
	}
	// ifn shellyinmap 0
	// ifactor RPG
	// {
		// findnearactorz SHELLY 2560 16384 target
		// ife target -1 findnearactorz SHELLYCROUCH 2560 16384 target
		// ife target -1 findnearactorz DUKEBOT 2560 16384 target
		// ife target -1 findnearactorz DUKEBOTCROUCH 2560 16384 target
		// ife target -1 findnearactorz WESBOT 2560 16384 target
		// ife target -1 findnearactorz WESBOTCROUCH 2560 16384 target
		// ifn target -1 ife actorvar[target].dodgetime 0
		// ife actorvar[target].myspawner -1
		// ifn sprite[].owner target
			// setav[target].myspawner THISACTOR
	// }

ends

defstate blowupcrack
	set xydist 9999
	set TMP_B 0
	headspritestat spriteid 6
	whilevarn spriteid -1
	{
		getactor[spriteid].picnum picnum
		switch picnum
		case CRACK1 case CRACK2 case CRACK3 case CRACK4
		ldist xydist THISACTOR spriteid
		ifl xydist 512 // 1025
		{
			set z sprite[].z
			sub z sprite[spriteid].z
			abs z
			ifl z 8192
			{
				seta[].yvel 0
				set TMP_B 1
			}
		}
		break
		default break
		endswitch
		nextspritestat spriteid spriteid
	}
ends

state validatedecal

	getwall[bottarget].nextsector mysector
	ifvarn mysector -1
	{
		setvar tempb 0
		getsector[mysector].lotag temp
		switch temp
		case 3
		case 16    // ELEVATOR PLATFORM DOWN
		case 17    // ELEVATOR PLATFORM UP
		case 18    // ELEVATOR DOWN
		case 19    // ELEVATOR UP
		case 20    // CEILING DOOR
	    case 21    // FLOOR DOOR
	    case 22    // SPLIT DOOR
	    case 23    // SWING DOOR
	    case 26    // SPLIT STAR TREK DOOR
	    case 28    // DROP FLOOR
	    case 29    // TEETH DOOR
	    case  9    // STAR TREK DOORS
	    case 25    // SLIDE DOOR
	    case 27    // BRIDGE
	    case 30    // ROTATE RISE BRIDGE
	    case 31    // 2 WAY TRAIN
	    setvar tempb 1
	    break
	    default break
	    endswitch
	    ifvare tempb 1 killit
	    
	   	headspritesect spriteid mysector
	   	whilevarn spriteid -1
	   	{
		   	ifvare sprite[spriteid].picnum SECTOREFFECTOR
		   	{
			   	getactor[spriteid].lotag tempc
			   	switch tempc
			   	case 11
			   	case 13
			   	case 15
			   	case 19
			   	case 21
			   	case 22
			   	case 25
			   	case 31
			   	case 32
			   	setvar tempb 1
			   	break
			   	endswitch
		   	}
	   		nextspritesect spriteid spriteid
	   		ifvare tempb 1 setvar spriteid -1
		}
			ifvare tempb 1 
			{
				ifactor WALLARROW
				ifvarand sprite[].cstat 16 state arrow_bits
				killit
			}
			ifawayfromwall killit
	}
ends

onevent EVENT_PREWORLD

	headspritestat spriteid 2
	whilevarn spriteid -1
	{
		ifl actorvar[spriteid].burning 0
		{
			ifvarand player[0].player_par 1 
			{
				changespritestat spriteid 1
				seta[spriteid].httimetosleep 100
			}
			else
			{
				set temp actorvar[spriteid].burning
				ifl temp -1
				{
					add temp 1
					setav[spriteid].burning temp
				}
			}
		}
		else
		ifn actorvar[spriteid].monstatus 0
		ifg sprite[spriteid].httimetosleep 32000
		{
			changespritestat spriteid 1
			seta[spriteid].httimetosleep 100
		}
		nextspritestat spriteid spriteid
	}
	
endevent

onevent EVENT_GAME

ife sprite[].statnum 4
{
	switch sprite[].picnum
	case CARXPLODE 
	 
		ifrnd 96
		{
		set temp 128
		ifrnd 128 orvar temp 4
		ifrnd 128 orvar temp 8
		seta[].cstat temp
		}
		ifspawnedby TERMINATORCRAWLING sizeat 16 16
	break
	
	case POTDEBRIS1 case POTDEBRIS2 case POTDEBRIS3 case POTDEBRIS4
	case WOODDEBRIS case STONEDEBRIS
		ife sprite[].yvel 1
		{
			geta[].zvel z
			add z 256
			seta[].zvel z
		}
	break
	
	case BOMBLET
		state projectilehitscan
		ife team 1
		ifvarand dukeupgrades[HANDBOMB_WEAPON] 2
		{
			state targetsearch
			state turntotarget
		}
	break
	case FIRELASER
		state projectilehitscan
		// cstator 2
		
		set temp 130
		ifrnd 128 orvar temp 4
		ifrnd 128 orvar temp 8
		seta[].cstat temp
		sizeat 6 6
	break
	case FIRELASER2
		state projectilehitscan
		seta[].blend 255
		ifn sprite[].htpicnum APLAYER
		{
			findplayer startx
			ifl startx 1560
			{
				ifn starty 0 ifg startx starty 
				ifcansee { ifactorsound THISACTOR PLASMA_FLYBY nullop else sound PLASMA_FLYBY }
				set starty startx
			}
		}
		ife myspawner player[].i
		{
			add countvar 1
			ife countvar 3 cstat 130
			ifpdistg 1560 ifg sprite[].xrepeat 32 spawn PLASMA_EXP
		}
		espawn SPEEDBLUR
		setav[RETURN].mtype FIRELASER2
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		seta[RETURN].alpha 80
		seta[RETURN].pal sprite[].pal
		seta[RETURN].cstat 128
		seta[RETURN].mdflags 16
	
	break
	
	case FIRELASER3
	case EDFLASER
	case FREEZEBOLT
		state projectilehitscan
		seta[].blend 255
	break
	
	case SCUBAPROJ
		state projectilehitscan
		seta[].blend 1
	break
	
	case ARCBALLPROJ
	case ARCBALLPROJ2
		state projectilehitscan
	break
	
	case TANKSHELL
		state projectilehitscan
	break
	
	case BLADEPROJ
		state projectilehitscan
		geta[].xvel xvel
		geta[].zvel z2	
		shiftr z2 4
		getangle tempb xvel z2
		seta[].pitch tempb
		
		ifl sprite[].yvel countvar
		{
			spawn SPARKFALL spawn SPARKFALL spawn SPARKFALL spawn SPARKFALL 
		}
		geta[].yvel countvar
		ifg sprite[].xvel 844 
		{
			geta[].z savz
			set z savz
			add z 2048
			seta[].z z
			state makespeedblur
			seta[].z savz
		}
	break

	case FREEZEBLAST
		ife mtype 1
		{
			add countvar 1
			ife countvar 3
			{
				ifn bottarget -1
				{
					state calczdist
					setprojectile[RANGERPROJ].workslike 36866
					mulvar zdist 844
					div zdist xydist
					ezshoot zdist RANGERPROJ
					seta[RETURN].owner sprite[].owner
					setprojectile[RANGERPROJ].workslike 32770
				}
				killit
			}
		}
		else
		{
			state projectilehitscan
			seta[].blend 255
			ifl sprite[].yvel countvar
			sound FREEZEBOUNCE
			geta[].yvel countvar
		}
		
	break
	case RPG
		ife initsprite 666 
		{
			geta[].xvel xvel mul xvel 3 div xvel 2 
			geta[].zvel yvel mul yvel 3 div yvel 2
			
			ife devside 1
			{
				setprojectile[CBPROJ].offset 65408
				
			}
			else
			{
				setprojectile[CBPROJ].offset 128
			}
			geta[].z z
			add z 2048
			seta[].z z
			
			eshoot CBPROJ
			seta[RETURN].extra 50
			seta[RETURN].zvel yvel
			seta[RETURN].xvel xvel
			seta[RETURN].owner sprite[].owner
			seta[RETURN].ang sprite[].ang
			seta[RETURN].xrepeat 26
			seta[RETURN].yrepeat 26
			setprojectile[CBPROJ].offset -160
			killit
		}
		state projectilehitscan
		ife mtype CANHEAD
		{
			add countvar 1
			ife countvar 20 // split!
			{
				sound RPG_SPLIT
				debris SCRAP1 2
				debris SCRAP2 2
				eshoot RPG
				setav[RETURN].mtype 666
				ifspawnedby BOSS3 seta[RETURN].extra 30 else
				seta[RETURN].extra 40
				seta[RETURN].ang sprite[].ang
				eshoot RPG
				setav[RETURN].mtype 666
				ifspawnedby BOSS3 seta[RETURN].extra 30 else
				seta[RETURN].extra 40
				seta[RETURN].ang sprite[].ang
				eshoot RPG
				setav[RETURN].mtype 666
				ifspawnedby BOSS3 seta[RETURN].extra 30 else
				seta[RETURN].extra 40
				seta[RETURN].ang sprite[].ang
				eshoot RPG
				setav[RETURN].mtype 666
				ifspawnedby BOSS3 seta[RETURN].extra 30 else
				seta[RETURN].extra 40
				seta[RETURN].ang sprite[].ang
				killit
			}
		}
		else ife mtype 666
		{
			state randtraj
			state randtraj
			sizeat 20 20
		}
		// else ife mtype 69 // spiral rockets
		// {
			
			// set temp player[].player_par
			// add temp countvarb
			// mul temp 96
			// sin tempb temp
			// shiftr tempb 11
			// add tempb sprite[].ang
			// seta[].ang tempb
		// }
		ifspritepal 47
		{
			ifactorsound THISACTOR ROCKETLOOP nullop else sound ROCKETLOOP
			spawn SPARKFALL
		}
		ifspritepal 11
		{
			ifactorsound THISACTOR ROCKETLOOP nullop else sound ROCKETLOOP
		}
		ifn sprite[].htpicnum APLAYER
		{
			findplayer startx
			ifl startx 1560
			{
				ifn starty 0 ifg startx starty 
				ifcansee { ifactorsound THISACTOR RPG_MISS nullop else sound RPG_MISS }
				set starty startx
			}
		}
		ife mtype TARGETLOCK
		{
			ifn bottarget -1
			{
				state turntotarget
				state zveltotarget
				ifn actorvar[bottarget].monstatus 1 ifrnd 2 set bottarget -1
			}
			
		}
	break
	
	case GRENADEPROJ
	case WESGRENADE
	case BLOODBOMB
		state blowupcrack
		ife team 1
		{
			state targetsearch
			ifn bottarget -1
			{
				geta[bottarget].x x2
				geta[bottarget].y y2
				sub x2 sprite[].x
				sub y2 sprite[].y
				getangle angvar x2 y2
				getincangle temp sprite[].ang angvar
				ifg temp 480 // has moved passed target
				{
					ldist xydist THISACTOR bottarget
					ifl xydist 844
					{
						geta[].z z
						sub z sprite[bottarget].z
						abs z
						ifl z 10240
						seta[].yvel 0
					}
				}
			}
		}
		state projectilehitscan
		ifactor BLOODBOMB
		{
			espawn JIBS6
			seta[RETURN].zvel 0
			seta[RETURN].xvel 24
			randvar temp 2047
			seta[RETURN].ang temp
			seta[RETURN].xrepeat 12 // 24
			seta[RETURN].yrepeat 12 // 24
			seta[RETURN].pal sprite[].pal
		}
	break
	case BIGGRENADEPROJ
	ife bottarget player[].i
	{
		geta[].z z
		sub z 2048
		getp[].posz z2
		ifg z2 z
		{
			sub z2 z
			mul z2 sprite[].xvel
			ldist temp THISACTOR bottarget
			div z2 temp
			movesprite THISACTOR 0 0 z2 CLIPMASK0 RETURN
		}
	}
	state projectilehitscan
	break
	
	case PLAYERPLASMA
		add countvar 1
		ife countvar 2
		{
			geta[].xvel xvel mul xvel 3 seta[].xvel xvel
			geta[].zvel z mul z 3 seta[].zvel z
		}
		state projectilehitscan
	break
	
	case ARROWPROJ
		getactor[].xvel xvel
		subvar xvel 2
		setactor[].xvel xvel
		getthisprojectile[].drop z
		ifvarg z -256 subvar z 1
		setthisprojectile[].drop z
		ife initsprite 0
		{
			// 0 = regular; 1 = burning; 2 = explosive; 3 = multi; 4 = freeze; 5 = spy; 6 = electric
			// 7 = blood; 8 = radioactive
			 setvar initsprite 1 
			 ife arrowtype 1 // burning
			 {
				 spritepal 2
				 setthisprojectile[].pal 2
			 }
			 ife arrowtype 2 // explosive
			 {
				 spritepal 7
				 setthisprojectile[].pal 7
				 setthisprojectile[].hitradius 1792
				 setthisprojectile[].extra 180 // 120
				 strength 180 // 120
				 setthisprojectile[].spawns EXPLOSION2
				 setthisprojectile[].isound RPG_EXPLODE
			 }
			 ife arrowtype 3 // multi
			 {
				 spritepal 12
				 setthisprojectile[].pal 12
				 state randtraj
			 }
			 ife arrowtype 4 // freeze
			 {
				 spritepal 1
				 setthisprojectile[].pal 1
			 }
			 ife arrowtype 5 // spy
			 {
				 spritepal 15
				 setthisprojectile[].pal 15 
			 }
			 ife arrowtype 6 // electric
			 {
				spritepal 117
				setthisprojectile[].pal 117 
			 }
			 ife arrowtype 7 // blood
			 {
				spritepal 54
				setthisprojectile[].pal 54 
			 }
			 ife arrowtype 8 // radioactive
			 {
				spritepal 6
				setthisprojectile[].pal 6 
			 }
		}

		ifspritepal 2 ifpdistg 1560 spawn STICKYFIRE
		// ifspritepal 7 spawn SMALLSMOKE
		ifspritepal 1 lotsofglass 1
		// ifspritepal 117 spawn SPARKFALL 
		ifspritepal 15
		{
			getactor[].extra temp
			addvar temp 8 ifvarg temp 800 setvar temp 800
			
			setactor[THISACTOR].extra temp
			ifvarvare arrowview THISACTOR
			{	
				// getplayer[].oang temp
				set temp oang
				getplayer[].ang tempb
				getincangle tempb temp tempb
				shiftvarr tempb 1
				getactor[].ang angvar
				addvarvar angvar tempb
				setactor[].ang angvar
				setplayer[].ang player[].oang
				
				// getplayer[].ohoriz temp
				set temp ohoriz
				getplayer[].horiz tempb
				subvarvar tempb temp
				shiftvarl tempb 4
				getactor[].zvel z
				subvarvar z tempb
				setactor[].zvel z
				setplayer[].horiz ohoriz // player[].ohoriz
				
				addvar countvar 1
				ifvarg countvar 180 setvar arrowview -1
			}
		}
		state projectilehitscan
	break
	
	case STAKEPROJ
		getactor[].xvel xvel
		subvar xvel 2
		setactor[].xvel xvel
		getthisprojectile[].drop z
		ifvarg z -256 subvar z 1
		setthisprojectile[].drop z
		state projectilehitscan
		
		add countvarb 1
		ifg countvarb 1
		{
			geta[].z savz
			geta[].z z
			add z 1024
			seta[].z z
			state makespeedblur
			seta[].z savz
		}
		
		geta[].xvel xvel
		geta[].zvel z2	
		shiftr z2 4
		getangle tempb xvel z2
		seta[].pitch tempb
		
	break
	
	case BLOODBULLET
		state projectilehitscan
		geta[].z savz
		set z savz
		add z 2048
		seta[].z z
		state makespeedblur
		seta[].z savz
		
	break
	
	case SHRINKSPARK
	    ife initsprite 0
		{
			set initsprite YES
			ifrnd 128 cstator 8
			ifrnd 128 cstator 4
			seta[].blend 1
			seta[].mdflags 16
			cstator 2
		}
		ifspawnedby SECTOREFFECTOR
		{
			ife PSHRINKING 0
			ifp palive
			ifpdistl 844
			ife sprite[].sectnum player[].cursectnum
			{
				seta[player[].i].htpicnum SHRINKSPARK
				ife sprite[player[].i].htextra -1 seta[player[].i].htextra 0
				seta[player[].i].htang sprite[].ang
				seta[player[].i].htowner THISACTOR
			}
			
			headspritestat spriteid 1
			whilevarn spriteid -1
			{
				// ife sprite[].sectnum sprite[spriteid].sectnum
				ifn actorvar[spriteid].monstatus 0
				ifn actorvar[spriteid].monstatus 2
				{
					dist xydist THISACTOR spriteid
					ifle xydist 844
					{
						seta[spriteid].htpicnum SHRINKSPARK
						ife sprite[spriteid].htextra -1 seta[spriteid].htextra 1
						seta[spriteid].htowner THISACTOR
					}
				}
				nextspritestat spriteid spriteid
			}
		}
		state projectilehitscan
	break
	
	case LOVEBOMB
		seta[].blend 1
		cstator 2
		espawn GROWSPARK
		rand x 1024, sub x 640
		add x sprite[].x
		seta[RETURN].x x
		rand y 1024, sub y 640
		add y sprite[].y
		seta[RETURN].y y
	break
	
	case MEGAPROJ
	case PLASMAPROJ
	case GREENLASER
	case STICKYPROJ
	case FLAKPROJ
	case SWIRLPROJ
	case COMETPROJ
	case RANGERPROJ
	case SHOCKPROJ
		state projectilehitscan
	break
	
	case BIGPLASMA
		state projectilehitscan
		espawn SPEEDBLUR
		setav[RETURN].mtype BIGPLASMA
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		seta[RETURN].alpha 80
		seta[RETURN].pal sprite[].pal
		seta[RETURN].cstat 128
		seta[RETURN].mdflags 16
	break
	
	case BIGBOIPROJ
		state projectilehitscan
		ife rendmode 0
		{
			ife sprite[].cstat 130
				cstat 134 else
			ife sprite[].cstat 134
				cstat 138 else
			ife sprite[].cstat 138
				cstat 130
		}
	break
	
	case CBPROJ
		ifspawnedby BOSS2 sizeat 64 64
		state projectilehitscan
		
		// espawn SPEEDBLUR
		// setav[RETURN].mtype CBPROJ
		// seta[RETURN].xrepeat sprite[].xrepeat
		// seta[RETURN].yrepeat sprite[].yrepeat
		// seta[RETURN].alpha 80
		// seta[RETURN].pal sprite[].pal
		// seta[RETURN].cstat 128
		// seta[RETURN].mdflags 16
	break
	
	case BMFGPROJ
		state projectilehitscan
		seta[].blend 1
		cstator 2
		ifspawnedby APLAYER 
		ifspritepal 22
		{
			setprojectile[BMFGPROJ].pal 0 // resets to normal in case altfire was used
			setprojectile[BMFGPROJ].hitradius 3072
			
		}
		headspritestat spriteid 1 // 990
		whilevarn spriteid -1
		{
			ife actorvar[spriteid].monstatus 1
			ifn actorvar[spriteid].team team
			ifn actorvar[spriteid].team 3
			{
				set target spriteid // actorvar[spriteid].mysignpost
				ifn target -1
				{
					dist xydist THISACTOR target
					
					ifl xydist 8192
					{
						canseespr THISACTOR target temp
						ife temp YES
						{
							geta[target].x x2
							geta[target].y y2
							sub x2 sprite[].x
							sub y2 sprite[].y
							getangle angvar x2 y2 // angle to make projectile face the target
							
							getincangle temp angvar sprite[spriteid].ang
							abs temp
							ifg temp 512
							{
								add angvar 1024
								cos xvel angvar
								sin yvel angvar
									  
								shiftvarr xvel 5
								shiftvarr yvel 5
								
								geta[].z z
								sub z sprite[target].z
								shiftr z 1
										 
								movesprite target xvel yvel z CLIPMASK0 RETURN
								
								setav[target].bottarget -1
								rand angvar 2047
								seta[target].ang angvar
								seta[target].xvel 0
								
								ifspritepal 22
								{
									ifl xydist 5120
									ife actorvar[target].shrunken 0
									ifg sprite[target].extra 0
									ife sprite[target].htextra -1
									{
										espawn SHRINKEREXPLOSION
										setav[RETURN].myvictim target
										setsprite RETURN sprite[target].x sprite[target].y sprite[target].z
										seta[target].htpicnum SHRINKSPARK
										seta[target].htowner player[].i
										ifl sprite[target].htextra 1 seta[target].htextra 1
									}
								}
								else
								{
									ifl xydist 6144
									ifrnd 40
									{
										ife actorvar[target].stun 0
										{
											espawn SHOCK_ACTOR
											setsprite RETURN sprite[target].x sprite[target].y sprite[target].z
											setav[RETURN].myspawner target
											seta[target].htowner player[].i
										}
									}
								}
									
							}

							
						}
					}
				}
			}
			nextspritestat spriteid spriteid
		}
		
	break
	
	case SHOCKBALL
	case SHOCKBALL2
		state projectilehitscan
		seta[].blend 1
		cstator 514
		cstator 256
		spawn SHOCKBALL
		ife monstatus 2
		{
			espawn SHOCKBALL_EXP
			setav[RETURN].mtype 1
			sound SHOCKBALLIMPACT
			hitradius 4096 60 85 110 135
			headspritestat spriteid 1
			whilevarn spriteid -1
			{
				ife actorvar[spriteid].monstatus 1
				ifn spriteid myspawner
				{
					dist xydist THISACTOR spriteid
					ifl xydist 4096
					{
						espawn SHOCK_ACTOR
						setsprite RETURN sprite[spriteid].x sprite[spriteid].y sprite[spriteid].z
						setav[RETURN].myspawner spriteid
						seta[spriteid].htowner player[].i
					}
				}
				nextspritestat spriteid spriteid
			}
			killit
		}
		
	break
	
	// case FIREBOLT
		// state projectilehitscan
		// ife countvar 0
		// {
			// set countvar 1
			// geta[].zvel z
			// shiftl z 1
			// seta[].zvel z
			// geta[].xvel x
			// shiftl x 1
			// seta[].xvel x
		// }
	// break
	case RANGERHEADPROJ
	case LIZHEADPROJ
	case ZOMBIEHEADPROJ case CRAZYHEADPROJ
	case NEWTROOPHEADPROJ
	case PIGHEADPROJ
	case ANTHEADPROJ
	case BBHEADJIBPROJ
	case BBARMJIBPROJ
	case BBLEGJIBPROJ
	case MANDOARMPROJ
	case MANDOHEADPROJ
	case MANDOCHESTPROJ
	case MANDOLEGPROJ
		ifspritepal 1 { setthisprojectile[].bsound GLASSTINK setthisprojectile[].trail -1 }
		add countvarb 1
		ifg countvarb 15 setthisprojectile[].trail -1
		ifge countvarc 2 ife sprite[].yvel 2 seta[].yvel 0
	break
	
	case BULLHEADPROJ
	case BULLLEGPROJ
	case BULLARMPROJ
	case COMMHEADPROJ
	case NEWCOMMHEADPROJ
	case BEASTHEADPROJ
	case EGGJIBPROJ
	case PIGLEGPROJ
	case PIGARMPROJ
	case COMMARMPROJ
	case RANGERLEGPROJ
	case RANGERARMPROJ
	case ARMPIGARMPROJ
	case ARMPIGLEGPROJ
	case ARMPIGFOOTPROJ
		ifspritepal 1 { setthisprojectile[].bsound GLASSTINK setthisprojectile[].trail -1 }
		add countvarb 1
		ifg countvarb 15 setthisprojectile[].trail -1
		add countvar 1
		ifg countvar 6
		{
			ife sprite[].cstat 128 cstat 132 else 
			ife sprite[].cstat 132 cstat 136 else
			ife sprite[].cstat 136 cstat 140 else
			cstat 128
			set countvar 0
		}
		ifge countvarc 2 ife sprite[].yvel 2 seta[].yvel 0
	break
	
	case ARROWBIT1 case ARROWBIT2 case ARROWBIT3
		add countvar 1
		ifg countvar 4
		{
			ife sprite[].cstat 128 cstat 132 else 
			ife sprite[].cstat 132 cstat 136 else
			ife sprite[].cstat 136 cstat 140 else
			cstat 128
			set countvar 0
		}
	break
	

	case COINPROJ
		ifpdistl 1024 { spawn NUKECOIN killit }
	break
	
	case IMPCOINPROJ
		ifpdistl 1024 { espawn IMPCOIN seta[RETURN].pal sprite[].pal killit }
	break
	
	// case BEACHBALLPROJ
	  // add countvar 1
	  // cstator 256
	  // ifaction BALLPROJAN
	  // ifl sprite[].xvel 256 action BALLPROJANSLOW
	  // ifg countvar 5
	  // ifpdistl 1024
		// ifp pfacing
		// ifcansee
		// {
			// sound BOUNCESOUND
			// geta[].zvel zdist
			// getp[].horiz temp
			// sub temp 100
			// mul temp -64
			// add zdist temp
			// ezshoot zdist BEACHBALLPROJ
			// seta[RETURN].ang player[].ang
			// ifhitspace nullop else
			// seta[RETURN].xvel 480
			// set monstatus 2
			// killit
		// }
	// break
	case SPIDERMINEFALLING
		add countvar 1
		ifg countvar 7
		{
			set countvar 0
			geta[].cstat temp
			ifvarand temp 8 ifvarand temp 4 { xorvar temp 8 } else
			ifvarand temp 4 { xorvar temp 4 } else
			ifvarand temp 8 { orvar temp 4 } else
			orvar temp 8
			seta[].cstat temp
		}
	break
	case RADPROJ
		state projectilehitscan
		geta[].cstat temp
		ifl sprite[].zvel 0
			orvar temp 8
		else
			ifvarand temp 8 xorvar temp 8
		seta[].cstat temp
		ife team 1 // from wesgrenade
		{
			state targetsearch
			ifn bottarget -1
			{
				ifvarand player[].player_par 1
				{
					state turntotarget
					state zveltotarget
				}
				ifn actorvar[bottarget].monstatus 1 ifrnd 2 set bottarget -1
				
				state randtraj
			}
		}
		ife mtype 1
		{
			geta[].htflags temp, orvar temp 4, seta[].htflags temp
			seta[].shade 35
			seta[].blend 0
			spritepal 10
			ifn bottarget -1
			{
				ifvarand player[].player_par 1
				{
					state turntotarget
					state zveltotarget
				}
				ifn actorvar[bottarget].monstatus 1 ifrnd 2 set bottarget -1
				
				state randtraj
			}
		}
		
	break
	case PURPPROJ
		state projectilehitscan
		geta[].cstat temp
		ifl sprite[].zvel 0
			orvar temp 8
		else
			ifvarand temp 8 xorvar temp 8
		seta[].cstat temp
	break
	case PADPROJ
		seta[].blend 1
		add countvar 1
		ife countvar 3
		{
			set countvar 0
			ife sprite[].cstat 642 cstat 646 else
			ife sprite[].cstat 646 cstat 650 else
			ife sprite[].cstat 650 cstat 654 else
			cstat 642
		}
		spawn PADPROJ
	break
	case POMPROJ

		cstat 32
		cstator 16
		
		geta[].xvel xvel
		geta[].zvel z	
		shiftr z 4
		getangle tempb z xvel
		sub tempb 512
		
		div tempb 16
		seta[].yoffset tempb
		

	break
	default
		ifspritepal 1 ife sprite[].statnum 4 { setthisprojectile[].bsound GLASSTINK setthisprojectile[].trail -1 }
	break
	endswitch
	ifn sprite[].picnum SHOCKPROJ ifvarand monstflags 1048576 spawn SPARKFALL
}

switch sprite[].picnum

case 0
	ifand sprite[].cstat 16 nullop else
	ifand sprite[].cstat 32 nullop else
	{
		geta[].htpicnum picnum
		al picnum
		killit
	}
break

case SECTOREFFECTOR

	ifn myspawner -1
	{
		ifg sprite[myspawner].statnum 2 { set myspawner -1 killit }
		ifn sprite[myspawner].picnum mtype { set myspawner -1 killit }
		seta[].x sprite[myspawner].x
		seta[].y sprite[myspawner].y
		seta[].z sprite[myspawner].z
		changespritesect THISACTOR sprite[myspawner].sectnum
	} 
	ife sprite[].lotag 666 // SE of death
	{
	
		geta[].sectnum mysector
		headspritesect spriteid mysector
		whilevarn spriteid -1
		{
			geta[spriteid].picnum picnum
			setvar temp 0
			ifvare picnum APLAYER
			{	
				getactor[spriteid].yvel tempb
				getplayer[tempb].dead_flag tempc
				ifvare tempc 0 { setvar temp 1 set falldeath YES }
			}
			else ife sprite[spriteid].statnum 1
			{
				 ife actorvar[spriteid].monstatus 1
					set temp 1
				 ife actorvar[spriteid].monstatus 3
					set temp 1
			}
			
			ifvare temp 1
			{
				getactor[THISACTOR].z z
				getactor[spriteid].z z2
				ifvarvarg z2 z
				{
					set tempb YES
					
					ifn starty 0
					{
						set temp starty
						mul temp 10
						add z temp
						ifg z2 z set tempb NO
					}
					ife tempb YES
					{
						setactor[spriteid].htextra 999
						setactor[spriteid].htpicnum RADIUSEXPLOSION
						setactor[spriteid].htowner spriteid	
					}
				}
			}
			nextspritesect spriteid spriteid
		}

	}
	ife sprite[].lotag 26 // escalator
		sectsetinterpolation sprite[].sectnum

break

case TOUCHPLATE

	ifn SPRITELOTAG 0
	{
		headspritesect spriteid sprite[].sectnum
		whilevarn spriteid -1
		{
			ife sprite[spriteid].statnum 1
			ife actorvar[spriteid].monstatus 1
				set mtype YES
			nextspritesect spriteid spriteid
		}
		
		ife mtype YES
		{
			operateactivators SPRITELOTAG 0
			operatemasterswitches SPRITELOTAG
			operaterespawns SPRITELOTAG
			killit
		}
	}

break

case NAVSPRITE

	ifn debugaa NO cstat 514
	else cstat 32768
	
	ifp pfacing
	ifpdistl 1560
	{
		ifhitspace { set hudnumber bluebaseval set hudnumber2 blueflagval }
		else
		{
		set hudnumber redbaseval
		set hudnumber2 redflagval
		// set hudnumber thirdbaseval
		// set hudnumber2 redflagval
		}
	}
	
	ife monstatus 2 killit
	
	ifl countvar 1 // do all of below only when countdown reaches 0, for framerate
	{
		
	ifg redbaseval 0
	{
		getp[].player_par tempe
		add tempe 1
		
		headspritestat spriteid 979 // 980
		whilevarn spriteid -1
		{
			set B redbaseval
			// sub B 1024
			ifn spriteid THISACTOR
			ifle actorvar[spriteid].redbaseval B
			// ife sprite[spriteid].htpicnum NAVSPRITE
			ifl rediteration actorvar[spriteid].rediteration
			// ifn redowner spriteid
			{
				geta[].z z
				sub z 6144
				geta[spriteid].z z2
				sub z2 z
				abs z2
				
				set temp YES
				ifn SPRITELOTAG 0
				{
					ifl SPRITELOTAG 1000
					{
						ifn SPRITELOTAG actorvar[spriteid].initflags set temp NO
					}
					else 
					{
						ife mtype 0 // pal 0, the middle of lotag 1000+ path
						{
							set z2 0
							getav[spriteid].SPRITELOTAG tempb
							sub tempb SPRITELOTAG
							abs tempb
							ifn tempb 1 set temp NO
						}
					}
				}
				ife temp YES
				ifl z2 MAXHEIGHTDIFF // no big height difference allowed
				{
					ldist xydist THISACTOR spriteid
					ife sprite[spriteid].pal 8 set TMP_A HALFNAVDIST else set TMP_A MAXNAVDIST
					ifl xydist TMP_A
					{
						geta[].z z
						sub z 6144
						seta[].z z
						canseespr THISACTOR spriteid temp
						add z 6144
						seta[].z z
						
						ifn initsprite -1
						ife initsprite actorvar[spriteid].initsprite
							set temp YES // forced visibility feature
						
						ife temp YES
						{
							shiftl xydist 5
							sub B xydist
							ifle actorvar[spriteid].redbaseval B
							{
								setav[spriteid].redbaseval B
								setav[spriteid].redtimer tempe
								// setav[spriteid].redowner THISACTOR
								set temp rediteration
								add temp 1
								setav[spriteid].rediteration temp
							}
						}
					}
				
				}
			}
			nextspritestat spriteid spriteid
		}
	}

	ifg bluebaseval 0
	{
		getp[].player_par tempe
		add tempe 1
		
		headspritestat spriteid 979 // 980
		whilevarn spriteid -1
		{
			set B bluebaseval
			// sub B 1024
			ifn spriteid THISACTOR
			ifle actorvar[spriteid].bluebaseval B
			// ife sprite[spriteid].htpicnum NAVSPRITE
			ifl blueiteration actorvar[spriteid].blueiteration
			// ifn blueowner spriteid
			{
			
				geta[].z z
				sub z 6144
				geta[spriteid].z z2
				sub z2 z
				abs z2
				
				set temp YES
				ifn SPRITELOTAG 0
				{
					ifl SPRITELOTAG 1000
					{
						ifn SPRITELOTAG actorvar[spriteid].initflags set temp NO
					}
					else 
					{
						ife mtype 0 // pal 0, the middle of lotag 1000+ path
						{
							set z2 0
							getav[spriteid].SPRITELOTAG tempb
							sub tempb SPRITELOTAG
							abs tempb
							ifn tempb 1 set temp NO
						}
					}
				}

				ife temp YES
				ifl z2 MAXHEIGHTDIFF // no big height difference allowed
				{
					ldist xydist THISACTOR spriteid
					ife sprite[spriteid].pal 8 set TMP_A HALFNAVDIST else set TMP_A MAXNAVDIST
					ifl xydist TMP_A
					{
						geta[].z z
						sub z 6144
						seta[].z z
						canseespr THISACTOR spriteid temp
						add z 6144
						seta[].z z
						
						ifn initsprite -1
						ife initsprite actorvar[spriteid].initsprite
							set temp YES // forced visibility feature

						ife temp YES
						{
							shiftl xydist 5
							sub B xydist
							ifle actorvar[spriteid].bluebaseval B
							{
								setav[spriteid].bluebaseval B
								setav[spriteid].bluetimer tempe
								// setav[spriteid].blueowner THISACTOR
								set temp blueiteration
								add temp 1
								setav[spriteid].blueiteration temp
							}
						}
					}
				
				}
			}
			nextspritestat spriteid spriteid
		}
	}
	
	ifg thirdbaseval 0
	{
		getp[].player_par tempe
		add tempe 1
		
		headspritestat spriteid 979
		whilevarn spriteid -1
		{
			set B thirdbaseval
			ifn spriteid THISACTOR
			ifle actorvar[spriteid].thirdbaseval B
			ifl thirdbaseiteration actorvar[spriteid].thirdbaseiteration
			{
			
				geta[].z z
				sub z 6144
				geta[spriteid].z z2
				sub z2 z
				abs z2
				
				set temp YES
				ifn SPRITELOTAG 0
				{
					ifl SPRITELOTAG 1000
					{
						ifn SPRITELOTAG actorvar[spriteid].initflags set temp NO
					}
					else 
					{
						ife mtype 0 // pal 0, the middle of lotag 1000+ path
						{
							set z2 0
							getav[spriteid].SPRITELOTAG tempb
							sub tempb SPRITELOTAG
							abs tempb
							ifn tempb 1 set temp NO
						}
					}
				}

				ife temp YES
				ifl z2 MAXHEIGHTDIFF // no big height difference allowed
				{
					ldist xydist THISACTOR spriteid
					ife sprite[spriteid].pal 8 set TMP_A HALFNAVDIST else set TMP_A MAXNAVDIST
					ifl xydist TMP_A
					{
						geta[].z z
						sub z 6144
						seta[].z z
						canseespr THISACTOR spriteid temp
						add z 6144
						seta[].z z
						
						ifn initsprite -1
						ife initsprite actorvar[spriteid].initsprite
							set temp YES // forced visibility feature

						ife temp YES
						{
							shiftl xydist 5
							sub B xydist
							ifle actorvar[spriteid].thirdbaseval B
							{
								setav[spriteid].thirdbaseval B
								setav[spriteid].thirdbasetimer tempe
								set temp thirdbaseiteration
								add temp 1
								setav[spriteid].thirdbaseiteration temp
							}
							
							
						}
					}
				}
			}
			nextspritestat spriteid spriteid
		}
	}
	
	ife sprite[].statnum 979
	{
		ife gametype 0 changespritestat THISACTOR 980
		else
		ife gametype CTF // CTF
		{
			ifg bluebaseval 0 ifg redbaseval 0
			ifg player[].player_par 30
			{
				changespritestat THISACTOR 980
				set rediteration 99999
				set blueiteration 99999
			}
		}
		else	
		ife gametype -1 // arena complex
		{
			changespritestat THISACTOR 980
			set rediteration 99999
			set blueiteration 99999
		}
		ife gametype SURVIVAL 
		{
			changespritestat THISACTOR 980
			set rediteration 99999
			set blueiteration 99999
		}
		else
		ife gametype DM
		{
			changespritestat THISACTOR 980
			set rediteration 99999
			set blueiteration 99999
		}
		else
		ife gametype CONTROL
		{
			ifg bluebaseval 0 ifg redbaseval 0 ifg thirdbaseval 0
			ifg player[].player_par 30
			{
				changespritestat THISACTOR 980
				set rediteration 99999
				set blueiteration 99999
				set thirdbaseiteration 99999
			}
		}
	}
		
	ifg countvarc 0
	{
		sub countvarc 1
		ife countvarc 0 
		{
			seta[].htpicnum NAVSPRITE
			set blueiteration 99999
		}
	}
	
	ife countvarc 0
	ifg player[].player_par bluetimer
	ifn blueflagval 0
	{
		set blueflagval 0 
		set countvarc 6
	}
	ifg blueflagval 0
	{
		getp[].player_par tempe
		add tempe 1
		
		headspritestat spriteid 980
		whilevarn spriteid -1
		{
			set B blueflagval
			ifn spriteid THISACTOR
			ifle actorvar[spriteid].blueflagval B
			// ife sprite[spriteid].htpicnum NAVSPRITE
			ifl blueiteration actorvar[spriteid].blueiteration
			// ifn blueowner spriteid
			{
				geta[].z z
				sub z 6144
				geta[spriteid].z z2
				sub z2 z
				abs z2
				
				set temp YES
				ifn SPRITELOTAG 0
				{
					ifl SPRITELOTAG 1000
					{
						ifn SPRITELOTAG actorvar[spriteid].initflags set temp NO
					}
					else 
					{
						ife mtype 0 // pal 0, the middle of lotag 1000+ path
						{
							set z2 0
							getav[spriteid].SPRITELOTAG tempb
							sub tempb SPRITELOTAG
							abs tempb
							ifn tempb 1 set temp NO
						}
					}
				}

				ife temp YES
				ifl z2 MAXHEIGHTDIFF // no big height difference allowed
				{
					ldist xydist THISACTOR spriteid
					ife sprite[spriteid].pal 8 set TMP_A HALFNAVDIST else set TMP_A MAXNAVDIST
					ifl xydist TMP_A
					{
						geta[].z z
						sub z 6144
						seta[].z z
						canseespr THISACTOR spriteid temp
						add z 6144
						seta[].z z
						
						ifn initsprite -1
						ife initsprite actorvar[spriteid].initsprite
						set temp YES // forced visibility feature

						ife temp YES
						{
							shiftl xydist 5
							sub B xydist
							ifle actorvar[spriteid].blueflagval B
							{
								sub B 1024 ifl B 1 set B 1
								setav[spriteid].blueflagval B
								setav[spriteid].bluetimer tempe
								// setav[spriteid].blueowner THISACTOR
								set temp blueiteration
								add temp 1
								setav[spriteid].blueiteration temp
							}
						}
					}
				
				}
			}
			nextspritestat spriteid spriteid
		}
	}
	
	ifg countvarb 0
	{
		sub countvarb 1
		ife countvarb 0 
		{
			seta[].htpicnum NAVSPRITE
			set rediteration 99999
		}
	}
	
	ife countvarb 0
	ifg player[].player_par redtimer
	ifn redflagval 0
	{
		set redflagval 0 
		set countvarb 6
	}
	ifg redflagval 0
	{
		getp[].player_par curr_tick
		add curr_tick 1
		
		headspritestat spriteid 980
		whilevarn spriteid -1
		{
			set B redflagval
			ifn spriteid THISACTOR
			ifle actorvar[spriteid].redflagval B
			ifn spriteid mynavsprite
			// ife sprite[spriteid].htpicnum NAVSPRITE
			ifl rediteration actorvar[spriteid].rediteration
			{
				geta[].z z
				sub z 6144
				geta[spriteid].z z2
				sub z2 z
				abs z2
				
				set temp YES
				ifn SPRITELOTAG 0
				{
					ifl SPRITELOTAG 1000
					{
						ifn SPRITELOTAG actorvar[spriteid].initflags set temp NO
					}
					else 
					{
						ife mtype 0 // pal 0, the middle of lotag 1000+ path
						{
							set z2 0
							getav[spriteid].SPRITELOTAG tempb
							sub tempb SPRITELOTAG
							abs tempb
							ifn tempb 1 set temp NO
						}
					}
				}

				ife temp YES
				ifl z2 MAXHEIGHTDIFF // no big height difference allowed
				{
					ldist xydist THISACTOR spriteid
					ife sprite[spriteid].pal 8 set TMP_A HALFNAVDIST else set TMP_A MAXNAVDIST
					ifl xydist TMP_A
					{
						geta[].z z
						sub z 6144
						seta[].z z
						canseespr THISACTOR spriteid temp
						add z 6144
						seta[].z z
						
						ifn initsprite -1
						ife initsprite actorvar[spriteid].initsprite
							set temp YES // forced visibility feature

						ife temp YES
						{
							shiftl xydist 5
							sub B xydist
							ifle actorvar[spriteid].redflagval B
							{
								sub B 1024 ifl B 1 set B 1
								setav[spriteid].redflagval B
								setav[spriteid].redtimer curr_tick
								set temp rediteration
								add temp 1
								setav[spriteid].rediteration temp
							}
							
							
						}
					}
				
				}
			}
			nextspritestat spriteid spriteid
		}
	}
	
	set temp NO
	ife gametype DM set temp YES
	ife gametype SURVIVAL set temp YES
	ife temp YES // code for setting redflagvalue based on visible monsters
	{
		getp[].player_par curr_tick
		add curr_tick 1
		set B 0 // used as flag here
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			ife actorvar[spriteid].team 0
			ife actorvar[spriteid].monstatus 1
			{
				geta[spriteid].z z2
				sub z2 sprite[].z
				abs z2
				ifl z2 MAXHEIGHTDIFF
				{
					ldist xydist THISACTOR spriteid
					ifl xydist MAXNAVDIST
					{
						geta[].z z
						sub z 6144
						seta[].z z
						canseespr THISACTOR spriteid temp
						add z 6144
						seta[].z z
						ife temp YES
						{
							ife B 0 { set B 1 set redflagval 0 }
							shiftl xydist 5
							set TMP_B sprite[spriteid].extra
							add TMP_B 100
							shiftl TMP_B 13 // 14
							sub TMP_B xydist
							ifl TMP_B 1 set TMP_B 1
							ifg TMP_B 99000000 set TMP_B 99000000
						
							add redflagval TMP_B
							ifg redflagval 1073741823 set redflagval 1073741823 
							set rediteration 0
							set redtimer curr_tick
							seta[].htpicnum REDFLAG
						}
					}
				}
			}
			nextspritestat spriteid spriteid
		}
	}
		set countvar 5
	} // end of ife countvar 0 block
	else
	{
		sub countvar 1
		// ife gametype -1 sub countvar 4
	}

break

case CHECKPOINT
	ife initsprite 0
	ifp palive
	{
		
		ife player[].cursectnum sprite[].sectnum
		{
			set initsprite YES
			set bigmsgcount 90
			set bigmsg 1249
			ife SPRITELOTAG 0 save 0 else
			ife SPRITELOTAG 1 save 1 else
			ife SPRITELOTAG 2 save 2 else
			ife SPRITELOTAG 3 save 3 else
			ife SPRITELOTAG 4 save 4 else
			ife SPRITELOTAG 5 save 5 else
			ife SPRITELOTAG 6 save 6 else
			ife SPRITELOTAG 7 save 7 else
			ife SPRITELOTAG 8 save 8 else
			ife SPRITELOTAG 9 save 9 else
			save 0
			// save SPRITELOTAG
		}
	}
break

case DOMELITE
	ife initsprite 1
	ifspritepal 0
	{
		seta[].shade -80
		seta[].htflags 4
		ifpdistl 6144
		{
			ifn proxsound -1 ife sprite[proxsound].statnum 1024 set proxsound -1
			ife proxsound -1
			{
				ifactorsound THISACTOR ALARM2 nullop else 
				{
					sound ALARM2
					set proxsound THISACTOR
				}
			}
			else
			{
				dist xydist THISACTOR player[].i
				dist xydist2 proxsound player[].i
				sub xydist2 xydist
				ifg xydist2 512
				{
					stopactorsound proxsound ALARM2
					ifactorsound THISACTOR ALARM2 nullop else sound ALARM2
					set proxsound THISACTOR
				}
			}
			
		}
		ifpdistl 10240
			soundonce ALARM2
	}
	else
	{
		geta[].htflags temp
		orvar temp 128
		seta[].htflags temp
	}
break

case NUKEBUTTON
	ifn sprite[].lotag 0
	{
		ifpdistl 2048
		ifp pfacing
		ifcansee
		ifp palive
		ife player[].fist_incs 0
			set secretsfound 10
	}
break

case SLOTDOOR
case LIGHTSWITCH
case SPACEDOORSWITCH
case SPACELIGHTSWITCH
case FRANKENSTINESWITCH
case DIPSWITCH
case DIPSWITCH2
case DIPSWITCH3
case TECHSWITCH
case ALIENSWITCH
case POWERSWITCH1
case POWERSWITCH2
case LOCKSWITCH1
case LIGHTSWITCH2
case HANDSWITCH
case PULLSWITCH
	// ifand sprite[].cstat 64
	// {
		// ifand sprite[].cstat 32 nullop else
		// {
			// ife initsprite 0 geta[].cstat initsprite
			// ifangdiffl 480
				// cstator 32768
			// else
			// ifand sprite[].cstat 32768
				// seta[].cstat initsprite	
		// }
	// }
	
	ife mtype 0
	{
		geta[].picnum initsprite
		geta[].lotag SPRITELOTAG
		spriteflags 64
		ife sprite[].pal 0 set mtype 1
		else set mtype -1
	}
	
	ife initflags 29 // coop only
	{
		// switchmode 0 == characters swap positions, 1 == player stays in same plays
		ifn myshelly -1
		ife switchmode 0
		{
			seta[].cstat ikicked
			seta[].lotag droptile
		}
		else
		{
			cstator 32768
			seta[].lotag 0
		}
	
	}
	else
	ife initflags 30 // solo only
	{
		ifn myshelly -1
		ife switchmode 0
		{
			cstator 32768
			seta[].lotag 0
		}
		else
		{
			seta[].cstat ikicked
			seta[].lotag droptile
		}
	}
	
	ifg countvar 0
	{
		sub countvar 1
		ife countvar 0
		{
			geta[].cstat temp
			orvar temp 256
			seta[].cstat temp
		}
	}
	
	ifn SPRITELOTAG 0
	ifn sprite[].picnum initsprite
	{
		geta[].picnum initsprite
		state AActivation
		state se17activation
		ifvarand sprite[].cstat 256
		ifg scandist 1561
		{
			geta[].cstat temp
			xorvar temp 256
			seta[].cstat temp
			set countvar 4
		}
	}
	
	ife mtype 1
	{
		ifvare player[THISACTOR].heat_on YES
		{
			ifvare sprite[THISACTOR].hitag 1
				setactor[THISACTOR].pal 6
			else setactor[THISACTOR].pal 0
		}
		else
		ife aimbot_on YES
		{
			ifvare sprite[THISACTOR].hitag 1
				setactor[THISACTOR].pal 6
			else setactor[THISACTOR].pal 0
		}
		else setactor[THISACTOR].pal 0
	}
	
break

case 133
case 135
case 137
case 139
case 141
case 163
case 165
case 167
case 169
case 713
case 861
case 863
case 865
case 1112
case 1123
case 1143
	// ifand sprite[].cstat 64
	// {
		// ifand sprite[].cstat 32 nullop else
		// {
			// ife initsprite 0 geta[].cstat initsprite
			// ifangdiffl 564
				// cstator 32768
			// else
			// ifand sprite[].cstat 32768
				// seta[].cstat initsprite
		// }
	// }
	ife mtype 0
	{
		geta[].picnum initsprite
		geta[].lotag SPRITELOTAG
		spriteflags 64
		ife sprite[].pal 0 set mtype 1
		else set mtype -1
	}
	
	ife initflags 29 // coop only
	{
		// switchmode 0 == characters swap positions, 1 == player stays in same plays
		ifn myshelly -1
		ife switchmode 0
		{
			seta[].cstat ikicked
			seta[].lotag droptile
		}
		else
		{
			cstator 32768
			seta[].lotag 0
		}
	
	}
	else
	ife initflags 30 // solo only
	{
		ifn myshelly -1
		ife switchmode 0
		{
			cstator 32768
			seta[].lotag 0
		}
		else
		{
			seta[].cstat ikicked
			seta[].lotag droptile
		}
	}
	
	ifg countvar 0
	{
		sub countvar 1
		ife countvar 0
		{
			geta[].cstat temp
			orvar temp 256
			seta[].cstat temp
		}
	}
	
	ifn SPRITELOTAG 0
	ifn sprite[].picnum initsprite
	{
		geta[].picnum initsprite
		state AActivation
		state se17activation
		ifvarand sprite[].cstat 256
		ifg scandist 1561
		{
			geta[].cstat temp
			xorvar temp 256
			seta[].cstat temp
			set countvar 4
		}
	}
	
	ife mtype 1
	{
		ifvare player[THISACTOR].heat_on YES
		{
			ifvare sprite[THISACTOR].hitag 0 setactor[THISACTOR].pal 6
			else setactor[THISACTOR].pal 0
		}
		else setactor[THISACTOR].pal 0
	}
break

case CANWITHSOMETHING case CANWITHSOMETHING2
case CANWITHSOMETHING3 case CANWITHSOMETHING4
case NUKEBARREL case NUKEBARRELDENTED case NUKEBARRELLEAKED
case EXPLODINGBARREL case FIREBARREL case FIREVASE
case RUBBERCAN case GUNPOWDERBARREL
case TRIPODCAMERA case FLOORBASKET case HATRACK
case EGG case OSCAR
case VACUUM case CAMERALIGHT case IVUNIT case COFFEEMACHINE
case POT1 case POT2 case SCALE case MOVIECAMERA case CHAIR3
case GUMBALLMACHINE case WETFLOOR case BROOM case MOP
case BOWLINGPIN case JOLLYMEAL case SODA2LITER case 14858 case 14895
case 4443 // flag
case 7463 case 7453 case 7455 case 7451 case 14901 case 14902
case CHAIR1_AA case 16153 case 16154 case CHAIR4 case CHAIR5 case CHAIR6
case BLOWUPDOLL case 10223 case GAMERCHAIR case 16088
	state checkheldobject
break

case OOZFILTER case SEENINE
ife sprite[].lotag 0 ife sprite[].hitag 0
	state checkheldobject
break

case THROWNOBJECT break

case MOVECAM
case BLUEFLAGATBASE
case BLUEBASENOFLAG
case BLUEFLAG
case REDFLAGATBASE
case REDBASENOFLAG
case REDFLAG
case TEAMSPAWNER
case HIGHSOUND
case EMPERORSCREEN
case CONTROL_A case CONTROL_B case CONTROL_C
case NPCNAV
case JUMPAD
case ANIMOPEN1
case ANIMOPEN2
case ANIMOPEN3
case UPDRAFT_SPAWNER
case LIGHTNING2
case BLACKHAWK
case COFFIN
case NAAMAH
	seta[].httimetosleep 0
	ifn sprite[].statnum 1 changespritestat THISACTOR 1
break


case BOSS1STATUE case BOSS2STATUE case BOSS3STATUE
	seta[].httimetosleep 0
	ife initsprite 5 ifn sprite[].statnum 1 changespritestat THISACTOR 1
break

case MUSICSECTOR

	ife player[].cursectnum sprite[].sectnum
	ife endlevel 0
	ife musicwait 0
	{
		getuserdef[].music_episode temp
		getuserdef[].music_level tempb
		ife temp mtype ife tempb SPRITELOTAG nullop else
		{
			starttrackslot mtype SPRITELOTAG
			setuserdef[].music_episode mtype
			setuserdef[].music_level tempb
		}
	}

break

case CUTSCENE_CAM


	// SPRITELOTAG == channel
	// myspawner == target sprite
	// initflags == length of scene in tics
	// mtype == sound to play
	// cutcam -1 0
	// cutcamtarget -1 0
	// cutcamtime 0 0
	// cutcamsound 0 0
	// cutcamchannel 0 0
	// pal 121 camera is the view point

	ife cutcamtime 0 // no cutscene is playing
	ife player[].cursectnum sprite[].sectnum
	{
		set cutcamchannel SPRITELOTAG
		set cutcamtime 30 // placeholder until pal 121 camera takes over
	}
	ife cutcamchannel SPRITELOTAG
	{
		ife droptile 121
		{
			ife cutcam -1 
			{
				set cutcam THISACTOR
				set cutcamtarget myspawner
				ife cutcamsound 0 ifg mtype 0 globalsoundvar mtype
				set cutcamtime initflags
			}
			sub cutcamtime 1
		}
		
		ife cutcamtime 0 
		{
			ife cutcam THISACTOR { set cutcam -1 set cutcamtarget -1 }
			killit
		}
	}
	
break

case BOMBSECTOR

ife initsprite 1
{
	ifp pjetpack
	{
		set countvar 0
		sets[].floorpal droptile
	}
	else
	ife player[].cursectnum sprite[].sectnum
	ifp palive
	{
		add countvar 1
		ife countvar 60
		{
			sound WARNBEEP
			sets[].floorpal 2
		}
		ife countvar 64 sets[].floorpal droptile
		ife countvar 90
		{
			sound WARNBEEP
			sets[].floorpal 2
		}
		ife countvar 94 sets[].floorpal droptile
		ife countvar 116
		{
			sound WARNBEEP
			sets[].floorpal 2
		}
		ife countvar 120 sets[].floorpal droptile
		ife countvar 138
		{
			sound WARNBEEP
			sets[].floorpal 2
		}
		ife countvar 142 sets[].floorpal droptile
		ife countvar 156
		{
			sound WARNBEEP
			sets[].floorpal 2
		}
		ife countvar 160 sets[].floorpal droptile
		ife countvar 170
		{
			sound WARNBEEP
			sets[].floorpal 2
		}
		ife countvar 174 sets[].floorpal droptile
		ife countvar 180
		{
			set countvar 0
			spawn EXPLOSION2
			flash
			globalsound ROBOT_EXPLODE
			hitradius 4096 150 150 150 150
			debris SCRAP1 10
			debris SCRAP2 10
			palfrom 52 48 12 12
		}
	}
	else 
	{
		set countvar 0
		sets[].floorpal droptile
	}
	
}

break

case LEVELPLATE

	seta[].z float
	ife monstatus 0
	ife player[].cursectnum sprite[].sectnum
	{
		ifg initsprite 20 // time after elevator activation based level plate
		{
			ifn sector[].floorz float
			{
				sub initsprite 1
				ife initsprite 20
				{
					set checkpoints NO
					savemapstate
					startlevel initflags SPRITELOTAG
					setuserdef[].display_bonus_screen NO
				}
			}
			
		}
		else
		ife initsprite 10 // distance based level plate
		{
			findplayer xydist
			ifl xydist 6144
			{
				set checkpoints NO
				ife mtype 2 set monstflags 2 // one use only
				savemapstate
				startlevel initflags SPRITELOTAG
				setuserdef[].display_bonus_screen NO
			}
		}
		else
		{
			set checkpoints NO
			
			// setarray loadx[LEVEL] player[].posx
			// setarray loady[LEVEL] player[].posy
			// setarray loadz[LEVEL] player[].posz
			ife mtype 2 set monstatus 2
			setarray keycards[LEVEL] player[].got_access
			setarray secretrooms[LEVEL] player[].secret_rooms
			setarray playerpar[LEVEL] player[].player_par
			setarray actorskilled[LEVEL] player[].actors_killed
			setarray savelevel[LEVEL] YES
			savemapstate
			al initflags
			al SPRITELOTAG
			ife mtype 2
			{
				set monstatus 2 // one use only
				setuserdef[].level_number SPRITELOTAG
				setplayer[].timebeforeexit 4
				setuserdef[].display_bonus_screen NO
				// mtype 2 means pal 2
				// this setting is used only for a fake secret exit
			}
			else
			{
				startlevel initflags SPRITELOTAG
				ifg initsprite 0 setuserdef[].display_bonus_screen YES
			}
		}
	}

break

case LEVELPLATE2

	ifn mtype 4 // not pal 4
	ife player[].cursectnum sprite[].sectnum
	{
		// reset ship cams array
		set temp 0
		whilevarn temp 100
		{
			setarray shipcams[temp] -1
			add temp 1
		}
		set shipcam -1
		
		set LOADMAP 0 // safety clear
		orvar LOADMAP 2 // trigger to search for pal 4 destination LEVELPLATE2
		set LAST_LEVEL LEVEL
		getp[].ang SAVEDANG
		set SAVEDANGCOUNT 7
		setuserdef[].display_bonus_screen NO
		setuserdef[].show_level_text NO
		ife initsprite YES
		{
			orvar LOADMAP 1
			savemapstate
		}

		startlevel initflags SPRITELOTAG
			
	}
	// pal 4 is destination only
	// lotag SPRITELOTAG = destination LEVEL; hitag initflags = volume
	// extra initsprite
	// if initsprite = 1, then save current level but not destination, 
	// otherwise load on destination but don't save current

break

case MATCHSTART

// SPRITELOTAG is the level it transports to
// initflags is the wave number the player must reach in order to be eligible
// checks to see if player is eligible for the level transport
// if so, and the player is in sector and close enough
// stops player with pop up asking if player is ready to start next match
// player can say yes, in which case it immediately starts that level, 
// or no, in which case it will not ask again unless player leaves sector and reeenters

ife mtype 1 // pal 1 at the elevator shaft
{
	ife player[].cursectnum sprite[].sectnum
	{
		findplayer xydist 
		switch wave
		case 3 ifl xydist 1560 set matchmenu 12164 else ife matchmenu 12164 set matchmenu NO break
		case 4 case 5
			ifl xydist 1560 set matchmenu 12165 else ife matchmenu 12165 set matchmenu NO break
		
		endswitch
	}
}
else
ife mtype 2 // pal 2 at the blue transporter
{
	ife player[].cursectnum sprite[].sectnum
	{
		findplayer xydist 
		switch wave
		case 10
		    ifl xydist 1560 set matchmenu 12163 else ife matchmenu 12163 set matchmenu NO break
		endswitch
	}
	else ife matchmenu 12163 set matchmenu NO
}
else
ife wave initflags
{
	findplayer xydist 
	ifl xydist 1560
	{
		ife player[].cursectnum sprite[].sectnum
		{
			// this next bit is a hack to prevent the player from entering certain matches
			// without having completed the ancients fights first
			// eventually this whole system should be redone with fewer sprites and no hacks
			
			ife SPRITELOTAG 17 ife vrdone 0 set matchmenu 12184 else
			ife SPRITELOTAG 20 ifl vrdone 2 set matchmenu 12184 else
			ife SPRITELOTAG 21 ife ancients 0 set matchmenu 12162 else
			ife SPRITELOTAG 23 ifl vrdone 3 set matchmenu 12184 else
			ife SPRITELOTAG 25 ifl ancients 4 set matchmenu 12162 else
			ife SPRITELOTAG 26 ifl ancients 7 set matchmenu 12162 else
			{
				set matchlevel SPRITELOTAG
				ife menuoff NO
				ife matchmenu NO
				{
					set matchmenu YES
					state autosave
				}
			}
		}
	}
	else ife matchmenu 12162 // more hacking
	{ 
		ife SPRITELOTAG 21 set matchmenu NO
		ife SPRITELOTAG 25 set matchmenu NO
		ife SPRITELOTAG 26 set matchmenu NO
	}
	else ife matchmenu 12184
	{ 
		ife SPRITELOTAG 17 set matchmenu NO
		ife SPRITELOTAG 20 set matchmenu NO
		ife SPRITELOTAG 23 set matchmenu NO
	}
	
}

break

case VRSET

ifn SPRITELOTAG 0
{
	ifg initsprite 0 ifge ancients initsprite killit
	
	findplayer xydist 
	ife vrkilled SPRITELOTAG
	{
		ifg xydist 1024 ifn sprite[].sectnum player[].cursectnum
			set vrkilled 0
		else set xydist 99999
	}
	ifl xydist 1560
	{
		ife countvar 0
		{
			set temp NO
			ife player[].cursectnum sprite[].sectnum set temp YES
			ifl xydist 1024
			{
				set temp YES
				set osector -1
			}
			ife temp YES
			{
				ife menuoff NO
				ife matchmenu NO
				{
					set temp YES
					ifg initsprite 0 
					{
						// ancients must be exactly one less than initsprite
						set tempb ancients
						add tempb 1
						ifn tempb initsprite set temp NO
					}
					ife temp YES
					{
						set matchmenu SPRITELOTAG
						set matchlevel SPRITELOTAG
						ifg initsprite 0 { mul matchmenu -1 set ancients_transport 3 }
						savenn 9
					}
				}
			}
		}
	}
	else ifn countvar 0 set countvar 0
	
}

break

case SOUNDPLATE

	ife mtype 0
	{
		ife player[].cursectnum sprite[].sectnum
		{
			ife SPRITELOTAG HEELTURN
			{
				stopallsounds
				set emp_overlay_tile 12266
				set cutcamtime player[].player_par	
				set emp_overlay 600
			} else
			ife SPRITELOTAG ONLINEPOLL
			{
				stopallsounds
				set emp_overlay_tile 12266
				set cutcamtime player[].player_par	
				set emp_overlay 1080
			} else
			ife SPRITELOTAG DONTGO
			{
				stopallsounds
				set emp_overlay_tile 12266
				set cutcamtime player[].player_par	
				set emp_overlay 210
			} else
			ife SPRITELOTAG ITSFINE
			{
				stopallsounds
				set emp_overlay_tile 12266
				set cutcamtime player[].player_par	
				set emp_overlay 800
			} else
			ife SPRITELOTAG FUNNIEST
			{
				stopallsounds
				set emp_overlay_tile 12266
				set cutcamtime player[].player_par	
				set emp_overlay 570
			}
			
			// globalsoundvar SPRITELOTAG
			screensound SPRITELOTAG
			
			ifn initflags 0
			{
				set musicwait initflags
				ife SPRITELOTAG PROT_BIGSPEECH 
				ifg player[].jetpack_amount 0
				{
					setp[].jetpack_amount 0
					setp[].jetpack_on NO
				}
				stopallmusic
			}
			killit
		}
	}
	else // spawned sound maker
	{
		ifn initsprite 0
		{
			soundvar SPRITELOTAG
			setactorsoundpitch THISACTOR SPRITELOTAG initsprite
		}
		else
		screensound SPRITELOTAG
		
		killit
	}

break

case MULTIPLATE

	ife SPRITELOTAG 0 killit
	
	ifn countvar 0
	{
		ifg countvar 0
		sub countvar 1
		else add countvar 1
		ife countvar 0 
		{
			state activatechannel 
			killit 
		}
	}
	else
	ife mtype 2 // waits for channel activation
	{
		ife droptile NO
		{
			checkactivatormotion SPRITELOTAG
			ife RETURN YES set droptile YES
		}
		ife droptile YES
		{
			set SPRITELOTAG initsprite
			ife initflags 0 // no delay
			{
				state activatechannel 
				killit
			}
			else ife countvar 0 set countvar initflags
		}
	}
	else
	ife player[].cursectnum sprite[].sectnum
	{
		ife initflags 0 // no delay
		{
			state activatechannel 
			killit
		}
		else ife countvar 0 set countvar initflags
	}

break

case GLOBALKILLER

	headspritestat spriteid 1
	whilevarn spriteid -1
	{
		ifg sprite[spriteid].z sprite[].z
		{
			seta[spriteid].htextra 100
			seta[spriteid].htpicnum RPG
			seta[spriteid].htowner THISACTOR
			ife sprite[spriteid].picnum BLUEFLAG
			{
				set bluecarrier -1
				setav[spriteid].monstatus 2
				getav[spriteid].myspawner temp
				setav[temp].mtype 1
			}
			ife sprite[spriteid].picnum REDFLAG
			{
				set redcarrier -1
				setav[spriteid].monstatus 2
				getav[spriteid].myspawner temp
				setav[temp].mtype 1
			}
		}
		nextspritestat spriteid spriteid
	}

break

case REACTOR2SPARK
	ifspawnedby APLAYER
	{
		ife initsprite 0
		{	
			sizeat 8 16
			cstat 32
			spritepal 21
			set initsprite 1	
		}
	}
	ife initsprite 1
	{
		add countvar 1
		ifg countvar 4 cstator 2
		ifg countvar 6 cstator 512
		ifg countvar 8 killit
	}

break

case ACCESSSWITCH
case ACCESSSWITCH2
case REACTOR2
ife float 32768 
{
	ife sprite[myspawner].statnum 1024 killit else
	ifn sprite[myspawner].picnum sprite[].picnum killit else
	ife userdef[].overhead_on 2 
	{
		cstat 32
		geta[myspawner].ang angvar
		add angvar 1024
		seta[].ang angvar
	}
	else cstat 32768
}
break

case CRACK1
case CRACK2
case CRACK3
case CRACK4
	ife float 32768 
	{
		ife sprite[myspawner].statnum 1024 killit else
		ifn sprite[myspawner].picnum sprite[].picnum killit else
		ife userdef[].overhead_on 2 
		{
			cstat 32
			geta[myspawner].ang angvar
			add angvar 1024
			seta[].ang angvar
		}
		else cstat 32768
	}
	ife monstatus 2 killit
	
break

case ACCESSCARD 
	ife float 32768 
	{
		ife sprite[myspawner].statnum 1024 killit else
		ifn sprite[myspawner].picnum sprite[].picnum killit else
		ife userdef[].overhead_on 2 
		{
			cstat 32
			geta[myspawner].ang angvar
			add angvar 1024
			seta[].ang angvar
		}
		else cstat 32768
	}
	else
	{
		set monstatus 100 strength 1
		ife radaron YES
		{
		geta[].sectnum mysector
		ifn sector[mysector].lotag 32767
		ifn sprite[].statnum 1
		changespritestat THISACTOR 1
		}
	}
break

case BREADCRUMB
	cstat 32768
	add countvar 1
	ifg countvar 1800 
	{
		changespritestat THISACTOR 1
		killit
	}
	ifl player[].player_par mtype
	{
		changespritestat THISACTOR 1
		killit
	}
break


case TEAM_TARGET
	cstat 32768
	// ife sprite[mysignpost].statnum 1024 
	// {
		// setav[mysignpost].mysignpost -1
		// killit
	// }
	// ife actorvar[mysignpost].monstatus 2 
	// {
		// setav[mysignpost].mysignpost -1
		// killit
	// }
	// getav[mysignpost].team team
	// geta[mysignpost].z z
	// sub z 8192
	// setsprite THISACTOR sprite[mysignpost].x sprite[mysignpost].y z
	// getav[mysignpost].monstatus monstatus
break

case BULLETHOLE
ife mtype 1024 cstat 32768
break

case SABERSCORCH

	ife initsprite 0
	{
		ifn saberpos 10 ifn saberpos 26 ifn saberpos 42
		ifn saberpos 54 ifn saberpos 67 killit else
		ifg saberpos 7 ifl saberpos 13 cstat 16 else
		ifg saberpos 23 ifl saberpos 29 cstat 20 else
		ifg saberpos 38 ifl saberpos 45 cactor SABERSCORCH2 else
		ifg saberpos 51 ifl saberpos 57 cstat 20 else
		ifg saberpos 64 ifl saberpos 70 cstat 16
		cstator 192 // half-submerged plus one-sided
		set initsprite YES
		geta[].htflags temp
		orvar temp 128
		seta[].htflags temp
		
		ife pchar 2
		{
			headspritestat spriteid 0
			set B 0
			whilevarn spriteid -1
			{
				ife sprite[spriteid].picnum 19897
				ifactor SABERSCORCH
				{
					ife sprite[].cstat sprite[spriteid].cstat
					{
						dist temp THISACTOR spriteid
						ifl temp 128 set B 1
					}
				}
				else
				ife sprite[spriteid].picnum 19898
				ifactor SABERSCORCH2
				{
					dist temp THISACTOR spriteid
					ifl temp 128 set B 1
				}
				nextspritestat spriteid spriteid
			}
			ife B 1 killit else
			ifactor SABERSCORCH cactor 19897 else
			ifactor SABERSCORCH2 cactor 19898
		}
	}
break


case APLAYER

	// ife pchar 1
	ifn player[].newowner -1
	{
		ife shellydummy -1
		{
			espawn SHELLYDUMMY
			set angvar sprite[player[].i].ang
			// add angvar 512
			setav[RETURN].angvel angvar
			seta[RETURN].mdflags 16
			set shellydummy RETURN
		}
	}
	else set shellydummy -1
	
	ife THISACTOR player[].holoduke_on
	{
		ife pchar 2
		{
			espawn NAAMAH
			set mynaamah RETURN
			setp[].holoduke_on -1
			killit
		}
		set team 1
		cstator 2
		ifrnd 1 state holotaunts
		// initflags ==0 normal; 1==teleporting; 2-20=teabagging even numbers stand odd crouch
		
		ifvarand inven_upgrades 4
		{
			ife initflags 0
			ifn bottarget -1
			ife actorvar[bottarget].monstatus 2
			{
				set initflags 1
				set startx sprite[bottarget].x
				set starty sprite[bottarget].y
				set float sprite[bottarget].z
				cstat 32768
				spawn TRANSPORTERSTAR
				sound TELEPORTER
				set countvarb 0
			}
			
			ife initflags 1
			{
				add countvarb 1
				ifge countvarb 10
				{
					
					setsprite THISACTOR startx starty float
					
					set bottarget -1
					spawn TRANSPORTERSTAR
					sound TELEPORTER
					set initflags 2
					set countvarb 0
					
					cstat 32768
					espawn HOLOBAGGER
					set myspawner RETURN
					seta[RETURN].xrepeat sprite[].xrepeat
					seta[RETURN].yrepeat sprite[].yrepeat
					seta[RETURN].ang sprite[].ang
					setav[RETURN].mtype THISACTOR
				}
			}
			
			ifge initflags 2 ifle initflags 20
			{
				cstat 32768
				fall
				add countvarb 1
				ifge countvarb 5 
				{ 
					add initflags 1 set countvarb 0
					ife initflags 21 setav[myspawner].mtype -1
				}
			}
			
			ife initflags 21
			{
				cstat 2
				set initflags 0
				set countvarb 0
				set countvar 0
			}
			
			ife initflags 0
			{
				cstator 2
				state targetsearch
				ifn bottarget -1
				{
					set spriteid bottarget
					state facesprite
					add countvar 1
					ifge countvar 3
					{
						cactor EDFSNIPER
						set countvar 0
						sound CHAINGUN_FIRE
						state hitscan_targetprep
						zshoot zdist CHAINGUN
						cactor APLAYER
						spawn AIRFLASH1
						getp[].holoduke_amount temp
						sub temp 3
						ifl temp 1 set temp 1
						setp[].holoduke_amount temp
					}
				}
			}
		}
	}

break

case HEAVYHBOMB
ifg sprite[].xvel 32
{
	state projectilehitscan
	seta[].mdflags 16
	add countvar 1
	ifg countvar 3 set countvar -2
	
}

ife PIPEBOMB_CONTROL 2
{
	ifn sprite[].htmovflag 0 
	{
		geta[].htmovflag temp
		addvar temp 16384
		ifvarl temp 16384 ifvarg temp -1 
		{ 
			ife sprite[temp].statnum 1
			{
			seta[].htextra 10, seta[].htpicnum RPG seta[].htowner player[].i 
			}
		}
	}
}
break

case WALLARROW
	ifvare botclip 0
	{
		ifvare droptile APLAYER
		ifvarn bottarget -1
			state validatedecal
		
	}
	ifp pfacing ifpdistl 1280
	{
		ifvarand sprite[].cstat 16
		{
			ifl player[].fta 90 { setp[].ftq 1189 setp[].fta 100 }
			ifhitspace
			{
			add arrows 1
			ifg arrows player[].max_ammo_amount SHOTGUN_WEAPON set arrows player[].max_ammo_amount SHOTGUN_WEAPON
			globalsound DUKE_GET
			palfrom 16 0 32
			ife player[].ftq 1189 setp[].fta 0
			}
		}
		ifhitspace killit
	}
	add countvar 1
	ifge countvar 1800 killit
break

case VERTARROW 
	ifp pfacing ifpdistl 1024
	{
		ife initsprite APLAYER
		{
			ifl player[].fta 90 { setp[].ftq 1189 setp[].fta 100 }
			ifhitspace
			{
			add arrows 1
			ifg arrows player[].max_ammo_amount SHOTGUN_WEAPON set arrows player[].max_ammo_amount SHOTGUN_WEAPON
			globalsound DUKE_GET
			palfrom 16 0 32
			ife player[].ftq 1189 setp[].fta 0
			}
		}
		ifhitspace killit
	}
	add countvar 1
	ifge countvar 1800 killit
break

case STALL
	ife pchar 1
	ife player[].last_pissed_time 0	
	{
		ifangdiffl 512 nullop else
		ifpdistl 1780
		ifcansee
		setp[].last_pissed_time 30
	}
	
	ife droptile 0
	ifangdiffl 512 nullop else
	ifpdistl 1780
	ifcansee 
	ifp pfacing
	{
		set temp NO
		ifhitspace set temp YES
		ife player[].last_pissed_time 5690
			set temp YES
		ife temp YES
		ifsound FLUSH_TOILET
		{
			seta[].mdflags 16
			set droptile 9247
			set countvar 120
		}
	}
	ifg countvar 0
	{
		sub countvar 1
		ife countvar 0 set droptile 0
	}
break

case TRIPBOMB
add countvar 1
ifg countvar 20
{
	ifspawnedby APLAYER
	{
		ifp pfacing
		ifp palive
		ifpdistl 1024
		{
			ifhitspace
			{
			sound SWITCH_ON
			stopsound DUKE_GRUNT
			stopsound B_GRUNT2
			cactor TRIPBOMBSPRITE
			changespritestat THISACTOR 1
			set countvar 0
			cstat 0
			geta[].xrepeat x
			mul x 4
			seta[].xrepeat x
			geta[].yrepeat y
			mul y 4
			seta[].yrepeat y
			}
			else ifl player[].fta 30 quote 125
		}
		else ifg player[].fta 0 ife player[].ftq 125 setp[].fta 0
	}
	else
	{
		ifhitspace
		ifp pfacing
		ifp palive
		ifpdistl 1024
		ifl player[].fta 30 quote 126
	}
}
break

case LASERLINE
ifn myspawner -1
{
	ifn sprite[myspawner].picnum mtype
	{
		changespritestat THISACTOR 1
		killit
	}
}

break

case GREENSLIME
case 2371 case 2372 case 2373 case 2374 case 2375 case 2376 case 2377

	ifvarand monstflags 4096 // radiation aura
	ife monxp 0
	{
		set monxp 100
		espawn RADAURA
		setav[RETURN].myspawner THISACTOR
		// seta[RETURN].pal 22
	}
	set temp NO
	set burning 0
	ifg sidekick 2 set temp YES
	ifn qk_proxy 0 set temp YES
	ifn slidekick 0 set temp YES
	ifn jumpkick 0 set temp YES
	ife player[].somethingonplayer THISACTOR
	ife temp YES
	{
		// setvarvar x2 sprite[].x
		// addvar x2 644
		// rotatepoint sprite[].x sprite[].y x2 sprite[].y player[].ang x y
		// setactor[].x x
		// setactor[].y y
			
		spritepal 6
		guts JIBS3 4
		// sound SLIM_DYING
		seta[].htg_t 0 0
		seta[].htextra 10
		setp[].somethingonplayer -1
		
	}
break

case COOLEXPLOSION1
ife mtype 1
{
	seta[].extra 80
	spawn FRAMEEFFECT1
	sizeto 255 255
	sizeto 255 255
	ifspritepal 6 spritepal 0 else spritepal 6
}
state projectilehitscan
break

case WALLBLOOD1
ifn mtype 0
{
	fall
	ife mtype 1 { changespritestat THISACTOR 1 insertspriteq set mtype 2 }
	sizeto 32 32
}
break

case WATERDRIP

ife initsprite 0
{
	state checkfloordist
	ifl temp 1024 // 3072
	{
		espawn WATERDRIPSPLASH
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		seta[RETURN].pal sprite[].pal
		changespritestat RETURN 1
	}
}

break

case SPIT

	ifvarand initflags 8
	{
		ifspritepal 6 spritepal 0 else spritepal 6
	}
break

case JIBS1
case JIBS2
case JIBS3
case JIBS4
case JIBS5

	state randomturn

	ife mtype YES
	{
		set initsprite 15
		spritepal 2
		seta[].mdflags 16
		ifpdistl 844
		{
			getp[].i temp
			getav[temp].burning tempb
			add tempb 5
			setav[temp].burning tempb
			seta[temp].htowner THISACTOR
			seta[temp].htang sprite[].ang
			seta[temp].htpicnum FIRELASER
			killit
		}
	}

	ifvarl initsprite 15
	{
		ife initsprite 0
		{
			ifactor JIBS2 { geta[].xrepeat x mulvar x 2 seta[].xrepeat x seta[].yrepeat x }
		}
		ifvarn sprite[].pal 1
		ife shrunken 0
		{
			espawn JIBS6
			seta[RETURN].zvel 0
			seta[RETURN].xvel 24
			randvar temp 2047
			seta[RETURN].ang temp
			seta[RETURN].xrepeat 12 // 24
			seta[RETURN].yrepeat 12 // 24
			setav[RETURN].init_xrepeat 12
			setav[RETURN].init_yrepeat 12
			seta[RETURN].pal sprite[].pal
		}
		add initsprite 1
	}

	state checkfloordist
	ifvarl temp 2048
	{
		ife mtype YES
		{
			ifrnd 16 { ifrnd 128 spawn BURNING else spawn BURNING2 }
			killit
		}
		else
		{
		seta[].htflags 128
		geta[].picnum picnum
		add picnum 4
		espawnvar picnum
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		seta[RETURN].pal sprite[].pal
		setav[RETURN].initsprite 1
		}
	}

break

case JIBS6
	ife init_xrepeat 0
	{
		geta[].xrepeat init_xrepeat
		div init_xrepeat 2
		seta[].xrepeat init_xrepeat
		geta[].yrepeat init_yrepeat
		div init_yrepeat 2
		seta[].yrepeat init_yrepeat
	}
		
break

case HEADJIB1
case ARMJIB1
case LEGJIB1
case LIZMANHEAD1
case LIZMANARM1
case LIZMANLEG1

	state randomturn

	ifvarl initsprite 15
	{
		ifvarn sprite[].pal 1
		{
			espawn JIBS6
			seta[RETURN].zvel 0
			seta[RETURN].xvel 24
			randvar temp 2047
			seta[RETURN].ang temp
			seta[RETURN].xrepeat 12 // 24
			seta[RETURN].yrepeat 12 // 24
			seta[RETURN].pal sprite[].pal
		}
		add initsprite 1
	}

	state checkfloordist
	ifvarl temp 2048
		state spawngroundjib
	else ifn sprite[].htmovflag 0 state spawngroundjib
	

break

case RECON

ifn monstatus 2
{
	state recontilt

	ifwasweapon SHRINKSPARK 
	{ 
		ife shrunken 0 set shrunken 1 
		sound ACTOR_SHRINKING 
		seta[].htpicnum SHOTSPARK1
	}
	ifg botclip 0
	{
		geta[].extra temp
		add temp botclip
		seta[].extra temp
		seta[].htextra botclip
		seta[].htowner player[].i
		set botclip 0
	}
	ifg sprite[].extra 0
	state monsterai
	else { set monstatus 2 set burning 0 }
	ifg shrunken 10 ifl shrunken SHRUNKCOUNT
	{
		ifactorsound THISACTOR RECO_ROAM { stopactorsound THISACTOR RECO_ROAM soundonce RECO_ROAMSHR }
		ifactorsound THISACTOR RECO_RECOG { stopactorsound THISACTOR RECO_RECOG sound RECO_RECOGSHR }
		ifactorsound THISACTOR RECO_ATTACK { stopactorsound THISACTOR RECO_ATTACK sound RECO_ATTACKSHR }
		ifactorsound THISACTOR RECO_PAIN { stopactorsound THISACTOR RECO_PAIN sound RECO_PAINSHR }
		ifactorsound THISACTOR RECO_DYING { stopactorsound THISACTOR RECO_DYING sound RECO_DYINGSHR }
	}
}
break

case LIZELITE
case LIZELITECROUCH
case MANDOFETT
case MANDOCROUCH
ifg gametype 0
ifn sprite[].statnum 1
ifg burning -1
changespritestat THISACTOR 1
break

case PIGSUV
case PATROLSENTRY
case SHELLY
case SHELLYCROUCH
case DUKEBOT
case DUKEBOTCROUCH
case WESBOT
case WESBOTCROUCH
case NEWRECON
case SMOKER
ifn sprite[].statnum 1
changespritestat THISACTOR 1
break

case SHELL
case SHOTGUNSHELL
ife initsprite 0
{
	ifspawnedby PIGBOSS sizeat 18 18
	ife mtype CLIPFALL { spawn CLIPFALL killit }
	geta[].sectnum mysector
	ifn mysector -1
	{
		getflorzofslope mysector sprite[].x sprite[].y z
		getactor[].z temp
		sub z temp
		ifvarl z 512
		{
			
			ifinwater nullop else
			{
				ifactor SHELL
				{
					ifrnd 128 sound SHELLFALL1 else sound SHELLFALL2
				}
				ifactor SHOTGUNSHELL
				{
					ifrnd 128 sound SHOTSHELLFALL1 else sound SHOTSHELLFALL2
				}
			}
			// changespritestat THISACTOR 1
			// cstat 32
			ifactor SHELL espawn NEWSHELL
			ifactor SHOTGUNSHELL espawn NEWSHOTGUNSHELL
			seta[RETURN].xrepeat sprite[].xrepeat
			seta[RETURN].yrepeat sprite[].yrepeat
			set initsprite 1
			cstat 32768
		}
	}
}
break


case SCRAP6 case 2391 case 2392 case 2393 case 2394 case 2395
case 2396 case 2397 case 2398 case 2399 case SCRAP1 case 2401 
case 2402 case 2403 case SCRAP2 case 2405 case 2406 case 2407


ife init_xrepeat 0
{
	geta[].xrepeat init_xrepeat
	div init_xrepeat 2
	seta[].xrepeat init_xrepeat
	geta[].yrepeat init_yrepeat
	div init_yrepeat 2
	seta[].yrepeat init_yrepeat
}

ife mtype 1
{
	espawn SMALLSMOKE
	seta[RETURN].pal 4
	seta[RETURN].cstat 130
}

// ifn sprite[].htpicnum SECTOREFFECTOR
// {
	// ifl framerate 20 killit
	// else
	// ifg framerate 35
	// ifl Numsprites 14000
	// {
		// findnearspritez EXPLOSION2 2048 16384 spriteid
		// ifn spriteid -1
		// {
			// espawn SMALLSMOKE
			// seta[RETURN].pal 4
			// seta[RETURN].cstat 130
		// }
		// else
		// {
			// findnearspritez MINEEXP 2048 16384 spriteid
			// ifn spriteid -1
			// {
				// espawn SMALLSMOKE
				// seta[RETURN].pal 4
				// seta[RETURN].cstat 130
			// }
		// }
	// }
// }

break

case SCRAP3 case SCRAP4 case SCRAP5
case 2409 case 2410 case 2411 case 2413 case 2414 case 2415 case 2417 case 2418

ife init_xrepeat 0
{
	geta[].xrepeat init_xrepeat
	div init_xrepeat 2
	seta[].xrepeat init_xrepeat
	geta[].yrepeat init_yrepeat
	div init_yrepeat 2
	seta[].yrepeat init_yrepeat
}
break


case AATELEPORTER

	// myspawner is matching teleporter
	// countvar will be used for player in sector
	// damflash is pal color if nonzero
	// initsprite is sound # if nonzero
	ifn myspawner -1
	{
		ife countvar 0
		{
			ife player[].cursectnum sprite[].sectnum
			{
				ifn initsprite 0 screensound initsprite
				ifspritepal 1 palfrom 42 0 0 63 else
				ifspritepal 2 palfrom 42 63 0 0 else
				ifspritepal 8 palfrom 42 0 63 0 else
				ifspritepal 7 palfrom 42 63 0 63
				
				setp[].posx sprite[myspawner].x
				setp[].posy sprite[myspawner].y
				set z sprite[myspawner].z, sub z 8192
				setp[].posz z
				add z 8192
				setsprite player[].i sprite[myspawner].x sprite[myspawner].y sprite[myspawner].z
				setp[].cursectnum sprite[myspawner].sectnum
				seta[player[].i].sectnum sprite[myspawner].sectnum
				setp[].ang sprite[myspawner].ang
				seta[player[].i].ang sprite[myspawner].ang
				lockplayer 2
				setav[myspawner].countvar 3
				setav[myspawner].countvarb 3
				setp[].posxv 0
				setp[].posyv 0
			}
		}
		else
		{
			ifn player[].cursectnum sprite[].sectnum sub countvar 1
			else ifg countvarb 0
			{
				sub countvarb 1
				cos kickfvel sprite[].ang
				sin kicksvel sprite[].ang
				
				mul kicksvel 100
				mul kickfvel 100
				
				setp[].posxv kickfvel
				setp[].posyv kicksvel
			}
			
		}
	}

break

case MOVESHIPCAM

	ifn initflags 0
	ife SPRITELOTAG 1
	{
	
		// the starting cam has an activation tag
		checkactivatormotion initflags
		ifvare RETURN YES set initflags 0
	}
	
	ife initflags 0
	ife shipcam -1
	ife SPRITELOTAG 1
	{
		getp[].posx startx
		getp[].posy starty
		getp[].posz droptile
		set shipcam THISACTOR
		set shipangoff countvarc
		changespritestat THISACTOR 1
		
		ife initsprite 0
		{
			ifmove 0
			move SHIPMOVE0 geth
			
		}
		set tempH sprite[].sectnum
		updatesector sprite[].x sprite[].y tempH
		ifg tempH -1 ifl tempH 4096 changespritesect THISACTOR tempH
		set spriteid 0
		whilevarn spriteid 16384
		{
			ife sprite[spriteid].picnum MOVESHIPCAM
			ife actorvar[spriteid].SPRITELOTAG 2
			{
				set bottarget spriteid 
				set spriteid 16383
			}
			add spriteid 1
		}
		geta[].ang mtype
	}
	ife shipcam THISACTOR 
	{
		seta[].htflags 18432
		ife monstatus 2
		{
			getactor[shipcam].z z
			getav[shipcam].droptile z2
			sub z2 player[].posz
			sub z z2
			setp[].posz z
			
			getp[].posx x2
			getp[].posy y2
			getav[shipcam].startx x
			getav[shipcam].starty y
			subvarvar x2 x
			subvarvar y2 y
			getangle angvar x2 y2 // angvar is now the displacement angle
			
			add angvar shipangoff
			
			set xydist x
			sub xydist player[].posx
			mul xydist xydist
			sub y player[].posy
			mul y y
			add xydist y
			sqrt xydist xydist
			set xvel sprite[shipcam].x
			add xvel xydist
			add angvar sprite[shipcam].ang
			rotatepoint sprite[shipcam].x sprite[shipcam].y xvel sprite[shipcam].y angvar x2 y2
			updatesector x2 y2 tempH
			set tempH sprite[shipcam].sectnum
			ife tempH -1 set tempH sprite[shipcam].sectnum
			setp[].posx x2
			setp[].posy y2
			setp[].cursectnum tempH
			getav[shipcam].mtype angvar
			add angvar player[].ang
			ifn shipangstart 999999
			sub angvar shipangstart
			setp[].ang angvar
			set shipcam -2
			//stopsound TRAINLOOP
			
			// ifn bottarget -1 setav[bottarget].monstatus 2
			set monstatus 0
			set transition 0
		}
		ifn monstflags 0
		ifn SPRITELOTAG 1
		{
			ife monstflags 1
			{
				setp[].ang sprite[].ang
				setp[].posx sprite[].x
				setp[].posy sprite[].y
				setp[].posz sprite[].z
				setp[].cursectnum sprite[].sectnum
				set shipcam -2
				stopsound TRAINLOOP
				// stopsound SHIPAIR
				setsprite THISACTOR countvar countvarb float
				move 0
				set transition 0
			}
			else
			{
				set spriteid 0
				whilevarn spriteid 16384
				{
					ife sprite[spriteid].picnum FAKEDOOR
					ife actorvar[spriteid].initsprite monstflags
					{
						seta[spriteid].pal 0
						seta[spriteid].cstat 16
					}
					add spriteid 1
				}
			}
		}
		else
		ife bottarget -1
		{
			set temp SPRITELOTAG
			add temp 1
			ifspritepal 23 set temp 1
			set spriteid 0
			whilevarn spriteid 16384
			{
				ife sprite[spriteid].picnum MOVESHIPCAM
				ife actorvar[spriteid].SPRITELOTAG temp
				{
					set bottarget spriteid 
					set spriteid 16383
				}
				add spriteid 1
			}
		}
		// iffloordistl 160 
		// ifg shipcam -1
		// {
			// ifsound SHIPWATER nullop else 
			// {
				// ife camerasprite -1
				// {
					// ife sector[].lotag 1 screensound SHIPWATER
					// else ifsound SHIPAIR nullop else
					// screensound SHIPAIR
				// }
			// }
		// }
		// else stopsound SHIPWATER
		
		// iffloordistl 128 stopsound SHIPAIR else 
		// ifg shipcam -1 { ifsound SHIPAIR nullop else ife camerasprite -1 screensound SHIPAIR }
					
	}
	else setsprite THISACTOR countvar countvarb float // maintain original coords
	
	ifg initsprite 0
	{
		ifg player[].player_par 2 ifn SPRITELOTAG 1 set initsprite 0
		set RETURN NO
		checkactivatormotion initsprite
		ifvare RETURN YES 
		{
			setvar initsprite 0
			ifmove 0
			{
				move SHIPMOVE0 geth
				set trainspeed 1
			}
		}
	}
	else ife initsprite -1
	{
		set initsprite 0
		ifmove 0
		{
			move SHIPMOVE0 geth
			set trainspeed 1
		}
	}
	
	ifn bottarget -1
	ife initsprite 0
	{
		ldist xydist THISACTOR bottarget
		seta[].ang mtype
		ifmove 0 nullop else
		{
			getactor[bottarget].x x2
			getactor[bottarget].y y2
			getactor[].x x
			getactor[].y y
			subvarvar x2 x
			subvarvar y2 y
			getangle angvar x2 y2
			getactor[].ang tempb
			getincangle tempd angvar tempb
			
			ifvarl tempd 7 ifvarg tempd -7
			{
				setactor[].ang angvar
				// ifspritepal 2
				// {
					// ifcount 2
					// {
					    // ifmove SHIPMOVE8 { move SHIPMOVE6 geth set trainspeed 8 } else
						// ifmove SHIPMOVE7 { move SHIPMOVE6 geth set trainspeed 7 } else
						// ifmove SHIPMOVE6 { move SHIPMOVE5 geth set trainspeed 6 } else
						// ifmove SHIPMOVE5 { move SHIPMOVE4 geth set trainspeed 5 } else
						// ifmove SHIPMOVE4 { move SHIPMOVE3 geth set trainspeed 4 } else
						// ifmove SHIPMOVE3 { move SHIPMOVE2 geth set trainspeed 3 } else
						// ifmove SHIPMOVE2 { move SHIPMOVE1 geth set trainspeed 2 }
					// }
				// }
			}
			else
			{
				// ifl tempd 0 { set temp NO add tempb 12 }
				// else { sub tempb 12 set temp YES }
				
				// shiftl tempd 8
				// div tempd xydist
				
				
				div tempd 6
				
				ifg tempd 0 { ifl tempd 7 set tempd 7 }
				else ifl tempd 0 { ifg tempd -7 set tempd -7 }
				
				sub tempb tempd
				
				// ife temp NO { ifg tempb angvar set tempb angvar }
				// ife temp YES { ifl tempb angvar set tempb angvar }
				
				
				setactor[].ang tempb
				
				ifmove SHIPMOVE8 { move SHIPMOVE6 geth set trainspeed 8 } else
				ifmove SHIPMOVE7 { move SHIPMOVE6 geth set trainspeed 7 } else
				ifcount 2
				{
					ifmove SHIPMOVE6 { move SHIPMOVE5 geth set trainspeed 6 } else
					ifmove SHIPMOVE5 { move SHIPMOVE4 geth set trainspeed 5 } else
					ifmove SHIPMOVE4 { move SHIPMOVE3 geth set trainspeed 4 } else
					ifmove SHIPMOVE3 { move SHIPMOVE2 geth set trainspeed 3 } 
					// else ifmove SHIPMOVE2 { move SHIPMOVE1 geth set trainspeed 2 } 
					// else ifmove SHIPMOVE1 { move SHIPMOVE0 geth set trainspeed 1 }
				}
				
			}
			// vertical movement
			geta[bottarget].z z2
			sub z2 sprite[].z
			// shiftl z2 10
			mul z2 768
			div z2 xydist
			movesprite THISACTOR 0 0 z2 CLIPMASK0 RETURN
			mul z2 -1
			set shotpitch z2
			
			
		}
		geta[].ang mtype
		
		ifn actorvar[bottarget].monstflags 0 // end of journey
		ifn actorvar[bottarget].SPRITELOTAG 1
		{
			ifl xydist 512 // disembark
			{
				stopsound TRAINLOOP
				set shipcam bottarget
				setav[bottarget].startx startx
				setav[bottarget].starty starty
				setav[bottarget].droptile droptile
				// palfrom 63 1 1 1
				setsprite THISACTOR countvar countvarb float
				move 0
				
			}
			else
			ifl xydist 1536
			{
				ifmove SHIPMOVE1
				{
					move SHIPMOVE0 geth
					set trainspeed 1
				}
			}
			else
			ifl xydist 4096
			{
				ifmove SHIPMOVE2
				{
					move SHIPMOVE1 geth
					set trainspeed 2
				}
			}
			else
			ifl xydist 8192 
			{
				ifmove SHIPMOVE4
				move SHIPMOVE3 geth
				ifmove SHIPMOVE3 ifcount 30
				move SHIPMOVE2 geth
			}
			else
			ifl xydist 12288
			{
				ifmove SHIPMOVE6
				move SHIPMOVE6 geth
				else
				ifmove SHIPMOVE6
				move SHIPMOVE5 geth
				else
				ifmove SHIPMOVE5
				move SHIPMOVE4 geth
				else
				ifmove SHIPMOVE4
				move SHIPMOVE3 geth
			}
			else
			{
				ifmove SHIPMOVE0 ifcount 20 { move SHIPMOVE1 geth set trainspeed 2 } else
				ifmove SHIPMOVE1 ifcount 20 { move SHIPMOVE2 geth set trainspeed 3 } else
				ifmove SHIPMOVE2 ifcount 20 { move SHIPMOVE3 geth set trainspeed 4 } else
				ifmove SHIPMOVE3 ifcount 20 { move SHIPMOVE4 geth set trainspeed 5 } else
				ifmove SHIPMOVE4 ifcount 20 { move SHIPMOVE5 geth set trainspeed 6 } else
				ifmove SHIPMOVE5 ifcount 20 { move SHIPMOVE6 geth set trainspeed 7 } else
				ifmove SHIPMOVE6 ifcount 20 { move SHIPMOVE7 geth set trainspeed 8 } else
				ifmove SHIPMOVE7 ifcount 20 { move SHIPMOVE8 geth set trainspeed 9 }
				
			}
		}
		else
		{
			ifl xydist 844 // 644
			{
				set shipcam bottarget
				setav[bottarget].startx startx
				setav[bottarget].starty starty
				setav[bottarget].droptile droptile
				seta[bottarget].ang sprite[].ang
				seta[bottarget].xvel sprite[].xvel
				setav[bottarget].mtype mtype
				setav[bottarget].ikicked ikicked
				setsprite bottarget sprite[].x sprite[].y sprite[].z
				setsprite THISACTOR countvar countvarb float
				seta[].x countvar, seta[].y countvarb, seta[].z float
				ifn botclip -1 changespritesect THISACTOR botclip
				move 0
				set bottarget -1
			}
			else
			{
				ifmove SHIPMOVE0 { ifcount 16 move SHIPMOVE1 geth set trainspeed 2 } else
				ifmove SHIPMOVE1 { ifcount 16 move SHIPMOVE2 geth set trainspeed 3 } else
				ifmove SHIPMOVE2 { ifcount 16 move SHIPMOVE3 geth set trainspeed 4 } else
				ifmove SHIPMOVE3 { ifcount 16 move SHIPMOVE4 geth set trainspeed 5 } else
				ifmove SHIPMOVE4 { ifcount 16 move SHIPMOVE5 geth set trainspeed 6 } else
				ifmove SHIPMOVE5 { ifcount 16 move SHIPMOVE6 geth set trainspeed 7 } else
				ifmove SHIPMOVE6 { ifcount 16 move SHIPMOVE7 geth set trainspeed 8 } else
				ifmove SHIPMOVE7 { ifcount 16 move SHIPMOVE8 geth set trainspeed 9 }
			}
		}
		ife shipcam THISACTOR
		ife initsprite 0 ifmove 0 
		{
			ife trainspeed 1
			move SHIPMOVE0 geth else
			ife trainspeed 2
			move SHIPMOVE1 geth else
			ife trainspeed 3
			move SHIPMOVE2 geth else
			ife trainspeed 4
			move SHIPMOVE3 geth else
			ife trainspeed 5
			move SHIPMOVE4 geth else
			ife trainspeed 6
			move SHIPMOVE5 geth else
			ife trainspeed 7
			move SHIPMOVE6 geth else
			ife trainspeed 8
			move SHIPMOVE7 geth else
			move SHIPMOVE8 geth
		}
		
		
			// ifmove 0 nullop else
			// ifactorsound THISACTOR TRAINLOOP nullop else sound TRAINLOOP
			ifg sprite[].xvel ikicked add ikicked 16 else
			ifl sprite[].xvel ikicked sub ikicked 16
			ifmove 0 set ikicked 0
			// setactorsoundpitch THISACTOR TRAINLOOP ikicked
		
	}
	
	
break

case WESCREDITS
	ife initsprite 0
	{
		set initsprite 1
		setuserdef[].display_bonus_screen 0
		set charsel 4
		set startmode 4
		set midscreen 14829
		set crawlfirstline 1288
		set cutend totalclock
		add cutend 18000
		set cutmash 0
		set crawlclock totalclock
		set crawlnumlines 62
		startscreen
		palfrom 63 0 0 0
		orvar charlocked 4
		savegamevar charlocked
		endofgame 2
	}
	break

default

	ifg navmode 0 ifn gametype 0 
	{
		ifn sprite[].statnum 1 ifg burning -1 changespritestat THISACTOR 1
	}
	else
	ifn sprite[].statnum 4
	ife navmode 0
	{
		geta[].htflags temp
		orvar temp 128
		seta[].htflags temp
	}
break

endswitch

endevent

defstate switchbulletcode

    getactor[].htmovflag spriteid
	addvar spriteid 16384
	ifvarl spriteid 16384 ifvarg spriteid -1
	ife actorvar[spriteid].monstatus 1 break

	getp[].posx savx
	getp[].posy savy
	getp[].posz savz
	getp[].ang savedvalue
	getp[].horiz angvel
	
	geta[].picnum safecount
	cactor APLAYER
	setp[].posx sprite[].x
	setp[].posy sprite[].y
	setp[].posz sprite[].z
	// setp[].ang sprite[].ang
	ifg spriteid -1 ifl spriteid 16384
	{
		ifvarand sprite[spriteid].cstat 32
		{
			ifg player[].posz sprite[spriteid].z setp[].horiz 299
			else setp[].horiz -99
		}
	}
	else
	setp[].horiz 100
	shoot SWITCHBULLET
	geta[].z z
	sub z 768
	setp[].posz z
	shoot SWITCHBULLET
	seta[].picnum safecount
	setp[].posx savx
	setp[].posy savy
	setp[].posz savz
	setp[].ang savedvalue
	setp[].horiz angvel
ends

state arrowhitscan
	geta[].zvel z
	geta[].xvel xvel
	shiftvarl z 14
	ife xvel 0 set xvel 1
	divvarvar z xvel
	cos mycos sprite[].ang
	sin mysin sprite[].ang
	hitscan sprite[].x sprite[].y sprite[].z sprite[].sectnum mycos mysin z hitsector hitwall hitsprite hitx hity hitz 4294901808
ends

defstate arrow_killit_code

	sizeat 10 10

	// ifspritepal 1 // freeze arrow
	// {
		// headspritestat temp 1
		// whilevarn temp -1
		// {
			// ifvare actorvar[temp].monstatus 1
			// {
				// dist tempb THISACTOR temp
				// ifvarl tempb 6144
				// {
					// setvar tempd 16384
					// getactor[temp].extra tempb
					// ifvarl tempb 1 setvar tempb 1
					// divvarvar tempd tempb
					// ifvarg tempd 130 setvar tempd 130
					// getactorvar[temp].burning tempc
					// subvarvar tempc tempd
					// setactorvar[temp].burning tempc
				// }
				
			// }
			// nextspritestat temp temp
		// }
	// }
	
	// ifspritepal 2 // burning arrow
	// {
		// espawn FIRESTARTER
		// ifvarg powcount 0 ifvarand pow 128 { setactor[RETURN].pal 1 setactorvar[RETURN].burning -30 spritepal 1 }
		// setactorvar[RETURN].myspawner sprite[THISACTOR].owner
		// setvar RETURN 0
	// }
	
	ifvarvare arrowview THISACTOR setvar arrowview -1
	// STICK IN MONSTER CODE
	getactor[THISACTOR].htmovflag spriteid
	addvar spriteid 16384
	ifvarl spriteid 16384 ifvarg spriteid -1
	{
		state switchbulletcode
		getactor[THISACTOR].htmovflag spriteid
		addvar spriteid 16384
		ifspritepal 7 // bomb arrow
		{
			setactor[spriteid].htpicnum RPG
			state arrow_bits
			seta[spriteid].htowner player[].i
			setvar RETURN 0 break
		}
		ifactor ARROWPROJ 
		{
			ifspritepal 1 // ice arrow
			setactor[spriteid].htpicnum FREEZEBLAST
			ifspritepal 2 // fire arrow
			{
				getav[spriteid].burning burning
				add burning 30
				setav[spriteid].burning burning
			}
			ifspritepal 6
			{
				set hitsprite spriteid
				set savedvalue spriteid
				
				state spawnradwound
				set spriteid savedvalue
				
				espawn RADIMPACT seta[RETURN].htowner player[].i setav[RETURN].myspawner player[].i 
				setav[RETURN].inithp healthbuff
				
				set RETURN 1
			}
		}
		set temp NO
		ife actorvar[spriteid].monstatus 1 set temp YES
		ife actorvar[spriteid].monstatus 3 set temp YES
		
		ife temp YES // live victim
		{
			ifactor BLADEPROJ // check for decapitation
			{
				set TMP_A 0
				switch sprite[spriteid].picnum
				case LIZTROOP case LIZMAN case LIZRANGER 
				case PIGCOP case NEWPIG case NEWPIGDIVE
				case NEWTROOP case NEWTROOPDUCKING
				case NEWTROOPONTOILET
				case PIGCOPDIVE case LIZRANGERDUCKING
				case LIZTROOPONTOILET case LIZTROOPJUSTSIT
				case NEWBEAST
				case CYBERBEAST case CRONEN case CRAZYLADY
				case ZOMBIE case ARMYANT case ARMYANTCRAWL
				case SPACEBULL
				case COMMANDER case NEWCOMM
				
					ifn sprite[spriteid].htpicnum HEADJIB1
					{
						set TMP_B sprite[spriteid].htextra
						mul TMP_B 4
						ifge TMP_B sprite[spriteid].extra
						{
							set picnum sprite[spriteid].picnum
							set zdist tiledata[picnum].ysize
							ife actorvar[spriteid].mtype 3 
							{
								ife picnum LIZTROOP 
									set zdist 52
								ife picnum NEWTROOP
									set zdist 70
							}
							mul zdist sprite[spriteid].yrepeat
							ife picnum PIGCOPDIVE mul zdist 6 else
							ife picnum NEWPIGDIVE mul zdist 6 else
							mul zdist 5
							div zdist 2 // distance up to the head
							geta[spriteid].z z
							sub z zdist
							ifle sprite[].z z
							{
								seta[spriteid].htpicnum HEADJIB1
								ife actorvar[spriteid].droptile 0 setav[spriteid].droptile NUKECOIN
								set TMP_A 1
							}
						}
					}
				break
				endswitch
				
				ife TMP_A 1
				{
					ifrnd 128 set RETURN 0
					else
					{
						set RETURN 1
						seta[].yvel 3
					}
					break
				}
			}
			geta[spriteid].picnum picnum
			set TILETYPE -1
			state tiletype
			ifge TILETYPE 2 ifle TILETYPE 4
			{
				spawn SPARKFALL spawn SPARKFALL
				spawn SPARKFALL spawn SPARKFALL
				ifrnd 128
				ifactor ARROWPROJ
				{
					state arrow_bits
					state hitmetalsounds 
					setvar RETURN 0
					break
				}
				else
				sound ARROWMETAL
			}
			else
			{
				ifrnd 128 sound ARROWFLESH
				else sound ARROWFLESH2
			}
			
			setvarvar x2 sprite[THISACTOR].x
			addvar x2 256
			rotatepoint sprite[THISACTOR].x sprite[THISACTOR].y x2 sprite[THISACTOR].y sprite[THISACTOR].ang x y
			setactor[THISACTOR].x x
			setactor[THISACTOR].y y
			ifactor BLADEPROJ espawn BLADEPROJSTUCK else
			ifactor STAKEPROJ espawn STAKESTUCK else
			espawn STUCKARROW
			setactor[RETURN].pal sprite[THISACTOR].pal
			setactor[RETURN].pitch sprite[].pitch
			setactorvar[RETURN].myspawner spriteid
			
			getactor[THISACTOR].ang angvar
			ifactor ARROWPROJ
			{
				addvar angvar 512
				
				// slightly randomized angle
				randvar tempb 256
				subvar tempb 128
				addvarvar angvar tempb
			}
			setactor[RETURN].ang angvar
			
			getincangle temp angvar sprite[spriteid].ang
			setactorvar[RETURN].botclip temp
			
			ldist xydist THISACTOR spriteid
			ifactor BLADEPROJ { mul xydist 2 div xydist 3  } else
			shiftvarr xydist 1
			setactorvar[RETURN].mtype xydist
			
			getactor[THISACTOR].x x2
			getactor[THISACTOR].y y2
			getactor[spriteid].x x
			getactor[spriteid].y y
			subvarvar x2 x
			subvarvar y2 y
			getangle tempc x2 y2 // angle to make monster face arrow
			getincangle angvel tempc sprite[spriteid].ang
			setactorvar[RETURN].angvel angvel
			
 			setactor[RETURN].xrepeat 10 // 12
 			setactor[RETURN].yrepeat 10 // 12
			
			setactor[RETURN].cstat 32
			getactor[THISACTOR].z z
			ifactor ARROWPROJ addvar z 424
			setactor[RETURN].z z
			
 			getactor[spriteid].z shotpitch
 			subvarvar shotpitch z
 			setactorvar[RETURN].shotpitch shotpitch
			ifactor BLADEPROJ
			{
				setvar RETURN 0
				break
			}
 			ifactor STAKEPROJ
			{
				setvar RETURN 0
				break
			}
			ifspritepal 117
			{
				espawn SHOCK_ACTOR
				setav[RETURN].myspawner spriteid
				setav[RETURN].mtype 1
				espawn SHOCK_ACTOR
				setav[RETURN].myspawner spriteid
				setav[RETURN].mtype 1
				espawn SHOCK_ACTOR
				setav[RETURN].myspawner spriteid
				setav[RETURN].mtype 1
			}
 			
 			espawn STUCKARROW
 			setactor[RETURN].pal sprite[THISACTOR].pal
			setactorvar[RETURN].myspawner spriteid
			subvar angvar 1024
			setactor[RETURN].ang angvar
			getincangle temp angvar sprite[spriteid].ang
			setactorvar[RETURN].botclip temp
 			setactor[RETURN].xrepeat 10 // 12
 			setactor[RETURN].yrepeat 10 // 12
 			setactor[RETURN].cstat 16
 			subvar shotpitch 600
 			setactorvar[RETURN].shotpitch shotpitch
 			setactorvar[RETURN].mtype xydist
 			setactorvar[RETURN].angvel angvel
			setvar RETURN 0
			break
		}
		else 
		{
			ifactor STAKEPROJ
			{
				state sawblade_bits 
				spawn SPARKFALL spawn SPARKFALL
				spawn SPARKFALL spawn SPARKFALL
				setvar RETURN 0
				break
			}
			ifactor BLADEPROJ
			{
				state sawblade_bits
				spawn SPARKFALL spawn SPARKFALL
				spawn SPARKFALL spawn SPARKFALL
				state hitmetalsounds 
				setvar RETURN 0
				break
			}
			ifspritepal 2
			{
				getactorvar[spriteid].burning temp
				addvar temp 90
				setactorvar[spriteid].burning temp
			}
			ifspritepal 117 spawn SHOCK_ACTOR
			
		}
	}
	else 
	{
		ifspritepal 117 spawn SHOCK_ACTOR
		ifspritepal 6 
		{ 
			espawn RADIMPACT seta[RETURN].htowner player[].i setav[RETURN].myspawner player[].i 
			setav[RETURN].inithp healthbuff
		}
	}
		
	
	


	ifceilingdistl 16 { setvar RETURN 0 break }
	
	state arrowhitscan
		
	ifvarn hitsprite -1
	{
		ifactor ARROWPROJ
		ifspritepal 7 // bomb arrow
		{ 
			setactor[spriteid].htpicnum RPG
			state arrow_bits
			seta[spriteid].htowner player[].i
			setvar RETURN 0 break
		}
		geta[hitsprite].picnum picnum
		set tempb NO
		ife sprite[hitsprite].picnum STUCKARROW set tempb YES
		ife sprite[hitsprite].picnum WALLARROW set tempb YES
		ife sprite[hitsprite].picnum VERTARROW set tempb YES
		ife sprite[hitsprite].picnum STAKESTUCK set tempb YES
		ife sprite[hitsprite].picnum BLADEPROJSTUCK set tempb YES
		
		ife tempb YES
		{
			// getactor[hitsprite].cstat temp
			// ifvarand temp 16
			// {
				getactor[hitsprite].xrepeat x2
				getactor[hitsprite].yrepeat y2
				setvarvar botclip hitsprite
				setactor[hitsprite].xrepeat 1
				setactor[hitsprite].yrepeat 1
				state arrowhitscan
				setactor[botclip].xrepeat x2
				setactor[botclip].yrepeat y2
			// }
		}
	}
	
	ifspritepal 7 { setvar RETURN 0 break }
	
	getactor[].x xydist
	getactor[].y y
	subvarvar xydist hitx
	mulvarvar xydist xydist
	subvarvar y hity
	mulvarvar y y
	addvarvar xydist y
	sqrt xydist xydist

	ifvarg xydist 1024 
	{
		ifvare mtype 1 ifvarl countvar 26 { setvar RETURN 1 break }
		setvar RETURN 0 
		break 
	}
	
	ifactor ARROWPROJ
	ifvarn mtype 1 // ifvarn droptile APLAYER
	{
		getactor[].owner temp
		ifvarn temp -1
		{
			dist tempb THISACTOR temp
			ifvarl tempb 2048 
			{
				state arrow_bits
				setvar RETURN 0 
				ifrnd 128 globalsound BREAKWOOD4 else globalsound BREAKWOOD5 
				break 
			}
		}
	}
			
	setvar temp 0
	ifvarn hitsprite -1
	{
		ifvarand sprite[hitsprite].cstat 16
			set temp 1
		else
		ife sprite[hitsprite].statnum 0
			set temp 1
	}
	ifvarn hitwall -1 
	{
		getwall[hitwall].cstat tempb
		ifvarand tempb 128 { setvar RETURN 0 break } // break on transparent
		ifvarand tempb 16 { setvar RETURN 0 break } // break on masking
		getw[hitwall].picnum picnum
		state tiletype
		ifge TILETYPE 2 ifle TILETYPE 4
		ifrnd 128
		{
			ifactor BLADEPROJ state sawblade_bits else
			state arrow_bits
			spawn SPARKFALL spawn SPARKFALL
			spawn SPARKFALL spawn SPARKFALL
			state hitmetalsounds 
			setvar RETURN 0
			break
		}
		setvar temp 1
	}
	ifvarn hitsector -1
	{
		getsector[hitsector].floorslope tempb
		ifn tempb 0 ifl sprite[].zvel 1024
		{
			gets[hitsector].floorpicnum picnum
			state tiletype
			ifge TILETYPE 2 ifle TILETYPE 4
			{
				ifactor BLADEPROJ state sawblade_bits else
				state arrow_bits
				spawn SPARKFALL spawn SPARKFALL
				spawn SPARKFALL spawn SPARKFALL
				state hitmetalsounds 
				setvar RETURN 0
				break
			}
			
			ifrnd 128 globalsound BREAKWOOD4 else globalsound BREAKWOOD5 
			setvar target -1
			ifactor ARROWPROJ
			{
				cactor WALLARROW
				cstat 32 // 33	
			}
			getactor[].ang angvar
			
			cos xvel angvar
			sin yvel angvar
				  
			ifactor BLADEPROJ
			{
				shiftvarr xvel 5
				shiftvarr yvel 5
			}
			else
			{
				shiftvarr xvel 4
				shiftvarr yvel 4
			}
					 
			movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN
						
			changespritestat THISACTOR 1
			ifactor STAKEPROJ
			{
				setvar RETURN 1 
				break
			}
			ifactor BLADEPROJ
			{
				setvar RETURN 1 
				cactor BLADEPROJSTUCK
				break
			}
			addvar angvar 512
			setactor[].ang angvar
			ifvare droptile APLAYER { espawn WALLARROW setactorvar[RETURN].droptile APLAYER setactorvar[RETURN].bottarget hitwall } else
			espawn WALLARROW
			setactor[RETURN].pal sprite[].pal
			setactor[RETURN].cstat 17
			subvar angvar 1024
			setactor[RETURN].ang angvar
			setactor[RETURN].xrepeat 10 // 12
			setactor[RETURN].yrepeat 10 // 12
			getactor[].z z
			subvar z 600 //768
			setactor[].z z
			setvar RETURN 1 break
		}
	}
	ifvare temp 1
	{
		ifrnd 128 globalsound BREAKWOOD4 else globalsound BREAKWOOD5 
		ifactor ARROWPROJ
		{
			setvar target -1
			cactor WALLARROW
			setvarvar bottarget hitwall
			cstat 32 // 33	
			
		}
		getactor[].ang angvar
		ifvare hitsprite -1
		{
			cos xvel angvar
			sin yvel angvar
				  
			shiftvarr xvel 4
			shiftvarr yvel 4
				     
			movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN
		}		
		changespritestat THISACTOR 1
		ifactor STAKEPROJ
		{
			setvar RETURN 1 
			cactor STAKESTUCK
			break
		}
		ifactor BLADEPROJ
		{
			setvar RETURN 1 
			cactor BLADEPROJSTUCK
			break
		}
		addvar angvar 512
		setactor[].ang angvar
		ifvare droptile APLAYER { espawn WALLARROW setactorvar[RETURN].droptile APLAYER setactorvar[RETURN].bottarget hitwall } else
 		espawn WALLARROW
 		setactor[RETURN].pal sprite[].pal
 		setactor[RETURN].cstat 17
 		subvar angvar 1024
 		setactor[RETURN].ang angvar
 		setactor[RETURN].xrepeat 10 // 12
 		setactor[RETURN].yrepeat 10 // 12

 		getactor[].z z
 		subvar z 304
 		setactor[].z z
 		setvar RETURN 1 break
    }
    else 
    {
	    ifvarn hitsector -1
	    {
		    getceilzofslope hitsector hitx hity temp
		    setvarvar z hitz
		    subvarvar z temp
		    shiftvarr z 8
		    subvar z 1
		    setvarvar z2 z
		    
		    getflorzofslope hitsector hitx hity z
		    setvarvar temp hitz
		    subvarvar z temp
		    shiftvarr z 8
		    subvar z 1
		    ifvarl z 1
		    {
				ifactor STAKEPROJ
				{
					cactor STAKESPRITE
					changespritestat THISACTOR 1
					set RETURN 1
					break
				}
				
				gets[].floorpicnum picnum
				state tiletype
				ifge TILETYPE 2 ifle TILETYPE 4
				{
					ifactor BLADEPROJ state sawblade_bits else
					state arrow_bits
					spawn SPARKFALL spawn SPARKFALL
					spawn SPARKFALL spawn SPARKFALL
					state hitmetalsounds 
					setvar RETURN 0
					break
				}
				ifactor BLADEPROJ
				{
					cactor BLADEPROJSTUCK
					changespritestat THISACTOR 1
					set RETURN 1
					break
				}
			    getsector[].floorstat tempb
			    ifvarand tempb 1 nullop else ifvarand tempb 2 nullop else
			    {
					ifn sector[].floorslope 0
					{
						getflorzofslope sprite[].sectnum sprite[].x sprite[].y z
						add z 512
						seta[].z z
					}
					
				    ifrnd 128 globalsound BREAKWOOD4 else globalsound BREAKWOOD5 
				    // ground arrow
				    cactor VERTARROW
					cstat 153
					getactor[THISACTOR].ang angvar			
					changespritestat THISACTOR 1
					set initsprite APLAYER
			 		espawn VERTARROW
			 		setactor[RETURN].pal sprite[THISACTOR].pal
			 		setactor[RETURN].cstat 153
			 		subvar angvar 512
			 		setactor[RETURN].ang angvar
			 		setactor[RETURN].xrepeat 10 // 12
			 		setactor[RETURN].yrepeat 10 // 12
					changespritestat RETURN 1
					
					add angvar 256
					getactor[THISACTOR].x x
					getactor[THISACTOR].y y
					setvarvar x2 x
					add x2 6
					rotatepoint x y x2 y angvar x2 y2
					
					setsprite RETURN x2 y2 sprite[].z
					
			 		setvar RETURN 1 
			 		break
			    }
			    
			} else
		    ifvarl z2 0 
		    {
			   getsector[mysector].ceilingstat tempb
			   ifvarand tempb 1 { setvar RETURN 0 break } else
			   {
				   // shatter to bits
				   setvar RETURN 0
				   break
			   } 
			}
		}
    }
    ifvare mtype 1 ifvarl countvar 26 { setvar RETURN 1 break }
	
	setvar RETURN 0


ends

state sticky_killit_code

	ifoutside ifceilingdistl 32 { set RETURN 0 break }
	
	getactor[THISACTOR].htmovflag spriteid
	addvar spriteid 16384
	ifvarl spriteid 16384 ifvarg spriteid -1
	{
		espawn STICKYBOMB
		setav[RETURN].team team
		setactor[RETURN].pal sprite[THISACTOR].pal
		setactorvar[RETURN].myvictim spriteid
		ifn myspawner -1 setav[RETURN].myspawner myspawner
		getactor[THISACTOR].ang angvar
		
		
		getincangle temp angvar sprite[spriteid].ang
		setactorvar[RETURN].botclip temp
		
		ldist xydist THISACTOR spriteid
		shiftvarr xydist 1
		setactorvar[RETURN].mtype xydist
		
		getactor[THISACTOR].x x2
		getactor[THISACTOR].y y2
		getactor[spriteid].x x
		getactor[spriteid].y y
		subvarvar x2 x
		subvarvar y2 y
		getangle tempc x2 y2 // angle to make monster face stickybomb
		getincangle angvel tempc sprite[spriteid].ang
		setactorvar[RETURN].angvel angvel
		
		ife actorvar[spriteid].monstatus 1
		{
			getav[spriteid].stun temp
			add temp 3
			setav[spriteid].stun temp
			ife sprite[spriteid].htextra -1
			{
				seta[spriteid].htextra 1
				seta[spriteid].htpicnum SHOTSPARK1
				seta[spriteid].htowner sprite[].owner
				seta[spriteid].htang sprite[].ang
			}
		}
		
		getactor[spriteid].z shotpitch
		subvarvar shotpitch sprite[].z
		setactorvar[RETURN].shotpitch shotpitch
		
		setvar RETURN 0
		break
	}
	else
	{
		state arrowhitscan
		ifvarn hitsprite -1
		{
			getactor[hitsprite].xrepeat x2
			getactor[hitsprite].yrepeat y2
			setvarvar botclip hitsprite
			setactor[hitsprite].xrepeat 1
			setactor[hitsprite].yrepeat 1
			state arrowhitscan
			setactor[botclip].xrepeat x2
			setactor[botclip].yrepeat y2
		}

		getactor[].x xydist
		getactor[].y y
		subvarvar xydist hitx
		mulvarvar xydist xydist
		subvarvar y hity
		mulvarvar y y
		addvarvar xydist y
		sqrt xydist xydist

		
		setvar temp 0
		ifvarn hitsprite -1
			set temp 1
		
		ifvarn hitwall -1 
			setvar temp 1
		

		ifvare temp 1
		{
			espawn STICKYBOMB
			ifn myspawner -1 setav[RETURN].myspawner myspawner
			set spriteid RETURN
			getactor[].ang angvar
			cos xvel angvar
			sin yvel angvar
				  
			shiftvarr xvel 4
			shiftvarr yvel 4			 
			movesprite spriteid xvel yvel 0 CLIPMASK0 RETURN
			
			setvarvar x2 sprite[].x
			add x2 192
			rotatepoint sprite[].x sprite[].y x2 sprite[].y sprite[].ang x2 y2
			set temp sprite[].sectnum
			updatesector x2 y2 temp
			ife temp sprite[].sectnum
				setsprite spriteid x2 y2 sprite[].z
			
			setvar RETURN 0 break
		}
		else 
		{
			ifvarn hitsector -1
			{
				getceilzofslope hitsector hitx hity temp
				setvarvar z hitz
				subvarvar z temp
				shiftvarr z 8
				subvar z 1
				setvarvar z2 z
				
				getflorzofslope hitsector hitx hity z
				setvarvar temp hitz
				subvarvar z temp
				shiftvarr z 8
				subvar z 1
				ifvarl z 1
				{
					getsector[].floorstat tempb
					ifvarand tempb 1 nullop else
					{
						espawn STICKYBOMB
						ifn myspawner -1 setav[RETURN].myspawner myspawner
						set spriteid RETURN
						getactor[].ang angvar
						cos xvel angvar
						sin yvel angvar
							  
						shiftvarr xvel 4
						shiftvarr yvel 4			 
						movesprite spriteid xvel yvel 0 CLIPMASK0 RETURN
						setvar RETURN 0 break
					}
					
				} 
				else
				ifvarl z2 0 
				{
				   getsector[mysector].ceilingstat tempb
				   ifvarand tempb 1 { setvar RETURN 0 break } else
				   {
					    espawn STICKYBOMB
						ifn myspawner -1 setav[RETURN].myspawner myspawner
						set spriteid RETURN
						getactor[].ang angvar
						cos xvel angvar
						sin yvel angvar
							  
						shiftvarr xvel 4
						shiftvarr yvel 4			 
						movesprite spriteid xvel yvel 0 CLIPMASK0 RETURN
						setvar RETURN 0 break
				   } 
				}
			}
		}
		setvar RETURN 0
	}

ends

onevent EVENT_KILLIT

ife sprite[].statnum 1
ife monstatus 1
{
	state enemy_death
	set monstatus 2
	set RETURN 0
}

ife heldobject THISACTOR set heldobject -1
// else
// set monstatus 0

switch sprite[].picnum

	case BOTTLE1 case BOTTLE2 case BOTTLE3
	case BOTTLE4 case BOTTLE5 case BOTTLE6
	case BOTTLE7 case BOTTLE8 case BOTTLE10
	case BOTTLE13 case BOTTLE14 case BOTTLE15 case BOTTLE16
	case BOTTLE17 case BOTTLE18 case BOTTLE19
	case BOTTLE20 case BOTTLE21 case BOTTLE22
		espawn PART_EXP
		seta[RETURN].pal sprite[].pal
		set RETURN 0
	break
	
	case DOMELITE
		ifactorsound THISACTOR ALARM2 stopactorsound THISACTOR ALARM2
	break
	
	case VASE
		ifspritepal 0 spritepal 93
		state pottery_debris
		ifspritepal 93 getlastpal
		set RETURN 0
	break
	
	case FIREVASE
		ifspritepal 0 spritepal 50
		state pottery_debris
		ifspritepal 50 getlastpal
		set RETURN 0
	break
	
	case STATUE
		state pottery_debris
		set RETURN 0
	break
	
	case FETUS
		seta[].alpha 84
		state pottery_debris
		set RETURN 0
	break
	
	case FIRELASER
		ifvarn sprite[].htmovflag 0
		{

			spawn SPARKFALL
			spawn SPARKFALL
			spawn SPARKFALL
			spawn SPARKFALL
			spawn SPARKFALL
			set RETURN 0
		}
	break
	case RECON
		ifg player[].player_par 1
		{
			set monstatus 1
			espawn RECONWRECK
			seta[RETURN].pal sprite[].pal
			set RETURN 0
		}
	break
	// case GREENSLIME
		// ifn attmode NO
		// {
			
			// ife monxp 0 set monxp 25
			// ife SHOWPOINTS YES state showpoints
			// add totalxp monxp
			// add playerxp monxp
		// }
		// set RETURN 0
	// break
	case SPIT
		ifvarand initflags 8
		{
			spawn POISONGAS
			spawn POISONGAS
			spawn POISONGAS
			spawn POISONGAS
			spawn POISONGAS
			spawn POISONGAS
			spawn POISONGAS
			set RETURN 0
		}
	break
	
	case CRACK1
	case CRACK2
	case CRACK3
	case CRACK4
		ifn monstatus 2
		ifg SPRITELOTAG 0
		{
			headspritestat spriteid 6
			whilevarn spriteid -1
			{
				ife SPRITELOTAG actorvar[temp].SPRITELOTAG
					setav[spriteid].monstatus 2
				nextspritestat spriteid spriteid
			}
		}
	break
	
	case CANWITHSOMETHING
	case CANWITHSOMETHING2
	case CANWITHSOMETHING3
	case CANWITHSOMETHING4
	ifn attmode 0
	{
		ife sprite[].lotag 0
		set value 4
		state spawnimpcoins
		set RETURN 0
	}
	break

	case GRENADEPROJ
	case WESGRENADE
	case BIGGRENADEPROJ
		ifoutside ifceilingdistl 32 nullop
		else
		{
			debris SCRAP1 5
			debris SCRAP2 5
			iffloordistl 16 spawn EXPLOSION2BOT
			set RETURN 0
		}
	break
	case STICKYPROJ
		state sticky_killit_code
	break
	case RPG
		ifspritepal 47 spawn NUKEEXPLOSION
	break
	// case BEACHBALLPROJ
	case SPIDERMINEFALLING
		ifceilingdistl 4 ifvarand sector[].ceilingstat 1 
		{
			geta[].zvel z
			ifl z 0
			{
				abs z
				seta[].zvel z
			}
		}
		ifg sprite[].yvel 0
		ifn monstatus 2
		set RETURN 1
		break
		case SHRINKSPARK
		
	    headspritestat spriteid 1
		set B -1
		whilevarn spriteid -1
		{
			dist xydist THISACTOR spriteid
			ifle xydist SHRINKERBLASTRADIUS
			{
				seta[spriteid].htpicnum SHRINKSPARK
				ifl sprite[spriteid].htextra 0 seta[spriteid].htextra 1
				seta[spriteid].htowner sprite[].owner
				ife sprite[spriteid].statnum 1 set B spriteid
			}
			nextspritestat spriteid spriteid
		}
		ife B -1 ifpdistl SHRINKERBLASTRADIUS
		{
			seta[player[].i].htpicnum SHRINKSPARK
			seta[player[].i].htextra 0
			seta[player[].i].htowner sprite[].owner
		}
		break
		
	case PIGHEADPROJ 
	case TROOPHEADPROJ 
	case NEWTROOPHEADPROJ 
	case LIZHEADPROJ 
	case COMMHEADPROJ 
	case NEWCOMMHEADPROJ 
	case ZOMBIEHEADPROJ case CRAZYHEADPROJ
	case RANGERHEADPROJ 
	case BEASTHEADPROJ 
	case ANTHEADPROJ 
	case BULLHEADPROJ 
	case MANDOHEADPROJ 
		add countvarc 1
	set RETURN 0
	break
	
	case ARROWPROJ
	case STAKEPROJ
	case BLADEPROJ
		state arrow_killit_code
	break
	
	case SHOCK_ACTOR ifn mtype 0 { sub TOTALSHOCKS 1 ifl TOTALSHOCKS 0 set TOTALSHOCKS 0 }

	default break

endswitch

ife sprite[].statnum 4
{
	set RETURN 0
	ifactor IMPCOINPROJ break
	geta[].htmovflag spriteid
	add spriteid 16384
	ifg spriteid -1 ifl spriteid 16384
	{
		ifactor CBPROJ
		ifspawnedby APLAYER
		ife sprite[spriteid].statnum 1
		{
			seta[spriteid].htpicnum RPG
			getav[spriteid].burning temp
			add temp 40
			setav[spriteid].burning temp
		}
		ife sprite[spriteid].picnum SHOCKBALL2
			setav[spriteid].monstatus 2
			
		ifactor FLAMEPROJ
		ifn actorvar[spriteid].monstatus 100
		ifg sprite[spriteid].statnum 0
		{
			ifspritepal 0
			{
				getav[spriteid].burning temp
				add temp 30
				setav[spriteid].burning temp
			}
			else
			ifspritepal 1
			{
				seta[spriteid].htpicnum FREEZEBLAST
			}
		}
		
		ifactor FIRELASER2
		ifspawnedby APLAYER
		{
			state switchbulletcode
			set RETURN 0
		}
		
		ifactor PLAYERPLASMA
		ifspawnedby APLAYER
		{
			state switchbulletcode
			set RETURN 0
		}
		
		ifactor SHOCKBALL2
		{
			seta[spriteid].htpicnum RPG
			espawn SHOCK_ACTOR
			setav[RETURN].myspawner spriteid
			set RETURN 0
		}
		ifactor BIGBOIPROJ
		ife myspawner player[].i
		{
			set hitsprite spriteid
			state spawnradwound
			set RETURN 0
		}
		geta[].xvel xvel
		// ifn sprite[].picnum RPG
		// ife sprite[spriteid].picnum BARRIER
		// {
			// geta[spriteid].ang angvar
			// getincangle temp angvar sprite[].ang
			// sub angvar temp
			// add angvar 1024
			// seta[].ang angvar
			// seta[].owner player[].i
			// set RETURN 1
			// break
		// }
		
		switch sprite[spriteid].picnum
		case SITH case SYTH
		ife actorvar[spriteid].mtype 1 // blocking
		{
			seta[spriteid].htextra -1
			set damflash 0
			geta[spriteid].ang angvar
			getincangle temp angvar sprite[].ang
			sub angvar temp
			add angvar 1024
			seta[].ang angvar
			globalsound BLASTERBOUNCE
			add countvarc 1
			ifl countvarc 2
			set RETURN 1
		}
		break
		case EBARRIER
			ife sprite[spriteid].pal 21
			{
				ifg sprite[spriteid].htextra 0
				{
					set temp sprite[spriteid].htextra
					div temp 3
					seta[spriteid].htextra temp
				}
				geta[spriteid].ang angvar
				getincangle temp angvar sprite[].ang
				sub angvar temp
				add angvar 1024
				seta[].ang angvar
				globalsound BLASTERBOUNCE
				add countvarc 1
				ifl countvarc 2
				set RETURN 1
			}
		break
		endswitch
		
		ife RETURN 1 break
		
		ifg saberpos 0 ifl saberpos 85 nullop else
		ifangdiffl 512 nullop else	
		ife sprite[spriteid].picnum APLAYER
		ife player[].curr_weapon KNEE_WEAPON
		ifn gotsaber 0 ife player[].weapon_pos 0
		ifn sprite[].picnum RPG
		ifn sprite[].picnum SHOCKBALL
		{
			// set knockvel -1
			seta[spriteid].htextra -1
			geta[].owner B
			seta[].owner spriteid
			getp[].ang angvar
			getincangle blockang angvar sprite[].ang
			sub angvar blockang
			add angvar 1024
			seta[].ang angvar
			ifl blockang 0 set blockang -9 else set blockang 9
			getp[].horiz z
			sub z 100
			mul z -100
			seta[].zvel z
			shiftr z 4
			getangle tempb xvel z
			seta[].pitch tempb
			
			ifrnd 128
			{
				ifg gotsaber 0 
				ifn halfpoint 0 set halfpoint 0 else
				{ 
					ife pchar 2 addphealth -2
					else
					sub gotsaber 1 
					set halfpoint 1 
				}
			}
			
			// ife rendmode 4
			// ifn saberlight -1 setav[saberlight].shade 4096
			// else 
			flash
			globalsound BLASTERBOUNCE
			
			// redirect to sender if possible
			ifn B -1
			ife actorvar[B].monstatus 1
			{
				set bottarget B
				geta[bottarget].x x2
				geta[bottarget].y y2
				sub x2 sprite[].x
				sub y2 sprite[].y
				getangle angvar x2 y2
				
				ifn holdinteract 0
				ifl holdinteract 8 
				{
					stopsound BLASTERBOUNCE
					screensound REFLECT
					screensound REFLECT
					screensound REFLECT
					seta[].ang angvar set justblocked 8 
					ifvarand gametips 128 { xorvar gametips 128 savegamevar gametips }
					geta[].extra temp, mul temp 3 div temp 2 seta[].extra temp
				}
				else
				{
					rand tempb 64
					sub tempb 32
					add angvar tempb
					seta[].ang angvar
				}
				
				geta[bottarget].z zdist
				ifactor MORTER sub zdist 8192
				sub zdist sprite[].z 
				
				geta[bottarget].picnum picnum
				
				set z2 tiledata[picnum].ysize
				mul z2 sprite[bottarget].yrepeat
				shiftl z2 1
				// z2 is proportional to height of enemy sprite
				
				sub zdist z2

				mul zdist sprite[].xvel
				ldist xydist THISACTOR bottarget
				ifvare xydist 0 setvar xydist 1 
				divvarvar zdist xydist
				
				ifn holdinteract 0  
				ifl holdinteract 8 
					seta[].zvel zdist 
				else
				{
					rand tempb 2048
					sub tempb 1024
					add zdist tempb
					seta[].zvel zdist
				}
			}

			set RETURN 1
			break
		}
		
		set RETURN 0
	}
	set RETURN 0
}

endevent


// Advances the random number generator seed a bit since EDuke32 currently never calls srand().

defstate advance_rand
    getticks temp
    andvar temp 255
    whilevarn temp 0
    {
        displayrand tempb
        subvar temp 1
    }
ends


// Randomizes the music choice on level start.

// gamevar music_level 0 0
// gamevar music_volume 0 0

// defstate apply_music
    // set temp VOLUME
    // setuserdef[].volume_number music_volume
    // starttrackvar music_level
    // setuserdef[].volume_number temp
// ends


appendevent EVENT_INCURDAMAGE

ifg player[].extra_extra8 0
ife sector[player[].cursectnum].lotag 2
ife player[].airleft 0
ife sprite[player[].i].htextra -1
{
	getp[].extra_extra8 temp
	shiftr temp 8
	add o2damage temp
}

endevent

onevent EVENT_CHECKTOUCHDAMAGE

ifge RETURN 49152 // sprite collision
{
	sub RETURN 49152
	switch sprite[RETURN].picnum
	case LASERWALL
		ife actorvar[RETURN].countvar 0
			setav[RETURN].countvar 1
	break
	case LIZMANGUARD
	case LIZRANGERGUARD
	case SPACEBULLGUARD
	case NEWTROOPGUARD
		ife sprite[RETURN].htextra -1
		seta[RETURN].htextra 1
	break
	endswitch
	
	add RETURN 49152
}

endevent

appendevent EVENT_RESETINVENTORY

	set LASERAMMO 0
	set pistolammo 0
	set LASERMODE NO
	set gotsaber 0
	// set gotsaw NO
	// set sawammo 0
	// state sawoff
	ife gameover YES
	{
		setuserdef[].display_bonus_screen 0 // resetplayer
		al gameover
		// set gameover NO
		ife challenge YES
		ife attmode YES
			state writehighscores
		else
		endofgame 2
		
	}
	

endevent

appendevent EVENT_RESETPLAYER

	state resetplayeramounts
	ife VOLUME 4 ife LEVEL 1 nullop else
	ife gametype 0 ifn attmode 1 set startguns -1
	ifn startguns -1 state applystartguns
	
	
	// player has died in a match
	ife VOLUME 6 ifg LEVEL 10 ifl LEVEL 38
	{
		// must set wave first to prevent some bad stuff
		ife LEVEL 13 
			set wave 1
				
		ife LEVEL 16 
			set wave 7
			
		ife LEVEL 18
			set wave 11
			
		ife LEVEL 21
			set wave 16
			
		ife LEVEL 25
			set wave 20
			
		ife LEVEL 26
			set wave 21
			
		ife LEVEL 37
			set gametype 0
		
		state wavesettings
		set survivor_winner NO
		setp[].timebeforeexit 0
	}

endevent

damageeventtilerange CRACK1 CRACK4

// onevent EVENT_DAMAGESPRITE

// getuserdef[].return 0 temp al temp
// getuserdef[].return 1 tempb al tempb

// geta[temp].htpicnum picnum
// al picnum
// geta[temp].htextra tempc
// al tempc

// endevent

onevent EVENT_POSTDAMAGESPRITE

	getuserdef[].return 0 spriteid

	geta[spriteid].picnum picnum
	ifge sprite[spriteid].picnum CRACK1 ifle sprite[spriteid].picnum CRACK4
	{
		set temp sprite[spriteid].htextra
		ifl temp -1
		{
			abs temp
			seta[spriteid].htextra temp
		}
	}


// geta[temp].htpicnum picnum
// al picnum
// geta[temp].htextra tempc
// al tempc

// THISACTOR == ID of the projectile or source of damage.
// RETURN == the ID of what is being damaged.
// The userdef return 1 through 5 equals the hitradius parameters. If there's no radius damage, return 1 equals -1.

	ife sprite[RETURN].picnum RECON
	// ife sprite[RETURN].htowner player[0].i
		setav[RETURN].botclip sprite[RETURN].htextra
	
endevent

appendevent EVENT_LOADGAME

// ife RANDOMTRACK YES
    // state apply_music

ifn music_position -1
	setmusicposition music_position
	
ife pchar 0 
{
	setp[].palookup dukepal
	setuserdef[].color dukepal
}
else
ife pchar 1 
{ 
	setp[].palookup shellypal
	setuserdef[].color shellypal
}
else
ife pchar 2
{ 
	setp[].palookup wespal
	setuserdef[].color wespal
}

endevent

appendevent EVENT_SAVEGAME
    getmusicposition music_position
	ife challenge YES
	ifg player[].player_par 30
	{
		ifg leveltoken 0 
		{
			sub leveltoken 1
			set bigmsg 1113
			set bigmsgcount 90
		}
		else
		{
			mul totalxp 9
			div totalxp 10
			set bigmsg 3108
			set bigmsgcount 90
		}
	}
endevent

include scripts/AAITEMS.CON
include scripts/INTERACT.CON
include scripts/AAPRELOAD.CON
include scripts/OLDENEMIES.CON
include scripts/PIGBOSS.CON
include scripts/LIZBOSS.CON
include scripts/LIZRANGER.CON
include scripts/ZOMBIE.CON
include scripts/CORRUPT.CON
include scripts/SITH.CON
include scripts/CRAZYLADY.CON
include scripts/CIVILIAN.CON
include scripts/BOMBSHELL.CON
include scripts/DUKEBOT.CON
include scripts/ROLLYTURRET.CON
include scripts/ARMPIG.CON
include scripts/MEGABRAIN.CON
include scripts/BOSS2FLY.CON
include scripts/TERMINATOR.CON
include scripts/CYBERBEAST.CON
include scripts/DEVOURER.CON
include scripts/VEHICLES.CON
include scripts/SCUBATROOP.CON
include scripts/MECHBRAIN.CON
include scripts/DRPROTON.CON
include scripts/LIZTURRET.CON
include scripts/EDFTROOP.CON
include scripts/ARMEDF.CON
include scripts/EDFSNIPER.CON
include scripts/SCHOOLGIRL.CON
include scripts/GUARD.CON
include scripts/LIZELITE.CON
include scripts/MANDO.CON
include scripts/ARMYANT.CON
include scripts/SPACEBULL.CON
include scripts/DEANOVA.CON
include scripts/CANHEAD.CON
include scripts/SPIDERMINE.CON
include scripts/WARMAGEDDON.CON
include scripts/NPCQUOTES.CON
include scripts/NEWVACA.CON
include scripts/LITTLEBIGMEN.CON
include scripts/CYCLOIDMAX.CON
include scripts/ANCIENTS.CON
include scripts/NEWTROOP.CON
include scripts/NEWPIG.CON
include scripts/NEWCOMM.CON
include scripts/NEWBATLORD.CON
include scripts/QUEEN.CON
include scripts/NURGLE.CON
include scripts/LIZDOG.CON
include scripts/WESBOT.CON
include scripts/NAAMAH.CON
include scripts/BATBOSS.CON
include scripts/CHEERBOT.CON
