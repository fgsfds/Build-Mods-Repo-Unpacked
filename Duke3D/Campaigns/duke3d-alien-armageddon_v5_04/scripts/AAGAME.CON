
include scripts/NEWSOUNDS.CON
include scripts/AADEFS.CON
include scripts/AAUSER.CON
include scripts/EBIKE.CON

precache 1820 1973 1
precache 2080 2217 1
precache 2690 2809 1
precache 5120 5596 1
precache 5632 5864 1
precache 6144 6250 1
precache 6656 6804 1
precache 7680 7798 1

precache 8176 8191 1
precache 8448 8494 1
precache 8555 8680 1
precache 8681 8684 1
precache 8875 8958 1
precache 8905 8937 1
precache 9472 9641 1
precache 9722 9726 1
precache 9966 9978 1
precache 10240 10429 1
precache 10624 10729 1
precache 10923 10945 1
precache 12080 12153 1

precache 13004 13047 1
precache 13312 13584 1
precache 14085 14215 1
precache 14376 14505 1
precache 15304 15351 1
precache 15460 15505 1
precache 16510 16530 1
precache 16540 16584 1
precache 16767 16778 1
precache 16844 16878 1
precache 16790 16878 1
precache 16896 17151 1
precache 17408 17660 1
precache 18176 18362 1
precache 18505 18533 1
precache 18590 18655 1
precache 20424 20454 1
precache 20640 20714 1
precache 21190 21235 1
gamevar do_upscale 1 0
gamevar ATTVOLUME 0 0
gamevar ATTLEVEL 0 0
gamevar FAKEVOLUME 0 0 // SET BACK TO 0 IF NONZERO, USED FOR BONUS SCREEN

defstate next_att_map

	set tempG NO // becomes YES when new map is found
	
	ife attmid NO // tutorial not done yet
	{
		set attmid 1
		set ATTLEVEL 11
		set ATTVOLUME 5
		set attmusic -1
		break
	}
	
	ifge plevel 5
	ifl attmid 2
	{
		set attmid 2
		set ATTLEVEL 41
		ifge attbosses 7 set attbosses 0
		add ATTLEVEL attbosses
		add attbosses 1, ifge attbosses 7 set attbosses 0
		savegamevar attbosses
		set ATTVOLUME 0
		set attmusic -1
		break
	}
	
	set temp ATTLENGTH
	ife challenge YES set temp 12
	
	ifge plevel temp
	{
		al plevel
		// ife challenge YES
		// {
			// set attmid 3
			// set ATTLEVEL 51
			// set ATTVOLUME 0
			// set attmusic -1
		// }
		// else
		// {
			set attmid 3
			set ATTLEVEL 47
			ifge attbosses 7 set attbosses 0
			add ATTLEVEL attbosses
			set ATTVOLUME 0
			set attmusic -1
		// }
		break
	}
	
	gettimedate temp tempb tempc x x x x x
	add temp 1 add tempb 1 add tempc 1
	mul temp tempb
	mul temp tempc
	shiftvarr temp 6
	whilevarn temp 0
    {
    ifrnd 1 { }
    subvar temp 1
    }

	whilevarn tempG YES
	{
		rand tempI TOTALATTMAPS
		
		ifl plevel 3 { rand tempI 62 add tempI 63 } // simple starting map in third episode
		
		add tempI 1
		
		set tempF 0
		whilevarn tempF RECATTMAPS
		{
			ife tempI recentmaps[tempF] set tempI -1
			add tempF 1
			ife tempI -1 set tempF RECATTMAPS
		}
		ifn tempI -1 set tempG YES
	}
	// update recentmaps array to make new selection most recent map
	set tempF RECATTMAPS, sub tempF 1
	set temp tempF, sub temp 1
	whilevarn temp -1
	{
		setarray recentmaps[tempF] recentmaps[temp]
		sub tempF 1
		sub temp 1
	}
	setarray recentmaps[0] tempI
	writearraytofile recentmaps 1250
	// translate selected map number into usable VOLUME and LEVEL numbers
	ifle tempI 63
	{
		set ATTVOLUME 1
		set ATTLEVEL tempI
	}
	else
	ifle tempI 126
	{
		set ATTVOLUME 2
		set ATTLEVEL tempI
		sub ATTLEVEL 63
	}
	else
	ifle tempI 190
	{
		set ATTVOLUME 3
		set ATTLEVEL tempI
		sub ATTLEVEL 127
	}
	else
	{
		set ATTVOLUME 5
		set ATTLEVEL tempI
		sub ATTLEVEL 191
		add ATTLEVEL 12
	}
	set TMP_A attmusic
	rand attmusic 62
	add attmusic 1
	ife attmusic TMP_A sub attmusic 1
	
ends

defstate autosave

	ifn AUTOSAVE YES break
	ife player[].cursectnum -1 break
	ifgapzl 32 break
	getp[].cursectnum mysector
	switch sector[mysector].floorpicnum
	case FLOORSLIME
	case FLOORPLASMA
	case PURPLELAVA
	break
	default
		ife player[].falling_counter 0
		{
			savenn 9
			getp[].player_par lastsave
		}
	break
	endswitch
ends

defstate writehighscores
	ife scoreswrote YES break
	set temp 0
	whilevarvarn temp MAXSCORES
	{
		ifg totalxp highscores[temp]
		{
			set tempb MAXSCORES
			sub tempb 1
			set tempc tempb
			sub tempc 1
			whilevarvarn tempb temp
			{
				setarray highscores[tempb] highscores[tempc]
				sub tempb 1
				sub tempc 1
			}
			setarray highscores[temp] totalxp
			set temp MAXSCORES
		}
		else
		add temp 1
	}
	writearraytofile highscores 3106
	// set totalxp 0
	set scoreswrote YES
	set vendor_screen 5
	set lastscreen vendor_screen
	set tempselect -1
ends

// This function swaps the data of walls J and K, except for the point2 fields

defstate swapwall
ifvarvarn J K {
getwall[J].x temp
getwall[K].x tempb
setwall[J].x tempb
setwall[K].x temp
getwall[J].y temp
getwall[K].y tempb
setwall[J].y tempb
setwall[K].y temp
getwall[J].cstat temp
getwall[K].cstat tempb
setwall[J].cstat tempb
setwall[K].cstat temp
getwall[J].picnum temp
getwall[K].picnum tempb
setwall[J].picnum tempb
setwall[K].picnum temp
getwall[J].overpicnum temp
getwall[K].overpicnum tempb
setwall[J].overpicnum tempb
setwall[K].overpicnum temp
getwall[J].shade temp
getwall[K].shade tempb
setwall[J].shade tempb
setwall[K].shade temp
getwall[J].pal temp
getwall[K].pal tempb
setwall[J].pal tempb
setwall[K].pal temp
getwall[J].xrepeat temp
getwall[K].xrepeat tempb
setwall[J].xrepeat tempb
setwall[K].xrepeat temp
getwall[J].yrepeat temp
getwall[K].yrepeat tempb
setwall[J].yrepeat tempb
setwall[K].yrepeat temp
getwall[J].xpanning temp
getwall[K].xpanning tempb
setwall[J].xpanning tempb
setwall[K].xpanning temp
getwall[J].ypanning temp
getwall[K].ypanning tempb
setwall[J].ypanning tempb
setwall[K].ypanning temp
getwall[J].lotag temp
getwall[K].lotag tempb
setwall[J].lotag tempb
setwall[K].lotag temp
getwall[J].hitag temp
getwall[K].hitag tempb
setwall[J].hitag tempb
setwall[K].hitag temp
getwall[J].extra temp
getwall[K].extra tempb
setwall[J].extra tempb
setwall[K].extra temp
getwall[J].nextwall temp
getwall[K].nextwall tempb
setwall[J].nextwall tempb
setwall[K].nextwall temp
getwall[J].nextsector temp
getwall[K].nextsector tempb
setwall[J].nextsector tempb
setwall[K].nextsector temp
}
ends

defstate mirrorplayer

	getactor[].x x
	mulvar x -1
	seta[].x x
	// setp[].posx x
	getactor[].y y
	getactor[].z z
	updatesectorz x y z temp
	
	changespritesect THISACTOR temp
	//setp[].cursectnum temp
	
	getactor[].ang angvar
	ifvarg angvar 1024 setvar temp 1536
	else setvar temp 512
	subvarvar temp angvar
	mulvar temp 2
	addvarvar angvar temp
	setactor[].ang angvar
	// setplayer[].ang angvar

ends

// This helper function sets temp to 1 if a wall's picnum is identified
// as a wall switch. Otherwise, it sets temp to 0.
// The input picum is also given in temp.
defstate iswallswitch
    switch temp
        case 130 // ACCESSSWITCH
        case 131 // ACCESSSWITCH+1; Not usable, but checked for consistency
        case 132 // SLOTDOOR
        case 133 // SLOTDOOR+1
        case 134 // LIGHTSWITCH
        case 135 // LIGHTSWITCH+1
        case 136 // SPACEDOORSWITCH
        case 137 // SPACEDOORSWITCH+1
        case 138 // SPACELIGHTSWITCH
        case 139 // SPACELIGHTSWITCH+1
        case 140 // FRANKENSTINESWITCH
        case 141 // FRANKENSTINESWITCH+1
        case 146 // MULTISWITCH
        case 147 // MULTISWITCH+1
        case 148 // MULTISWITCH+2
        case 149 // MULTISWITCH+3
        case 162 // DIPSWITCH
        case 163 // DIPSWITCH+1
        case 164 // DIPSWITCH2
        case 165 // DIPSWITCH2+1
        case 166 // TECHSWITCH
        case 167 // TECHSWITCH+1
        case 168 // DIPSWITCH3
        case 169 // DIPSWITCH3+1
        case 170 // ACCESSSWITCH2
        case 171 // ACCESSSWITCH2+1; Not usable, but checked for consistency
        case 712 // LIGHTSWITCH2
        case 713 // LIGHTSWITCH2+1
        case 860 // POWERSWITCH1
        case 861 // POWERSWITCH1+1
        case 862 // LOCKSWITCH1
        case 863 // LOCKSWITCH1+1
        case 864 // POWERSWITCH2
        case 865 // POWERSWITCH2+1
        case 1155 // HANDPRINTSWITCH
//      case 1156 // Unrelated to HANDPRINTSWITCH, but checked in Duke3D's code
        case 1142 // ALIENSWITCH
        case 1143 // ALIENSWITCH+1
        case 1122 // PULLSWITCH
        case 1123 // PULLSWITCH+1
        case 1111 // HANDSWITCH
        case 1112 // HANDSWITCH+1
            setvar temp 1
            break
        default
            setvar temp 0
            break
    endswitch
ends

defstate mirror

// Adjust sector ceilings and floors
setvar I 0
whilevarvarn I NUMSECTORS
{
    // If bit 2 (swap x&y) is set, invert bit 5 (y-flip).
    // Otherwise, invert bit 4 (x-flip).

    getsector[I].ceilingstat A
    ifvarand A 4 xorvar A 32 else xorvar A 16
    setsector[I].ceilingstat A

    getsector[I].floorstat A
    ifvarand A 4 xorvar A 32 else xorvar A 16
    setsector[I].floorstat A

    addvar I 1
}

// Horizontally flip the walls
setvar I 0
whilevarvarn I NUMWALLS
{
    // Flip each wall point's x coordinate. This will temporary make
    // the map technically invalid, because a sector's exterior walls
    // (e.g., all walls of a convex sector) will be sorted in
    // anti-clockwise order, instead of clockwise. This is fixed later.
    getwall[I].x A
    mulvar A -1
    setwall[I].x A
    // Initialize SWAPWALLS for later use
    setarray SWAPWALLS[I] -1
    // Visually flip a wall's tile, except for specific tile numbers
    getwall[I].picnum temp
    switch temp
        case 277 case 394 case 415 case 498 case 499
        case 500 case 502 case 518 case 519 case 520 case 521 case 522 case 523 case 524 case 525
        case 526 case 527 case 528 case 529 case 530 case 531 case 532 case 533 case 534 case 535
        case 568 case 593 case 594 case 598 case 599 case 600 case 612 case 613 case 614 case 639
        case 657 case 666 case 667 case 687 case 699 case 721 case 728 case 736 case 766 case 776 
        case 777 case 778 case 784 case 817 case 818 case 822 case 826 case 835 case 838 case 837
        case 841 case 839 case 848 case 849 case 856 case 858 case 871 case 872 case 937 case 938 
        case 945 case 946 case 949 case 961 case 963 case 964 case 965 case 966 case 967 case 968
        case 970 case 980 case 992 case 1043 case 1044 case 1046 case 1047 case 1064 case 1065 case 1066
        case 1072 case 1210 case 1211 case 1212 case 1214 case 1215 case 1217 case 1244 case 1245
        case 2486 case 2492 case 2493 case 2500 case 2504 case 2505 case 2506 case 3370 case 3371 case 3372
        case 3373 case 3374 case 3382 case 3383 case 3391 case 3402 case 3403 case 3421 case 3422 case 3423
        case 4096 case 4108 case 4125 case 4126 case 4238 case 4306 case 4307 case 4318 case 4323
        case 4329 case 4447 case 4450 case 4451 case 4477 case 4472 case 4475 case 4476
        case 4478 case 4479 case 4484 case 4485 case 4486 case 4487 case 4488 case 4492 case 4499
        case 4494 case 4504 case 4505 case 4506 case 4507 case 4508 case 4553 case 4564 case 4565
        case 4578 case 4579 case 4597 case 4598 case 4599 case 4889 case 4891 case 4892 case 4896 
        case 4897 case 4898 case 4899 case 4903 case 4904 case 4905 case 4906 case 4907 case 4908
        case 4924 case 4925 case 4926 case 4927 case 4928 case 4929 case 4930 case 4931 case 4932
        case 4933 case 4934 case 4937 case 4938 case 4939 case 4942 case 4945 case 4947 case 4948
        case 4950 case 4951 case 4952 case 4956
            break
        default
            state iswallswitch
            ifvarn temp 0 break

            getwall[I].cstat temp
            xorvar temp 8
            setwall[I].cstat temp
            break
    endswitch
    addvar I 1
}

// Make exterior walls clockwise-ordered again, one cycle after the other
setvar I 0
whilevarvarn I NUMWALLS
{
    // A cycle's first and last wall numbers will be A and K, respectively
    setvarvar A I
    getwall[I].point2 B
    setvarvar K I
    whilevarvarn A B
    {
        addvar K 1
        getwall[K].point2 B
    }
    // Swap walls I and A (K), then I+1 and A-1, and so on
    setvarvar A K
    setvarvar J I
    setvarvar L K
    subvarvar L J
    divvar L 2
    addvar J 1
    whilevarn L 0
    {
        state swapwall
        setarray SWAPWALLS[J] K
        setarray SWAPWALLS[K] J
        addvar J 1
        addvar K -1
        addvar L -1
    }

    // Repeatedly swap the x,y fields of walls J (first wall)
    // and each other wall in the cycle, in the given order.
    setvarvar J I
    whilevarvarn I A
    {
        setvarvar K I
        addvar K 1
        getwall[J].x B
        getwall[J].y C
        getwall[K].x D
        getwall[K].y E
        setwall[J].x D
        setwall[J].y E
        setwall[K].x B
        setwall[K].y C

        addvar I 1
    }

    // Continue to the next cycle
    addvar I 1
}

// Fix the nextwall fields by using the SWAPWALLS array
setvar I 0
whilevarvarn I NUMWALLS
{
    getwall[I].nextwall A
    ifvarn A -1
        ifvarn SWAPWALLS[A] -1
            setwall[I].nextwall SWAPWALLS[A]

    addvar I 1
}

// Process actors/sprites. cstat isn't changed here.
setvar I 0
whilevarn I 16384
{
    // Flip the x coordinate
    getactor[I].x A
    mulvar A -1
    setactor[I].x A
    getactor[I].picnum picnum
    
    // Flip the angle
    getactor[I].ang A
    ifvarg A 1024
    {
        setvar B 1536
    } else {
        setvar B 512
    }
    subvarvar B A
    mulvar B 2
    addvarvar A B

    setactor[I].ang A

    // Adjust sector effectors
    getactor[I].lotag temp
    ifvare picnum SECTOREFFECTOR ifvare temp 0
    {
        getactor[I].pal temp
        ifvare temp 2 setactor[I].pal 0 else
        ifvare temp 0 setactor[I].pal 2
    }
    ifvare picnum SECTOREFFECTOR ifvare temp 11
    {
        ifvarg A 0 ifvarl A 1025 subvar A 1
        else
            ifvarg A 1024 ifvarl A 2047 addvar A 1
        addvar A 1025
        ifvarg A 2047 subvar A 2048
        setactor[I].ang A
    }

    addvar I 1
}

ifg player[].player_par 1 
{
	setp[].posx sprite[player[].i].x
	setp[].posy sprite[player[].i].y
	setp[].ang sprite[player[].i].ang
}

ends

defstate pkick_check

	ife sprite[player[].i].extra 0 break
	
	ifn qk_proxy 0 { setp[].quick_kick 0 break }
	
	ife pchar 0 
	{
		ifvarand altcostume 8
		set qk_proxy 15
	}
	else
		set qk_proxy 15
ends

defstate shield_discount

	// discounts
	set temp 1
	{
		whilevarn temp 7
		{
			ife es_owned[temp] YES 
			{
				ifle tempd 7000
					sub tempd 4000
				else
				ifg temp 3
					sub tempd 8000
			}
			add temp 1
		}
		ifl tempd 100 set tempd 100
		
	}

ends

defstate nova_discount

	// discounts
	set temp 7
	{
		whilevarn temp 10
		{
			ife es_owned[temp] YES sub tempd 3000
			add temp 1
		}
		ifl tempd 100 set tempd 100
		
	}

ends

defstate pricetable

	set tempd 0
	
	switch TMP_B
	
	case 1 set tempd 5000 state shield_discount break
	case 2 set tempd 6000 state shield_discount break
	case 3 set tempd 7000 state shield_discount break

	case 4 ife gametype 0 ife vrtrip 0 set tempd 12000 else set tempd 16000 state shield_discount break
	case 5 ife gametype 0 ife vrtrip 0 set tempd 16000 else set tempd 20000 state shield_discount break
	case 6 ife gametype 0 ife vrtrip 0 set tempd 20000 else set tempd 24000 state shield_discount break
	case 7 case 8 case 9 set tempd 6000 state nova_discount break
	
	case 100 // vanilla pistol
		set tempd 1000
	break
	case 101 // glock18
		set tempd 5000
		ife weap_owned[101] YES shiftr tempd 2
	break
	case 102 // AP rounds
		set tempd 6000
		ife weap_owned[102] YES shiftr tempd 2
	break
	case 103 // dual wield
		set tempd 6000
		ife weap_owned[103] YES shiftr tempd 2
	break
	case 104 // alien pistol
		set tempd 1000
		ife weap_owned[104] YES shiftr tempd 2
	break
	case 105 // alien pistol upgrade
		set tempd 6000
		ife weap_owned[105] YES shiftr tempd 2
	break
	case 106 // doubled pistol ammo
		set tempd 4000
		ife weap_owned[106] YES shiftr tempd 1
	break
	
	case 107 // increased pistol reload speed
	case 507
		set tempd 5000
	break

	case 110 // vanilla shotty
		set tempd 1000
	break
	case 111 // explosive shells
		set tempd 5000
		ife weap_owned[111] YES shiftr tempd 2
	break
	case 112 // DB shotty
		set tempd 2000
	break
	case 113 // DB shotty + reload
		set tempd 3000
	break
	case 114 // atomic shotty
		set tempd 3000
	break
	case 115 // rad shells
		set tempd 4000
	break
	case 116 // burst fire
		set tempd 5000
	break
	case 120 // vanilla chaingun
		set tempd 1000
	break
	case 121 // minigun
		set tempd 7000
		ife weap_owned[121] YES shiftr tempd 1
	break
	case 122 // AP
		set tempd 6000
		ife weap_owned[122] YES shiftr tempd 2
	break
	case 123 // +max ammo
		set tempd 4000
		ife weap_owned[123] YES shiftr tempd 2
	break
	case 124 // executioner
		set tempd 5000
		ife weap_owned[124] YES shiftr tempd 2
	break
	case 125 // chain gang
		set tempd 2000
		ife weap_owned[125] YES div tempd 2
	break
	case 130 // vanilla RPG
		set tempd 1000
	break
	case 131 // smart RPG
		set tempd 6000
		ife weap_owned[131] YES shiftr tempd 2
	break
	case 132 // fast rox
		set tempd 2000
		ife weap_owned[132] YES shiftr tempd 2
	break
	case 133 // multi rox
		set tempd 3000
		ife weap_owned[133] YES shiftr tempd 2
	break
	case 140 // regular pipebombs
		set tempd 1000
	break
	case 141 // cluster pipebombs
		set tempd 6000
		ife weap_owned[241] YES shiftr tempd 1 else
		ife weap_owned[141] YES shiftr tempd 1
		
		ife weap_owned[43] YES shiftr tempd 1
		
	break
	case 142 // smart bomblets
		set tempd 8000
		ife weap_owned[242] YES shiftr tempd 1 else
		ife weap_owned[142] YES shiftr tempd 1
		
		ife weap_owned[43] YES shiftr tempd 1
	break
	
	case 143 // big boom
	
		set tempd 10000
		ife weap_owned[141] YES shiftr tempd 1 else
		ife weap_owned[142] YES shiftr tempd 1 else
		ife weap_owned[241] YES shiftr tempd 1 else
		ife weap_owned[242] YES shiftr tempd 1 else
		ife weap_owned[41] YES shiftr tempd 1 else
		ife weap_owned[42] YES shiftr tempd 1
	
	break
	case 150 // regular shrinker
		set tempd 1000
	break
	case 151 // BMFG
		ife VOLUME 6 ifge LEVEL 12 set tempd 12000 else
		set tempd 8000
		ife weap_owned[151] YES shiftr tempd 2
	break
	case 152 // BMFG altfire
		set tempd 3000
		ife weap_owned[152] YES shiftr tempd 2
	break
	case 153 // plasma rifle double ammo
		set tempd 2000
		ife weap_owned[153] YES shiftr tempd 1
		ife weap_owned[253] YES shiftr tempd 1
	break
	case 154 // babifier
		set tempd 1000
	break
	case 155 // fan service
		set tempd 4000
		ife weap_owned[156] YES set tempd 2000
		ife weap_owned[56] YES set tempd 2000
	break
	case 156 // BFF ray
		set tempd 6000
		ife weap_owned[155] YES set tempd 3000
		ife weap_owned[55] YES set tempd 3000
	break
	case 157 // plasma rifle
		set tempd 1000
	break
	
	case 160 // normal devastator
		set tempd 1000
	break
	case 161 // meteorator
		set tempd 6000
		ife weap_owned[161] YES shiftr tempd 1
	break
	case 162 // quad barrels
		set tempd 8000
		ife weap_owned[162] YES shiftr tempd 2 else
		ife weap_owned[262] YES shiftr tempd 2 else
		ife weap_owned[362] YES shiftr tempd 2
	break
	case 170 // railgun
		set tempd 1000
	break
	case 171 // barret
		set tempd 6000
		ife weap_owned[171] YES shiftr tempd 2 else
		ife weap_owned[271] YES shiftr tempd 2
	break
	case 172 // barret semi-auto
		set tempd 9000
		ife weap_owned[172] YES shiftr tempd 2 else
		ife weap_owned[272] YES shiftr tempd 2
	break
	case 180 // laser tripbomb
		set tempd 3000
		ife weap_owned[180] YES shiftr tempd 2
	break
	case 181 // spider bomb
		set tempd 8000
		ife weap_owned[181] YES shiftr tempd 2
	break
	case 182 // spider mobility upgrade
		set tempd 3000
		ife weap_owned[182] YES shiftr tempd 2
	break
	case 183 // DEATHBEAM MINE
		set tempd 3000
		ife weap_owned[183] YES shiftr tempd 2
	break
	case 190 // REGULAR FREEZER
		set tempd 1000
	break
	case 191 // FREEZE BEAM
		set tempd 7000
		ife weap_owned[191] YES shiftr tempd 1
	break
	case 194 // DEFLECT BULLETS
		set tempd 6000
		ife weap_owned[194] YES shiftr tempd 1 else
		ife weap_owned[294] YES shiftr tempd 1
	break

	// BOMBSHELL UPGRADES
	case 200 // regular DE pistol
		set tempd 1000
	break
	case 201 // shelly glock18
		set tempd 5000
		ife weap_owned[1] YES shiftr tempd 2
	break
	case 202 // shelly AP
		set tempd 6000
		ife weap_owned[2] YES shiftr tempd 2
		ife weap_owned[202] YES shiftr tempd 2
	break
	case 203 // shelly dual pistols
		set tempd 6000
		ife weap_owned[3] YES shiftr tempd 2
	break
	case 204 // alien pistol
		set tempd 1000
		ife weap_owned[4] YES shiftr tempd 2
	break
	case 205 // alien pistol upgrade
		set tempd 6000
		ife weap_owned[5] YES shiftr tempd 2
	break
	case 206 // doubled pistol ammo
		set tempd 4000
		ife weap_owned[6] YES shiftr tempd 1 else
		ife weap_owned[206] YES shiftr tempd 1
	break
	
	case 207 // increased pistol reload speed
		set tempd 5000
	break

	case 210 // shelly shotgun
		set tempd 1000
	break
	case 211 // explosive rounds
		set tempd 5000
		ife weap_owned[11] YES shiftr tempd 2
	break
	case 212 // semi-auto shotgun
		set tempd 6000
		ife weap_owned[212] YES shiftr tempd 1
	break
	case 214 // bow
		set tempd 2000
	break
	case 215 // explosive arrows
		set tempd 4000
		ifvarand shellyupgrades[SHOTGUN_WEAPON] 16 shiftr tempd 1
		ifvarand shellyupgrades[SHOTGUN_WEAPON] 64 shiftr tempd 1
		// 8
	break
	case 216 // multishot arrows
		set tempd 4000
		ifvarand shellyupgrades[SHOTGUN_WEAPON] 8 shiftr tempd 1
		ifvarand shellyupgrades[SHOTGUN_WEAPON] 64 shiftr tempd 1
		// 16
	break
	case 217 // electric arrows
		set tempd 4000
		ifvarand shellyupgrades[SHOTGUN_WEAPON] 8 shiftr tempd 1
		ifvarand shellyupgrades[SHOTGUN_WEAPON] 16 shiftr tempd 1
		// 64
	break
	case 220 // regular M4
		set tempd 1000
	break
	case 221 // double m4
		set tempd 7000
		ife weap_owned[21] YES shiftr tempd 1
	break
	case 222 // AP M4
		set tempd 6000
		ife weap_owned[22] YES shiftr tempd 2
	break
	case 223 // +max ammo M4
		set tempd 4000
		ife weap_owned[23] YES shiftr tempd 2
	break
	case 224 // executioner
		set tempd 5000
		ife weap_owned[24] YES shiftr tempd 2
	break
	case 225 // chain gang
		set tempd 2000
		ife weap_owned[25] YES div tempd 2
	break
	case 230 // vanilla RPG
		set tempd 1000
	break
	
	case 231 // smart RPG
		set tempd 6000
		ife weap_owned[31] YES shiftr tempd 2
	break
	case 232 // fast rox
		set tempd 2000
		ife weap_owned[32] YES shiftr tempd 2
	break
	case 233 // multi rox
		set tempd 3000
		ife weap_owned[33] YES shiftr tempd 2
	break
	
	case 240 // regular turret
		set tempd 6000
	break
	case 241 // missile turret
		set tempd 6000
		ife weap_owned[241] YES shiftr tempd 1 else
		ife weap_owned[41] YES shiftr tempd 1
	break
	case 242 // armored turrets
		set tempd 6000
		ife weap_owned[242] YES shiftr tempd 1 else
		ife weap_owned[42] YES shiftr tempd 1
	break
	case 250 // regular shrinker
		set tempd 1000
	break
	case 251 // BMFG
		ife VOLUME 6 ifge LEVEL 12 set tempd 12000 else
		set tempd 8000
		ife weap_owned[51] YES shiftr tempd 2
	break
	case 252 // BMFG altfire
		set tempd 3000
		ife weap_owned[52] YES shiftr tempd 2
	break
	case 253 // plasma ammo doubled
		set tempd 2000
		ife weap_owned[53] YES shiftr tempd 1
		ife weap_owned[253] YES shiftr tempd 1
	break
	case 254 // babifier
		set tempd 1000
	break
	case 255 // fan service
		set tempd 4000
		ife weap_owned[156] YES set tempd 2000
		ife weap_owned[56] YES set tempd 2000
	break
	case 256 // BFF ray
		set tempd 6000
		ife weap_owned[55] YES set tempd 3000
		ife weap_owned[155] YES set tempd 3000
	break
	case 257 // plasma rifle
		set tempd 1000
	break
	
	case 260 // regular devastator
		set tempd 1000
	break
	case 261 // sticky bombs
		set tempd 5000
		ife weap_owned[61] YES shiftr tempd 1
	break
	case 262 // quad barrels
		set tempd 8000
		ife weap_owned[62] YES shiftr tempd 2 else
		ife weap_owned[262] YES shiftr tempd 2 else
		ife weap_owned[362] YES shiftr tempd 2
	break
	case 270 // regular railgun
		set tempd 1000
	break
	case 271 // barret
		set tempd 6000
		ife weap_owned[71] YES shiftr tempd 2 else
		ife weap_owned[271] YES shiftr tempd 2
	break
	case 272 // barret semi-auto
		set tempd 9000
		ife weap_owned[72] YES shiftr tempd 2 else
		ife weap_owned[272] YES shiftr tempd 2
	break
	case 280 // tripbombs
		set tempd 3000
		ife weap_owned[80] YES shiftr tempd 2 else
		ife weap_owned[280] YES shiftr tempd 2
	break
	case 281 // spider bombs
		set tempd 8000
		ife weap_owned[81] YES shiftr tempd 2 else
		ife weap_owned[281] YES shiftr tempd 2
	break
	case 282 // spider mobility upgrade
		set tempd 3000
		ife weap_owned[82] YES shiftr tempd 2 else
		ife weap_owned[282] YES shiftr tempd 2
	break
	case 283 // DEATHBEAM MINE
		set tempd 3000
		ife weap_owned[83] YES shiftr tempd 2 else
		ife weap_owned[283] YES shiftr tempd 2
	break
	case 290 // INCINERATOR
		set tempd 1000
	break
	case 291 // INCINERATOR UPGRADE
		set tempd 6000
		ife weap_owned[91] YES shiftr tempd 1
	break
	case 294 // DEFLECT BULLETS
		set tempd 6000
		ife weap_owned[94] YES shiftr tempd 1 else
		ife weap_owned[294] YES shiftr tempd 1
	break
	
		// WES UPGRADES
	case 300 // regular 8-shooter pistol
		set tempd 1000
	break
	
	case 302 // Wes AP
		set tempd 6000
		ife weap_owned[2] YES shiftr tempd 2 else
		ife weap_owned[102] YES shiftr tempd 2
	break
	
	case 304 // alien pistol
		set tempd 1000
		ife weap_owned[4] YES shiftr tempd 2 else
		ife weap_owned[104] YES shiftr tempd 2
	break
	case 305 // alien pistol upgrade
		set tempd 6000
		ife weap_owned[5] YES shiftr tempd 2 else
		ife weap_owned[105] YES shiftr tempd 2
	break
	case 306 // doubled pistol ammo
		set tempd 4000
		ife weap_owned[6] YES shiftr tempd 1 else
		ife weap_owned[106] YES shiftr tempd 1
	break
	
	case 307 // increased pistol reload speed
		set tempd 5000
	break

	case 310 // wes shotgun
		set tempd 1000
	break

	case 312 // semi-auto shotgun
		set tempd 6000
		ife weap_owned[112] YES shiftr tempd 1
	break
	case 314 // bow
		set tempd 2000
	break
	case 315 // RADIOACTIVE arrows
		set tempd 4000
		ifvarand wesupgrades[SHOTGUN_WEAPON] 16 shiftr tempd 1
		ifvarand wesupgrades[SHOTGUN_WEAPON] 512 shiftr tempd 1
		// 8
	break
	case 316 // multishot arrows
		set tempd 4000
		ifvarand wesupgrades[SHOTGUN_WEAPON] 8 shiftr tempd 1
		ifvarand wesupgrades[SHOTGUN_WEAPON] 512 shiftr tempd 1
		// 16
	break
	case 317 // ELEMENTAL arrows
		set tempd 4000
		ifvarand wesupgrades[SHOTGUN_WEAPON] 8 shiftr tempd 1
		ifvarand wesupgrades[SHOTGUN_WEAPON] 16 shiftr tempd 1
		// 64
	break
	case 320 // regular uzi
		set tempd 1000
	break
	case 322 // AP uzi
		set tempd 6000
		ife weap_owned[22] YES shiftr tempd 2 else
		ife weap_owned[122] YES shiftr tempd 2
	break
	case 323 // +max ammo uzi
		set tempd 4000
		ife weap_owned[23] YES shiftr tempd 2 else
		ife weap_owned[123] YES shiftr tempd 2
	break
	case 324 // executioner
		set tempd 5000
		ife weap_owned[24] YES shiftr tempd 2 else
		ife weap_owned[124] YES shiftr tempd 2
	break
	case 325 // chain gang
		set tempd 2000
		ife weap_owned[25] YES div tempd 2 else
		ife weap_owned[125] YES div tempd 2
	break
	case 330 // vanilla RPG
		set tempd 1000
	break

	
	case 340 // regular freeze bombs
		set tempd 1000
	break
	case 341 // cluster freeze bombs
		set tempd 6000
		ife weap_owned[141] YES shiftr tempd 1 else
		ife weap_owned[41] YES shiftr tempd 1
		
	break
	case 342 // seeking freeze bombs
		set tempd 8000
		ife weap_owned[142] YES shiftr tempd 1 else
		ife weap_owned[42] YES shiftr tempd 1
	break

	case 351 // bloodzombie
		set tempd 3000
	break
	case 353 // plasma ammo doubled
		set tempd 2000
		ife weap_owned[53] YES shiftr tempd 1 else
		ife weap_owned[153] YES shiftr tempd 1
	break
	
	case 355 // SCAR full auto
		set tempd 3000
	break

	case 357 // plasma rifle
		set tempd 1000
	break
	
	case 360 // regular devastator
		set tempd 1000
	break
	
	case 362 // quad barrels
		set tempd 8000
		ife weap_owned[62] YES shiftr tempd 2 else
		ife weap_owned[162] YES shiftr tempd 2 else
		ife weap_owned[362] YES shiftr tempd 2
	break
	case 370 // regular railgun
		set tempd 1000
	break
	case 371 // barret
		set tempd 6000
		ife weap_owned[71] YES shiftr tempd 2 else
		ife weap_owned[171] YES shiftr tempd 2
	break
	case 372 // barret semi-auto
		set tempd 9000
		ife weap_owned[72] YES shiftr tempd 2 else
		ife weap_owned[172] YES shiftr tempd 2
	break
	case 380 // tripbombs
		set tempd 3000
		ife weap_owned[80] YES shiftr tempd 2 else
		ife weap_owned[180] YES shiftr tempd 2
	break
	case 381 // spider bombs
		set tempd 8000
		ife weap_owned[81] YES shiftr tempd 2 else
		ife weap_owned[181] YES shiftr tempd 2
	break
	case 382 // spider mobility upgrade
		set tempd 3000
		ife weap_owned[82] YES shiftr tempd 2 else
		ife weap_owned[182] YES shiftr tempd 2
	break
	
	case 383 // DEATHBEAM MINE
		set tempd 3000
		ife weap_owned[83] YES shiftr tempd 2 else
		ife weap_owned[183] YES shiftr tempd 2
    break
	
	case 390 // BLADE LAUNCHER
		set tempd 1000
	break
	case 391 // BLADE LAUNCHER UPGRADE
		set tempd 6000
		ife weap_owned[91] YES shiftr tempd 1 else
		ife weap_owned[191] YES shiftr tempd 1
	break
	case 394 // DEFLECT BULLETS
		set tempd 6000
		ife weap_owned[94] YES shiftr tempd 1 else
		ife weap_owned[194] YES shiftr tempd 1 else
		ife weap_owned[394] YES shiftr tempd 1
	break
	
	case 400 // regular wrist blaster
		set tempd 1000
	break
	
	case 402 // wrist +ROF
		set tempd 6000
		ife weap_owned[401] YES shiftr tempd 1
	break
	
	case 404 // alien pistol
	case 504
		set tempd 1000
		ife weap_owned[4] YES shiftr tempd 2 else
		ife weap_owned[104] YES shiftr tempd 2 else
		ife weap_owned[204] YES shiftr tempd 2
	break
	case 405 // alien pistol upgrade
	case 505
		set tempd 6000
		ife weap_owned[5] YES shiftr tempd 2 else
		ife weap_owned[105] YES shiftr tempd 2 else
		ife weap_owned[205] YES shiftr tempd 2
	break
	case 406 // doubled pistol ammo
	case 506
		set tempd 4000
		ife weap_owned[6] YES shiftr tempd 1 else
		ife weap_owned[106] YES shiftr tempd 1 else
		ife weap_owned[206] YES shiftr tempd 1
	break
	
	case 412 // plasma shotty altfire
		set tempd 4000
	break
	
	case 414 // DB shotty
		set tempd 1000
	break
	
	case 415 // shieldbreaker rounds on DB shotty
		set tempd 4000
		ife weap_owned[415] YES shiftr tempd 1
	break
	
	case 416 // rad rounds on Mando's DB shotty
		set tempd 4000
		ife weap_owned[415] YES shiftr tempd 1
	break
	
	case 420 // regular slugthrower
		set tempd 1000
	break
	case 421 // doubled
		set tempd 6000
		ife weap_owned[21] YES shiftr tempd 2 else
		ife weap_owned[121] YES shiftr tempd 2
	break
	case 422 // AP slugthrower
		set tempd 6000
		ife weap_owned[22] YES shiftr tempd 2 else
		ife weap_owned[122] YES shiftr tempd 2 else
		ife weap_owned[222] YES shiftr tempd 2
	break
	case 423 // +max ammo chaingun
	case 523
		set tempd 4000
		ife weap_owned[23] YES shiftr tempd 2 else
		ife weap_owned[123] YES shiftr tempd 2 else
		ife weap_owned[223] YES shiftr tempd 2
	break
	case 424 // executioner
	case 524
		set tempd 5000
		ife weap_owned[24] YES shiftr tempd 2 else
		ife weap_owned[124] YES shiftr tempd 2 else
		ife weap_owned[224] YES shiftr tempd 2
	break
	case 425 // chain gang
	case 525
		set tempd 2000
		ife weap_owned[25] YES div tempd 2 else
		ife weap_owned[125] YES div tempd 2 else
		ife weap_owned[225] YES div tempd 2
	break
	
	case 531
		set tempd 4000
	break
	
	case 430
		set tempd 1000
	break
	
	case 431 // RPG doubleboom
		set tempd 8000
		ife weap_owned[31] YES shiftr tempd 1 else
		ife weap_owned[131] YES shiftr tempd 1
	break
	
	case 432 // burstfire rockets
		set tempd 3000
		ife weap_owned[33] YES shiftr tempd 1 else
		ife weap_owned[133] YES shiftr tempd 1
	break
	
	case 541 // hypno-doll
		set tempd 3000
	break
	
	case 440 // thermal detonators
		set tempd 1000
	break
	
	case 441 // sticky detonators
		set tempd 4000
		ife weap_owned[241] YES shiftr tempd 1 else
		ife weap_owned[141] YES shiftr tempd 1 else
		ife weap_owned[41] YES shiftr tempd 1
	break
	
	case 450 // regular shrinker
		set tempd 1000
	break
	case 451 // BMFG
		ife VOLUME 6 ifge LEVEL 12 set tempd 12000 else
		set tempd 8000
		ife weap_owned[51] YES shiftr tempd 2 else
		ife weap_owned[151] YES shiftr tempd 2
	break
	case 452 // BMFG altfire
		set tempd 3000
		ife weap_owned[52] YES shiftr tempd 2 else
		ife weap_owned[152] YES shiftr tempd 2
	break
	case 453 // plasma ammo doubled
	case 553
		set tempd 2000
		ife weap_owned[53] YES shiftr tempd 1
		ife weap_owned[253] YES shiftr tempd 1
	break
	case 454 // babifier
		set tempd 1000
	break
	case 455 // fan service
		set tempd 4000
		ife weap_owned[156] YES shiftr tempd 1
		ife weap_owned[56] YES shiftr tempd 1
	break
	case 456 // BFF ray
		set tempd 6000
		ife weap_owned[55] YES shiftr tempd 1
		ife weap_owned[155] YES shiftr tempd 1
	break
	case 457 // plasma rifle
	case 557
		set tempd 1000
	break
	case 460 // regular annihilator
	case 560
		set tempd 1000
	break
	case 461 // annihilator shock rounds
	case 561
		set tempd 5000
	break
	case 462 // annihilator quad barrels
	case 562
		set tempd 8000
		ife weap_owned[62] YES shiftr tempd 2 else
		ife weap_owned[162] YES shiftr tempd 2 else
		ife weap_owned[262] YES shiftr tempd 2 else
		ife weap_owned[362] YES shiftr tempd 2 else
		ife weap_owned[462] YES shiftr tempd 2
	break
	
	case 470 // disintegrator
	case 570
		set tempd 1000
	break
	
	case 471 // disintegrator splash zone
	case 571
		set tempd 4000
	break
	
	case 472 // disintegrator smart ricochet
	case 572
		set tempd 6000
	break
	
	case 480 // laser tripbomb
	case 580
		set tempd 3000
		ife weap_owned[180] YES shiftr tempd 2
	break
	case 481 // spider bomb
	case 581
		set tempd 8000
		ife weap_owned[181] YES shiftr tempd 2
	break
	case 482 // spider mobility upgrade
	case 582
		set tempd 3000
		ife weap_owned[182] YES shiftr tempd 2
	break
	case 483 // DEATHBEAM MINE
	case 583
		set tempd 3000
		ife weap_owned[183] YES shiftr tempd 2
	break
	case 490 // CARBONITE RIFLE
		set tempd 1000
	break
	
	case 491 // ALTFIRE MIST
		set tempd 4000
		ife weap_owned[491] YES shiftr tempd 1
	break
	
	case 492 // BRAIN WASHER
	case 596 // ANCESTRAL RAGE
		set tempd 4000
	break
	
	case 494 // deflect hitscan
	case 594
		set tempd 6000
		ife weap_owned[94] YES shiftr tempd 1 else
		ife weap_owned[194] YES shiftr tempd 1 else
		ife weap_owned[294] YES shiftr tempd 1
	break
	
	case 501 // Dea corrosive pistol rounds
		set tempd 5000
		ife weap_owned[302] YES shiftr tempd 1
	break
	
	case 511	// Dea concussive shotgun
		set tempd 4000
		ife weap_owned[312] YES shiftr tempd 1
	break
	case 512	// Dea life leach shotgun
		set tempd 4000
		ife weap_owned[312] YES shiftr tempd 1
	break
	
	case 521 	// dea altfire burst chaingun
		set tempd 2000
	break
	
	case 515 // Dea seeking blastballs on Xbow
		set tempd 5000
		ife weap_owned[315] YES shiftr tempd 1
	break
	
	case 551 // Dea chrono-trigger
		set tempd 2000
	break
	
	case 552 // Dea chrono-cross
		set tempd 4000
	break
	
	case 555 // eviscerator extended suffering
		set tempd 3000
	break
	
	case 591 // Dea goo puddles
		set tempd 4000
		ife weap_owned[391] YES shiftr tempd 1
	break
	
	case 595 // Dea increased cloak
		set tempd 3000
	break
	
	case 600 // EMT TRAINING
		set tempd 10000
	break
	
	case 601 // UPGRADED MEDKIT
		set tempd 8000
	break
	
	case 602 // NORMAL GOGGLES
		set tempd 1000
	break
	
	case 603 // AIMBOT GOGGLES
		set tempd 5000
	break
	
	case 604 // COVER CUBE CRUSHER
		set tempd 3000
	break
	
	case 605 // HOLOBAGGER
		set tempd 8000	
	break
	
	case 606 // NORMAL BOOTS
		set tempd 1000
	break
	
	case 607 // DASH BOOTS
		set tempd 5000
	break
	
	case 610 // HEALTH +25
		set tempd healthbuff
		mul tempd 70
	break
	
	case 611 // COIN MAGNET
		set tempd 5000
	break
	
	case 612 // low health regen
		ifg regenmax 60 set tempd 999999
		else
		set tempd 5000
	break
	
	case 613 // EDF rescue
		set tempd 15000
	break
	
	case 614 // quicker kicks
		set tempd 6000
	break
	
	case 615 // I-FRAMES+ ; USED TO BE RADAR
		set tempd iframes_max
		add tempd 20
		mul tempd tempd
		mul tempd 8
		add tempd 800
	break
	
	case 616 // no self damage
		set tempd 8000
	break
	
	case 617 // companion sideguns
		set tempd 14000
	break
	
	case 620 // duke perk
		set tempd 6000
	break
	
	case 621 // bombshell perk
		set tempd 6000
	break
	
	case 622 // wes perk
		set tempd 6000
	break
	
	case 623 // auto-revive
		set tempd 4000
	break
	
	case 624 // mando perk
		set tempd 6000
	break
	
	case 625 // dea perk
		set tempd 6000
	break
	
	default 
		set tempd 0
		// this should only happen if the player has selected a blank area with no item
	break
	
	endswitch
	
	ifge TMP_B 100 ifl TMP_B 600 // looking to buy a weapon
	ife marathon 2 
	{	
		set tempe tempd
		div tempd 2
		ifl tempd 500 ifge tempe 500 set tempd 500
	}
	// cheaper weapons in campaign
ends

include scripts/weapons_hud.CON

defstate setshieldarrays

// basic weak shield
setarray es_hpmax[1] 50
setarray es_delay[1] 180
setarray es_speed[1] 5

// fast, weak shield
setarray es_hpmax[2] 30
setarray es_delay[2] 100
setarray es_speed[2] 4

// strong, slow shield
setarray es_hpmax[3] 70
setarray es_delay[3] 250
setarray es_speed[3] 4

// SECOND ROW OF SHIELDS MUCH MORE EXPENSIVE AND JUST PLAIN BETTER

setarray es_hpmax[4] 100
setarray es_delay[4] 180
setarray es_speed[4] 3

setarray es_hpmax[5] 70
setarray es_delay[5] 120
setarray es_speed[5] 2

setarray es_hpmax[6] 140
setarray es_delay[6] 240
setarray es_speed[6] 2

// last 3 shields may not be used; last 3 slots on vendor screen for nova mods
setarray es_hpmax[7] 125
setarray es_delay[7] 150
setarray es_speed[7] 2

setarray es_hpmax[8] 70
setarray es_delay[8] 80
setarray es_speed[8] 1

setarray es_hpmax[9] 220
setarray es_delay[9] 240
setarray es_speed[9] 1

ends

defstate clearshock
	set startshocktime -1
	setarray shockchain[0] -1
	setarray shockchain[1] -1
	setarray shockchain[2] -1
	setarray shockchain[3] -1
	setarray shockchain[4] -1
	ifactorsound THISACTOR ELECTRICLOOP stopactorsound THISACTOR ELECTRICLOOP
ends

defstate civlist

	switch sprite[spriteid].picnum
	case FEMCIV case FEMCIVCROUCH case FEMCIV2 case FEMCIV2CROUCH 
	case FEMCIV3 case FEMCIV3CROUCH case FEMCIV5 case FEMCIV5CROUCH
	case MALECIV1 case MALECIV1CROUCH case MALECIV2 case MALECIV2CROUCH 
	case MALECIV4 case MALECIV4CROUCH case MALECIV3 case MALECIV3CROUCH
	case MALECIV5 case MALECIV5CROUCH
	case MALECIV6 case MALECIV6CROUCH case MALECIV2SMOKING
	case GUARD case GUARDCROUCH case CRYSTAL case MAIDNPC
	case EDFSNIPER case EDFSNIPERCROUCH case EDFTROOP case ARMEDF
	case EDFDRONE
	case NAKEDBABE case NAKEDBABECROUCH case PIGSTRIPPER
	case STRIPPER case STRIPPERCROUCH case KBABE case KBABECROUCH case CHEERLEADER
	case CHEERLEADERCROUCH case HOOKER case HOOKERCROUCH case POLEDANCER
	case CAVEGIRL case CAVEGIRLCROUCH case BIKINIBABE case BIKINIBABE2
	case FATGUY1 case FATGUY2 case ALIENCIVMALE case ALIENCIVFEM
		changespritestat spriteid 1
	break
	endswitch

ends

defstate wakeupcivs
	
	headspritestat spriteid 2
	whilevarn spriteid -1
	{
		state civlist
		nextspritestat spriteid spriteid
	}
	

ends

defstate checkheldobject

	ifn PLAYERONTHEBIKE 1
	ifpdistl 1024
	ifp pfacing
	ifcansee
	ifp palive
	ife heldobject -1
	
	ife zombieonplayer -1
	ife onturret -1
	ife sidekick 0
	ife pipehold 0
	ife slidekick 0
	ife heldtime 0
	ife juice_pos 0
	ife player[].kickback_pic 0
	ife vendor_screen 0
	ife brutalvictim -1
	{
		set heldnear 10
		ifhitspace
		{
			set heldobject THISACTOR
			set heldcstat sprite[].cstat
			set heldtime 1
		}
	}
ends

defstate checksaberblock

	set spriteid player[].i
	
	ifg sprite[spriteid].htextra 1 ife sprite[spriteid].htowner THISACTOR
	ifn blockang 6666 seta[spriteid].htextra -1
	else ife blockang 6666
	{
		ifg saberpos 0 ifl saberpos 85 nullop else
		ifangdiffl 512 nullop else	
		ife sprite[spriteid].htowner THISACTOR
		ife player[].curr_weapon KNEE_WEAPON
		ifn gotsaber 0 ife player[].weapon_pos 0
		{
			seta[spriteid].htextra -1
			getp[].ang angvar
			getincangle blockang angvar sprite[].ang
			ifl blockang 0 set blockang -9 else set blockang 9
			flash
			
			ife pchar 4
			{
				rand temp 2
				ife temp 0 screensound DEABLOCK else
				ife temp 1 screensound DEABLOCK2 else
				screensound DEABLOCK3
			}
			else
			ife pchar 2 soundonce BLADEHITMET else
			soundoncevar sabclashsnd
			
			set tempe player[].posz add tempe 1024
			espawn SPARKFALL setsprite RETURN player[].posx player[].posy tempe
			espawn SPARKFALL setsprite RETURN player[].posx player[].posy tempe
			espawn SPARKFALL setsprite RETURN player[].posx player[].posy tempe
		}
	}
ends

defstate sawon
	set WEAPON0_FIREDELAY 2
	set WEAPON0_SHOOTS SAWPROJ
	set WEAPON0_FLAGS 268
	set WEAPON0_TOTALTIME 8
	set gotsaw YES
ends

defstate sawoff
	set WEAPON0_FIREDELAY 7
	set WEAPON0_SHOOTS KNEE
	set WEAPON0_FLAGS 292
	set WEAPON0_TOTALTIME 14
	set gotsaw NO
ends

defstate incoming_eval

	ife sprite[myspawner].statnum 1024 { set myspawner -1 break }
	
	geta[myspawner].x x
	geta[myspawner].y y
	sub x sprite[].x
	sub y sprite[].y
	geta[].z z
	sub z 8192
	getangle angvel x y

	add angvel 512
	cos mycos angvel
	sin mysin angvel
	hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 mysector temp spriteid x y zdist 4294901809
	sub x sprite[].x
	sub y sprite[].y
	mul x x
	mul y y
	add x y
	sqrt x x
	set xydist x
	
	sub angvel 1024
	cos mycos angvel
	sin mysin angvel
	hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 mysector temp spriteid x y zdist 4294901809
	sub x sprite[].x
	sub y sprite[].y
	mul x x
	mul y y
	add x y
	sqrt x x
	
	ifl x xydist add angvel 1024
ends

defstate jumpheightcheck
	hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 tempd hitwall hitsprite hitx hity hitz CLIPMASK1
	
	set starty sprite[].x
	sub starty hitx
	mul starty starty
	set y2 sprite[].y
	sub y2 hity
	mul y2 y2
	add starty y2
	sqrt starty starty
ends

defstate dmtauntcode
	ifn thiscam -1 break
	// this is run by actors who taunt the player during matches
	
	ife LEVEL 11 // opening match
	{
		ife player[].player_par 95
		{
			set cutcamtime player[].player_par
			set emp_overlay 210
			set emp_overlay_tile 15266
			set subtitle_start 696
			set subtitle_numlines 2
			set subtitle_time 210
			screensound ELITEROAM1
		}
		ife bluescore 17
		ifle redscore 15
		ife monstatus 1
		ifge sprite[].htextra sprite[].extra
		{
			set cutcamtime player[].player_par
			set emp_overlay 180
			set emp_overlay_tile 15266
			set subtitle_start 698
			set subtitle_numlines 2
			set subtitle_time 180
			screensound ELITEROAM2
		}
		
	}
	
	ife LEVEL 16 // sith boss fight
	{
		ifspritepal 10
		ife FEMKILLCOUNT 0
		{
			screensound SITHTAUNT1
			set cutcamtime player[].player_par
			set emp_overlay 120
			set emp_overlay_tile 15268
			set subtitle_start 800
			set subtitle_numlines 1
			set subtitle_time 120
			set FEMKILLCOUNT 1
		}
		ifspritepal 22
		ife monstatus 1
		ife subtitle_time 0
		ife player[].player_par 1800
		{
			globalsound SYTHTAUNT2
			set cutcamtime player[].player_par
			set emp_overlay 150
			set emp_overlay_tile 15267
			set subtitle_start 801
			set subtitle_numlines 2
			set subtitle_time 150
		}
	}
	
	// littlebigmen fight handled in their code
	
ends

defstate blowupcrack
	
	set TMP_B 0
	headspritestat spriteid 6
	whilevarn spriteid -1
	{
		getactor[spriteid].picnum picnum
		switch picnum
		case CRACK1 case CRACK2 case CRACK3 case CRACK4
		ldist xydist THISACTOR spriteid
		ifl xydist 512 // 1025
		{
			set z sprite[].z
			sub z sprite[spriteid].z
			abs z
			ifl z 8192
			{
				seta[].yvel 0
				set TMP_B 1
			}
		}
		break
		default break
		endswitch
		nextspritestat spriteid spriteid
		ife TMP_B 1 set spriteid -1
	}
ends


defstate predamage

	ife sprite[].htextra -1
	ifn bleeding 0
	{
		ifg bleeding inithp set bleeding inithp
		ifl bleeding 0
		{
			set TMP_A bleeding, abs TMP_A
			ifg TMP_A inithp { set bleeding inithp mul bleeding -1 }
		}
		ifvarand player[].player_par 1
		{
			seta[].htextra 1
			ifg bleeding 0 seta[].htpicnum SHOTSPARK1 else seta[].htpicnum RADWOUND
			ifn team 1 ifn team 3
				seta[].htowner player[].i
			ifg bleeding 0
			sub bleeding 1
			else add bleeding 1
			ife bleeding 0 { ifactorsound THISACTOR RADFRY stopactorsound THISACTOR RADFRY }
			else ife sprite[].mdflags 0 seta[].mdflags 16
			ifactor APLAYER
			{
				soundonce RADFRY
				set waterpal 8
				ifg water_screen -20 set water_screen -30
				ifg player[].boot_amount 0
				{
				  getp[].boot_amount temp
				  sub temp 1
				  setp[].boot_amount temp
				  ife player[].fta 0 quote 75
				  seta[].htextra -1
				}
				ifl bleeding 0 ifg bleeding -30
				{
					set temp player[].player_par
					modvar temp 3
					ife temp 0 seta[].htextra -1
				}
			}
			break
		}
	}
	ifn attmode NO
	ife player[].actorsqu THISACTOR
	ife player[].knee_incs 14
	{
		set temp inithp
		mul temp 2
		seta[].htextra temp
		seta[].htowner player[].i
		seta[].htpicnum BOOTS
	}
	
	ife monstatus 1
	ifl sprite[].extra 0
		strength 1
	
	ife sprite[].htextra 0 ifn sprite[].htpicnum SHRINKSPARK seta[].htextra -1
	ife sprite[].htextra -1 break
	
	switch sprite[].htpicnum
	
	case SHOTSPARK1
	case SABERPROJ
		
		ifg saberpos 0 ifl saberpos 85 nullop else
		ife THISACTOR player[].i
		ifg gotsaber 0 ife player[].weapon_pos 0
		ife player[].curr_weapon KNEE_WEAPON
		{
			ifvarand dukeupgrades[KNEE_WEAPON] 1
			{
				getincangle angvar sprite[].htang player[].ang
				set temp angvar
				abs temp
				ifg temp 512
				{
					seta[].htextra -1
					ifn pchar 2 ifn pchar 4
					{
						ifn halfpoint 0 set halfpoint 0 else
						{
							sub gotsaber 1 
							set halfpoint 1 
						}
					}
					// set temp sprite[].htextra
					// div temp 4
					// ifl temp 1 set temp 1
					// seta[].htextra temp
					ifl blockang 0 set blockang -9 else set blockang 9
					flash
					globalsound BLASTERBOUNCE
					set tempe player[].posz add tempe 1024
					set x player[].posx
					add x 384
					rotatepoint player[].posx player[].posy x player[].posy player[].ang savx savy
					
					espawn SPARKFALL setsprite RETURN savx savy tempe
					espawn SPARKFALL setsprite RETURN savx savy tempe
					espawn SPARKFALL setsprite RETURN savx savy tempe
					espawn SPARKFALL setsprite RETURN savx savy tempe
					espawn SPARKFALL setsprite RETURN savx savy tempe
					espawn SPARKFALL setsprite RETURN savx savy tempe
					
					ifrnd 128 shoot SHOTSPARK1
					ifrnd 128 shoot SHOTSPARK1
				}
			}
		}
		
		ife pchar 2 ife sprite[].htowner player[].i
		ife player[].curr_weapon GROW_WEAPON
		ifn sprite[].pal 1 ifg sprite[].extra 1
			seta[].htpicnum FREEZEBLAST

	break
	
	// case RADIUSEXPLOSION
		// ife monstatus 1
		// ifn sprite[].htowner -1
		// ife sprite[sprite[].htowner].picnum FIREEXT
			// seta[].htpicnum FREEZEBLAST
	// break
	
	case GRENADEPROJ
	case BIGGRENADEPROJ
	case BMFGPROJ
	case COMETPROJ
	case MORTER2
	case CBPROJ
	case TANKSHELL
	case EXPBULLET
	case WESGRENADE
	case BOOBROCKET
	case PLASGOOPROJ
	case PLASROCKET
	case RAGNAROCKET
	case SMARTBOMB
		seta[].htpicnum RPG
	break
	
	case BLASTBALL
		seta[].htpicnum RPG
	break
	
	case RPG
		ife sprite[].htowner player[].i
		ife player[].curr_weapon SHOTGUN_WEAPON
		{
			set temp NO
			ife pchar 0 ife shotexpduke YES set temp YES
			ife pchar 1 
			{
				ifvarand gotbow 2 nullop else
				ife shotexpshelly YES set temp YES
			}
			ife temp YES
			{
				set temp sprite[].htextra
				mul temp 3 div temp 2
				seta[].htextra temp
			}
		}
	break
		
	case SHRINKSPARK
		ifactor SHARK
			seta[].htextra 1
		set TMP_A 500
		
		set tempb NO
		ife sprite[].htowner player[].i set tempb YES
		ife sprite[].htowner myshelly set tempb YES
		ife tempb YES
		{
			ife pchar 4 set temp nweaplevel[6] else
			ife pchar 3 set temp mweaplevel[6] else
			ife pchar 2 set temp wweaplevel[6] else
			ife pchar 1 set temp bweaplevel[6] else
			set temp dweaplevel[6]
			mul temp 180
			add TMP_A temp
			set TMP_B plevel
			mul TMP_B 50
			
			add TMP_A TMP_B
			add TMP_A sprite[].htextra
			
			ifg sprite[].extra TMP_A 
			// ife sprite[].htextra 0
			{
				seta[].htpicnum SHOTSPARK1  
				set temp plevel
				ife pchar 0
				add temp dweaplevel[6]
				else
				ife pchar 3
				add temp mweaplevel[6]
				else
				ife pchar 2
				add temp wweaplevel[6]
				else
				ife pchar 4
				add temp nweaplevel[6]
				else
				add temp bweaplevel[6]
				mul temp 10
				add temp 20
				seta[].htextra temp
			}
		}
		else
		{
			ifg sprite[].extra TMP_A 
			ife sprite[].htextra 0
			{ seta[].htpicnum SHOTSPARK1 seta[].htextra 30 }
		}
		
	break
	
	case BLOODBULLET
	case BLOODBOMB
		ife monstatus 1
		ifn team 1 ifn team 3 
		{
			ife sprite[].htowner myshelly add botleach 200 else
			add leach 200
		}
	break
	
	case BOMBLET
		seta[].htpicnum RPG
		seta[].htowner player[].i
	break
	
	case FREEZEBOLT
		ifl sprite[].extra 1
		ifspritepal 1
		ifrnd 64 seta[].htpicnum RPG
		else seta[].htpicnum FREEZEBLAST
	break
	
	// case GENERICBOLT

	case LOVEBOMB
		seta[].htpicnum GROWSPARK
		seta[].htowner player[].i
		ifg team 0
			seta[].htextra -1
		else spawn GROWSPARK
	break
	case SHOCKPROJ
		ifvarand monstflags 1048576 seta[].htextra -1
		else
		ifn sprite[].picnum APLAYER
		{
			add stun sprite[].htextra
			sub stun mlevel
			ifl stun 0 set stun 0
		}
	break
	case TIDALPROJ
		ifactor APLAYER
		{
			set spriteid sprite[].htowner
			ifn spriteid -1
			ife sprite[spriteid].picnum POLYMORPH 
			ifl player[].loogcnt 24
			{
				seta[].htpicnum SPIT
				setp[].numloogs 6
				setp[].loogcnt 72
				setp[].loogiex 1 60
				setp[].loogiex 2 120
				setp[].loogiex 3 180
				setp[].loogiex 4 240
				setp[].loogiex 5 300
				setp[].loogiex 6 360
			}
		}
	break
	endswitch
	
	ifg sprite[].htextra 0
	{
		ifn sprite[].htowner -1
		{
			ifvarand actorvar[sprite[].htowner].monstflags 64 // double shot power
			{
				geta[].htextra temp, 
				// shiftl temp 1, 
				mul temp 3 div temp 2
				seta[].htextra temp
			}
			ife sprite[].htpicnum SHOTSPARK1
			ifvarand actorvar[sprite[].htowner].monstflags 128 // multishot
			{
				geta[].htextra temp, 
				// shiftl temp 1, 
				mul temp 3 div temp 2
				seta[].htextra temp
			}
			ifvarand actorvar[sprite[].htowner].monstflags 256 // gigantism
			{
				geta[].htextra temp, mul temp 3, div temp 2 seta[].htextra temp
			}
			ifvarand actorvar[sprite[].htowner].monstflags 4096 // radioactive
			{
				soundonce RADFRY
				set temp sprite[].htextra
				shiftr temp 2, ifl temp 1 set temp 1
				ifg bleeding 0 mul bleeding -1
				sub bleeding temp
				espawn BIGSMOKE
				seta[RETURN].pal 76
			}
			
			ifvarand actorvar[sprite[].htowner].monstflags 16384 // vampirism
			ifn team actorvar[sprite[].htowner].team
			ifn team 3
			ifn sprite[].picnum NATTYBRA ifn sprite[].picnum CYCLOIDMAX
			ifn sprite[].picnum BATBOSS
			{
				set temp sprite[].htowner
				ife sprite[temp].htextra -1 seta[temp].htpicnum CAPTUREPLUS
				set tempb sprite[temp].extra
				add tempb sprite[].htextra
				ifg tempb 32767 set tempb 32767
				seta[temp].extra tempb
				// ifn attmode 0
				
					set tempc actorvar[temp].inithp
					mul tempc 4 div tempc 3
					ifg tempb tempc
					{
						getav[temp].mlevel tempc
						add tempc 1
						setav[temp].mlevel tempc
						setav[temp].inithp tempb
						set tempc actorvar[temp].monxp
						mul tempc 10
						div tempc 9
						setav[temp].monxp tempc
						ifl gametype 1 setav[temp].spawnprotect 70
						else setav[temp].spawnprotect 30
						screensound VRTRANSND
						ife actorvar[temp].team 0
						userquote 1251
					}
				
			}
			
			ifvarand perks 8
			ife team 3
			ife sprite[].htowner player[].i
				seta[].htextra -1
				
			ife team actorvar[sprite[].htowner].team
			{
				ife sprite[sprite[].htowner].picnum SIDEGUN
				seta[].htextra -1

				// ifwasweapon FREEZEBLAST
				ife myshelly sprite[].htowner
				{
					ife myshelly THISACTOR 
					seta[].htextra -1
					
					ifactor APLAYER 
					seta[].htextra -1
				}

				ifvarand perks 8
				ife team 1
				{
					ifactor APLAYER ife sprite[].htowner player[].i 
					{
						set temp sprite[].htextra
						div temp 4, ifl temp 1 set temp 1
						seta[].htextra temp
					}
					else
					seta[].htextra -1
				}
				
			}
			
			
			ife sprite[sprite[].htowner].picnum ROLLYTURRET
			{
				set temp sprite[].htowner
				ife actorvar[temp].team 1
				seta[].htowner player[].i
				set safecount ROLLYTURRET
			}
			else
			ife sprite[sprite[].htowner].picnum SIDEGUN
			{
				set temp sprite[].htowner
				ife actorvar[temp].myspawner player[].i
				seta[].htowner player[].i
				set safecount SIDEGUN
			}
			else set safecount -1

			set temp NO
			ife player[].i sprite[].htowner set temp YES
			ife myshelly sprite[].htowner set temp YES
			ife leftsidegun sprite[].htowner set temp YES
			ife rightsidegun sprite[].htowner set temp YES
			ife temp YES
			{
				ifn pdamage 100
				{
					geta[].htextra temp
					mul temp pdamage
					div temp 100
					seta[].htextra temp
				}
			}
			else // mlevel damage scaling
			// ifn attmode NO
			{
				getav[sprite[].htowner].mlevel TMP_A
				ifg TMP_A 1
				{
					sub TMP_A 1
					mul TMP_A 5
					add TMP_A 75 // 100
				
					geta[].htextra temp
					mul temp TMP_A
					div temp 100
					seta[].htextra temp
				}
			}
// code below is a mess; it is supposed to give the bot
// a damage bonus based on the corresponding character's weapon level
// but it needs to be rewritten
/*		
			ife myshelly sprite[].htowner
			{
				set tempb -1
				switch sprite[].htpicnum
				case SHOTSPARK1
					ife actorvar[myshelly].thirdbaseval 7 set tempb 9 else
					ife pchar 2 set tempb 1 // pistol
					else
					ife pchar 0 set tempb 3 // chaingun
					else set tempb 2  // shotgun
				break
				case KNEE
					set tempb 0 // kicks
				break
				case RPG
					set tempb 4 // RPG
				break
				case FREEZEBLAST
				case FIREBOLT
				case BURNING
					set tempb 9 // FREEZER or INCINERATOR
				break
				case FLAMEPROJ2
					set tempb 1
				break
				endswitch
				ifn tempb -1
				{
					// apply character level damage to bot damage
					set picnum sprite[myshelly].picnum 
					switch picnum
					case DUKEBOT case DUKEBOTCROUCH set tempc dweaplevel[tempb] break
					case SHELLY case SHELLYCROUCH set tempc bweaplevel[tempb] break
					case WESBOT case WESBOTCROUCH set tempc wweaplevel[tempb] break
					case MANDOFETT case MANDOCROUCH tempc mweaplevel[tempb] break
					default set tempc 0
					endswitch
					
					mul tempc 8
					add tempc 100
					ifg tempc 100
					{
						set temp sprite[].htextra
						mul temp tempc
						div temp 100
						seta[].htextra temp
					}
				}
			}
*/	
		}
	}
	ifn restartatt 0 break
	ifn attmode NO
	ife monstatus 1
	ifn team 1 ifn team 3
	ifg sprite[].htextra 0
	{
		geta[].htextra temp
		ifn sprite[].htowner -1
		{
			ife actorvar[sprite[].htowner].team team set temp 0
/*
			ifn sprite[].htowner player[].i
			{
				ife sprite[].htowner leftsidegun ife actorvar[leftsidegun].myspawner player[].i nullop else
				ife sprite[].htowner rightsidegun ifn actorvar[leftsidegun].myspawner player[].i nullop else
				ife sprite[].htowner player[].holoduke_on nullop else
				ife sprite[sprite[].htowner].picnum ROLLYTURRET nullop else
				div temp 2 // half xp from ally kills
			}
*/
		}
		
		set tempb -1 // this is going to be the weapon number
		ifn shrunken 0 ifn pchar 2 set tempb 6 
		else ife sprite[].htpicnum KNEE set tempb 0
		else ife safecount ROLLYTURRET set tempb 5
		else ife sprite[].htpicnum BOOTS set tempb 6
		else ifspritepal 1
		{
			ife sprite[].htpicnum FREEZEBLAST set tempb -1
			else set tempb 9
		}
		else
		{
			set tempF player[].curr_weapon 
			ife instasis player[].player_par set tempF 6
			switch tempF
			case 0 // 0 kicks  // formerly 10 was chainsaw and lightsaber
				ife sprite[].htpicnum SHOTSPARK1
				ife sprite[].htowner player[].i
				{
					set tempb 0
					ifn saberpos 0 seta[].htpicnum SABERPROJ
				}
				else
				{
					ife gotsaw YES set tempb 0 else
					ifg gotsaber 0 set tempb 0 else
					set tempb 0
				}
			break
			case 1 // 1 pistol, laser pistol and comm gun
				set tempb 1
				ife sprite[].htowner player[].i 
					ife LASERMODE 3 set tempb 6 
			break
			case 2 // 2 shotgun
				set tempb 2
				ife pchar 0 ifvarand gotDB 2 set tempb 12
				ife pchar 3 ifvarand gotDB 2 set tempb 12
				ife pchar 4 ifvarand gotDB 2 set tempb 12
				ifge pchar 1 ifle pchar 2 ifvarand gotbow 2 set tempb 12
			break
			case 3 // 3 chaingun
				set tempb 3
			break
			case 4 // 4 RPG
				set tempb 4
				
			break
			case 5 // 5 pipebomb
			case 10
				set tempb 5
			break
			case 6 // 6 shrinker / BMFG
				set tempb 6
				ife pchar 4 mul temp 2
			break
			case 7 // 7 devastator / railgun
				set tempb 7
			break
			case 8 // 8 spider and tripbombs
				set tempb 8
			break
			case 9 // 9 freezer and incinerator / terminator gun
				set tempb 9
			break
			case 11 // 11 expander / shock rifle
				set tempb 11
			break
			endswitch
		}
		ifn tempb -1
		{
			// apply weapon proficiency bonuses, if any
			ife instasis player[].player_par set TMP_A nweaplevel[tempb]
			else ife pchar 4 set TMP_A nweaplevel[tempb]
			else ife pchar 3 set TMP_A mweaplevel[tempb]
			else ife pchar 2 set TMP_A wweaplevel[tempb]
			else ife pchar 1 set TMP_A bweaplevel[tempb]
			else set TMP_A dweaplevel[tempb] 
			ifge TMP_A 3 // opening salvo perk
			ife sprite[].extra inithp
			{
				ife sprite[].htpicnum SHOTSPARK1 seta[].htpicnum RPG
				geta[].htextra tempc
				
				ife tempb 2
				{
					mul tempc 4
					div tempc 3
				}
				else
				{
					add tempc 20
					mul tempc 3, div tempc 2
				}
				
				seta[].htextra tempc
				add stun 20
				// sound
			}
			ifge TMP_A 5 // life leech perk
			ife sprite[].htowner player[].i
			ifn sprite[].picnum EBARRIER
			ifn sprite[].picnum BARRICADE
			{
				set tempd sprite[].htextra
				ifg tempd sprite[].extra set tempd sprite[].extra
				ifg leach 500 div tempd 2
				add leach tempd
			}
			
			ife sprite[].htpicnum BOOTS
			{
				set tempd inithp, mul tempd 2
				ifg sprite[].htextra tempd set temp tempd
			}
			else ifg temp sprite[].extra set temp sprite[].extra
			
			ife sprite[].htpicnum HEADJIB1 add temp 50
			
			ifg temp 0
			ifg monxp 0
			// ife attmode YES
			{
				ife pchar 0 
				{
					set tempc dweapxp[tempb] 
					ifl tempc 0 set tempc 0 // failsafe
					ife sprite[].htowner player[].i
					ifvarand comboperk 1 // ifle combotime 0 
					ifn safecount ROLLYTURRET ifn sprite[].htpicnum KNEE 
					ifn sprite[].htpicnum BURNING 
					set combotime -20
				}
				else
				ife pchar 3
				{
					set tempc mweapxp[tempb] 
					ifl tempc 0 set tempc 0 // failsafe
					ife sprite[].htowner player[].i
					ifvarand comboperk 8 // ifle combotime 0 
					ifn safecount ROLLYTURRET ifn sprite[].htpicnum KNEE 
					ifn sprite[].htpicnum BURNING 
					set combotime -20
				}
				else
				ife pchar 4
				{
					set tempc nweapxp[tempb] 
					ifl tempc 0 set tempc 0 // failsafe
					ife sprite[].htowner player[].i
					ifvarand comboperk 16 // ifle combotime 0 
					ifn safecount ROLLYTURRET ifn sprite[].htpicnum KNEE 
					ifn sprite[].htpicnum BURNING 
					set combotime -20
				}
				else
				ife pchar 2
				{
					set tempc wweapxp[tempb] 
					ifl tempc 0 set tempc 0 // failsafe
					ife sprite[].htowner player[].i
					ifvarand comboperk 4 // ifle combotime 0 
					ifn safecount ROLLYTURRET ifn sprite[].htpicnum KNEE 
					ifn sprite[].htpicnum BURNING 
					set combotime -20
				}
				else 
				{
					set tempc bweapxp[tempb]
					ifl tempc 0 set tempc 0 // failsafe
					ife sprite[].htowner player[].i
					ifvarand comboperk 2 // ifle combotime 0 
					ifn safecount ROLLYTURRET ifn sprite[].htpicnum KNEE 
					ifn sprite[].htpicnum BURNING 
					set combotime -20
				}
				ifn marathon NO 
				{
					set TMP_A temp
					ifvarand startmode 1 ifge dready 1 add temp TMP_A else
					ifvarand startmode 2 ifge bready 1 add temp TMP_A else
					ifvarand startmode 4 ifge wready 1 add temp TMP_A else
					ifvarand startmode 8 ifge mready 1 add temp TMP_A else
					ifvarand startmode 16 ifge nready 1 add temp TMP_A
					div temp 2
				}
				add tempc temp // temp has now served its purpose and can be reused
				ife pchar 0 setarray dweapxp[tempb] tempc else 
				ife pchar 2 setarray wweapxp[tempb] tempc else
				ife pchar 3 setarray mweapxp[tempb] tempc else
				ife pchar 4 setarray nweapxp[tempb] tempc else
				setarray bweapxp[tempb] tempc
				
				ife attmode YES ife VOLUME 5 ife LEVEL 11
				{
					// setarray dweapxp[tempb] tempc setarray bweapxp[tempb] tempc
					setarray dweapxp[2] tempc 
					setarray bweapxp[2] tempc
					setarray wweapxp[2] tempc
					setarray nweapxp[2] tempc
				}
				
				ife pchar 0 set TMP_A dweaplevel[tempb] else 
				ife pchar 2 set TMP_A wweaplevel[tempb] else
				ife pchar 3 set TMP_A mweaplevel[tempb] else
				ife pchar 4 set TMP_A nweaplevel[tempb] else
				set TMP_A bweaplevel[tempb]
				add TMP_A 1
				ifg TMP_A 3 mul TMP_A 3500 else
				ifg TMP_A 2 mul TMP_A 3000 else
				ifg TMP_A 1 mul TMP_A 2500 else
				mul TMP_A 2000
				sub TMP_A 1000
				
				ife pchar 0 set temp dweapxp[tempb] else
				ife pchar 2 set temp wweapxp[tempb] else
				ife pchar 3 set temp mweapxp[tempb] else
				ife pchar 4 set temp nweapxp[tempb] else
				set temp bweapxp[tempb]
				
				ifge temp TMP_A
				{
					ife attmode YES
					ife VOLUME 5 ife LEVEL 11
					{
						operateactivators 2 0
						setarray dweapxp[tempb] 0
						setarray bweapxp[tempb] 0
						setarray wweapxp[tempb] 0
						setarray nweapxp[tempb] 0
						set bigmsgcount 90
						set bigmsg 1137
						screensound WEAPON_UPGRADE
						screensound WEAPON_UPGRADE
						palfrom 32 63 63 63
						break
					}
					
					ife pchar 0 set temp dweaplevel[tempb] else 
					ife pchar 2 set temp wweaplevel[tempb] else
					ife pchar 3 set temp mweaplevel[tempb] else
					ife pchar 4 set temp nweaplevel[tempb] else
					set temp bweaplevel[tempb]
					add temp 1
					ifl temp 7 add totalxp 1000
					ife pchar 0 
					{
						setarray dweaplevel[tempb] temp 
						ifvarand comboperk 1 nullop else
						// check to see if comboperk is achieved
						{
							set TMP_A 0
							set TMP_B 0
							whilevarn TMP_A 13
							{
								ifg dweaplevel[TMP_A] 0
								add TMP_B 1
								add TMP_A 1
							}
							ifge TMP_B 11
							{
								orvar comboperk 1
								set buffermsg 1139
							}
						}
					}
					else ife pchar 4
					{
						setarray nweaplevel[tempb] temp 
						ifvarand comboperk 16 nullop else
						// check to see if comboperk is achieved
						{
							set TMP_A 0
							set TMP_B 0
							whilevarn TMP_A 13
							{
								ifg nweaplevel[TMP_A] 0
								add TMP_B 1
								add TMP_A 1
							}
							ifge TMP_B 11
							{
								orvar comboperk 16
								set buffermsg 1139
							}
						}
					}
					else ife pchar 3
					{
						setarray mweaplevel[tempb] temp 
						ifvarand comboperk 8 nullop else
						// check to see if comboperk is achieved
						{
							set TMP_A 0
							set TMP_B 0
							whilevarn TMP_A 13
							{
								ifg mweaplevel[TMP_A] 0
								add TMP_B 1
								add TMP_A 1
							}
							ifge TMP_B 11
							{
								orvar comboperk 8
								set buffermsg 1139
							}
						}
					}
					else ife pchar 2
					{
						setarray wweaplevel[tempb] temp 
						ifvarand comboperk 4 nullop else
						// check to see if comboperk is achieved
						{
							set TMP_A 0
							set TMP_B 0
							whilevarn TMP_A 13
							{
								ifg wweaplevel[TMP_A] 0
								add TMP_B 1
								add TMP_A 1
							}
							ifge TMP_B 11
							{
								orvar comboperk 4
								set buffermsg 1139
							}
						}
					}
					else 
					{
						setarray bweaplevel[tempb] temp
						ifvarand comboperk 2 nullop else
						// check to see if comboperk is achieved
						{
							set TMP_A 0
							set TMP_B 0
							whilevarn TMP_A 13
							{
								ifg bweaplevel[TMP_A] 0
								add TMP_B 1
								add TMP_A 1
							}
							ifge TMP_B 11
							{
								orvar comboperk 2
								set buffermsg 1139
							}
						}
					}
					
					ife buffermsg 0
					{
						// ife temp 1 set buffermsg 795 else 
						ife temp 3 set buffermsg 796 else ife temp 5 set buffermsg 797
					}
					ife pchar 0 set bigmsg 793 else 
					ife pchar 2 set bigmsg 1195 else 
					ife pchar 3 set bigmsg 1372 else 
					ife pchar 4 set bigmsg 1414 else 
					set bigmsg 794
					set bigmsgcount 90
/*			
					ife pchar 0 set temp dweapxp[tempb] else 
					ife pchar 2 set temp wweapxp[tempb] else 
					ife pchar 3 set temp mweapxp[tempb] else
					ife pchar 4 set temp nweapxp[tempb] else
					set temp bweapxp[tempb]
					sub temp TMP_A
*/
					// ife pchar 0 setarray dweapxp[tempb] temp else setarray bweapxp[tempb] temp
					ife pchar 0 setarray dweapxp[tempb] 0 else 
					ife pchar 2 setarray wweapxp[tempb] 0 else 
					ife pchar 3 setarray mweapxp[tempb] 0 else
					ife pchar 4 setarray nweapxp[tempb] 0 else
					setarray bweapxp[tempb] 0
					screensound WEAPON_UPGRADE
					screensound WEAPON_UPGRADE
					palfrom 32 63 63 63
					
				
				}
				
				ife pchar 0 set TMP_A dweaplevel[tempb] else 
				ife pchar 2 
				{
				 set TMP_A wweaplevel[tempb]
				 ife tempb 0 add TMP_A 2
				}
				else
				ife pchar 3
				 set TMP_A mweaplevel[tempb]
				else
				ife pchar 4
				 set TMP_A nweaplevel[tempb]
				else
				set TMP_A bweaplevel[tempb]
				
				ifg TMP_A 6 { sub TMP_A 6 mul TMP_A 4 add TMP_A 48 }
				else
				mul TMP_A 8
				add TMP_A 100
				geta[].htextra temp
				mul temp TMP_A
				div temp 100
				seta[].htextra temp
			}
		}
	}
	
	set temp NO
	ife attmode YES set temp YES
	ifg gametype 0 set temp YES
	ife temp YES
	ifg sprite[].htextra 0
	ifn sprite[].picnum NEWTROOPTARGET
	ifn sprite[].picnum NEWPIGTARGET
	{
		switch SKILL // userdef[].player_skill
		case 0
		case 1 // piece of cake
			geta[].htextra temp
			ife team 1
			{
				div temp 2
				ifl temp 1 set temp 1
				seta[].htextra temp
			}
			else ifn team 3
			{
				mul temp 2
				seta[].htextra temp
			}
		break
		case 2 // lets rock
			geta[].htextra temp
			ife team 1
			{
				mul temp 3 div temp 4
				ifl temp 1 set temp 1
				seta[].htextra temp
			}
			else ifn team 3
			{
				mul temp 4 div temp 3
				seta[].htextra temp
			}
		break
		case 4 // DIG
		break
		case 5 // Good Day to Die
		case 6 // THIS IS BULLSHIT
		ife gametype 0
		{
			geta[].htextra temp
			ife team 1
			{
				mul temp 5 div temp 4
				seta[].htextra temp
			}
			else ifn team 3
			{
				mul temp 3 div temp 4
				ifl temp 1 set temp 1
				seta[].htextra temp
			}
		}
		break
		endswitch
	}
ends

defstate spritebounce
	
	setvarvar temp sprite[].htmovflag
	andvar temp 49152
	ifvare temp 32768
	{
		// hit a wall
		setvarvar hitwall sprite[].htmovflag
		andvar hitwall 16383
		getwall[hitwall].point2 B
		getwall[hitwall].x x2
		getwall[hitwall].y y2
		getwall[B].x x
		getwall[B].y y
		subvarvar x2 x
		subvarvar y2 y
		getangle angvar x2 y2
		
		getactor[THISACTOR].ang tempb
		getincangle tempc angvar tempb
		subvarvar angvar tempc
		ifvarg angvar 2047 subvar angvar 2048
		ifvarl angvar 0 addvar angvar 2048
		setactor[THISACTOR].ang angvar
		set angvel angvar
	}
	else 
	{
		set spriteid sprite[].htmovflag
		addvar spriteid 16384
		ifvarl spriteid 16384 ifvarg spriteid -1 // hit a sprite
		{
			geta[spriteid].ang angvar
			getincangle temp angvar sprite[].ang
			sub angvar temp
			add angvar 1024
			seta[].ang angvar
			set angvel angvar
			ifactor SBALLACTOR count 30
			ifactor BEACHBALL count 30
		}
	}
	
ends

defstate damagepushenemy

	ifactor BIGTURRET break
	ifactor LIZTURRET break
	ifactor EDFTURRET break
	ifactor ROTATEGUN break
	ifactor PIGSUV break
	ifactor TANK break
	ifactor NEWTROOPTARGET break
	ifactor NEWPIGTARGET break
	ifactor NEWMECH break
	ifactor GUNSHIP break
	ifactor NATTYBRA break

// blueflagval amount
// lastangvel direction

ifg sprite[].htextra 50
ife monstatus 1
// ifn mtype 1
{
	// ife monstatus 1 ifg sprite[].htextra sprite[].extra break
	
	switch sprite[].htpicnum
	case SHOTSPARK1
	case RPG
	case RADIUSEXPLOSION
	case KICKIMPACT
	case CASTERPROJ
	case SABERSCORCH3
	case KINETICPROJ
	geta[].htextra temp
	
	shiftl temp 12
	ife sprite[].htpicnum KICKIMPACT { mul temp 3 div temp 2 }
	ife sprite[].htpicnum CASTERPROJ mul temp 2
	ife sprite[].htpicnum KINETICPROJ mul temp 2
	div temp tiledata[sprite[].picnum].xsize
	div temp sprite[].xrepeat
	
	ifg temp 1024 set temp 1024
	
	ifg temp blueflagval
	{
		seta[].xvel 0
		set lastangvel sprite[].htang
		set blueflagval temp
	}
	break
	endswitch
}

ifvarg blueflagval 0
{
	cos xvel lastangvel
	sin yvel lastangvel
	setvarvar temp blueflagval
	// ifvarg temp 1024 setvar temp 1024
	mul xvel temp
	mul yvel temp
	shiftvarr xvel 12
	shiftvarr yvel 12
	 
	movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN 
	// shiftvarr blueflagval 1
	mul blueflagval 3, div blueflagval 5
	ifn RETURN 0 
	{
		// cause damage to hit sprite
		addvar RETURN 16384
		ifvarl RETURN 16384 ifvarg RETURN -1 
		{
			ife sprite[RETURN].htextra -1
			{
				set temp blueflagval
				shiftr temp 3
				ifg temp 0
				{
					seta[RETURN].htextra temp
					seta[RETURN].htpicnum SHOTSPARK1
					seta[RETURN].htowner THISACTOR
					seta[RETURN].htang lastangvel
				}
			}
		}
		set blueflagval 0
	}
	ifvarl blueflagval 2 setvar blueflagval 0
}

ends

defstate damagepush

// dodgetime, angvel

ifg sprite[].htextra 0
{
	geta[].htextra temp
	
	mul temp 844
	ife sprite[].htpicnum KNEE mul temp 2
	
	div temp tiledata[sprite[].picnum].xsize
	ifg temp dodgetime
	{
		ifactor SBALLACTOR set B YES
		ifactor BEACHBALL set B YES
		set angvel sprite[].htang
		set dodgetime temp
		seta[].ang angvel
	}
}



ifvarg dodgetime 0
{
	cos xvel angvel
	sin yvel angvel
	setvarvar temp dodgetime
	ifvarg temp 1024 setvar temp 1024
	mulvarvar xvel temp
	mulvarvar yvel temp
	shiftvarr xvel 13
	shiftvarr yvel 13
	movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN 
	// shiftvarr dodgetime 1
	mul dodgetime 2, div dodgetime 3
	ifn RETURN 0 
	{
		// cause damage to hit sprite
		addvar RETURN 16384
		ifvarl RETURN 16384 ifvarg RETURN -1 
		{
			ife sprite[RETURN].htextra -1
			{
				set temp dodgetime
				shiftr temp 3
				ifg temp 0
				{
					seta[RETURN].htextra temp
					ifactor COVERBLOCK seta[RETURN].htpicnum RPG else
					seta[RETURN].htpicnum SHOTSPARK1
					ifactor COVERBLOCK seta[RETURN].htowner player[].i else
					seta[RETURN].htowner THISACTOR
					seta[RETURN].htang angvel
				}
			}
			set dodgetime 0
		}
		// set dodgetime 0
	}
	ifvarl dodgetime 2 setvar dodgetime 0
}

ends

defstate damagepushblock

// dodgetime, angvel

ifg sprite[].htextra 0
{
	geta[].htextra temp
	
	shiftl temp 11
	ife sprite[].htpicnum KNEE mul temp 2
	ifn sprite[].htowner -1
	ife actorvar[sprite[].htowner].team 0 div temp 3
	
	div temp tiledata[sprite[].picnum].xsize
	ifg temp dodgetime
	{
		set angvel sprite[].htang
		set dodgetime temp
		seta[].ang angvel
	}
}

ifvarg dodgetime 0
{
	cos xvel angvel
	sin yvel angvel
	setvarvar temp dodgetime
	ifvarg temp 8192 setvar temp 8192
	mulvarvar xvel temp
	mulvarvar yvel temp
	shiftvarr xvel 13
	shiftvarr yvel 13
	movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN 
	// shiftvarr dodgetime 1
	mul dodgetime 2, div dodgetime 3
	
	ifge dodgetime 4	
	{
		set TMP_B NO
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			set z sprite[].z
			sub z 16384
			ifge sprite[spriteid].z z
			ifn spriteid THISACTOR
			ife actorvar[spriteid].monstatus 1
			{
				set z sprite[].z
				add z 8192
				ifle sprite[spriteid].z z
				{
					ldist xydist THISACTOR spriteid
					ifle xydist 1024
					{
						al spriteid
						set temp dodgetime
						shiftr temp 3
						ifg temp 0
						{
							seta[spriteid].htextra temp
							seta[spriteid].htpicnum RPG 
							seta[spriteid].htowner player[].i
							seta[spriteid].htang angvel
							set TMP_B YES
						}
					}
				}
			}
			nextspritestat spriteid spriteid
		}
		
		ife TMP_B YES div dodgetime 2
	}
	ifvarl dodgetime 2 setvar dodgetime 0
	
}

ends


defstate playerpush

	ifp pstanding break
	findplayer temp
	
	ifhitspace { ifg temp 1408 break }
	else 
	{
		ifactor COVERBLOCK sub temp 512
		ifg temp 844 break
	}
	
	ife dodgetime 0
	ifcansee
	ifp palive
	{
		getp[].posx x2
		getp[].posy y2
		sub x2 sprite[].x
		sub y2 sprite[].y
		getangle angvel x2 y2
		ifhitspace { ifl temp 1024 break  } else
		add angvel 1024
		
		cos xvel angvel
		sin yvel angvel
		
		ifactor SHOPPINGCART
		{
			div xvel 96
			div yvel 96
		}
		else
		{
			shiftvarr xvel 7
			shiftvarr yvel 7
		}
		movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN 
	}

ends

defstate makespeedblur
	espawn SPEEDBLUR
	ifaction 0 setav[RETURN].mtype sprite[].picnum else
	ifaction ANULLACTION setav[RETURN].mtype sprite[].picnum else
	ife sprite[].htpicnum 0 setav[RETURN].mtype sprite[].picnum else
	setav[RETURN].mtype sprite[].htdispicnum
	seta[RETURN].xrepeat sprite[].xrepeat
	seta[RETURN].yrepeat sprite[].yrepeat
	ifg sprite[].alpha 96 seta[RETURN].alpha sprite[].alpha else
	seta[RETURN].alpha 80
	seta[RETURN].pal sprite[].pal
	seta[RETURN].mdflags 16
	seta[RETURN].pitch sprite[].pitch
	set temp sprite[].cstat
	ifvarand temp 1 xorvar temp 1
	ifvarand temp 256 xorvar temp 1
	seta[RETURN].cstat temp
ends

defstate staticblur
	espawn SPEEDBLUR
	setav[RETURN].mtype sprite[].htdispicnum
	seta[RETURN].xrepeat sprite[].xrepeat
	seta[RETURN].yrepeat sprite[].yrepeat
	seta[RETURN].alpha 80
	seta[RETURN].pal sprite[].pal
	seta[RETURN].mdflags 16
	set temp sprite[].cstat
	ifvarand temp 1 xorvar temp 1
	ifvarand temp 256 xorvar temp 1
	seta[RETURN].cstat temp
ends

defstate spawnsmokeonscrap
  ifl sprite[].xrepeat 16 break
  ifge framerate 29
  ifl Numsprites 14000
  ifn sector[].lotag 2
  {
	headspritestat spriteid 5
	whilevarn spriteid -1
	{
		switch sprite[spriteid].picnum
		case SCRAP6 case 2391 case 2392 case 2393 case 2394 case 2395
		case 2396 case 2397 case 2398 case 2399 case SCRAP1 case 2401 
		case 2402 case 2403 case SCRAP2 case 2405 case 2406 case 2407
			ifn sprite[spriteid].htpicnum SECTOREFFECTOR
			{
				dist xydist THISACTOR spriteid
				ifle xydist 2048
				{
					setav[spriteid].mtype 1
					// espawn SMALLSMOKE
					// seta[RETURN].pal 4
					// seta[RETURN].cstat 130
					// setsprite RETURN sprite[spriteid].x sprite[spriteid].y sprite[spriteid].z
					// seta[RETURN].htbposx sprite[spriteid].x
					// seta[RETURN].htbposy sprite[spriteid].y
					// seta[RETURN].htbposz sprite[spriteid].z
				}
			}
		break
		endswitch
		nextspritestat spriteid spriteid
	}
  
  }
  ends

spriteflags MOVESHIPCAM 8192
eventloadactor MOVESHIPCAM

ife sprite[].pal 4
	geta[].ang shipangstart 
else
{
	geta[].lotag SPRITELOTAG
	setarray shipcams[SPRITELOTAG] THISACTOR
	seta[].lotag 0
	geta[].hitag initflags
	seta[].hitag 0
	
	geta[].extra monstflags
	geta[].xvel countvarc // shipangoff
	geta[].yvel initsprite
	seta[].yvel 0
	ife monstflags -1 set monstflags 0
	ifn SPRITELOTAG 0 cstat 32768
	// sizeat 200 200
	// cstat 0
	// ifn SPRITELOTAG 1 set initsprite 0
	geta[].x countvar
	geta[].y countvarb
	geta[].z float
	geta[].sectnum botclip
}

enda

useractor notenemy MOVESHIPCAM 0 enda

// 0 DEFAULT
// 1 WOOD
// 2 TIN
// 3 GRATE
// 4 GRASS
// 5 TILE
// 6 CARPET
// 7 CONCRETE
// 8 SNOW
// 9 WATER
// 10 ELECTRONIC
// 11 ORGANIC

defstate tiletype

switch picnum

case 0 set TILETYPE 0 break

case 70 case 370 case 735 case 745 case 749 case 821 case 822 case 879 case 880 case 884
case 1188 case 1200 case 1201 case 4110 case 4111 case 4303 case 4428 case 1170
// DC steps
case 3684 case 3685 case 3691

case 7019 case 7035 case 7037 case 7100 case 7101 case 7102 case 7103 case 7112

// WOOD
case 11413 case 11414 case 11415 case 11465 case 11466 case 11468 case 11469
case 11805 case 11819 case 11826 case 11827 case 11838 case 11839 
case 11840 case 11841 case 11842 case 11859 case 11870 case 11888 
case 11896 case 11940 case 11950 case 11951 case 11952 case 11972
case 15747 case 15748 case 15760 case 15761 case 15768 case 15771
case 15778 case 15779 case 15780 case 16116 case 16117 case 16118
case 16119 case 16120 case 16121
case NEWTROOPTARGET case NEWPIGTARGET 
case WOODENHORSE
case HORSEONSIDE
case BURNTPALM
// NUWOOD
set TILETYPE 1 break

case EDFCHEST case ITEMCHEST
case 150 case 151 case 152 case 153 case 154 case 155 case 156 case 157 case 158 case 159
case 182 case 195 case 196 case 211 case 216 case 218 case 220 case 221 case 222 case 223 case 224
case 226 case 227 case 231 case 232 case 242 case 243 case 244 case 257 case 258 case 259
case 278 case 283 case 284 case 285 case 286 case 287 case 288 case 289 case 290 case 291
case 292 case 294 case 295 case 296 case 300 case 302 case 303 case 309 case 311 case 312 
case 313 case 314 case 315 case 317 case 318 case 319 case 322 case 325 case 327 case 344 
case 345 case 346 case 347 case 348 case 350 case 354 case 365 case 366 case 369 case 373
case 374 case 375 case 378 
case 379 case 380 case 381 case 382 case 383 case 384 case 385 case 392 case 393 case 394 
case 395 case 396 case 397 case 399 case 400 case 407 case 408 case 409 case 410 case 411
case 412 case 413 case 418 case 419 case 420 
case 441 case 442 case 447 case 448 case 449 case 450 case 451 case 452 case 453 case 454 
case 455 case 456 case 457 case 458 case 459 case 460 case 467 case 469 case 470 case 471 
case 513 case 514 case 515 case 609 case 665 case 709 case 711 case 715 case 717 case 736 
case 737 case 738 case 739 case 754 case 755 case 756 case 767 case 795 case 797 case 798 
case 829 case 843 case 877 case 883 case 886 case 913 case 962 case 946 case 947 case 948 
case 1024 case 1097 case 1098 case 1099 case 1102 case 1103
case 1107 case 1108 case 1109 case 1110 case 1117 case 1118 
case 1119 case 1120 case 1124
case 1144 case 1173 case 1178 case 1179 case 1187 case 1190 case 4097 case 4098
case 4099 case 4105 case 4106 case 4108 case 4109 case 4117 case 4118 case 4119 case 4162
case 4163 case 4164 case 4165 case 4168 case 4201 case 4202 case 4276 case 4277
case 4278 case 4279 case 4282 case 4283 case 4284 case 4285 case 4286 case 4287 case 4288
case 4300 case 4301 case 4302 case 4304 case 4305 case 4308 case 4309 case 4310 case 4330
case 4331 case 4334 case 4335 case 4349 case 4350 case GRAVESPANEL
case 3693 case 3694 case 3727 case 3779
case BLUEBALLVEND case SNACKVEND case BLUEBALLBROKE case SNACKBROKE case ASIANVEND
case BRAWNDOVEND case 15891 case REACTORVEND case 15923
case 6886
case 6912 case 6913 case 6914 case 6917 case 6918 case 6919 case 6921 
case 6922 case 6923 case 6929 case 6931 case 6934 case 6935 case 6936 
case 6937 case 6938 case 6939 case 6945 case 6949 case 6951 
case 6952 case 6953
case 6960 case 6970 case 6972 case 6973 case 6974 case 6975 case 7001 
case 7002 case 7011 case 7014 case 7032 case 7039 case 7040 case 7042 
case 7044 case 7045 case 7047 case 7048 case 7049 case 7050 
case 7054 case 7059 case 7063 case 7064 case 7066 case 7068 case 7108 
case 7109 case 7113 case 7116

case 11467 case 11854 case 11855 case 11857 case 11858 
case 11860 case 11861 case 11862 case 11863 case 11869 case 11886 
case 11916 case 11921 case 11924 case 11933 case 11937 case 11943 
case 11947 case 11948 case 12548 case 12550 case 12554 case 12555 
case 12559 case 12561 case 12562 case 12563 case 12564 case 12565 
case 12566 case 12567 case 12568 case 12571 case 12574 
case 12576 case 12577 case 12578 case 12579 
case 12580 case 12581 case 12582 case 12583 
case 12584 case 12585 case 12586 case 12587 case 12588 case 12589 
case 12590 case 12591 case 12592 case 12593 case 12594 case 12595 
case 12596 case 12597 case 12598 case 12599 case 12600 case 12603 
case 12604 case 12605 case 12606 case 12607 case 12608 case 12609 
case 12610 case 12611 case 12614 case 12615 case 12619 case 12623 
case 12624 case 12625 case 12626 case 12627 case 12628 case 12629 
case 12630 case 12631 case 12632 case 12633 case 12634 case 12635 
case 12636 case 12637 case 12638 case 12639 case 12640 case 12641 
case 12642 case 12643 case 12644 case 12645 case 12646 case 12647 
case 12648 case 12649 case 12650 case 12651 case 12652 case 12653 
case 12654 case 12655 case 12656 case 12657 case 12658 case 12659 
case 12660 case 12661 case 12662 case 12663 case 12664 case 12665 
case 12666 case 12667 case 12668 case 12669 case 12670
case 12671 case 12672 case 12673 case 12675 case 12676
case 12677 case 12678 case 12679 case 12680 case 12681 case 12682
case 12683 case 12684 case 12685 case 12686 case 12687 case 12688
case 12689 case 12690 case 12691 case 12692 case 12693  
case 12697 case 12698 case 12699 case 12700 case 15783 case 15784
case 12701 case 12702 case 12703 case 12704 case 12705 case 12706 
case 12707 case 12708 case 12709 case 12710 case 12711 case 12715
case 12716 case 12717 case 12718 case 12719 case 12720 case 12721
case 12722 case 12723 case 12724 case 12730 case 12731 case 12732 
case 12733 case 12734 case 12735 case 12736 case 12737 case 12738 
case 12739 case 12740 case 12741 case 12742 case 12743 case 12744 
case 12745 case 12746 case 12747 case 12748 case 12749 case 15782
case 12750 case 12751 case 12752 case 12753 case 12754 case 12759
case 12760 case 12761 case 12762 case 12763 case 12771 case 12772
case 12773 case 12774 case 12776 case 12777 case 12778 case 12779
case 12780 case 12781 case 12785 case 15749 case 15750 case 15769
case 15867 case 15868 case 15869 case 15870 case 15889 case 16123
case 16124 case 16125 case 16126
case 18688 case 18689 case 18690 case 18691 case 18692 case 18693
case 18694 case 18695 case 18696 case 18697 case 18698 case 18699
case 18700 case 18701 case 18702 case 18703 case 18704 case 18705
case 18706 case 18707 case 18708 case 18709 case 18710 case 18711
case 18712 case 18713 case 18714 case 18715 case 18716 case 18717
case 18718
// NUMETAL

case BOSS1STATUE case BOSS2STATUE case BOSS3STATUE case FORCEBUBBLE
case EDFDRONE case NEWSENTRY case MECHBRAIN case CANHEAD case CYCLOIDMAX case FLYINGFIST case CANHEADNOARMS case FOODCART case OSCAR case NEWMECH
case LIZTURRET case EMPTYTURRET case EDFTURRET case EMPTYEDFTURRET
case SPIDERMINE case SPIDERWALK
case CHAIRBROKE1
case SHOPPINGCART
case COVERBLOCK case ROBOTMOUSE
case EDFTANK case EDFTANKTURRET case BLACKHAWK
case BMWM4 case COPCAR case TAXI case CRUZ case CIVIC case PORSCHE case LAMBO90
case BEETLE case HUMMER case JEEP case LIMO case PICKUP case PICKUP2 case VAN1
case VAN2 case WRECKEDCAR case DODGECAR case FORD case ROVER
case BMWM3 case NANOCOOPER case TOWTRUCK case CHEVELLE case OLDCAR 
case FLYCAR_1 case FLYCAR_2 case FLYCAR_3
case FLYCAR_PARKED1 case FLYCAR_PARKED2 case FLYCAR_PARKED3 case FLYCAR_PARKED4
case EDFTANKWRECK case MICROBUS case AUDIA
case TERMINATOR case TERMINATORDUCKING case TERMINATORCRAWLING case ROLLYTURRET
case CHEERBOT
case GEISHA1 case GEISHA2 case GEISHA3 case GEISHA4
case DRONE case TANK case TANKWRECK case ROTATEGUN 
case RECONWRECK 
case PATROLSENTRY case SPYDRONE
case SIDEGUN case BIGTURRET
case PARKMETER case PARKMETER2 case PARKMETERBROKE
case GUNSHIP case SHIPTURRET case REPAIRDRONE case UFOFLOAT
// METAL
set TILETYPE 2 break

case RECON case NEWRECON case PIGSUV 
case PSPIDER case PSPIDERJUMPING case DRPROTON case ARMEDF
case LIZBOSS case MANDOFETT case MANDOCROUCH ifrnd 128 set TILETYPE 2 break

case ARMPIG
case ARMLIZTROOP
case ARMLIZTROOPDUCK
	ifl actorvar[hitsprite].mtype 2
	set TILETYPE 2 break

case 183 case 710 case 915 case 4154 case 4155
// DC steps
case 3712 case 3732

// NEW TILES
case 6955 case 6981 case 6991 case 6992 case 6997 case 6999 case 7038 case 7067 case 7110
case 12544 case 12552 case 12569 
case 12712 case 12788
case PANNEL1 case PANNEL2 case 4206 case 6941 case 7043 case 7070 case 12545 case 12546
case 12570 case 12714 
// METAL, GRATES
set TILETYPE 3 break

// GRASS or dirt
case 803 

case 11322 case 11323 case 11324
case 11798 case 11804 case 11812 case 11894 case 11935 case 11941 case 11942 case 11969 case 11984 case 11985  
// NUDIRT
set TILETYPE 4 break

case 186 case 187 case 188 case 189 case 190 case 191 case 192 case 246 case 332 case 720 
case 857 case 1205 case 4102
case 3692

// NEW TILES
case 6926 case 6927 case 6944 case 6980 case 7003
case 15756 case 15757 case 15758 case 15759
case 16115
// NUTILE
set TILETYPE 5 break

case 1219 // could be grass or carpet
gets[].floorpal temp
ifvare temp 0
ifoutside set TILETYPE 4
else set TILETYPE 6
break

case 331 
case 545 case 898 case 899 case 900 case 1218

case 3604 case 3612 case 3613 case 3614 case 3615 case 3616
case 7111 case 13256 case 13272 case 15753 case 15754 case 15755 case 16101 case 16102 case 16103
case 16104 case 16332 case 16333
// NUCARPET
set TILETYPE 6 break

case 181 case 184 case 197 case 207 case 209 case 236 case 237 
case 238 case 239 case 240 case 251 case 252
case 334 case 335 case 349 case 367 case 368 case 372 
case 376 case 377 case 414 case 417 case 429 case 430 case 431 case 432 
case 433 case 434 case 435 case 437 case 461 case 465 case 466 case 468 
case 478 case 718 case 723 case 724 case 725 case 734 case 742 
case 743 case 747 case 748 case 750 case 757 case 759 case 760 
case 761 case 763 case 764 case 770 case 772 case 773 case 775 case 780 
case 781 case 782 case 783 case 790 case 793 case 794 case 796 case 799 case 800 
case 801 case 802 case 804 case 805 case 812 case 814 case 815 case 816 
case 817 case 818 case 819 case 823 case 824 case 825 case 827 case 828 
case 852 case 853 case 859 case 876 case 887 case 893 case 894 
case 895 case 1169 case 1171 case 1182 case 1183 case 1184 case 1185 
case 1186 case 1189 case 1191 case 1193 case 1204 case 1279 case 2922 
case 3381 case 3384 case 3385 case 3386 case 3387 case 3394 case 3395 case 3396 
case 3398 case 3407 case 4112 case 4151 case 4152 case 4190 case 4208 
case 4210 case 4211 case 4212 case 4213 case 4214 case 4215 case 4216 case 4217 
case 4218 case 4219 case 4220 case 4221 case 4222 case 4223 case 4234 case 4235 
case 4236 case 4255 case 4259 case 4319 case 4320 case 4321 
case 4322 case 4323 case 4332 case 4333 case 5065 case 5066 case 5067 case 5068 
case 5069 case 5070 case 5071 case 5072 case 5073 case 5074 case 5075 case 5076 
case 5077 case 5078 case 5083

// NEW TILES
case OCEANSPRITE3
case 6916 case 6928 case 6932 case 6933 case 6940 case 6942 case 6946 case 6947 case 6948 case 6954 case 6979 case 6982 case 6983 case 6984 case 6985 case 6986 case 6987 case 6988 case 6989 case 7005 case 7008 case 7009 case 7010 case 7012 case 7015 case 7016 case 7017 case 7018 case 7022 case 7025 case 7029 case 7034 case 7086
case 7114 case 7115 case 7118 case 7119 case 7125 case 7126 case 7127 case 7130 case 7131 case 7133
case 11367 case 11449 case 11450
case 11794 case 11796 case 11797 case 11799 case 11800 case 11801 case 11802
 case 11803 case 11807 case 11808 case 11809 case 11810 
 case 11811 case 11814 case 11815 case 11816 case 11817 case 11818 
 case 11820 case 11821 case 11828 case 11829 case 11830 case 11831 
 case 11834 case 11835 case 11836 case 11837 case 11850 case 11851 
 case 11852 case 11853 case 11856 case 11867 case 11868 case 11871 
 case 11872 case 11873 case 11874 case 11875 case 11876 case 11881 
 case 11882 case 11883 case 11884 case 11885 case 11887 case 11889 
 case 11892 case 11897 case 11898 case 11899 case 11901 case 11902 
 case 11904 case 11905 case 11907 case 11908 case 11909 case 11910 
 case 11911 case 11912 case 11913 case 11914 case 11915 case 11919 
 case 11920 case 11925 case 11926 case 11927 case 11928 case 11929 
 case 11931 case 11932 case 11934 case 11936 case 11938 case 11945 
 case 11946 case 11949 case 11954 case 11955 case 11958 case 11959 
 case 11963 case 11973 case 11974 case 11975 case 11976 case 11977 
 case 11979 case 11980 case 11981 case 11982 case 11987 case 11989 
 case 12549 case 12556 case 12573 case 12575 case 12613 case 12674
 case 12694 case 12695 case 12696 case 12727 case 12728 case 12729
 case 12755 case 14068 case 14069
 case 15665 case 15666 case 15667 case 15668 case 15669 case 15670 case 15671
 case 15710 case 15711 case 15712 case 15713 case 15714 case 15715 case 15716 
 case 15717 case 15718 case 15719 case 15720 case 15767 case 15866
 case 16099 case 16100 case 16366 case 16367 case 16368 case 16369 case 16370
 case 16371 case 16372 case 16373 case 16374 case 16375 case 16376
 case 16377 case 16378 case 16379 case 16380 case 16381 case 16382 case 16383
// NUCONCRETE
set TILETYPE 7 break

case 3416
getsector[].floorpal temp
ifvare temp 0
set TILETYPE 8
else ifvare temp 6 set TILETYPE 4
else set TILETYPE 7
break

case 241
ifvare sector[].floorpal 0
ifvarl sector[].floorshade 10
ifoutside
set TILETYPE 8
// NUSNOW type 8
else ifvare temp 6 set TILETYPE 4
else set TILETYPE 7
break

case 336 case 337 case 338 case 889 case 890 case 891 case 892
case 7071 case 7092
// NUWATER 9
set TILETYPE 9 break


case 203 case 268 case 269 case 270 case 271 case 272 case 273 case 274
case W_TECHWALL1 case W_TECHWALL2 case 298 case W_TECHWALL15 case W_TECHWALL4 case W_TECHWALL16
case 357 case 358 case 359 
case 360 case 361 case 362 case 363 case 426 case 427 case 428
case 806 case 4127 case 4130 case 4131 case 4132 case 4133 case 4134
case 4135 case 4136 case 4137 case 4138 case 4139 case 4140
case 4141 case 4142 case 4143 case 4144 case 4145 case 4146 case 4147
case 4924 case 4932
case 5865 case 5866 case 5867 case 5868 case 5869 case 5870 case 5871
case 6829 case 6832 case 6835 case 6838 case 6841
case 6876 case 6877 case 6878 case 6879 case 6880 case 6881 case 6882 case 6883 
case 6884 case 6885 case 6887 case 6888 case 6889 case 6890 case PHONYBREAK

ifactor BULLETHOLE set TILETYPE 10 else
ifactor SHOTSPARK1 set TILETYPE 10 else
ifactor 1 set TILETYPE 10 else
ifactor 2 set TILETYPE 10 else
set TILETYPE 7
// NUELECTRONIC 10
break

case 1100
case 1116 case 1130 case 1131 case 1137 case 1139 case 1140 case 1141
case 5079 case 5080 case 5099 case 5102
set TILETYPE 11
// NUSQUISHY
break
default 

break
endswitch

ends

action ANEWFEMANG5  0  2  5  1  50
action ANEWFEMANG8  0  2  8  1  50
action ANEWANG5FRO  0  1  8  1  10
action ANEWANG8FRO  0  1  8  1  10


defstate checkfloordist

set temp 3072
set tempb sprite[].sectnum
updatesectorz sprite[].x sprite[].y sprite[].z tempb
ifvarn tempb -1
{
	getflorzofslope tempb sprite[].x sprite[].y temp // temp is the return var
	sub temp sprite[].z
}

ends

defstate spawn_goodie

	set picnum COLA
	rand temp 20
	switch temp
	case 0 ife pchar 0 ifvarand dukeupgrades[PISTOL_WEAPON] 8 set picnum GLOCKSPRITE else
		   ife pchar 1 ifvarand shellyupgrades[PISTOL_WEAPON] 8 set picnum GLOCKSPRITE else
		   set picnum FIRSTGUNSPRITE 
		break
	case 1 ife pchar 1 set picnum BOWSPRITE else
		   ife pchar 2 set picnum BOWSPRITE else
		set picnum DBSPRITE 
		break
	case 2 set picnum CHAINGUNSPRITE break
	case 3 set picnum RPGSPRITE break
	case 4 set picnum HBOMBAMMO break
	case 5 set picnum FREEZESPRITE break
	case 6 set picnum SHRINKERSPRITE break
	case 7 set picnum TRIPBOMBSPRITE break
	case 8 set picnum DEVISTATORSPRITE break
	case 9 set picnum GROWSPRITEICON break
	case 10 set picnum COLA break
	case 11 set picnum SIXPAK break
	case 12 set picnum ATOMICHEALTH break
	case 13 ifrnd 128 { ifrnd 128 set picnum FIRSTAID else set picnum STEROIDS }
		else ifrnd 128 { ifrnd 128 set picnum HOLODUKE else set picnum HEATSENSOR }
		break
	case 14 set picnum SABERSPRITE break
	case 15 set picnum PLASMASPRITE break
	case 16 set picnum RAILGUNSPRITE break
	case 17 set picnum NUKESPRITE break
	case 18 ifrnd 128 set picnum COMMGUN else set picnum LASERPISTOL break
	case 19 set picnum SHIELD break
	case 20 set picnum SHOTGUNSPRITE break
	endswitch
	espawnvar picnum
ends

defstate spawn_goodie2

	set picnum COLA
	rand temp 19
	switch temp
	case 0 set picnum AMMO break
	case 1 set picnum SHOTGUNAMMO break
	case 2 set picnum BATTERYAMMO break
	case 3 set picnum RPGAMMO break
	case 4 set picnum HBOMBAMMO break
	case 5 set picnum FREEZEAMMO break
	case 6 set picnum CRYSTALAMMO break
	case 7 set picnum TRIPBOMBSPRITE break
	case 8 set picnum DEVISTATORAMMO break
	case 9 set picnum GROWAMMO break
	case 10 set picnum COLA break
	case 11 set picnum SIXPAK break
	case 12 set picnum ATOMICHEALTH break
	case 13 ifrnd 128 { ifrnd 128 set picnum FIRSTAID else set picnum STEROIDS }
		else ifrnd 128 { ifrnd 128 set picnum HOLODUKE else set picnum HEATSENSOR }
		break
	
	case 14 set picnum PLASMASPRITE break
	case 15 set picnum RAILGUNAMMO break
	case 16 ifn pchar 1 ifn pchar 2 set picnum DBAMMO else set picnum QUIVERSPRITE break
	case 17 set picnum AMMO break
	case 18 ifrnd 128 set picnum COMMGUN else set picnum LASERPISTOL break
	case 19 set picnum SHIELD break
	endswitch
	espawnvar picnum
ends

defstate randomize_item

// do not replace BOOTS, JETPACK, ACCESSCARD, AIRTANK, HEAVYHBOMB
	ifactor BOOTS break
	ifactor JETPACK break
	ifactor ACCESSCARD break
	ifactor AIRTANK break
	ifactor HEAVYHBOMB break

	set picnum COLA
	rand temp 82
	add temp 1
	switch temp
	case 1 case 2 case 3 set picnum FIRSTGUNSPRITE 
	break
	case 4 case 5 case 6 case 7 case 8 case 9 set picnum AMMO break
	case 10 case 11 
		ife pchar 1 set picnum BOWSPRITE else
		   ife pchar 2 set picnum BOWSPRITE else
		set picnum DBSPRITE 
	break
	case 12 case 13 ifge pchar 1 ifle pchar 2 set picnum QUIVERSPRITE else set picnum DBAMMO break
	case 14 case 15 case 16 set picnum CHAINGUNSPRITE break
	case 17 case 18 case 19 case 20 set picnum BATTERYAMMO break
	case 21 case 22 set picnum RPGSPRITE break
	case 23 case 24 case 25 set picnum RPGAMMO break
	case 26 case 27 case 28 set picnum HBOMBAMMO break
	case 29 case 30 case 31 set picnum SHOTGUNSPRITE break
	case 32 case 33 case 34 case 35 case 36 set picnum SHOTGUNAMMO break
	case 37 case 38 set picnum FREEZESPRITE break
	case 39 case 40 set picnum FREEZEAMMO break
	case 41 case 42 set picnum SHRINKERSPRITE break
	case 43 case 44 set picnum CRYSTALAMMO break
	case 45 case 46 case 47 set picnum TRIPBOMBSPRITE break
	case 48 case 49 set picnum DEVISTATORSPRITE break
	case 50 case 51 set picnum DEVISTATORAMMO break
	case 52 set picnum GROWSPRITEICON break
	case 53 set picnum COVERSPRITE break
	case 54 case 55 set picnum GROWAMMO break
	case 56 set picnum PLASMASPRITE break
	case 57 set picnum PLASMAAMMO break
	case 58 case 59 case 60 case 61 case 62 case 63 case 64 set picnum COLA break
	case 65 case 66 case 67 case 68 set picnum SIXPAK break
	case 69 case 70 set picnum ATOMICHEALTH break
	case 71 set picnum FIRSTAID break
	case 72 case 73 set picnum STEROIDS break
	case 74 set picnum HOLODUKE break
	case 75 set picnum HEATSENSOR break
	case 76 set picnum RAILGUNSPRITE break
	case 77 case 78 set picnum RAILGUNAMMO break
	case 79 ifrnd 128 set picnum NUKESPRITE else { set picnum BIGSTACK spritepal 23 } break
	// case 81 set picnum SABERSPRITE break
	case 80 case 81 case 82 set picnum SHIELD break
	case 83 set picnum BOOTS break
	endswitch
	seta[].picnum picnum
ends

defstate rand_db_bow
    set TMP_A 0
	ifvarand startmode 1 set TMP_A 1 // include DB stuff
	ifvarand startmode 2 orvar TMP_A 2 // include bow stuff
	ifvarand startmode 4 orvar TMP_A 2 // include bow stuff
	ifvarand startmode 8 orvar TMP_A 1
	ifvarand startmode 16 orvar TMP_A 1
	
	ife player[].gotweapon SHOTGUN_WEAPON YES
	{
		ife TMP_A 1 spawn DBAMMO else
		ife TMP_A 2 spawn QUIVERSPRITE else
		{
			ifrnd 128 spawn DBAMMO else spawn QUIVERSPRITE 
		}
	}
	else
	{
		ife TMP_A 1 spawn DBSPRITE else
		ife TMP_A 2 spawn BOWSPRITE else
		{
			ifrnd 128 spawn DBSPRITE else spawn BOWSPRITE 
		}
	}
ends

defstate startgun_replace
	
	ifrnd 32
	{
		ifle cover_amount 300
		ifrnd 84
		ife random_items NO
		{
			spawn COVERSPRITE
			break
		}
		ifle player[].holoduke_amount 1200
		ife random_items NO
		ifrnd 96
		{
			espawn HOLODUKE
			setav[RETURN].initsprite YES
			break
		}
		ife random_items NO
		{
			ife es_type 0 	
			{
				ife player[].shield_amount 0
				{
					espawn SHIELD
					seta[RETURN].htpicnum PIGCOP
					break
				}
			}
			else ife es_battery 0
			{
				espawn SHIELD
				seta[RETURN].htpicnum PIGCOP
				break
			}
		}
	}
	// need to rework for more than 2 startguns
	ifrnd 128 // first bit
	{
		ifvarand startguns 1 { ifrnd 128 spawn AMMO else spawn FIRSTGUNSPRITE } else
		ifvarand startguns 2 spawn SHOTGUNAMMO else
		ifvarand startguns 4 spawn BATTERYAMMO else
		ifvarand startguns 256 spawn FREEZEAMMO else
		ifvarand startguns 512 spawn GROWAMMO else
		ifvarand startguns 1024 spawn PLASMAAMMO else
		ifvarand startguns 32768
		{
			state rand_db_bow
		}
	}
	else
	{
		ifvarand startguns 8 spawn RPGAMMO else
		ifvarand startguns 16 spawn HBOMBAMMO else
		ifvarand startguns 32 spawn CRYSTALAMMO else
		ifvarand startguns 64 spawn DEVISTATORAMMO else
		ifvarand startguns 128 spawn TRIPBOMBSPRITE else
		ifvarand startguns 2048 { ifg gotsaber 50 state spawn_goodie2 else { espawn SABERSPRITE setav[RETURN].initsprite 10 } } else
		ifvarand startguns 16384 spawn RAILGUNAMMO
	}

ends

defstate facesprite
	ifl spriteid 0
	{
		al THISACTOR
		geta[].picnum picnum al picnum
		break
	}
	geta[spriteid].x x2
	geta[spriteid].y y2
	sub x2 sprite[].x
	sub y2 sprite[].y
	getangle angvar x2 y2
	seta[].ang angvar
ends

// defstate facespriteslow

	// geta[spriteid].x x2
	// geta[spriteid].y y2
	// sub x2 sprite[].x
	// sub y2 sprite[].y
	// getangle tempb x2 y2
	
	// getincangle temp sprite[].ang tempb
	
	// ifn sprite[].ang tempb
	// {
		// set B 64
		// mul B -1
		// ifg temp B ifl temp 64
			// seta[].ang tempb
		// else
		// {
			// geta[].ang angvar
			// ifl temp 0 sub angvar 64
			// else add angvar 64
			// seta[].ang angvar
		// }
		// set lastang sprite[].ang
	// }

// ends

defstate turntotarget

	ife bottarget -1 break

	geta[bottarget].x x2
	geta[bottarget].y y2
	sub x2 sprite[].x
	sub y2 sprite[].y
	getangle tempb x2 y2
	
	getincangle temp sprite[].ang tempb
	
	ifn sprite[].ang tempb
	{
		set B MAXSHELLYTURN
		mul B -1
		ifg temp B ifl temp MAXSHELLYTURN
		{
			seta[].ang tempb
			ifactor APLAYER setp[].ang tempb
		}
		else
		{
			geta[].ang angvar
			ifl temp 0 sub angvar MAXSHELLYTURN
			else add angvar MAXSHELLYTURN
			seta[].ang angvar
			ifactor APLAYER setp[].ang angvar
		}
		set lastang sprite[].ang
	}
	abs temp

ends

defstate turnatrate

	// TMP_B set to turning rate before this state is called
	ife bottarget -1 break

	geta[bottarget].x x2
	geta[bottarget].y y2
	sub x2 sprite[].x
	sub y2 sprite[].y
	getangle tempb x2 y2
	
	getincangle temp sprite[].ang tempb
	
	ifn sprite[].ang tempb
	{
		set B TMP_B
		mul B -1
		ifg temp B ifl temp TMP_B
		{
			seta[].ang tempb
			ifactor APLAYER setp[].ang tempb
		}
		else
		{
			geta[].ang angvar
			ifl temp 0 sub angvar TMP_B
			else add angvar TMP_B
			seta[].ang angvar
			ifactor APLAYER setp[].ang angvar
		}
		set lastang sprite[].ang
	}
	abs temp

ends

defstate floatcode

	ifmove 0
	{
		move STOPPED
		rand initsprite 65536
		geta[].z starty
	}
	
	set temp player[].player_par
	add temp initsprite
	shiftl temp 5
	sin tempb temp
	shiftr tempb 8
	geta[].z z
	sub z tempb
	ifvarand player[].player_par 1 sub z 1
	seta[].z z

ends

defstate playerturntome

	geta[].x x
	geta[].y y
	sub x player[].posx
	sub y player[].posy
	getangle angvar x y

	getincangle B player[].ang angvar
	getp[].ang temp
	shiftr B 4
	add temp B
	setp[].ang temp

ends

defstate checksectvisited

	ife switchmode YES break

	ifl sprite[].sectnum 0 break
	
	break // disable until further notice
	
	ife psectvisited[sprite[].sectnum] YES
	{
		set botx sprite[].x
		set boty sprite[].y
		set botz sprite[].z
	}
	else ifl gametype 1
	{
		ife botx 0 ife boty 0 ife botz 0 break
		// ife seeplayer YES
			// nullop
		// else
		setsprite THISACTOR botx boty botz
	}

ends

defstate zveltotarget
	
	
	set TMP_A tiledata[sprite[bottarget].picnum].ysize
	mul TMP_A sprite[bottarget].yrepeat
	shiftl TMP_A 1
	add TMP_A 2048
	// TMP_A is now overall z size of target; how far up from the feet to strike
	// for comparison a standard liztroop would have a TMP_A of 78*40*2+2048==8228
	
	geta[].z z2
	geta[bottarget].z z
	sub z TMP_A
	
	sub z z2
	
	ldist xydist THISACTOR bottarget
	ifg xydist 1024
	{
		mul z sprite[].xvel
		div z xydist
		seta[].zvel z
	}
ends

defstate calczdist
	geta[bottarget].z zdist
	sub zdist sprite[].z
	ldist xydist THISACTOR bottarget
	ife xydist 0 setvar xydist 1
ends

defstate lowlineofsight

set B NO
ife bottarget -1 break

// this state sets B to YES if actor can see bottarget from 2048 units off of ground

set savz sprite[].z
set z sprite[].z
sub z 3072
seta[].z z

canseespr THISACTOR bottarget B

seta[].z savz


ends

defstate sethordeval

	ife mynavsprite -1
	{
		espawn NAVSPRITE
		set mynavsprite RETURN
		changespritestat RETURN 980
		ife gametype -1 setav[RETURN].mtype 6
	}
	getp[].player_par countvar
	add countvar 1
	ife team 1
	{
		setav[mynavsprite].blueflagval 17000000
		setav[mynavsprite].blueiteration 0
		setav[mynavsprite].bluetimer countvar
		seta[mynavsprite].htpicnum BLUEFLAG
	}
	else
	{
		setav[mynavsprite].redflagval 17000000
		setav[mynavsprite].rediteration 0
		setav[mynavsprite].redtimer countvar
		seta[mynavsprite].htpicnum REDFLAG
	}
	seta[mynavsprite].htpicnum sprite[].picnum
	geta[].z savz sub savz 6144
	setsprite mynavsprite sprite[].x sprite[].y savz
	setav[mynavsprite].countvar 0

ends

defstate avoidmines

	set B NO
	switch sprite[bottarget].picnum
	case SPIDERWALK
	case SPIDERMINE
	case DOLLBOMB
	case ZOMBIE case CRAZYLADY
	case DEANOVA
	case CYCLOIDMAX
	case FLYINGFIST
	case LIZBOSS
	case BOSS1 case NEWBOSS1
	case BOSS2
	case BOSS3
	case BOSS4
	case PIGBOSS
	case PSPIDER
	case CANHEAD
	case NEWMECH
	case CANHEADNOARMS
	case NEWBATLORD
	case QUEEN
	case LARGEMAN case COMBINEDMEN
		ife dodgetime 0
		ifl targetdist 4096
		ifl navpoint 0 
			set B YES
	break
	case TERMINATORCRAWLING
	ife actorvar[bottarget].countvarc YES
	ife dodgetime 0
		ifl targetdist 4096
		ifl navpoint 0 
			set B YES
	break
	endswitch

ends

defstate avoidboss
	
		ifg spawnprotect 30 break
		ifn actorvar[bottarget].shrunken 0 break
		
		switch sprite[bottarget].picnum
		case BOSS1
		case NEWBOSS1
		case BOSS2
		case BOSS3
		case BOSS4 case QUEEN
		case PSPIDER
		case PSPIDERJUMPING
		case DEVOURER
		case LIZBOSS
		case CANHEAD case NEWMECH
		case CANHEADNOARMS
		case CYCLOIDMAX case FLYINGFIST
		case LARGEMAN case COMBINEDMEN
		case SITH
		case SYTH
		case DEANOVA
		case DOLLBOMB
			ifl xydist 6144 add angvel 1024 else
			ifl xydist 8192
			ife myspawner -1 ife dodgetime 0 set myspawner bottarget
		break
		case TERMINATORCRAWLING
			ife actorvar[bottarget].countvarc YES
			{
				ifl xydist 8192
				{
					ife myspawner -1 ife dodgetime 0 set myspawner bottarget
					else add angvel 1024
				}
			}
		break
		case ARMYANT case ARMYANTCRAWL
			ife actorvar[bottarget].initsprite YES
			{
				ldist temp THISACTOR bottarget
				ifl temp 2048 add angvel 1024
			}
		break
		default
			ife dodgetime 0
			ifl xydist 4096 
			{
				ifg ikicked 60 
				ifl navpoint 0 add angvel 1024
			}
		break
		endswitch
	
ends

defstate randzshoot

	set temp zdist
	abs temp
	add temp 1280
	shiftr temp 5
	randvarvar tempb temp
	ifrnd 128 mul tempb -1
	add tempb zdist

ends

defstate randzrange

	rand z2 5120
	sub zdist z2
	add zdist 2048

ends

defstate hitscan_targetprep

	ife bottarget -1 { set zdist 0 break }
	
	ife bottarget player[].i
	{
		set zdist player[].posz
		add zdist 8192
	}
	else
	geta[bottarget].z zdist
	
	switch sprite[].picnum
	case EDFSNIPER case EDFSNIPERCROUCH
	case EDFDRONE
	case NEWSENTRY
	case SPACEBULL case SPACEBULLDUCKING
	case BOSS1
	case NEWBOSS1
	case LIZMAN
	case PIGCOP case PIGCOPDIVE
	case NEWPIG case NEWPIGDIVE
	case NEWBATLORD
	case NEWRECON
	case EDFTURRET
	case TANK case MECHBRAIN
	case ARMLIZTROOP case ARMLIZTROOPDUCK
		state randzrange
	break
	
	case BATBOSS
		ifn countvar 7 state randzrange
	break
	endswitch
	
	sub zdist sprite[].z 
	geta[bottarget].picnum picnum
	
	set z2 sprite[bottarget].yrepeat
	mul z2 tiledata[picnum].ysize
	// z2 is proportional to height of enemy sprite
	
	geta[].picnum picnum
	set temp sprite[].yrepeat
	mul temp tiledata[picnum].ysize
	// temp is now proportional to height of THISACTOR
	
	ifg temp z2 // aim down
	{
		sub temp z2
		
		mul temp 5
		div temp 2
		
		add zdist temp
	}
	// note there is no need to aim up at taller enemies
	shiftl zdist 8
	ldist xydist THISACTOR bottarget
	ifvare xydist 0 setvar xydist 1 
	divvarvar zdist xydist

ends

defstate rpg_targetprep

	ife bottarget -1 { set zdist 0 break }
	
	geta[bottarget].z zdist
	ifactor DUKEBOT ifge sprite[bottarget].z sprite[].z add zdist 6144 // aim near the feet
	ifactor SHELLY ifge sprite[bottarget].z sprite[].z add zdist 6144
	ifactor WESBOT ifge sprite[bottarget].z sprite[].z add zdist 6144
	sub zdist sprite[].z 
	geta[bottarget].picnum picnum
	
	set z2 tiledata[picnum].ysize
	mul z2 sprite[bottarget].yrepeat
	// z2 is proportional to height of enemy sprite
	
	geta[].picnum picnum
	set temp tiledata[picnum].ysize
	mul temp sprite[].yrepeat
	// temp is now proportional to height of THISACTOR
	
	// ifg temp z2 // aim down
	ifn temp z2
	{
		sub temp z2
		mul temp 3
		add zdist temp
	}
	
	
	mul zdist xvel
	ldist xydist THISACTOR bottarget
	ifvare xydist 0 setvar xydist 1 
	divvarvar zdist xydist

ends

defstate friendlyfirecheck

// target has been set to bottarget before this state is called
	ife target -1 break // error
	
	geta[target].x x2
	geta[target].y y2
	sub x2 sprite[].x
	sub y2 sprite[].y
	getangle angvar x2 y2
	
	headspritestat spriteid 1 // 990
	whilevarn spriteid -1
	{
		ifg actorvar[spriteid].monstatus 0
		ife team actorvar[spriteid].team
		ifn actorvar[spriteid].monstatus 2
		ifl actorvar[spriteid].monstatus 100
		ifn spriteid THISACTOR
		// ifn actorvar[spriteid].mysignpost THISACTOR
		{
			dist temp THISACTOR spriteid
			ifl temp targetdist // check for friend in the way
			ifg temp 32
			{
				geta[spriteid].x tempc
				geta[spriteid].y tempd
				sub tempc sprite[].x
				sub tempd sprite[].y
				getangle B tempc tempd
				
				getincangle tempb angvar B
				abs tempb
				set tempe 524288
				div tempe temp
				ifg tempe 512 set tempe 512
				ifl tempb tempe
					set target -1
				
			}
		}
		ife spriteid player[].i set spriteid -1
		else
		{
			nextspritestat spriteid spriteid
			ife spriteid -1 set spriteid player[].i
		}
		ife target -1 set spriteid -1
	}

ends

defstate navspritevischeck

	// replaces canseespr THISACTOR spriteid temp
	// temp == YES if true, NO if false
	
	geta[spriteid].cstat bossang
	geta[spriteid].xrepeat tempxrepeat
	geta[spriteid].yrepeat tempyrepeat
	
	seta[spriteid].cstat 256
	seta[spriteid].xrepeat 128
	seta[spriteid].yrepeat 128
	
	geta[].z tempF
	set tempI tiledata[sprite[].picnum].ysize
	mul tempI sprite[].yrepeat
	shiftl tempI 1
	add tempI 2048
	sub tempF tempI
	
	geta[spriteid].z tempG
	set bossx tiledata[sprite[spriteid].picnum].ysize
	mul bossx sprite[spriteid].yrepeat
	shiftl bossx 1
	sub tempG bossx
	set bossy tempG
	sub bossy tempF

	geta[].x x
	geta[].y y
	
	geta[spriteid].x x2
	geta[spriteid].y y2
	sub x2 sprite[].x
	sub y2 sprite[].y
	getangle tempH x2 y2
	
	cos mycos tempH
	sin mysin tempH
	shiftl bossy 14

	ldist xydist3 THISACTOR spriteid
	ife xydist3 0 set xydist3 1
	div bossy xydist3

	hitscan x y tempF sprite[].sectnum mycos mysin bossy bossx bossx hitsprite x2 y2 tempI 16777281
	
	ife hitsprite spriteid set temp YES else set temp NO
	
	seta[spriteid].cstat bossang
	seta[spriteid].xrepeat tempxrepeat
	seta[spriteid].yrepeat tempyrepeat
ends

defstate targetcheck

	ife actorvar[target].team 7 // fake braccus or other decoy
	{
		ife team 0
		{
			ldist xydist THISACTOR target
			ifl xydist 10240
			{
				ife sprite[target].picnum FAKEBRACCUS
				{ set xydist -1560 break }
			}
			else { set target -1 break }
		}
		else { set target -1 break }
	}
	ifvarand sprite[target].cstat 256 nullop else { set target -1 break }
	ifg actorvar[target].spawnprotect 10 { set target -1 break }
	
	ife sprite[].htowner target 
	ifn sprite[].picnum DEANOVA
	ifn actorvar[target].team 7
	ifg blueiteration 0 // countdown set when last hit
	{
		ife team 0
			break // automatically allow targeting of something that hit you
		ife team 1
		ifn team actorvar[sprite[].htowner].team break
		
	}
	
	dist xydist THISACTOR target
	ifg xydist MAXRANGE { ife bottarget target set bottarget -1 set target -1 break }

	geta[].z z
	set z2 tiledata[sprite[].picnum].ysize
	mul z2 sprite[].yrepeat
	shiftl z2 1
	add z2 2048
	sub z z2
	
	geta[target].z tempb
	set tempc tiledata[sprite[target].picnum].ysize
	mul tempc sprite[target].yrepeat
	shiftl tempc 1
	
	add tempc 2048
	
	// ***** uncomment if you want to hitscan to approximate middle of target, 
	// ***** but this has issues...
	sub tempb tempc
	set zdist tempb
	sub zdist z
/*	
	// otherwise just do this instead
	set zdist sprite[target].z
	sub zdist z // sprite[].z
*/	
	ifl zdist -8192 ifactor ZOMBIE { set target -1 break }
	ifg zdist 8192 ife sprite[target].picnum SPIDERWALK { set target -1 break }
	
	switch sprite[target].picnum
	case DOLLBOMB set xydist 1 break // priority targeting
	case EGG case EGGYOUNG add xydist 8192 break // low priority
	endswitch

	ifl xydist 1024
	{
		// an unfortunate hack because the hitscans have been missing
		// when at close range!
		canseespr THISACTOR target temp
		ife target player[].i ife pchar 4 ifl cloak 0 set temp NO
		ife temp YES break
	}
	
	geta[].x x
	geta[].y y
	// rand temp 64 sub temp 32
	// add x temp
	// rand temp 64 sub temp 32
	// add y temp
	
	// x and y can be offset by the gun position, making this more accurate
	// right side enemies:
	// lizman, boss1, newbatlord, liztroop, newtroop, pigcop, newpig, boss2
	// edfpig, armpig, terminator, armedf, lizelite, spacebull, spacebullducking
	// MANDOFETT, mandocrouch, SMALLMAN, newboss1, CYCLOIDMAX, NEWCOMM
	// left side enemies:
	// pigboss, lizboss, drproton, pspider, armyant, armyantcrawl

	switch sprite[].picnum
		
		case NEWPIG case NEWPIGDIVE
		case LIZMAN case EDFPIG case ARMPIG case TERMINATOR case TERMINATORDUCKING
		case LIZELITE case SPACEBULL case SPACEBULLDUCKING case NEWCOMM
		case NEWBATLORD case ARMEDF case MANDOFETT case MANDOCROUCH case SMALLMAN
		
			set newx x
			set temp sprite[].xrepeat
			// shiftl temp 3
			mul temp 10
			add newx temp
			set angvar sprite[].ang
			add angvar 512
			
			rotatepoint sprite[].x sprite[].y newx sprite[].y angvar x y
		break
		case BOSS2 case BOSS1 case NEWBOSS1
		case LIZTROOP case LIZTROOPDUCKING case PIGCOP case PIGCOPDIVE
			set newx x
			set temp sprite[].xrepeat
			shiftl temp 4
			add newx temp
			set angvar sprite[].ang
			add angvar 512
			
			rotatepoint sprite[].x sprite[].y newx sprite[].y angvar x y
		break
	endswitch

	
	// geta[].z z
	// sub z 8192
		
	geta[].sectnum mysector
	ife mysector -1 { set target -1 break }

	geta[target].x x2
	geta[target].y y2
	sub x2 x
	sub y2 y
	
	
	getangle angvar x2 y2
	
	ife team actorvar[player[].i].team
	{
		ldist temp THISACTOR player[].i
		ifl temp xydist // check for player in the way
		ifl temp 6144
		{
			getp[].posx tempc
			getp[].posy tempd
			sub tempc sprite[].x
			sub tempd sprite[].y
			getangle B tempc tempd
			
			getincangle tempb angvar B
			abs tempb
			ifl tempb 128
			{
				set target -1
				break
			}
		}
	}

	cos mycos angvar
	sin mysin angvar
	shiftl zdist 14
	
	ife xydist 0 set xydist 1
	div zdist xydist
	
	geta[target].xrepeat tempxrepeat
	geta[target].yrepeat tempyrepeat
	ifl tempxrepeat 64 seta[target].xrepeat 64
	ifl tempyrepeat 64 seta[target].yrepeat 64
	
	geta[].xrepeat savx
	geta[].yrepeat savy
	sizeat 1 1
	hitscan x y z mysector mycos mysin zdist tempc tempc hitsprite x2 y2 z2 16777280
	// 16777216 is sprite hitscan
	// 64 is wall hitscan
	// 16777280 is both hitscans
	
	// 16777281 add wall blocking
	// 4294901808? 4294901809?

	seta[].xrepeat savx
	seta[].yrepeat savy
	
	// al hitsprite
	// al target
	
	
	ifn hitsprite target
	{
		// ifn hitsprite -1 ife sprite[hitsprite].picnum BARRICADE { set temp sprite[hitsprite].cstat al temp }
		add z 4096
		hitscan x y z mysector mycos mysin zdist tempc tempc hitsprite x2 y2 z2 16777280
	// 16777281
	}
	
	seta[target].xrepeat tempxrepeat
	seta[target].yrepeat tempyrepeat
	
	ifn hitsprite target 
		set target -1 
		
	// adjust distance for certain targets
	ifn target -1
	{
		ife sprite[target].picnum GREENSLIME shiftl xydist 2 else
		ife sprite[target].picnum EGG shiftl xydist 2 else
		ife sprite[target].picnum DRONE shiftl xydist 1
	}
ends

defstate targetsearch

	ife team 3 { set bottarget -1 break }
	
	ifg bluetimer 0 
	{
		sub bluetimer 1
		ifn bottarget -1
		{
			ifn actorvar[bottarget].team team
			ife actorvar[bottarget].monstatus 2 set bottarget -1
			// ifn bottarget -1
			// ifl sprite[bottarget].extra 0 set bottarget -1
			ifn bottarget -1
			{
				ife sprite[bottarget].statnum 1024 set bottarget -1
				else
				ife actorvar[spriteid].team 3 set bottarget -1
				else
				ifg actorvar[spriteid].stasis 0 set bottarget -1
			}
		}
		ifl cloak 0 ife pchar 4 ife bottarget player[].i set bottarget -1
		break
	}
	
	set xydist2 150000
	
	ifn bottarget -1
	{
		ife actorvar[bottarget].monstatus 2
		{
			ifn actorvar[bottarget].team team set bottarget -1 else
			ife team 0 set bottarget -1
		}
		ifn bottarget -1
			ife sprite[bottarget].statnum 1024 set bottarget -1
		ifn bottarget -1
		{
			geta[].z z
			sub z 8192
			seta[].z z
			canseespr THISACTOR bottarget temp
			add z 8192
			seta[].z z
			ife temp NO set bottarget -1
			else
			{
				ldist xydist2 THISACTOR bottarget
				sub xydist2 512
				set bluetimer 5
				ife actorvar[bottarget].monstatus 1
				ife team 0 ife actorvar[bottarget].team 0
				{
					ife disable_infighting YES set bottarget -1
					else
					ife seeplayer YES break // keep infighting
					else ifrnd 64 break
					set bottarget -1
				}
			}
		}
	}
	
	ife bottarget -1 set target -1
	
	
	// should select closest target with line of sight
	// also, do not select the target if the player is in the way
	
	ife team 1
	ifn sprite[].picnum APLAYER
	ifn sprite[].picnum SPIDERWALK
	{
		findnearspritez GREENSLIME 5120 20480 temp
		ifn temp -1
		{
			set target temp
			state targetcheck
			ifn target -1 
			{
				set bottarget target
				set bluetimer 6
				break
			}
		}
	}
	
	// headspritestat spriteid 990
	// whilevarn spriteid -1
	// {
		// ifn actorvar[spriteid].team team
		// ifn actorvar[spriteid].team 3
		// {
			// set target actorvar[spriteid].mysignpost
			// state targetcheck
			// ifn target -1
			// {
				// ifl xydist xydist2
				// {
					// set xydist2 xydist
					// set bottarget target
					// set bluetimer 6
				// }
			// }
		// }
		// nextspritestat spriteid spriteid
	// }
	
	headspritestat spriteid 1
	whilevarn spriteid -1
	{
		ifg actorvar[spriteid].monstatus 0
		ifn actorvar[spriteid].monstatus 2
		ifn actorvar[spriteid].team team
		ifl actorvar[spriteid].monstatus 100
		ifn actorvar[spriteid].team 3
		{
			set target spriteid
			
			state targetcheck
			ifn target -1
			{
				ife spriteid player[].i sub xydist 1024
				ifl xydist xydist2
				{
					set xydist2 xydist
					set bottarget target
					set bluetimer 6
				}
			}
		}
		ife spriteid player[].i 
		{
			set spriteid -1
			// ife team 0 ife bottarget -1 ife seeplayer YES set bottarget player[].i
		}
		else
		{
			nextspritestat spriteid spriteid
			ife spriteid -1 
			{
				ifn team 1
				set spriteid player[].i
				ife pchar 4 
				{
					ifl cloak 0 set spriteid -1 else
					ifn bottarget -1 ife sprite[bottarget].picnum FAKEBRACCUS set spriteid -1
				}
			}
		}
	}
	
	ife bottarget -1
	{
		headspritestat spriteid 2
		whilevarn spriteid -1
		{
			ifn actorvar[spriteid].team team
			ife actorvar[spriteid].monstatus 1
			ifn actorvar[spriteid].team 3
			{
				set target spriteid
				state targetcheck
				ifn target -1
				{
					ifl xydist xydist2
					{
						set xydist2 xydist
						set bottarget target
						set bluetimer 6
					}
				}
			}
			nextspritestat spriteid spriteid	
		}
	}
	else
	ife actorvar[bottarget].team 7
	{
		set spriteid bottarget
		state facesprite
		set bottarget -1
		set bluetimer 30
	}
					
	ife bluetimer 0
	{
		
		ife gametype 0
		{
			rand bluetimer 4
			add bluetimer 4
			ifpdistg 65536
			{
			set temp xydist2
			shiftr temp 11
			add bluetimer temp
			ife team 1 ifg bluetimer 10 set bluetimer 10
			}
			else ife target -1 rand bluetimer 2
			
		}
		else
		{
			rand bluetimer 4
			add bluetimer 4
		}
		
	}
	// set bluetimer 6

ends

defstate squish_bot

	set xydist2 1280
	ifactor QUEEN ifspritepal 42 set xydist2 2048
	ifn bottarget -1
	{
		ife bottarget myshelly ife actorvar[myshelly].monstatus 2 break
		ifl targetdist xydist2
		{
			ife bottarget player[].i ife pdown YES break
			
			ifspritepal 0 set temp 60 else set temp 40
			seta[bottarget].htextra temp
			seta[bottarget].htpicnum RPG
			seta[bottarget].htowner THISACTOR
			seta[bottarget].htang sprite[].ang
		}
	}
	else
	ifn myshelly -1
	ifn team actorvar[myshelly].team
	{
		ife actorvar[myshelly].monstatus 2 break
		dist xydist THISACTOR myshelly
		ifl xydist xydist2
		{
			ifspritepal 0 set temp 60 else set temp 40
			seta[bottarget].htextra temp
			seta[myshelly].htpicnum RPG
			seta[myshelly].htowner THISACTOR
			seta[myshelly].htang sprite[].ang
		}
		
	}

ends

defstate changetodecal

	// getactorvar[myspawner].droptile FLOORTEX
	// ifvare FLOORTEX -1
	// {
		// getactor[myspawner].htg_t 6 hitwall
		// ifvare hitwall -1 break
		// getwall[hitwall].picnum FLOORTEX
	// }
	
	getactor[myspawner].htg_t 6 temp
	ifvare temp -1 break
	
	getwall[temp].nextsector mysector
				
	ifn mysector -1 ifvarand sector[mysector].ceilingstat 1 
	{
		ife sector[mysector].floorz sector[mysector].ceilingz
		{
			set mtype 1024 break 
		}
	}
	
	getwall[temp].cstat tempb
	ifvarand tempb 2 // ignore this is upper half of wall
	{
		getwall[temp].nextsector B
		ife B -1 getwall[temp].picnum picnum
		else
		{
			ifg sprite[].z sector[B].ceilingz
			{
				getwall[temp].nextwall B
				ife B -1 getwall[temp].picnum picnum
				else getwall[B].picnum picnum
			}
			else getwall[temp].picnum picnum
		}
	}
	else
	getwall[temp].picnum picnum
		
	state tiletype

	set x 0
	switch TILETYPE
	case 1 set picnum WOODHOLE
	set x 4
	break
	case 2 set picnum METALHOLE
	set x 2
	break
	case 5 case 7 

	set picnum CONCRETEHOLE set x 2
	break
	case 10 
	set picnum ELECTRONICHOLE
	set x 3
	break
	case 11 set picnum ORGANICHOLE 
	set x 3
	break
	default 
		set picnum BULLETHOLE
	break
	endswitch
	ifn picnum BULLETHOLE
	{
		seta[].picnum picnum
		seta[].xrepeat x
		seta[].yrepeat x
		cstator 16
		cstator 128
		ifrnd 128 cstator 4
		changespritestat THISACTOR 1
	}
ends


defstate hitmetalsounds

	set temp 0
	ifsound METALHIT1 add temp 1
	ifsound METALHIT2 add temp 1
	ifsound METALHIT3 add temp 1
	ifsound METALHIT4 add temp 1
	ifsound METALHIT5 add temp 1
	ifsound METALHIT6 add temp 1
	
	ifg temp 3 break // don't play more than 4 at once
	
	rand tempb 5
	switch tempb
	case 0 sound METALHIT1 break
	case 1 sound METALHIT2 break
	case 2 sound METALHIT3 break
	case 3 sound METALHIT4 break
	case 4 sound METALHIT5 break
	case 5 sound METALHIT6 break
	endswitch

ends

defstate breakmetalsounds

	sound BREAK_MET3
	break
	
	set temp 0
	ifsound BREAK_MET1 add temp 1
	ifsound BREAK_MET2 add temp 1
	ifsound BREAK_MET3 add temp 1
	ifg temp 1 break
	
	rand tempb 2
	switch tempb
	case 0 sound BREAK_MET1 break
	case 1 sound BREAK_MET2 break
	case 2 sound BREAK_MET3 break
	endswitch

ends

defstate hitconcretesounds

	set temp 0
	ifsound CONCRETEHIT1 add temp 1
	ifsound CONCRETEHIT2 add temp 1
	ifsound CONCRETEHIT3 add temp 1
	ifsound CONCRETEHIT4 add temp 1
	ifsound CONCRETEHIT5 add temp 1
	ifsound CONCRETEHIT6 add temp 1
	ifsound CONCRETEHIT7 add temp 1
	
	ifg temp 3 break // don't play more than 4 at once

	rand tempb 6
	switch tempb
	case 0 sound CONCRETEHIT1 break
	case 1 sound CONCRETEHIT2 break
	case 2 sound CONCRETEHIT3 break
	case 3 sound CONCRETEHIT4 break
	case 4 sound CONCRETEHIT5 break
	case 5 sound CONCRETEHIT6 break
	case 6 sound CONCRETEHIT7 break
	
	endswitch

ends

defstate kickcheckcode
	ifge sprite[].alpha 160 
	{ 
		ife dashtarg THISACTOR set dashtarg -1  
		ife kicktarg THISACTOR set kicktarg -1
		break
	}
	ifn saberdash 0 ife dashtarg -1
	ifpdistl 6144
	ifp pfacing
		set dashtarg THISACTOR

	set temp NO
	
	ife slidehit NO
	{
		ifg slidekick 5 ifl slidekick 23
		{
			ifp pfacing
			set temp YES
		}
		else
		{
			switch sidekick
			case 0
				
				ifpdistl 2560
				ifvarand bits 4194304
				ifp pfacing
				{
					ife kicktarg -1
					{
						ifn player[].quick_kick 0
							set kicktarg THISACTOR
						else
						ifn qk_proxy 0
							set kicktarg THISACTOR
					}	
					ife player[].quick_kick 1 set sidekick 51 else
					ife qk_proxy 1 set sidekick 51
					
					ife sidekick 51
					{
						setp[].quick_kick 0
						set qk_proxy 0
						setp[].last_quick_kick 0
						set slidehit NO
					}
					
				}
			break
			case 8 case 9 case 10 case 11
			case 12 case 13 case 14 case 15
			case 40 case 41 case 42 case 43
			case 58 case 59 case 60 case 61
			ifp pfacing
			{
				set temp YES
				ife kicktarg -1
				ifpdistl 2560
					set kicktarg THISACTOR
			}
			
			break
			
			case 110 case 111 case 112 case 113
			case 114 case 115 case 116 case 117
			case 118 case 119 case 120
				ifp pfacing
				{
					set temp YES
					ife kicktarg -1
					ifpdistl 2560
						set kicktarg THISACTOR
				}
				else
				ife sprite[].htpicnum KNEE
				ifg sprite[].htextra 0 set temp YES
			
			break
			endswitch
			
		}
	}
	
	ife temp YES
	ifpdistl 1024
	{
		set slidehit YES
		ife pchar 4 ifl cloak 0 
		{
			mul cloak -1
			set switchboost 15
			sound CLOAKOFF
		}
		geta[].htextra temp
		// ifl temp 10 set TMP_A YES else set TMP_A NO
		set tempb SLIDEKICKSTRENGTH
		mul tempb pdamage, div tempb 100
		add temp tempb
		seta[].htpicnum KNEE
		seta[].htowner player[].i
		seta[].htang player[].ang
		seta[].htextra temp
		
		// ife TMP_A YES 
		ifn attmode NO
		ifg monxp 0
		ifg temp 1
		{
			ifn sprite[].pal 1
			ifg temp sprite[].extra set temp sprite[].extra
			// ifspritepal 1 set TMP_B 9 else 
			set TMP_B 0
			ife pchar 0 set tempc dweapxp[TMP_B] else 
			ife pchar 2 set tempc wweapxp[TMP_B] else 
			ife pchar 3 set tempc mweapxp[TMP_B] else
			ife pchar 4 set tempc nweapxp[TMP_B] else
			set tempc bweapxp[TMP_B]
			
			ifn marathon NO 
			{
				set TMP_A temp
				ifvarand startmode 1 ifge dready 1 add temp TMP_A else
				ifvarand startmode 2 ifge bready 1 add temp TMP_A else
				ifvarand startmode 4 ifge wready 1 add temp TMP_A else
				ifvarand startmode 8 ifge mready 1 add temp TMP_A else
				ifvarand startmode 16 ifge nready 1 add temp TMP_A
				div temp 2
			}
			add tempc temp
			ife pchar 0 setarray dweapxp[TMP_B] tempc else 
			ife pchar 2 setarray wweapxp[TMP_B] tempc else
			ife pchar 3 setarray mweapxp[TMP_B] tempc else
			ife pchar 4 setarray nweapxp[TMP_B] tempc else
			setarray bweapxp[TMP_B] tempc
		
			ife pchar 0 set TMP_A dweaplevel[TMP_B] else 
			ife pchar 2 set TMP_A wweaplevel[TMP_B] else
			ife pchar 3 set TMP_A mweaplevel[TMP_B] else
			ife pchar 4 set TMP_A nweaplevel[TMP_B] else
			set TMP_A bweaplevel[TMP_B]
			add TMP_A 1
			
			ifg TMP_A 3 mul TMP_A 3500 else
			ifg TMP_A 2 mul TMP_A 3000 else
			ifg TMP_A 1 mul TMP_A 2500 else
			mul TMP_A 2000
			sub TMP_A 1000
			
			ife pchar 0 set temp dweapxp[TMP_B] else 
			ife pchar 2 set temp wweapxp[TMP_B] else
			ife pchar 3 set temp mweapxp[TMP_B] else
			ife pchar 4 set temp nweapxp[TMP_B] else
			set temp bweapxp[TMP_B]
			
			ifge temp TMP_A
			{
				
				ife pchar 0 
				{
					set temp dweaplevel[TMP_B]
					add temp 1
					ifl temp 7 add totalxp 1000
					setarray dweaplevel[TMP_B] temp
					
					ifvarand comboperk 1 nullop else
					// check to see if comboperk is achieved
					{
						set tempc 0
						set tempb 0 
						whilevarn tempc 13
						{
							ifg dweaplevel[tempc] 0
							add tempb 1
							add tempc 1
						}
						ifge tempb 11
						{
							orvar comboperk 1
							set buffermsg 1139
						}
					}
					
					ife buffermsg 0
					{
						// ife temp 1 set buffermsg 795 else 
						ife temp 3 set buffermsg 796 else ife temp 5 set buffermsg 797
					}
					set bigmsg 793
					set bigmsgcount 90
					// set temp dweapxp[TMP_B]
					// sub temp TMP_A
					setarray dweapxp[TMP_B] 0 // temp
				}
				else
				ife pchar 4
				{
					set temp nweaplevel[TMP_B]
					add temp 1
					ifl temp 7 add totalxp 1000
					setarray nweaplevel[TMP_B] temp
					
					ifvarand comboperk 16 nullop else
					// check to see if comboperk is achieved
					{
						set tempc 0
						set tempb 0 
						whilevarn tempc 13
						{
							ifg mweaplevel[tempc] 0
							add tempb 1
							add tempc 1
						}
						ifge tempb 11
						{
							orvar comboperk 16
							set buffermsg 1139
						}
					}
					
					ife buffermsg 0
					{
						// ife temp 1 set buffermsg 795 else 
						ife temp 3 set buffermsg 796 else ife temp 5 set buffermsg 797
					}
					set bigmsg 1414
					set bigmsgcount 90
					// set temp nweapxp[TMP_B]
					// sub temp TMP_A
					setarray nweapxp[TMP_B] 0 // temp
				}
				else
				ife pchar 3
				{
					set temp mweaplevel[TMP_B]
					add temp 1
					ifl temp 7 add totalxp 1000
					setarray mweaplevel[TMP_B] temp
					
					ifvarand comboperk 8 nullop else
					// check to see if comboperk is achieved
					{
						set tempc 0
						set tempb 0 
						whilevarn tempc 13
						{
							ifg mweaplevel[tempc] 0
							add tempb 1
							add tempc 1
						}
						ifge tempb 11
						{
							orvar comboperk 8
							set buffermsg 1139
						}
					}
					
					ife buffermsg 0
					{
						// ife temp 1 set buffermsg 795 else 
						ife temp 3 set buffermsg 796 else ife temp 5 set buffermsg 797
					}
					set bigmsg 1195
					set bigmsgcount 90
					// set temp mweapxp[TMP_B]
					// sub temp TMP_A
					setarray mweapxp[TMP_B] 0 // temp
				}
				else
				ife pchar 2
				{
					set temp wweaplevel[TMP_B]
					add temp 1
					ifl temp 7 add totalxp 1000
					setarray wweaplevel[TMP_B] temp
					
					ifvarand comboperk 4 nullop else
					// check to see if comboperk is achieved
					{
						set tempc 0
						set tempb 0 
						whilevarn tempc 13
						{
							ifg wweaplevel[tempc] 0
							add tempb 1
							add tempc 1
						}
						ifge tempb 11
						{
							orvar comboperk 4
							set buffermsg 1139
						}
					}
					
					ife buffermsg 0
					{
						// ife temp 1 set buffermsg 795 else 
						ife temp 3 set buffermsg 796 else ife temp 5 set buffermsg 797
					}
					set bigmsg 1195
					set bigmsgcount 90
					// set temp wweapxp[TMP_B]
					// sub temp TMP_A
					setarray wweapxp[TMP_B] 0 // temp
				}
				else
				{
					set temp bweaplevel[TMP_B]
					add temp 1
					ifl temp 7 add totalxp 1000
					setarray bweaplevel[TMP_B] temp
					
					ifvarand comboperk 2 nullop else
					// check to see if comboperk is achieved
					{
						set tempc 0
						set tempb 0 
						whilevarn tempc 13
						{
							ifg bweaplevel[tempc] 0
							add tempb 1
							add tempc 1
						}
						ifge tempb 11
						{
							orvar comboperk 2
							set buffermsg 1139
						}
					}
					
					ife buffermsg 0
					{
						// ife temp 1 set buffermsg 795 else 
						ife temp 3 set buffermsg 796 else ife temp 5 set buffermsg 797
					}
					set bigmsg 794
					set bigmsgcount 90
					// set temp bweapxp[TMP_B]
					// sub temp TMP_A
					setarray bweapxp[TMP_B] 0 // temp
				}
				screensound WEAPON_UPGRADE
				screensound WEAPON_UPGRADE
				palfrom 32 63 63 63
			}
			
			ife pchar 0 set TMP_A dweaplevel[TMP_B] else 
			ife pchar 2 set TMP_A wweaplevel[TMP_B] else
			ife pchar 3 set TMP_A mweaplevel[TMP_B] else
			ife pchar 4 set TMP_A nweaplevel[TMP_B] else
			set TMP_A bweaplevel[TMP_B]
			mul TMP_A 8
			add TMP_A 100
			geta[].htextra temp
			mul temp TMP_A
			div temp 100
			seta[].htextra temp	
		}
		
		switch sprite[].picnum
		case BOSS1
		case BOSS2
		case BOSS3
		case BOSS4
		case PSPIDER
		case CYCLOIDMAX
		case NEWBATLORD
		case QUEEN
		case PIGBOSS
		case LIZBOSS
		case MEGABRAIN
		case EGG case EGGYOUNG
		case TERMINATORCRAWLING
		case TANK
		case EBARRIER case BARRICADE
		break
		
		default
			getp[].i spriteid
			state facesprite
			set xvel -1024
			set z -2048
			ifn sidekick 0 { shiftr xvel 1 shiftr z 1 }
			seta[].xvel xvel
			seta[].zvel z
			geta[].z z
			sub z 2048
			seta[].z z
			set temp sprite[].htextra
			mul temp 5
			div temp inithp
			ifg temp 1
			add stun temp
		break
		endswitch
		
		sound KICKIMPACT
	}
	else
	ifp ponground nullop
	else
	ifpdistl 2048
	ifl sprite[player[].i].z sprite[].z
	ife jumpkickhit NO
	ifg jumpkick 0 ifl jumpkick 18
	{
		set jumpkickhit YES
		
		geta[].htextra temp
		set tempb SLIDEKICKSTRENGTH
		mul tempb pdamage, div tempb 100
		add temp tempb
		seta[].htextra temp
		
		ifstrength 90
		ifrnd 96
		seta[].htpicnum HEADJIB1
		else 
		seta[].htpicnum KNEE
		seta[].htowner player[].i
		seta[].htang player[].ang
		
		switch sprite[].picnum
		case BOSS1
		case BOSS2
		case BOSS3
		case BOSS4
		case PSPIDER
		case CYCLOIDMAX
		case NEWBATLORD
		case QUEEN
		case PIGBOSS
		case LIZBOSS
		case MEGABRAIN
		case EGG case EGGYOUNG
		case TERMINATORCRAWLING
		case TANK
		case EBARRIER case BARRICADE
		break
		
		default
			getp[].i spriteid
			state facesprite
			seta[].xvel -1024
			seta[].zvel -2048
			geta[].z z
			sub z 3072
			seta[].z z
			set temp sprite[].htextra
			mul temp 6
			div temp inithp
			ifg temp 1
			add stun temp
		break
		endswitch
		sound KICKIMPACT
	}
ends


defstate AActivation

	set spriteid 0
	whilevarn spriteid 16384 // Numsprites
	{
		switch sprite[spriteid].picnum
		
		case JUMPAD
			ife actorvar[spriteid].SPRITELOTAG SPRITELOTAG
				setav[spriteid].SPRITELOTAG 0
		break
		
		case SECTORLIGHT
			ife actorvar[spriteid].SPRITELOTAG SPRITELOTAG
			{
				ifge actorvar[spriteid].mtype 2
					setav[spriteid].mtype 1 // turn light on
				else ife actorvar[spriteid].mtype 0
				setav[spriteid].mtype -1 // turn light off
			}
		break
		
		case NUKEENDING
		case UFOFLOAT
			ife actorvar[spriteid].SPRITELOTAG SPRITELOTAG
			ife actorvar[spriteid].mtype 0
				setav[spriteid].mtype 1
		break
		
		case FANACTIVATE
			ife actorvar[spriteid].SPRITELOTAG SPRITELOTAG
			{
				ife actorvar[spriteid].mtype 0 setav[spriteid].mtype 1 else
				setav[spriteid].mtype 0
			}
		break
		case UPDRAFT_SPAWNER
		
			ife actorvar[spriteid].SPRITELOTAG SPRITELOTAG
			{
				setav[spriteid].SPRITELOTAG 0
				setav[spriteid].initsprite SPRITELOTAG
				setav[spriteid].countvar 60
			}
			else
			ife actorvar[spriteid].initsprite SPRITELOTAG
			{
				setav[spriteid].SPRITELOTAG SPRITELOTAG
				setav[spriteid].initsprite 0
			}
		break
		
		case MULTIPLATE
			ife actorvar[spriteid].mtype 2
			ife actorvar[spriteid].SPRITELOTAG SPRITELOTAG
				setav[spriteid].droptile YES
		
		break
		
		case 18719
		case 18720
		case 18721
			ife SPRITELOTAG actorvar[spriteid].SPRITELOTAG
			ife actorvar[spriteid].countvar 0 // not currently active
			{
				setav[spriteid].countvar 1
				// al SPRITELOTAG
				
				ife actorvar[spriteid].countvarb 0 // in starting position
					setav[spriteid].countvarc 1 // start animation forward
				else
					setav[spriteid].countvarc -1 // start animation backward
			}
		break
		case MOVESHIPCAM
			ife SPRITELOTAG actorvar[spriteid].initsprite
			setav[spriteid].initsprite -1
			
			ife SPRITELOTAG actorvar[spriteid].initflags
			ife actorvar[spriteid].SPRITELOTAG 1
			setav[spriteid].initflags 0
		break
		
		case LASERWALL
		case DEATHZONE
			ife SPRITELOTAG actorvar[spriteid].SPRITELOTAG
			{
				// mtype 1 == deactivated
				ife actorvar[spriteid].mtype 0 setav[spriteid].mtype 1 else
				setav[spriteid].mtype 0
			}
		break
		case NEWLASERLINE
			ife SPRITELOTAG actorvar[spriteid].SPRITELOTAG
			{
				ife sprite[spriteid].cstat actorvar[spriteid].initflags
					seta[spriteid].cstat 32768
				else
					seta[spriteid].cstat actorvar[spriteid].initflags
			}
		break
		
		case DIALOGBUB
			ife SPRITELOTAG actorvar[spriteid].startx
			ife actorvar[spriteid].initflags -1
			{
				setav[spriteid].monstatus 2
				seta[spriteid].cstat 32768
			}
		break
			
		case NOCNITSA
			ife SPRITELOTAG actorvar[spriteid].SPRITELOTAG
			setav[spriteid].monstatus 2
		break
		
		case BLACKHAWK
			ife actorvar[spriteid].SPRITELOTAG SPRITELOTAG
			{
				setav[spriteid].SPRITELOTAG 0
				changespritestat spriteid 1
			}
		break
			
		case COFFIN
			ife actorvar[spriteid].SPRITELOTAG SPRITELOTAG
			ife actorvar[spriteid].initsprite NO
				setav[spriteid].initsprite YES
		break
		
		case MESSAGER
		ife actorvar[spriteid].mtype SPRITELOTAG
		{
			ife actorvar[spriteid].droptile 2
			{
				setav[spriteid].droptile 1
				setav[spriteid].mtype 0
			}
			else
			ife actorvar[spriteid].droptile 0
			setav[spriteid].monstatus 2
		}
		break
		
		case GRAVESNPC
		ife SPRITELOTAG GRAVESNPC
		{
			setav[spriteid].initsprite 11
		}
		break
		
		case LEVELENDER
		ife actorvar[spriteid].SPRITELOTAG SPRITELOTAG
			setav[spriteid].monstatus 1
		break
		
		case PORTALMANAGER
		ife SPRITELOTAG PORTALMANAGER
			setav[spriteid].mtype 1
		break
		
		endswitch

		add spriteid 1
	}
ends

defstate se17activation

	headspritesect spriteid sprite[].sectnum
	whilevarn spriteid -1
	{
		ife sprite[spriteid].picnum SECTOREFFECTOR
		ife sprite[spriteid].lotag 17
			operatesectors sprite[].sectnum player[].i
		
		nextspritesect spriteid spriteid
	}

ends
	
defstate activatechannel

	state AActivation
	operateactivators SPRITELOTAG 0
	operatemasterswitches SPRITELOTAG
	operaterespawns SPRITELOTAG
	
	
	
	set SPRITELOTAG 0

ends

// defstate spawnmysignpost

	// espawn TEAM_TARGET
	// setav[RETURN].team team
	// setav[RETURN].mysignpost THISACTOR
	// seta[RETURN].cstat 32768
	// set mysignpost RETURN
	// seta[RETURN].xrepeat 32
	// seta[RETURN].yrepeat 32
	// seta[RETURN].z player[].posz
	// changespritestat RETURN 990

// ends

defstate wavesettings
	// if timebeforeexxit is set, that means spawnsleft and monleft must be set later for next match
	switch wave
	case 1
		set spawnsleft 30
		set monleft 30
		set gametime 10800
	break
	case 2
		set spawnsleft 2
		set monleft 2
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			ife actorvar[spriteid].monstatus 1
				setav[spriteid].teamspawned -1
			ife sprite[spriteid].picnum TEAMSPAWNER
			{
				setav[spriteid].myspawner -1
				setav[spriteid].countvar 60
			}
			nextspritestat spriteid spriteid
		}
	break
	
	case 3
		set spawnsleft 0
		set monleft 0
		
		ife pdown NO
		ifp palive
		{
			set survivor_winner YES
			al survivor_winner
			setp[].movement_lock 0
			setp[].dead_flag 0
			setp[].newowner -1
			ifl sprite[player[].i].extra 100 seta[player[].i].extra 100
			setp[].wackedbyactor -1
			set pdown NO
			
		}
		setp[].timebeforeexit 210
		set endgametime gametime
		set gametime -1
		
		
	break
	case 7
		set spawnsleft 24 //34
		set monleft 24 // 34
	break
	case 8
		operateactivators 1 0
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			ife actorvar[spriteid].monstatus 1
			ifn sprite[spriteid].picnum SITH
			ifn sprite[spriteid].picnum SYTH
				setav[spriteid].teamspawned -1
			nextspritestat spriteid spriteid
		}
		// set spawnsleft 2
		set monleft 2
		// this is a special case
	break
	// case 9 end of sith match, use default
	// case 10 // MICKY'S CTF
	
	case 11  // second arena survival match
		set spawnsleft 30
		set monleft 30
	break
	case 12
		set spawnsleft 3
		set monleft 3
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			ife actorvar[spriteid].monstatus 1
				setav[spriteid].teamspawned -1
			ife sprite[spriteid].picnum TEAMSPAWNER
			{
				setav[spriteid].myspawner -1
				setav[spriteid].countvar 60
			}
			nextspritestat spriteid spriteid
		}
	break
	
	case 21 // zombies
	case 24 // drones
	case 22 // liztroop
		set spawnsleft 50
		set monleft 50
	break
	
	case 28 // army ant
	case 33 // terminator
	case 23 // lizman
	case 25 // pigcop, armpig, tank
	case 26 // octabrain, megabrain
	case 27 // newbeast, cyberbeast
	case 30 // lizranger
	case 32 // spacebull
		set spawnsleft 30
		set monleft 30
	break
	
	case 29 // commander
	case 31 // mechbrain
	case 34 // lizelite
		set spawnsleft 18
		set monleft 18
	break
	
	case 35 // lizboss and boss3 pal
		set spawnsleft 14
		set monleft 14
	break
	
	case 39
	break
	
	case 40 // first cycloidmax wave
		set spawnsleft 12
		set monleft 12
	break
	
	case 41
	break
	
	case 42
		set spawnsleft 16
		set monleft 16
	break
	
	case 43
	break
	
	default
	setp[].timebeforeexit 180
	
	ife pdown NO
	ife gametype SURVIVAL
	ife monleft 0
	ife spawnsleft 0
	{
		set survivor_winner YES 
		al survivor_winner
	}
	break
	endswitch

ends

// GLADIATORS WAVE MASTER LIST
// wave 0 first DM to start game
// wave 1 first survival wave in arena
// wave 2 boss survival wave in arena
// wave 3 end of 1st survival contest
// wave 4 got new shotgun from ogus
// wave 5 JCTF
// wave 6 arctic control
// wave 7 survival wave in sith battle
// wave 8 boss wave in sith battle
// wave 9 end of sith battle
// wave 10 Micky's sausage CTF
// wave 11,12 regular and boss waves in arena 2
// wave 13 arena 2 finished
// wave 14 dungeon CTF
// wave 15 confeud control
// wave 16 big boi boss fight in altar.map
// wave 17 DM vs bubafett in ironwill
// wave 18 sewers CTF
// wave 19 factory control
// wave 20 space command CTF
// wave 21 survive in edelheim



defstate mandoconcedesounds

	ife bluescore 1 
	{ stopallsounds globalsound MANDO_EVENTUALLY 
		set subtitle_time 120 set subtitle_numlines 1 set subtitle_start 580 
		set cutcamtime player[].player_par
		set emp_overlay 120
		set emp_overlay_tile 15270
		} 
	else
	ife bluescore 2 
	{ stopallsounds globalsound MANDO_GOODSHOT 
		set subtitle_time 120 set subtitle_numlines 1 set subtitle_start 581 
		set cutcamtime player[].player_par
		set emp_overlay 120
		set emp_overlay_tile 15270
		} 
	else
	ife bluescore 4 
	{ stopallsounds globalsound MANDO_UDONTSUCK 
		set subtitle_time 150 set subtitle_numlines 1 set subtitle_start 582 
		set cutcamtime player[].player_par
		set emp_overlay 150
		set emp_overlay_tile 15270
		} 
	else
	ife bluescore 6 
	{ stopallsounds globalsound MANDO_UHAVESKILL 
		set subtitle_time 150 set subtitle_numlines 2 set subtitle_start 583 
		set cutcamtime player[].player_par
		set emp_overlay 150
		set emp_overlay_tile 15270
		}
	else
	ifg bluescore 7 ifg bluescore redscore
	{
		set temp bluescore
		modvar temp 2
		ife temp 0
		{ stopallsounds globalsound MANDO_UNDERESTIMATED 
			set subtitle_time 150 set subtitle_numlines 1 set subtitle_start 585
			set cutcamtime player[].player_par
			set emp_overlay 150
			set emp_overlay_tile 15270
		}
	}
	
ends

defstate deathmatchscore

	ife teamspawned 99999 break
	
	ife gametime -1 break // match already over
	set value 1
	
	geta[].htowner spriteid
	ifwasweapon BURNING
	{
		ife pchar 1 set spriteid player[].i else
		ifn myshelly -1 set spriteid myshelly
	}
	ife spriteid player[].i
	{
		ife pchar 0 add duke_kills 1
		ife pchar 1 add shelly_kills 1
		ife pchar 2 add wes_kills 1
		ife pchar 3 add mando_kills 1
		ife pchar 4 add nova_kills 1
	}
	else ifn myshelly -1 ife spriteid myshelly
	{
		ife sprite[myshelly].picnum SHELLY add shelly_kills 1 else
		ife sprite[myshelly].picnum SHELLYCROUCH add shelly_kills 1 else
		ife sprite[myshelly].picnum DUKEBOT add duke_kills 1 else
		ife sprite[myshelly].picnum DUKEBOTCROUCH add duke_kills 1 else
		ife sprite[myshelly].picnum WESBOT add wes_kills 1 else
		ife sprite[myshelly].picnum WESBOTCROUCH add wes_kills 1 else
		ife sprite[myshelly].picnum DEABOT add nova_kills 1 else
		ife sprite[myshelly].picnum DEABOTCROUCH add nova_kills 1
	}
	else
	{
		ifn spriteid -1
		{
			ife team actorvar[spriteid].team
			{
				ifactor MANDOFETT { sub enemy1_kills 1 sub redscore 1 } else
				ifactor MANDOCROUCH { sub enemy1_kills 1 sub redscore 1 } else
				ife sprite[spriteid].pal 12 { sub enemy1_kills 1 sub redscore 1 } else
				ife sprite[spriteid].pal 10 { sub enemy2_kills 1 sub redscore 1 }
				
				ifl enemy1_kills 0 set enemy1_kills 0
				ifl enemy2_kills 0 set enemy2_kills 0
				ifl redscore 0 set redscore 0
			}
		}
		else
		{
			ife pchar 0 add duke_kills 1
			ife pchar 1 add shelly_kills 1
			ife pchar 2 add wes_kills 1
			ife pchar 3 add mando_kills 1
			ife pchar 4 add nova_kills 1
		}
	}
	
	ife team 0 ifl bluescore scorelimit add bluescore value
	ife team 1 ifl redscore scorelimit add redscore value
	
	ifactor MANDOFETT { add enemy1_deaths 1 state mandoconcedesounds } else
	ifactor MANDOCROUCH { add enemy1_deaths 1 state mandoconcedesounds } else
	ifspritepal 12 add enemy1_deaths 1 else
	ifspritepal 10 add enemy2_deaths 1

	ifge bluescore scorelimit ifg bluescore redscore { setp[].timebeforeexit 180 set endgametime gametime set gametime -1 }
	ifge redscore scorelimit ifg redscore bluescore { setp[].timebeforeexit 180 set endgametime gametime set gametime -1 }
	
	ife gametime 0 ifn bluescore redscore { setp[].timebeforeexit 180 set endgametime gametime set gametime -1 }

ends

defstate spawnoutline

	espawn OUTLINE
	ifvarand monstflags 32768 seta[RETURN].pal 4
	seta[RETURN].mdflags 16
	setav[RETURN].initsprite sprite[].htdispicnum
	seta[RETURN].xrepeat sprite[].xrepeat
	seta[RETURN].yrepeat sprite[].yrepeat
	
	ifge pchar 3
	ife team 0
	ifvarand gotrailgun 2
	ife monstatus 2
	ife sprite[].htowner player[].i
	{
		ife pchar 3
		{
			ifrnd 128 setav[RETURN].droptile M_TARGETDELETED else
			ifrnd 160 setav[RETURN].droptile M_MONEYSHOT else
			setav[RETURN].droptile M_NUISANCE
		}
		else
		{
			ifrnd 128 setav[RETURN].droptile DEA_PRECISION else
			ifrnd 160 setav[RETURN].droptile DEA_VAPORIZED else
			setav[RETURN].droptile DEA_SILENCED
		}
	}

ends

move NUMBERUP 0 -16
move NUMBERUPFAST 0 -32

defstate numberstate
	set shrunken 0
	ifvare mtype 0 break
	spriteflags 68
	ifmove 0
	{
		ife mtype 1 move NUMBERUPFAST geth getv
		else
		move NUMBERUP geth	
		sizeat 40 40
		cstator 80
		spritepal 21
		seta[].shade -127
	}

	geta[].alpha temp
	add temp 3
	seta[].alpha temp 
	ifcount 84 killit

ends

useractor notenemy 12821 0 state numberstate enda

useractor notenemy 12822 0 state numberstate enda

useractor notenemy 12823 0 state numberstate enda

useractor notenemy 12824 0 state numberstate enda

useractor notenemy 12825 0 state numberstate enda

useractor notenemy 12826 0 state numberstate enda

useractor notenemy 12827 0 state numberstate enda

useractor notenemy 12828 0 state numberstate enda

useractor notenemy 12829 0 state numberstate enda

useractor notenemy 12830 0 state numberstate enda

defstate moveitleft
getactor[THISACTOR].ang angvar
addvar angvar 512
getactor[RETURN].x x
getactor[RETURN].y y
setvarvar x2 x
addvar x2 128
rotatepoint x y x2 y angvar x2 y2
setactor[RETURN].x x2
setactor[RETURN].y y2
ends

defstate moveitright
getactor[THISACTOR].ang angvar
subvar angvar 512
getactor[RETURN].x x
getactor[RETURN].y y
setvarvar x2 x
addvar x2 128
rotatepoint x y x2 y angvar x2 y2
setactor[RETURN].x x2
setactor[RETURN].y y2
ends

defstate spawnimpcoins
	// spawn coins
	ifactor NEWTROOPTARGET break
	ifactor NEWPIGTARGET break
	whilevarn value 0
	{ 
	  randvar angvar 2047
	  seta[].ang angvar
	  randvar z 4096
	  mulvar z -1
	  ezshoot z IMPCOINPROJ
	  ifn RETURN -1
	  {
		  ifrnd 160 { seta[RETURN].pal 8 set savx 10 } else
		  ifrnd 160 { seta[RETURN].pal 1 set savx 11 } else
		  ifrnd 160 { seta[RETURN].pal 12 set savx 13 } else
		  ifrnd 160 { seta[RETURN].pal 97 set savx 12 } else
		  ifrnd 160 { seta[RETURN].pal 10 set savx 14 } else
		  { seta[RETURN].pal 63 set savx 15 }
		  seta[RETURN].xrepeat savx
		  seta[RETURN].yrepeat savx
	  }
	  ife monstatus 1 ifg value 10 sub value 1
	  subvar value 1
	}
ends

defstate spawn_number
	setvarvar tempb TMP_A
	addvar tempb NEWNUMSTART
	espawnvar tempb
	setav[RETURN].mtype monstatus
	setav[RETURN].myspawner THISACTOR

	set zdist tiledata[].ysize
	mul zdist sprite[].yrepeat
	add zdist 3072
	mul zdist 2
	getactor[].z z, sub z zdist
	seta[RETURN].z z

	setactor[RETURN].ang sprite[THISACTOR].ang
ends

defstate showpoints

getactor[THISACTOR].ang savx
getplayer[THISACTOR].posx x2
getplayer[THISACTOR].posy y2
getactor[THISACTOR].x x
getactor[THISACTOR].y y
subvarvar x2 x
subvarvar y2 y
getangle angvar x2 y2
setactor[THISACTOR].ang angvar

setvarvar tempd monxp

switch SKILL // userdef[].player_skill
case 0 case 1 div tempd 4 break
case 2 div tempd 2 break
case 4 mul tempd 3 div tempd 2 break
case 5 case 6 mul tempd 2 break
endswitch

setvarvar tempI tempd

ifvarg tempd 9999
{
	setvarvar TMP_A tempI
	divvar TMP_A 10000
	state spawn_number
	mulvar TMP_A 10000
	subvarvar tempI TMP_A // tempI is now the number that is left over
	state moveitleft
	state moveitleft
	state moveitleft
}
ifvarg tempd 999
{
	setvarvar TMP_A tempI
	divvar TMP_A 1000
	state spawn_number
	mulvar TMP_A 1000
	subvarvar tempI TMP_A // tempI is now the number that is left over
	state moveitleft
	state moveitleft
}
ifvarg tempd 99
{
	setvarvar TMP_A tempI
	divvar TMP_A 100
	state spawn_number
	mulvar TMP_A 100
	subvarvar tempI TMP_A
	state moveitleft
}
ifvarg tempd 9
{
	setvarvar TMP_A tempI
	divvar TMP_A 10
	state spawn_number
	mulvar TMP_A 10
	subvarvar tempI TMP_A
}
setvarvar TMP_A tempI
state spawn_number
state moveitright

setactor[THISACTOR].ang savx

ends


defstate enemy_death

  ife DAMAGEFLASH YES ife sawfleshtime 0 
  ife sprite[].htowner player[].i
  set damflash player[].player_par
  
  set spriteid sprite[].htowner
  ife spriteid -1 set spriteid player[].i
  ife spriteid player[].i
  ifrnd SWEARFREQUENCY
  ife jibsound -1
  {
	  ife pchar 4
	  ifg rage 0
	  {
	    rand temp 5
		switch temp
		case 0 set jibsound DEA_EASYPREY break
		case 1 set jibsound DEA_STRUCKYOUDOWN break
		case 2 set jibsound DEA_GETUPKILL break
		case 3 set jibsound DEA_LAUGH break
		case 4 set jibsound DEA_WHYSOWEAK break
		case 5 set jibsound DEA_IMUDEATH break
		endswitch
	  }
	  else
      ifwasweapon ARROWPROJ
	  ife pchar 1
	  {
		ifrnd 84 set jibsound B_SHAFT else
		ifrnd 128 set jibsound B_GOTTHEPOINT else
		set jibsound B_AMAZONDELIVERY
	  }
	  else
	  ifwasweapon SHOTSPARK1
	  ife pchar 3
	  ife player[].curr_weapon CHAINGUN_WEAPON
	  {
		ifrnd 36 set jibsound M_EATLEAD
	  }
	  else
	  {
		switch sprite[].picnum
		case PIGCOP case PIGCOPDIVE case NEWPIG case NEWPIGDIVE
		ifl pchar 2
		{
			ifg burning 0 ifwasweapon BURNING
			{
			  ifrnd 96
			  {
				ife pchar 0 set jibsound MAKINBACON else
				ife pchar 1 set jibsound B_MAKINBACON
			  }
			}
			else ifwasweapon SHOTSPARK1
			{
			  ifrnd 96
			  {
				ife pchar 0 set jibsound SQUEALPIGGY else
				ife pchar 1 set jibsound B_SQUEALPIGGY
			  }
			}
			else ifwasweapon RPG
			{
			  ifrnd 32
			  {
				ife pchar 0 set jibsound MAKINBACON else
				ife pchar 1 set jibsound B_MAKINBACON
			  }
			}
		}
		break
		case OCTABRAIN
		ifrnd 48
		ifl pchar 2
		{
		  ife pchar 0 set jibsound TENTACLES else
		  ife pchar 1 set jibsound B_TENTACLES
		}
		else
		ifwasweapon RPG ife pchar 4 ifrnd 96 set jibsound DEA_OCTARAIN
		break
		case COMMANDER
		case NEWCOMM
		ifrnd 64
		ifl pchar 2
		{
		  ife pchar 0 set jibsound JIBBED_ACTOR12
		  ife pchar 1 { ifrnd 160 set jibsound B_FATFUCK else set jibsound B_SUCKIT }
		}
		break
		case BOSS1 case BOSS2 case BOSS3 case BOSS4
		case PIGBOSS case LIZBOSS case CANHEADNOARMS
		case CYCLOIDMAX case BATBOSS case NURGLE
		ifrnd 96
		{
			ife pchar 0 set jibsound BIGBLEED else
			ife pchar 2 set jibsound WESSTAYDOWN else
			ife pchar 3 set jibsound M_IFITBLEEDS else
			ife pchar 4 { ifrnd 128 set jibsound DEA_BOSSKILL1 else set jibsound DEA_KILLBOSS2 } 
			else set jibsound B_BIGBLEED
		}
		break
		case LIZDOG
			ife pchar 4 ifrnd 96 set jibsound DEA_DOGLEASH
		break
		endswitch
	  }
	ifn jibsound -1 set jibsound_delay 6
  }
  set burning 0
  set bleeding 0
  ifvarand monstflags 2048 seta[].alpha 0 // ghostly
  // seta[].mdflags 0
  ife targetlock[0] THISACTOR setarray targetlock[0] -1
  ife targetlock[1] THISACTOR setarray targetlock[1] -1
  ife targetlock[2] THISACTOR setarray targetlock[2] -1
  
  // failsafe
  ife mybounty THISACTOR
  {
	ife team 1 { set team 0 add maxkills 1 }
	ife monstatus 1 set monstatus 1
  }
  
  ifn team 1 ifn team 3 add killcount 1
  
  ifn team 1
  ife restartatt 0
  ifn monstatus 2
  {
      ife team 0 ifvarand perks 1
	  ifn gametype -1
	  {
		ifl leftsidegun -1 add leftsidegun 1
		ifl rightsidegun -1 add rightsidegun 1
	  }
	  ifvarand perks 64 ifl rescuecharge RESCUEAMOUNT add rescuecharge 1
	  ife pchar 4 ifge cloak 0 ife rage 0 
	  {
		set temp cloakmax
		div temp 40
		ifl temp 4 set temp 4
		add cloak temp
	  }
	  
	  // ife pchar 3 
	  ifvarand startmode 8 ifvarand inven_upgrades 4
	  ife player[].holoduke_on -1
	  {
		getp[].holoduke_amount temp
		add temp 48
		//ifg temp HOLODUKE_AMOUNT set temp HOLODUKE_AMOUNT
		ifg temp 4800 set temp 4800
		setp[].holoduke_amount temp
	  }
	  set safecount monxp
	  
	  ife mybounty THISACTOR
	  {
		set bigmsg 1397
		set bigmsgcount 90
		shiftl monxp 1
		set temp monxp
		add credits temp
		add lastcredits temp
		add totalcredits temp
		set gotcoins 90
		// BOUNTY SOUNDS
		screensound MEGAPORT
		globalsound GETCOINS
	  }
	  
	  add safecount 50
	  div safecount 5
	  sqrt safecount safecount
	  
	  ifl safecount 1 set safecount 1
	  
	  ife mybounty THISACTOR
	  {
		shiftl safecount 1
		ife padang 131313 mul safecount 2
		set mybounty -1
	  }
	  
	  ife vrtrip 0
	  {
		set value safecount
		ifn gametype 0 shiftr value 1
		ife marathon 1 { mul value 3 div value 5 }
		state spawnimpcoins
	  }
	  
	  shiftr safecount 3, ife marathon 2 sub safecount 2 else sub safecount 1, clamp safecount 0 5
	  ife gametype DM set safecount 0
	  
	  ife pdown NO
	  {
		set temp healthbuff
		div temp 3
		ifl sprite[player[].i].extra temp
		ifrnd 160
			add safecount 1
		else
		ifrnd 16
	    ifn startguns -1
		ifn marathon 2
	    state startgun_replace
	  }
	  

	  whilevarn safecount 0
	  {
		  randvar angvar 2047
		  seta[].ang angvar
		  randvar z 4096
		  mulvar z -1
		  zshoot z COINPROJ
		  subvar safecount 1
	  }
	ifn attmode NO
	{
		set temp monxp
		ifn gameover YES
		{
			switch SKILL // userdef[].player_skill
			case 0 case 1 div temp 4 add totalxp temp break
			case 2 div temp 2 add totalxp temp break
			case 3 add totalxp monxp break
			case 4 mul temp 3 div temp 2 add totalxp temp break
			case 5 case 6 mul temp 2 add totalxp temp break
			endswitch
		}
		ifn marathon NO 
		{
			ife marathon 2 { mul monxp 2 div monxp 5 } else
			div monxp 2
		}
		ifg monxp 0 ife SHOWPOINTS YES state showpoints
		add playerxp monxp
		ifge playerxp nextplevel
		ifp palive
		ife pdown NO
		{
			ife attmode YES ife VOLUME 5 ife LEVEL 11 
			{
				operateactivators 3 0
				set playerxp 0
				screensound LEVELUP
				screensound LEVELUP
				screensound LEVELUP
				palfrom 50 63 63 63
				addphealth 100
				set bigmsg 1138
				set bigmsgcount 90
				break
			}
			sub playerxp nextplevel
			add plevel 1
			set spriteid player[].i
			setav[spriteid].spawnprotect 90
			ifg plevel 7 { mul nextplevel 6, div nextplevel 5 } else
			{ mul nextplevel 5, div nextplevel 4 }
			
			ifl plevel 10
			{
				set temp 8192
				set tempb plevel
				mul tempb 644
				sub temp tempb
				add nextplevel temp
			}

			screensound LEVELUP
			screensound LEVELUP
			screensound LEVELUP
			palfrom 50 63 63 63
			add pdamage 5
			add healthbuff 10
			addphealth 100
			setp[].max_player_health healthbuff
			ifn bigmsgcount 0 { ife buffermsg 0 set buffermsg 792 } else
			{
				set bigmsg 792
				set bigmsgcount 90
			}
			ife checkpoints NO
			state autosave
		}
	}
	set monxp 0
	
	ifvarand monstflags 1048576 // electric explosion	
	{
		sound RADEXPLOSION
		
		// do not fire if in null space
		set mysector sprite[].sectnum
		updatesector sprite[].x sprite[].y mysector
		ifn mysector -1
		{
			set safecount 0
			whilevarn safecount 64
			{
				geta[].ang angvar
				add angvar 32
				seta[].ang angvar
				add safecount 1
				eshoot SHOCKPROJ
			}
		}
		xorvar monstflags 1048576
		ife pchar 2 ifrnd 32 globalsound WESSHOCKING
	}
	
  }

  set monstatus 2
  ifvarand monstflags 2 xorvar monstflags 2
  ife bluecarrier THISACTOR set bluecarrier -1
  ife redcarrier THISACTOR set redcarrier -1
  ifwasweapon BLOODBULLET
  ifvarand wesupgrades[SHRINKER_WEAPON] 1
  {
	spawn BLOODEXP
	espawn ZOMBIE
	setav[RETURN].team 1
	seta[RETURN].pal 2
	setav[RETURN].FEMKILLCOUNT 1800
	setav[RETURN].mlevel plevel
	setav[RETURN].teamspawned 99999
	seta[RETURN].xrepeat 28
	seta[RETURN].yrepeat 26
	setav[RETURN].monstflags 80 // speedy plus double damage
  }
  ifvarand monstflags 32768
  {
	espawn BMFGIMPACT
	seta[RETURN].pal 10
	setav[RETURN].team team
	geta[RETURN].z zdist
	sub zdist 10240
	seta[RETURN].z zdist
  }
  ifn droptile 0 { espawnvar droptile set droptile 0 }
  
  ife gametype SURVIVAL
  ifn teamspawned -1 ifn teamspawned 99999 ifn actorvar[teamspawned].mtype 0
  {
	sub monleft 1
	ifl monleft 1 
	{
		add wave 1
		globalsound BIGCHEER
		state wavesettings
		// ifg player[].timebeforeexit 0 ife pdown NO { set bluescore 500 set redscore 0 }
		
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			ife actorvar[spriteid].monstatus 2
			ifn actorvar[spriteid].teamspawned -1
			ifn sprite[spriteid].picnum TEAMSPAWNER
			ifg sprite[spriteid].htg_t 0 30 // move count >30
			{
				seta[spriteid].picnum BIGSMOKE // turn body into smoke
				seta[spriteid].xrepeat 0
				seta[spriteid].yrepeat 0
			}
			
			setav[spriteid].teamspawned -1 // safety
			
			ife player[].timebeforeexit 0
			ife sprite[spriteid].picnum TEAMSPAWNER
			ifn actorvar[spriteid].mtype 0
			{
				ifg actorvar[spriteid].countvar 90
					setav[spriteid].countvar 90
				
				setav[spriteid].myspawner -1
			}
			nextspritestat spriteid spriteid
		}
		getp[].player_par curr_tick
		add curr_tick 1
		headspritestat spriteid 980
		whilevarn spriteid -1
		{
			setav[spriteid].redflagval 0
			setav[spriteid].rediteration 99999
			setav[spriteid].redtimer curr_tick
			nextspritestat spriteid spriteid
		}
		
	}
	set teamspawned -1
  }
  // ifvarand monstflags 256
  // {
	// set upscaled NO
	// mul init_xrepeat 2
	// div init_xrepeat 3
	
	// seta[].xrepeat init_xrepeat
	// mul init_yrepeat 2
	// div init_yrepeat 3
	// seta[].yrepeat init_yrepeat
	// state spawnoutline
  // }
  ifactor PIGSUV break // safety
  ifg SPRITELOTAG 9
  {
    state activatechannel
  }
  ifg gametype 0
  {
    set value 1
	
	switch sprite[].picnum
	case ZOMBIE case CRAZYLADY case CRONEN case EGG case EGGYOUNG case LIZTROOP case NEWTROOP 
	case PIGCOP case PIGCOPDIVE case NEWPIG case NEWPIGDIVE
	set value 0 break
	case TANK case COMMANDER case NEWCOMM case NEWBEAST case CYBERBEAST case TERMINATOR case TERMINATORCRAWLING
	case EDFPIG case ARMPIG case PIGSUV case ARMEDF case MEGABRAIN case MECHBRAIN
	case NURGLE case BATBOSS case ARMLIZTROOP
	case CHEERBOT
	add value 1 break
	case EDFTROOP ifspritepal 19 add value 1 break
	case PIGBOSS case BOSS1 case BOSS2 case BOSS3 case BOSS4 case LIZBOSS case CANHEADNOARMS case CYCLOIDMAX ifspritepal 0 add value 9 else add value 3 break
	case LIZELITE case LIZELITECROUCH case MANDOFETT case MANDOCROUCH add value 2 break
	case DOLLBOMB set value 0 break
	endswitch
	ife gametype DM state deathmatchscore
	else ifn gametime -1
	{
		ife team 0 add bluescore value
		ife team 1 add redscore value
		
		ifn gametype SURVIVAL
		{
			ifge bluescore scorelimit ifg bluescore redscore { setp[].timebeforeexit 180 set endgametime gametime set gametime -1 }
			ifge redscore scorelimit ifg redscore bluescore { setp[].timebeforeexit 180 set endgametime gametime set gametime -1 }
			
			ife gametime 0
			ifn redscore bluescore
			{
				setp[].timebeforeexit 180 set endgametime gametime set gametime -1
			}
		}
	}
	
  }

ends

defstate freezeme

	ifn shrunken 0 break
	set burning 0
	
	espawn ICESPRITE
	setav[RETURN].myspawner THISACTOR
	setav[RETURN].mtype sprite[].picnum
	setav[RETURN].padang padang
	
	ife padang 131313 // carbonite freezing
	ifn sprite[].picnum APLAYER
	{
		seta[].mdflags 16
		ifactorsound THISACTOR NEWFREEZE stopactorsound THISACTOR NEWFREEZE
		sound CARBONFREEZE
		ife team 0 addkills 1
		
		state enemy_death
		changespritestat THISACTOR STATUESTAT
		set jumpadxvel 125 // temporary HP for statue form
		set padmove 0
		seta[].alpha 0
		cstat 257
	}
	espawn BIGSMOKE
	// seta[RETURN].pal 1
	seta[RETURN].xrepeat 96
	seta[RETURN].yrepeat 96
	geta[RETURN].z z
	sub z 4096
	seta[RETURN].z z
	
	ifg spawnprotect 0 { ifspritepal 33 getlastpal set spawnprotect 0 }

ends


defstate playerpainsounds // dukepainsounds

	set temp player[].max_player_health
	div temp 2
	ifg temp 80 set temp 80
	
	ifl sprite[].extra temp
	// ifphealthl YELLHURTSOUNDSTRENGTHMP
	{
	  // DEANOTE2#
	  ife pchar 4
	  {
		ifsound DEA_PAIN1 break
		ifsound DEA_PAIN2 break
		ifsound DEA_PAIN3 break
		ifsound DEA_PAIN4 break
		rand temp 3
		ife temp 0 screensound DEA_PAIN1 else
		ife temp 1 screensound DEA_PAIN2 else
		ife temp 2 screensound DEA_PAIN3 else
		ife temp 3 screensound DEA_PAIN4
	  }
	  else
	  ife pchar 1
	  {
		ifactorsound THISACTOR SHELLYPAIN2 break
		ifactorsound THISACTOR SHELLYPAIN3 break
		ifrnd 128 
		{
			ifrnd 128 sound SHELLYPAIN2 else
			sound SHELLYPAIN3
		}
		else
		{
			ifrnd 128 sound SHELLYDIE2
			else sound B_DIE
		}
	  }
	  else ife pchar 2
	  {
		ifrnd 84
			sound WESPAIN5
		else ifrnd 128
			sound WESPAIN4
		else sound WESDEATH2
	  }
	  else ife pchar 3
	  {
		ifrnd 84
			sound M_LONGPAIN1
		else ifrnd 128
			sound M_LONGPAIN2
		else sound M_LONGPAIN3
	  }
	  else
	  {
		  ifrnd 64
			sound DUKE_LONGTERM_PAIN2
		  else
			ifrnd 64
			  sound DUKE_LONGTERM_PAIN3
		  else
			ifrnd 64
			  sound DUKE_LONGTERM_PAIN4
		  else
			sound DUKE_DEAD
	  }
	}
	else
	{
	  ife pchar 4
	  {
		ifsound DEA_PAIN1 break
		ifsound DEA_PAIN2 break
		ifsound DEA_PAIN3 break
		ifsound DEA_PAIN4 break
		rand temp 3
		ife temp 0 screensound DEA_PAIN1 else
		ife temp 1 screensound DEA_PAIN2 else
		ife temp 2 screensound DEA_PAIN3 else
		ife temp 3 screensound DEA_PAIN4
	  }
	  else
	  ife pchar 1
	  {
		ifactorsound THISACTOR SHELLYPAIN1 break
		ifactorsound THISACTOR SHELLYPAIN4 break
		ifrnd 128 
		{
			ifrnd 128 sound B_OW 
			else sound SHELLYPAIN5
		}
		else
		{
			ifrnd 128 sound SHELLYPAIN1 else
			sound SHELLYPAIN4
		}
	  }
	  else ife pchar 2
	  {
		ifrnd 84
			sound WESPAIN1
		else ifrnd 128
			sound WESPAIN2
		else sound WESPAIN3
	  }
	  else ife pchar 3
	  {
		
		ifrnd 64
			sound MANDO_PAIN1
		  else ifrnd 64
			sound MANDO_PAIN2
		  else ifrnd 64
			sound MANDO_PAIN3
		  else
			sound MANDO_PAIN4
	  }
	  else
	  {
		  ifrnd 64
			sound DUKE_LONGTERM_PAIN5
		  else ifrnd 64
			sound DUKE_LONGTERM_PAIN6
		  else ifrnd 64
			sound DUKE_LONGTERM_PAIN7
		  else
			sound DUKE_LONGTERM_PAIN8
	  }
	}
ends

defstate stopgrunting

	stopsound DUKE_GRUNT
	stopsound B_SEARCH
	stopsound B_GRUNT2
	stopsound M_LIFTING
	stopsound M_HARDLAND1
	stopsound M_WHEREISIT
	stopsound DEA_WHEREISIT
	stopsound DEA_EFFORT1
	stopsound DEA_FALL1
	stopsound DEA_HMMM

ends

defstate holotaunts

	ifsound HOLOTAUNT1 break
	ifsound HOLOTAUNT2 break
	ifsound HOLOTAUNT3 break
	ifsound HOLOTAUNT4 break
	ifsound HOLOTAUNT5 break
	rand temp 4
	ife temp 0 sound HOLOTAUNT1 else
	ife temp 1 sound HOLOTAUNT2 else
	ife temp 2 sound HOLOTAUNT3 else
	ife temp 3 sound HOLOTAUNT4 else
	ife temp 4 sound HOLOTAUNT5

ends

defstate recontilt

 // tilt code thanks to Hunter_Rus for initial version
  getactor[].ang angvar
  getincangle temp angvar countvarb
  
  set countvarb angvar
  shiftvarl temp 20
  divvar temp 18768
  ifvarg temp  256 set temp  256 else
  ifvarl temp -256 set temp -256 
  // added this code to make it smoother 
  getactor[].roll mtype
  ifvarvarg temp mtype 
  {
	  addvar mtype 24
	  ifvarvarg mtype temp set mtype temp
  }
  else ifvarvarl temp mtype
  {
	  subvar mtype 24
	  ifvarvarl mtype temp set mtype temp
  }
  setactor[].roll mtype
  
ends

defstate teleportnearplayer

	ifl gametype 1 { set spawnprotect 0 break }
	
	add spawnprotect 1
	{
		resetcount
		resetactioncount
		ife spawnprotect -30 // teleport
		{
			ifspritepal 33 getlastpal
			
			
			set value 0
			set TMP_A -1
			headspritestat spriteid 980
			whilevarn spriteid -1
			{
				ifn spriteid mynavsprite
				ifg actorvar[spriteid].blueflagval value
				{
					set value actorvar[spriteid].blueflagval
					set TMP_A spriteid
				}
				nextspritestat spriteid spriteid
			}
			ifn TMP_A -1
			{
				setsprite THISACTOR sprite[TMP_A].x sprite[TMP_A].y sprite[TMP_A].z
				sound BOSSPORT
				ife initsprite 1996
				{
					geta[].z savz
					set z savz
					sub z 32768
					seta[].z z
					espawn SHOCKBALL_EXP
					seta[].z savz
					setav[RETURN].mtype 2
					seta[RETURN].pal 12
					
				}
			}
		}
		else ifg spawnprotect -30 // after teleporting
		{
			ife initsprite 1996
			{
				ife spawnprotect -27
				ifpdistl 4560
				{
					sound LIGHTNING_SLAP
					hitradius 5120 10 20 30 40
					// seta[].htextra -1
					set spriteid player[].i
					geta[spriteid].x x2
					geta[spriteid].y y2
					sub x2 sprite[].x
					sub y2 sprite[].y
					getangle angvar x2 y2
					cos xvel angvar
					sin yvel angvar
				
					shiftvarl xvel 10
					shiftvarl yvel 10
					add xvel player[].posxv
					add yvel player[].posyv
					setplayer[].posxv xvel
					setplayer[].posyv yvel
					
					getp[].posz z
					sub z 1024
					setp[].posz z
					setp[].poszv -3072
				}
				ife spawnprotect 0 { ifspritepal 33 getlastpal } else
				{
					ifspritepal 33 getlastpal else spritepal 33
				}
			}
				
			
		}
		else
		{
			ifspritepal 33 getlastpal else spritepal 33
			ife spawnprotect -44 sound BOSSPORT
			ife spawnprotect -35 ife initsprite 1996
			{
				geta[].z savz
				set z savz
				sub z 32768
				seta[].z z
				espawn SHOCKBALL_EXP
				seta[].z savz
				setav[RETURN].mtype 2
				seta[RETURN].pal 12
			}
		}
	}

ends

defstate spawnprotectcode

	ifvarand monstflags 131072 nullop else
	ifl gametype 1 ifg spawnprotect 0 ifle spawnprotect 40 
	{
		set spawnprotect 0
		ifspritepal 33 getlastpal
	}
	
	ifg spawnprotect 0
	{
		ifactor APLAYER ife pdown YES addphealth 1
		sub spawnprotect 1
		ifspritepal 33 getlastpal else ifg spawnprotect 0 spritepal 33
		seta[].htextra -1	
	}
	ifl spawnprotect 0 state teleportnearplayer

ends

defstate imgooified

	ifl gooify 0 // temporary ally
	{
		add gooify 1
		ife gooify 0
		{
			ife team 1 { set team 0 add maxkills 1 }
			set bluetimer 0
			set bottarget -1
		}
		break
	}

	sub gooify 1
	ifle gooify 0 { changespritestat THISACTOR 1 sleeptime 100 }
	else
	{
		set temp gooify
		mul temp 2
		ifge temp sprite[].extra
		{
			ifl sprite[].zvel 0 seta[].zvel 128
			ifg sprite[].xvel 48 seta[].xvel 48
			ifl sprite[].xvel -48 seta[].xvel -48
			set temp player[].player_par
			modvar temp 40
			ife temp 0
			iffloordistl 16
			{
				ifvarand novaupgrades[FREEZE_WEAPON] 1
				{
					findnearactorz BLOODPOOL2 384 4096 spriteid
					ife spriteid -1
					{
						espawn BLOODPOOL2
						seta[RETURN].pal 126
						setav[RETURN].mtype 1
					}
				}
				else
				{
					espawn BLOODPOOL
					seta[RETURN].pal 126
				}
			}
			
			ifge gooify sprite[].extra
			ifl sprite[].htextra sprite[].extra
			{
				changespritestat THISACTOR 2
				sleeptime 32767
			}
		}
	}
ends


defstate imonfire

	ifinwater { set burning 0 break }
	geta[].mdflags temp
	orvar temp 16
	seta[].mdflags temp

	sub burning 1
	ifg burning 2048 set burning 2048
	

	ifonwater iffloordistl 16 ifg burning 1 subvar burning 1
	
	ifvarand initflags 4 nullop else
	ifvarand player[].player_par 1
	{
		ifactor APLAYER
		{
			quote 108
			palfrom 26 63 20 20
			ifg burning 300 set burning 300
			getp[].boot_amount temp
			ifg temp 0
			{
				subvar temp 1
				setp[].boot_amount temp
				// setp[].inven_icon 7
				ife player[].fta 0 quote 75
				subvar burning 3
				ifvarl burning 0 set burning 0
			}
			soundonce FIRE_CRACKLE
			ifrnd 16 state playerpainsounds
			ifphealthl 50 subvar burning 1
		}
		set temp burning
		shiftvarr temp 6
		ifg temp 8 set temp 8
		ifactor APLAYER ifg temp 4 set temp 4
		ifvarl temp 1 set temp 1
		sub burning temp
		ifvarl burning 0 set burning 0
		ifg temp 0
		{
			geta[].htextra tempb
			ife tempb -1 set tempb 0
			add temp tempb
			ifl temp 1 set temp 1
			seta[].htextra temp
			ifn sprite[].htpicnum RPG
			ifn sprite[].htpicnum RADIUSEXPLOSION
			ifn sprite[].htpicnum NOVAPLASBOLT
			ifn sprite[].htpicnum SABERSCORCH3
			seta[].htpicnum BURNING
			// seta[].htowner player[].i
			add temp 1
			ifvarvarl sprite[].extra temp
			{
				geta[].htflags temp
				orvar temp 4
				seta[].htflags temp
				getsector[].floorshade tempb
				add tempb 12 ifg tempb 28 set tempb 28
				seta[].shade tempb
			}
		}
		
	}

	espawn STICKYFIRE
	setav[RETURN].mtype sprite[].picnum
	setav[RETURN].myspawner THISACTOR

	ifg burning 260
	{
		espawn STICKYFIRE
		setav[RETURN].botclip sprite[].picnum
		setav[RETURN].myspawner THISACTOR
		ife sprite[].htpicnum NOVAPLASBOLT seta[RETURN].pal 118
		ife sprite[].htpicnum SABERSCORCH3 seta[RETURN].pal 118
	}
	ifvarn monstatus 0
	{
		ifvarand initflags 4 soundonce FIRE_CRACKLE
		else
		soundonce COOKINGDEEPFRIER
	}
	ifn sprite[].picnum APLAYER
	ifrnd 16
	{
		espawn BIGSMOKE 
		geta[RETURN].z z
		sub z 4096
		seta[RETURN].z z
		seta[RETURN].htpicnum BURNING
	}
	
ends

defstate avoidwater

ife gametype SURVIVAL
iffloordistl 8 ifonwater
ifl navpoint 0
{
	ifn teamspawned -1
		setsprite THISACTOR sprite[teamspawned].x sprite[teamspawned].y sprite[teamspawned].z
	else ife team 1
	{
		setsprite THISACTOR loadx[LEVEL] loady[LEVEL] loadz[LEVEL]
	}
	break
}

// ifg gametype 0 break

ifn team 0
ifg navpoint -1 break
ifactornotstayput nullop else break
// ifonwater break
ifinwater break // too late
ife sector[].floorpicnum PURPLELAVA break

switch sprite[].picnum

case LIZTROOP
case NEWTROOP
case SHARK
case ROTATEGUN
case SIDEGUN
case COMMANDER 
case NEWCOMM
case OCTABRAIN
case MEGABRAIN
case DRONE case EDFDRONE case NEWSENTRY
case BOSS2FLY
case BOSS4
case RECON case NEWRECON
case SCUBATROOP
case NAAMAH case DEVOURER
case MANDOFETT case MANDOCROUCH
case CYBERBALL
case BIGTURRET case SHIPTURRET
break

default
	ifonwater
	{
		geta[].htflags temp
		orvar temp 134217728
		orvar temp 16
		seta[].htflags temp
	}
	// neartag <x> <y> <z> <sect> <ang> <nearTagSector> <nearTagWall> <nearTagSprite> <nearTagHitDist> <nearTagRange> <tagSearch>
	else
	{
		ifvarand monstflags YES set angvar angvel else set angvar sprite[].ang
		ifl sprite[].xvel -16 add angvar 1024
		
		set temp -1
		neartag sprite[].x sprite[].y sprite[].z sprite[].sectnum angvar temp tempb spriteid xydist 512 1
		
		ifn temp -1
		ife sector[temp].lotag 1
		{
		
		/*
		geta[].ang angvar
		ifvarand monstflags YES set angvar angvel
		// ifl sprite[].xvel -16 { add angvar 1024 set x2 -1 } // moving backwards
		
		set x2 sprite[].x
		add x2 512 // 384
		rotatepoint sprite[].x sprite[].y x2 sprite[].y angvar xvel z
		set mysector sprite[].sectnum
		updatesectorz xvel z sprite[].z mysector
		set tempc 0
		ifn mysector -1
		{
			gets[mysector].lotag tempc
			ife sector[mysector].floorpicnum PURPLELAVA set tempc 1
		}
		ife tempc 0
		{
			sub angvar 160
			rotatepoint sprite[].x sprite[].y x2 sprite[].y angvar xvel z
			updatesectorz xvel z sprite[].z mysector
			ifn mysector -1
			{
				gets[mysector].lotag tempc
				ifn sector[].floorpicnum PURPLELAVA
				ife sector[mysector].floorpicnum PURPLELAVA set tempc 1
			}
			ife tempc 0
			{
				add angvar 320
				rotatepoint sprite[].x sprite[].y x2 sprite[].y angvar xvel z
				updatesectorz xvel z sprite[].z mysector
				ifn mysector -1
				{
					gets[mysector].lotag tempc
					ifn sector[].floorpicnum PURPLELAVA
					ife sector[mysector].floorpicnum PURPLELAVA set tempc 1
				}
			}
		}
		
		ife tempc 1 // water sector ahead
		{
		*/
			set tempd NO
			ife team 3 set tempd YES
			ifvarand monstflags YES set tempd YES
			ife tempd YES
			{
				geta[].ang angvar
				add angvar 768
				rand temp 512
				add angvar temp
				seta[].ang angvar
				set dodgetime 10
			}
			else ifg sprite[].xvel 0 iffloordistl 16
			{
				ifrnd 8
				{
					geta[].ang angvar
					add angvar 768
					rand temp 512
					add angvar temp
					seta[].ang angvar
					seta[].xvel 0
					set crumbwait 10
					resetcount
				}
				else
				{
					// ife x2 0 seta[].xvel -128 else seta[].xvel 128
					seta[].xvel -128
				}
			}
			
		}
	}
	
break
endswitch

ends

defstate avoidcliffs

ifn sprite[].htactorstayput -1 break
ifvarand monstflags 1 break
ifn navpoint -1 break

getactor[].x x
getactor[].ang angvar
ifvarl sprite[].xvel -16 addvar angvar 1024 // moving backwards
setvarvar x2 sprite[].x
addvar x2 768

rotatepoint sprite[].x sprite[].y x2 sprite[].y angvar x2 y2
set mysector sprite[].sectnum
updatesector x2 y2 mysector
ifvarn mysector -1
ifvarvarn mysector sprite[].sectnum
{
	getflorzofslope mysector x2 y2 temp
	getflorzofslope sprite[].sectnum sprite[].x sprite[].y tempb
	subvarvar temp tempb
	ifvarand sector[mysector].floorstat 1 set temp 100000
	ifvarg temp 65536 // 20480
	{
		addvar angvar 768
		randvar temp 512
		addvarvar angvar temp
		ifvarl sprite[].xvel -16 // moving backwards
		{
			getactor[].xvel xvel
			mulvar xvel -1
			setactor[].xvel xvel
		}
		
		setactor[].ang angvar
	}
}

ends

defstate setfarang

	setarray tmpar1[0] 3072
	setarray tmpar1[1] 3072
	setarray tmpar1[2] 3072
	setarray tmpar1[3] 3072

	rand angle2 2047
	set xydist 3072
	set bossang -6666
	set B 0
	set K -1
	whilevarn B 16
	{
		add B 1
		geta[].z z
		sub z 2048
		add angle2 128
		cos mycos angle2
		sin mysin angle2
		hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 hitsector hitwall hitsprite hitx hity hitz clipmask
		
		set newx sprite[].x
		sub newx hitx
		mul newx newx
		set y2 sprite[].y
		sub y2 hity
		mul y2 y2
		add newx y2
		sqrt newx newx
		
		ifg newx tmpar1[0] { ife K -1 set K 0 setarray tmpar1[0] newx setarray tmpar2[0] angle2 } else
		ifg newx tmpar1[1] { ife K 0 set K 1 setarray tmpar1[1] newx setarray tmpar2[1] angle2 } else
		ifg newx tmpar1[2] { ife K 1 set K 2 setarray tmpar1[2] newx setarray tmpar2[2] angle2 } else
		ifg newx tmpar1[3] { ife K 2 set K 3 setarray tmpar1[3] newx setarray tmpar2[3] angle2 }
		
		ifg newx xydist { set xydist newx set bossang angle2 }
		
	}
	ifn bossang -6666 
	{
		rand temp K
		seta[].ang tmpar2[temp]
		// seta[].ang bossang 
		set crumbwait 15 
	}
ends

defstate crumbcode

	ifn sprite[].htactorstayput -1 break
	ifg navpoint -1 break
	ifg crumbwait 0 { sub crumbwait 1 break }
	ifvarand monstflags YES nullop else
	ifn bottarget -1 break
	
	ifvarand monstflags 262144
	ife team 0
	{
		ifpdistl 16384 
		{
			state setfarang
			break
		}
	}
	sleeptime 100

	ife seeplayer YES ifawayfromwall set xydist2 4096
	else set xydist2 2048

	set B -1 // reset crumb and search from scratch
	// linked list of sprites already in order from most recent to oldest
	headspritestat spriteid 999
	whilevarn spriteid -1
	{
		ldist xydist THISACTOR spriteid
		ifg xydist 384 ifl xydist xydist2
		ifge actorvar[spriteid].mtype lastcrumb
		{
			canseespr THISACTOR spriteid temp
			ife temp YES
			{ set B spriteid getav[B].mtype lastcrumb }
		}
		
		nextspritestat spriteid spriteid
		ifn B -1 set spriteid -1
	}

	ife B -1 // longer distance check
	{
		mul xydist2 2
		headspritestat spriteid 999
		whilevarn spriteid -1
		{
			ldist xydist THISACTOR spriteid
			ifg xydist 384 ifl xydist xydist2 
			ifge actorvar[spriteid].mtype lastcrumb
			{
				canseespr THISACTOR spriteid temp
				ife temp YES
				{ set B spriteid getav[B].mtype lastcrumb }
			}
			nextspritestat spriteid spriteid
			ifn B -1 set spriteid -1
		}
	}

	ifn B -1 // face crumb
	{
		// ifn bottarget -1
		// ife seemytarget YES
			// break
		
		ifactor GUARD ifmove GUARDWALKVEL
		move GUARDFOLLOWVEL geth
		geta[B].x x
		geta[B].y y
		sub x sprite[].x
		sub y sprite[].y
		getangle angvar x y
		ifvarand monstflags YES set angvel angvar else
		seta[].ang angvar
		ifactor EDFDRONE ifl sprite[B].z sprite[].z
			movesprite THISACTOR 0 0 -2048 CLIPMASK0 RETURN
		ifactor NEWSENTRY ifl sprite[B].z sprite[].z
			movesprite THISACTOR 0 0 -2048 CLIPMASK0 RETURN
		ifnotmoving
		{
			set crumbwait 20
			geta[].z z
			geta[B].z temp
			sub z temp
			ifg z 10240
			ifg sprite[].zvel -1
			{
				set crumbwait 22 // jump trigger
				ifactor LIZMAN ifrnd 160 break
				ifactor NEWBEAST ifrnd 160 break
				ifactor LIZTROOP ifrnd 160 break
			}
			
			sub angvar 384
			rand temp 768
			add angvar temp
			ifvarand monstflags YES set angvel angvar
			else
			seta[].ang angvar
		}
	}

ends

defstate getcrumb

	// set angvel to angle facing nearest crumb
	// ife seeplayer YES ifawayfromwall set xydist2 4096
	// else 
	set xydist2 2048

	set B -1 // reset crumb and search from scratch
	// linked list of sprites already in order from most recent to oldest
	headspritestat spriteid 999
	whilevarn spriteid -1
	{
		ldist xydist THISACTOR spriteid
		ifg xydist 256 ifl xydist xydist2
		ifge actorvar[spriteid].mtype lastcrumb
		{
			canseespr THISACTOR spriteid temp
			ife temp YES
			{ set B spriteid getav[B].mtype lastcrumb }
		}
		
		nextspritestat spriteid spriteid
		ifn B -1 set spriteid -1
	}

	ife B -1 // longer distance check
	{
		mul xydist2 2
		headspritestat spriteid 999
		whilevarn spriteid -1
		{
			ldist xydist THISACTOR spriteid
			ifg xydist 256 ifl xydist xydist2 
			ifge actorvar[spriteid].mtype lastcrumb
			{
				canseespr THISACTOR spriteid temp
				ife temp YES
				{ set B spriteid getav[B].mtype lastcrumb }
			}
			nextspritestat spriteid spriteid
			ifn B -1 set spriteid -1
		}
	}
	
	ife B -1 // longer distance check
	{
		mul xydist2 2
		headspritestat spriteid 999
		whilevarn spriteid -1
		{
			ldist xydist THISACTOR spriteid
			ifg xydist 256 ifl xydist xydist2 
			ifge actorvar[spriteid].mtype lastcrumb
			{
				canseespr THISACTOR spriteid temp
				ife temp YES
				{ set B spriteid getav[B].mtype lastcrumb }
			}
			nextspritestat spriteid spriteid
			ifn B -1 set spriteid -1
		}
	}
	
	ife B -1
	ife seeplayer YES
	getp[].i B

	ifn B -1 // face crumb
	{
		geta[B].x x
		geta[B].y y
		sub x sprite[].x
		sub y sprite[].y
		getangle angvel x y
	}
ends

defstate moveatangvar

	ifvarand monstflags YES nullop else
	ife sprite[].xvel 0 break

	cos xvel angvar
	sin yvel angvar
	shiftr xvel 8
	shiftr yvel 8
	ife team 3 { shiftr xvel 1 shiftr yvel 1 }
	movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN

ends


defstate strafecheck
	
	ifvarand monstflags YES set angvar angvel else
	geta[].ang angvar
	sub angvar 480
	geta[].z z
	sub z 6144 // 8192
	cos mycos angvar
	sin mysin angvar
	hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 hitsector hitwall hitsprite hitx hity hitz 16777281
	
	set xydist sprite[].x
	sub xydist hitx
	mul xydist xydist
	set y2 sprite[].y
	sub y2 hity
	mul y2 y2
	add xydist y2
	sqrt xydist xydist
	
	ifn hitsprite -1 ifl xydist 384
	ifn actorvar[hitsprite].monstatus 0
	break
	
	add angvar 960
	cos mycos angvar
	sin mysin angvar
	hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 hitsector hitwall hitsprite hitx hity hitz 16777281
	set xydist2 sprite[].x
	sub xydist2 hitx
	mul xydist2 xydist
	set y2 sprite[].y
	sub y2 hity
	mul y2 y2
	add xydist2 y2
	sqrt xydist2 xydist2
	
	ifl xydist2 xydist ifl xydist2 384
	{
		ifvarand monstflags YES set angvar angvel else
		set angvar sprite[].ang
		sub angvar 512
		state moveatangvar
	}
	else
	{
		ifle xydist xydist2 ifl xydist 384
		{
			ifvarand monstflags YES set angvar angvel else
			set angvar sprite[].ang
			add angvar 512
			state moveatangvar
		}
	}

ends

defstate strafechecklong
	
	ifvarand monstflags YES set angvar angvel else
	geta[].ang angvar
	sub angvar 256
	geta[].z z
	sub z 6144 // 8192
	cos mycos angvar
	sin mysin angvar
	hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 hitsector hitwall hitsprite hitx hity hitz 16777281
	
	set xydist sprite[].x
	sub xydist hitx
	mul xydist xydist
	set y2 sprite[].y
	sub y2 hity
	mul y2 y2
	add xydist y2
	sqrt xydist xydist
	
	add angvar 512
	cos mycos angvar
	sin mysin angvar
	hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 hitsector hitwall hitsprite hitx hity hitz 16777281
	set xydist2 sprite[].x
	sub xydist2 hitx
	mul xydist2 xydist
	set y2 sprite[].y
	sub y2 hity
	mul y2 y2
	add xydist2 y2
	sqrt xydist2 xydist2
	
	ifl xydist2 xydist ifl xydist2 1024
	{
		ifvarand monstflags YES set angvar angvel else
		set angvar sprite[].ang
		sub angvar 512
		state moveatangvar
	}
	else
	{
		ifle xydist xydist2 ifl xydist 1024
		{
			ifvarand monstflags YES set angvar angvel else
			set angvar sprite[].ang
			add angvar 512
			state moveatangvar
		}
	}

ends


defstate stayincontrol
// the current node being checked has been validated
// invalidate the node if it leads to leaving the control sector prematurely
ife temp YES 
{
	ifg actorvar[spriteid].SPRITELOTAG 999
	{
		ife sprite[].sectnum sprite[A_ID].sectnum
		{
			ifn redbasestat LOCKDOWN ifn redbasestat REDLOCKDOWN set temp NO
		}
		else
		ife sprite[].sectnum sprite[B_ID].sectnum
		{
			ifn bluebasestat LOCKDOWN ifn bluebasestat REDLOCKDOWN set temp NO
		}
		else
		ife sprite[].sectnum sprite[C_ID].sectnum
		{
			ifn thirdbasestat LOCKDOWN ifn thirdbasestat REDLOCKDOWN set temp NO
		}
	}
}

ends

defstate valuetranslate
	
	ife gametype CONTROL // control
	{
		// redbasestat used for CONTROL_A
		// bluebasestat used for CONTROL_B
		// thirdbasestat used for CONTROL_C
		// negative numbers mean red influence, le REDLOCKDOWN means red lockdown
		// positive numbers mean blue influence, LOCKDOWN means blue lockdown
		ife team 1
		{
			ifl redbasestat LOCKDOWN getav[spriteid].redbaseval value
			ifl bluebasestat LOCKDOWN ifg actorvar[spriteid].bluebaseval value getav[spriteid].bluebaseval value
			ifl thirdbasestat LOCKDOWN ifg actorvar[spriteid].thirdbaseval value getav[spriteid].thirdbaseval value
		}
		else
		ife team 0
		{
			ifg redbasestat REDLOCKDOWN getav[spriteid].redbaseval value
			ifg bluebasestat REDLOCKDOWN ifg actorvar[spriteid].bluebaseval value getav[spriteid].bluebaseval value
			ifg thirdbasestat REDLOCKDOWN ifg actorvar[spriteid].thirdbaseval value getav[spriteid].thirdbaseval value
		}
		
	}
	else
	ife gametype DM
	{
		ife team 1 
		{

			ifg actorvar[spriteid].redflagval value
				set value actorvar[spriteid].redflagval
			
			ifg actorvar[spriteid].redbaseval value
				set value actorvar[spriteid].redbaseval
		}
		else
		ife team 0 
		{	

			ifg actorvar[spriteid].blueflagval value
				set value actorvar[spriteid].blueflagval
			
			ifg actorvar[spriteid].bluebaseval value
				set value actorvar[spriteid].bluebaseval
		}
	}
	else
	ife gametype -1 // tour guide
	{
		ifg tourgoal 7
		{
			ifg actorvar[spriteid].redflagval value
				set value actorvar[spriteid].redflagval
				
			ifactor GUIDEDRONE break
			
			ifg actorvar[spriteid].redbaseval value
				set value actorvar[spriteid].redbaseval
		}
		else
		ifcansee ifpdistl 8192
		{
			ifg actorvar[spriteid].redflagval value
				set value actorvar[spriteid].redflagval
			
			ifg actorvar[spriteid].redbaseval value
				set value actorvar[spriteid].redbaseval
		}
		else
		{
			set initflags YES // flag for player-following
			ifg actorvar[spriteid].blueflagval value
				set value actorvar[spriteid].blueflagval
			
			ifg actorvar[spriteid].bluebaseval value
				set value actorvar[spriteid].bluebaseval
		}
	}
	else
	ife gametype SURVIVAL
	{
		ife team 1 
		{
			ifg actorvar[spriteid].redflagval value
				set value actorvar[spriteid].redflagval
			
			ifg actorvar[spriteid].redbaseval value
				set value actorvar[spriteid].redbaseval
				
			ife pdown YES // ife myshelly THISACTOR
			{
				set value 0
				ifn spriteid mynavsprite
				ifg actorvar[spriteid].blueflagval value
				set value actorvar[spriteid].blueflagval
			
				ifg actorvar[spriteid].bluebaseval value
					set value actorvar[spriteid].bluebaseval
			}
			else ifle value 0
			{
				ifg actorvar[spriteid].blueflagval value
				set value actorvar[spriteid].blueflagval
			}
		}
		else
		ife team 0 
		{

			ifg actorvar[spriteid].blueflagval value
				set value actorvar[spriteid].blueflagval
			
			ifg actorvar[spriteid].bluebaseval value
				set value actorvar[spriteid].bluebaseval
		}
		else
		ife team 3 
		{
			ifg actorvar[spriteid].redflagval value
				set value actorvar[spriteid].redflagval
		}
	}
	else // CTF
	{
		
		ife team 1
		{
			ife redcarrier THISACTOR
			{
				getav[spriteid].bluebaseval value
				ife bluecarrier -1
				ifg actorvar[spriteid].blueflagval value
				set value actorvar[spriteid].blueflagval
			}
			else
			{
				getav[spriteid].blueflagval value
		
				ife redcarrier -1
				{
					ifg actorvar[spriteid].redflagval value
						set value actorvar[spriteid].redflagval
					else
					ifg actorvar[spriteid].redbaseval value
						set value actorvar[spriteid].redbaseval
				}
				else ife value 0
				{
					ifg actorvar[spriteid].redbaseval value
						set value actorvar[spriteid].redbaseval
				}
					
				ifvarand monstflags YES ife bluecarrier -1
				ifg actorvar[spriteid].blueflagval 1000
					getav[spriteid].blueflagval value
			}
		}
		else
		ife team 0 
		{
			ife bluecarrier THISACTOR
			{
				getav[spriteid].redbaseval value
				ife redcarrier -1
				ifg actorvar[spriteid].redflagval value
				set value actorvar[spriteid].redflagval
			}
			else
			{
				getav[spriteid].redflagval value
				
				ife bluecarrier -1
				{
					ifg actorvar[spriteid].blueflagval value
						set value actorvar[spriteid].blueflagval
					else
					ifg actorvar[spriteid].bluebaseval value
						set value actorvar[spriteid].bluebaseval
				}
				else ife value 0
				{
					ifg actorvar[spriteid].bluebaseval value
						set value actorvar[spriteid].bluebaseval
				}
					
				ifvarand monstflags YES ife redcarrier -1
				ifg actorvar[spriteid].redflagval 1000
					getav[spriteid].redflagval value
			}
		}
	}
	
	
	
	ifg actorvar[spriteid].SPRITELOTAG 999
	ifn sprite[spriteid].pal 0
	ifg actorvar[spriteid].initflags 0
	{
		// adjust value
		headspritestat TMP_A 980
		whilevarn TMP_A -1
		{
			ife actorvar[spriteid].initflags actorvar[TMP_A].initflags
			ifn TMP_A spriteid
			{
				ife value actorvar[spriteid].bluebaseval getav[TMP_A].bluebaseval TMP_B else
				ife value actorvar[spriteid].redbaseval getav[TMP_A].redbaseval TMP_B else
				ife value actorvar[spriteid].thirdbaseval getav[TMP_A].thirdbaseval TMP_B else
				ife value actorvar[spriteid].blueflagval getav[TMP_A].blueflagval TMP_B else
				getav[TMP_A].redflagval TMP_B
				add value TMP_B
				div value 2
				set TMP_A -1
			}
			ifn TMP_A -1
			nextspritestat TMP_A TMP_A
		}
	}
ends

defstate navforcedpath
	
	set B NO
	headspritestat spriteid 980
	whilevarn spriteid -1
	{
		ldist xydist THISACTOR spriteid
		ifl xydist MAXNAVDIST
		ifn spriteid navpoint
		{
			set temp YES
			getav[spriteid].SPRITELOTAG tempb
			sub tempb actorvar[navpoint].SPRITELOTAG
			
			ifn tempb direction set temp NO
			
			ife temp YES
			{
				// geta[].z z
				// subvar z 6144
				// seta[].z z
				// canseespr THISACTOR spriteid temp
				// add z 6144 // 8192
				// seta[].z z
				// ifn padmove 0 set temp YES
				
				set temp YES // we are going to force accessibility as an experiment
				ife temp YES // found it!!
				{
					set B YES
					ifvarand monstflags YES
					{
						geta[spriteid].x x2
						geta[spriteid].y y2
						sub x2 sprite[].x
						sub y2 sprite[].y
						getangle angvel x2 y2
					}
					else
					state facesprite
					set value 0
					state valuetranslate
					set savedvalue value

					set navpoint spriteid
					// note DO NOT change direction here!!
					set spriteid -1
				}
				
			}
		}
		ifn spriteid -1
		nextspritestat spriteid spriteid
	}
	ife B NO
	ifg navpoint 0
	{
		// add navpoint 16384
		// mul navpoint -1
		set navpoint -1
		set direction 0
	}

ends

defstate tanknavcode

ifg navpoint -1
{
	set spriteid navpoint
	
	geta[navpoint].x x2
	geta[navpoint].y y2
	sub x2 sprite[].x
	sub y2 sprite[].y
	getangle tempb x2 y2
	
	getincangle temp sprite[].ang tempb
	
	ifn sprite[].ang tempb
	{
		set B MAXTANKTURN
		mul B -1
		ifg temp B ifl temp MAXTANKTURN
			seta[].ang tempb
		else
		{
			geta[].ang angvar
			ifl temp 0 sub angvar MAXTANKTURN
			else add angvar MAXTANKTURN
			seta[].ang angvar
		}
	}
	
	ldist xydist THISACTOR navpoint
	ifl xydist 384
	{
		ifg actorvar[navpoint].SPRITELOTAG 999
		{
			state navforcedpath
			break
		}
		// find new point, but only
		set tempd 0 // current element in tmpar1
		set tempc 0 // current element in tmpar2
		headspritestat spriteid 980
		whilevarn spriteid -1
		{
			ifn spriteid navpoint
			ifn spriteid mynavsprite
			{
				geta[].z z
				subvar z 6144 // 8192
				geta[spriteid].z z2
				sub z2 z
				abs z2
				
				set temp YES
				ifn actorvar[navpoint].SPRITELOTAG 0
				{
					ifn actorvar[navpoint].SPRITELOTAG actorvar[spriteid].initflags
					set temp NO
					
					ifg actorvar[spriteid].SPRITELOTAG 999
					{
						ife sprite[spriteid].pal 0 set temp NO
						ifl navpoint 0
						ifn sprite[spriteid].sectnum sprite[].sectnum
							set temp NO
					}
				}

				ife temp YES // if lotag nonzero must match next node's hitag
				ifl z2 MAXHEIGHTDIFF // no big height difference allowed
				{

					geta[].z z
					subvar z 6144 // 8192
					seta[].z z
					canseespr THISACTOR spriteid temp
					add z 6144 // 8192
					seta[].z z
			
					ifg navpoint -1
					ifg actorvar[navpoint].initsprite -1
					ife actorvar[navpoint].initsprite actorvar[spriteid].initsprite
						set temp YES
					
					ife temp YES
					{
						geta[spriteid].x x2
						geta[spriteid].y y2
						sub x2 sprite[].x
						sub y2 sprite[].y
						getangle B x2 y2
						
						getincangle tempb sprite[].ang B
						abs tempb
						ifn bottarget -1 set tempb 0
						ifl tempb 640
						{
							dist xydist THISACTOR spriteid
							
							ife sprite[spriteid].pal 8 set TMP_A HALFNAVDIST else set TMP_A MAXNAVDIST		
							
							ifl xydist TMP_A
							{
								setarray tmpar1[tempd] spriteid
								add tempd 1
							}
							else ifl xydist 16384 // long distance points
							{
								setarray tmpar2[tempc] spriteid
								add tempc 1
							}
						}
					}
				
				}
			}
			nextspritestat spriteid spriteid
			ife tempd MAXELEMENTS set spriteid -1
			ife tempc MAXELEMENTS set spriteid -1
		}
		// choose randomly from tmpar1
		// or choose closest to target
		
		ifg tempd 0
		{
			sub tempd 1
			ife tempd 0 set navpoint tmpar1[tempd]
			else
			{
				ifn bottarget -1
				{
					set tempG 99999
					whilevarn tempd -1
					{
						dist tempH tmpar1[tempd] bottarget
						ifl tempH tempG
						{
							set tempG tempH
							set navpoint tmpar1[tempd]
						}
						sub tempd 1
					}
				}
				else
				{
					randvarvar temp tempd
					set navpoint tmpar1[temp]
				}
			}
		}
		else ifg tempc 0
		{
			sub tempc 1
			ife tempc 0 set navpoint tmpar2[tempc]
			else
			{
				ifn bottarget -1
				{
					set tempG 99999
					whilevarn tempc -1
					{
						dist tempH tmpar2[tempc] bottarget
						ifl tempH tempG
						{
							set tempG tempH
							set navpoint tmpar2[tempc]
						}
						sub tempc 1
					}
				}
				else
				{
					randvarvar temp tempc
					set navpoint tmpar2[temp]
				}
			}
		}
		else
		{
			add navpoint 16384
			mul navpoint -1
		}
	}
	
}
ends

defstate defaultwandercode
	
	ifg navpoint -1
	{
		set spriteid navpoint
		ifvarand monstflags YES
		{
			geta[spriteid].x x2
			geta[spriteid].y y2
			sub x2 sprite[].x
			sub y2 sprite[].y
			getangle angvel x2 y2
		}
		else
		ifn sprite[].xvel 0
		state facesprite
		
		ldist xydist THISACTOR navpoint
		ifl xydist 384
		{
			ifg actorvar[navpoint].SPRITELOTAG 999
			{
				state navforcedpath
				break
			}
			// find new point, but only in front
			set tempd 0 // current element in tmpar1
			set tempc 0 // current element in tmpar2
			headspritestat spriteid 980
			whilevarn spriteid -1
			{
				ifn spriteid navpoint
				ifn spriteid mynavsprite
				{
					geta[].z z
					subvar z 6144 // 8192
					geta[spriteid].z z2
					sub z2 z
					abs z2
					
					set temp YES
					ifn actorvar[navpoint].SPRITELOTAG 0
					{
						ifn actorvar[navpoint].SPRITELOTAG actorvar[spriteid].initflags
						set temp NO
						
						ifg actorvar[spriteid].SPRITELOTAG 999
						{
							ife sprite[spriteid].pal 0 set temp NO
							ifl navpoint 0
							ifn sprite[spriteid].sectnum sprite[].sectnum
								set temp NO
						}
					}
					// hack to prevent actors from leaving control sector prematurely via forced path
					ife gametype CONTROL // control
					state stayincontrol
					
					ifactor DUMCIV ife actorvar[spriteid].mtype 6 set temp NO
					
					ife temp YES // if lotag nonzero must match next node's hitag
					ifl z2 MAXHEIGHTDIFF // no big height difference allowed
					{
						geta[].z z
						subvar z 6144 // 8192
						seta[].z z
						canseespr THISACTOR spriteid temp
						add z 6144 // 8192
						seta[].z z
						
						ifg navpoint -1
						ifg actorvar[navpoint].initsprite -1
						ife actorvar[navpoint].initsprite actorvar[spriteid].initsprite
							set temp YES
						
						ife temp YES
						{
							geta[spriteid].x x2
							geta[spriteid].y y2
							sub x2 sprite[].x
							sub y2 sprite[].y
							getangle B x2 y2
							
							ifvarand monstflags YES getincangle tempb angvel B else
							getincangle tempb sprite[].ang B
							abs tempb
							ifl tempb 640
							{
								dist xydist THISACTOR spriteid
								
								ife sprite[spriteid].pal 8 set TMP_A HALFNAVDIST else set TMP_A MAXNAVDIST		
								
								ifl xydist TMP_A // 6144
								{
									setarray tmpar1[tempd] spriteid
									add tempd 1
								}
								else ifl xydist 16384 // long distance points
								{
									setarray tmpar2[tempc] spriteid
									add tempc 1
								}
							}
						}
					
					}
				}
				nextspritestat spriteid spriteid
				ife tempd MAXELEMENTS set spriteid -1
				ife tempc MAXELEMENTS set spriteid -1
			}
			// choose randomly from tmpar1
			
			ifg tempd 0
			{
				sub tempd 1
				ife tempd 0 set navpoint tmpar1[tempd]
				else
				{
					randvarvar temp tempd
					set navpoint tmpar1[temp]
				}
			}
			else ifg tempc 0
			{
				sub tempc 1
				ife tempc 0 set navpoint tmpar2[tempc]
				else
				{
					randvarvar temp tempc
					set navpoint tmpar2[temp]
				}
			}
			else 
			{
				add navpoint 16384
				mul navpoint -1
			}
			
			ifg navpoint 0
			{
				set spriteid navpoint
				ifvarand monstflags YES
				{
					geta[spriteid].x x2
					geta[spriteid].y y2
					sub x2 sprite[].x
					sub y2 sprite[].y
					getangle angvel x2 y2
				}
				else
				state facesprite
			}
		}
		else 
		{
			ifvarand monstflags YES nullop else
			{
				geta[].htmovflag temp
				ifn temp 0
				{
					// bumping something
					add temp 16384
					ifl temp 16384 ifg temp -1 // bumping a sprite
					{
						set B NO
						ife actorvar[temp].monstatus 1
						ife actorvar[temp].team team set B YES
						ifn gametype 0 ifvarand sprite[temp].cstat 16 set B YES
						ife gametype CTF ife actorvar[temp].monstatus 0 set B YES
						ife B YES
						{
							set x2 sprite[].x
							add x2 256
							rotatepoint sprite[].x sprite[].y x2 sprite[].y sprite[].ang x y
							setsprite THISACTOR x y sprite[].z
							seta[].htmovflag 0
						}
					}
				}
			}
		}
		
	}
ends

defstate getaflagnode

	set value 0 // should be initialized first
	ifg navpoint 0
		ifg actorvar[navpoint].SPRITELOTAG 999
	{
		state navforcedpath
		break
	}
	set tempd 0
	set B savedvalue
	
	ifl navpoint -1
	{
		set tempe navpoint
		mul tempe -1
		sub tempe 16384
	}
	else set tempe -1
	
	headspritestat spriteid 980
	whilevarn spriteid -1
	{
		set value 0 // should be initialized first
		state valuetranslate
		
		ldist xydist THISACTOR spriteid
		ife sprite[spriteid].pal 8 set TMP_A HALFNAVDIST else set TMP_A MAXNAVDIST
		ifl xydist TMP_A
		ifn spriteid navpoint
		ifn spriteid tempe
		ifg value B
		{
			geta[].z z
			subvar z 6144 // 8192
			geta[spriteid].z z2
			sub z2 z
			abs z2
			
			set temp YES
			
			ifg navpoint -1
			{
				ifn actorvar[navpoint].SPRITELOTAG 0
				{
					ifn actorvar[navpoint].SPRITELOTAG actorvar[spriteid].initflags
					set temp NO
				}
				
				ifg actorvar[spriteid].SPRITELOTAG 999
				ife sprite[spriteid].pal 0 set temp NO
			}
			else
			{
				ifn actorvar[spriteid].SPRITELOTAG 0
				{
					ifn sprite[spriteid].sectnum sprite[].sectnum
					set temp NO
				}
			}
			// hack to prevent actors from leaving control sector prematurely via forced path
			ife gametype CONTROL // control
				state stayincontrol
				
			ifactor COMMANDER set z2 0
			ifactor NEWCOMM set z2 0
			ifactor BOSS2FLY set z2 0
			ifactor OCTABRAIN set z2 0
			
			ife temp YES
			ifl z2 MAXHEIGHTDIFF // no big height difference allowed
			{
				geta[].z z
				subvar z 6144 // 8192
				seta[].z z
				ife navpoint -1 state navspritevischeck
				else canseespr THISACTOR spriteid temp
				
				add z 6144 // 8192
				seta[].z z
				
				ifg navpoint -1
				ifg actorvar[navpoint].initsprite -1
				ife actorvar[navpoint].initsprite actorvar[spriteid].initsprite
					set temp YES
				
				ife temp YES
				{
					setarray tmpar1[tempd] spriteid
					add tempd 1
					ifvarand monstflags YES set tempG YES else set tempG NO
					
					ife navpoint -1 set B value else
					ife tempG NO set B value else
					ifg navpoint -1
					set B value
				}
			
			}
		}
		nextspritestat spriteid spriteid
		ife tempd MAXELEMENTS set spriteid -1
	}
	
	ifg tempd 0
	{
		sub tempd 1
		ife tempd 0 
		{
			set navpoint tmpar1[tempd]
		}
		else
		{
			set tempc NO
			ife savedvalue -1
			ifrnd 128 set tempc YES
			else
			ife gametype -1 set tempc YES else
			ife gametype SURVIVAL set tempc YES
			
			ife tempc YES // take high value
			{
				set value 0 // should be initialized first
				whilevarn tempd -1
				{
					set spriteid tmpar1[tempd]
					state valuetranslate
					ifg value savedvalue { set navpoint spriteid set savedvalue value }
					sub tempd 1
				}
			}
			else
			{
				randvarvar temp tempd
				set navpoint tmpar1[temp]
			}
		}
		ifg actorvar[navpoint].SPRITELOTAG 999
		{
			ife sprite[navpoint].pal 1 set direction 1
			else
			ife sprite[navpoint].pal 2 set direction -1
		}
		
		set spriteid navpoint
		set value 0 // should be initialized first
		state valuetranslate
		set savedvalue value
		
	}
	else 
	{
		set savedvalue -1 // reset value if failed to find new node
		state defaultwandercode
		break
	}
	
	ifg navpoint 0
	{
		set spriteid navpoint
		ifvarand monstflags YES
		{
			geta[spriteid].x x2
			geta[spriteid].y y2
			sub x2 sprite[].x
			sub y2 sprite[].y
			getangle angvel x2 y2
		}
		else
		state facesprite
	}

ends

// write this state only if the CTF code proves to be inadequate
// state hordepursuitcode ends

defstate getanode

	ifg navpoint -1
	{
		// remember statnum 1 means it is not a navsprite
		ife sprite[navpoint].statnum 1
		// ife actorvar[navpoint].SPRITELOTAG 0
		{
			dist xydist THISACTOR navpoint
			ifl xydist 4096 // 1560
			{
				// geta[].z z
				// subvar z 6144
				// seta[].z z
				// canseespr THISACTOR navpoint temp
				// add z 6144
				// seta[].z z
				// ife temp YES
				// {
					geta[].z z
					geta[navpoint].z z2
					sub z z2
					abs z
					ifg z MAXHEIGHTDIFF
						set navpoint -1
				// }
				// else set navpoint -1
			}
			else set navpoint -1
			
		}
		else
		ife sprite[navpoint].statnum 1024 set navpoint -1
	}
	
	ifl navpoint 0
	{
		ifl navpoint -1
		{
			set tempe navpoint
			mul tempe -1
			sub tempe 16384
		}
		else set tempe -1
		
		ife crumbwait 0
		{
			ife navmode 2
			{
				state getaflagnode
				ifg navpoint -1 
				break
			}
			set xydist2 99999
			set target -1
			headspritestat spriteid 980
			whilevarn spriteid -1
			{
				ifn spriteid tempe
				ifn spriteid mynavsprite
				{
					geta[].z z
					subvar z 6144 // 8192
					seta[].z z
					ife navpoint -1 state navspritevischeck
					else canseespr THISACTOR spriteid temp
					add z 6144 // 8192
					seta[].z z
					
					ifactor DUMCIV ife actorvar[spriteid].mtype 6 set temp NO
					
					ifn actorvar[spriteid].SPRITELOTAG 0
					{
						ifg actorvar[spriteid].SPRITELOTAG 999
						{
							ife sprite[spriteid].pal 0
								set temp NO
							ifl navpoint 0
							ifn sprite[spriteid].sectnum sprite[].sectnum
								set temp NO
						}
						else
						ifn sprite[spriteid].sectnum sprite[].sectnum
						set temp NO
					}
					ife gametype CONTROL // control
						state stayincontrol
					ife temp YES
					{
						dist xydist THISACTOR spriteid
						ifl xydist xydist2
						{
							set target spriteid
							set xydist2 xydist
						}
					}
				}
				nextspritestat spriteid spriteid
			}
			ifn target -1 
			{
				set navpoint target
				ifg actorvar[navpoint].SPRITELOTAG 999
				{
					ife sprite[navpoint].pal 1 set direction 1
					else
					ife sprite[navpoint].pal 2 set direction -1
				}
			}
		}
	}

ends

defstate getflagcode

	ifg navpoint -1
	{
		set spriteid navpoint
		ifvarand monstflags YES
		{
			geta[spriteid].x x2
			geta[spriteid].y y2
			sub x2 sprite[].x
			sub y2 sprite[].y
			getangle angvel x2 y2
		}
		else
		state facesprite
		ldist xydist THISACTOR navpoint
		ife sprite[navpoint].picnum NAVSPRITE
		{
			ifvarand monstflags YES set tempG YES else set tempG NO
			ifl xydist 384
				state getaflagnode
			else
			ife tempG NO
			{
				geta[].htmovflag temp
				ifn temp 0
				{
					// bumping something
					add temp 16384
					ifl temp 16384 ifg temp -1 // bumping a sprite
					{
						set B NO
						ife actorvar[temp].monstatus 1
						ife actorvar[temp].team team set B YES
						ifn gametype 0 ifvarand sprite[temp].cstat 16 set B YES
						ife B YES
						{
							set x2 sprite[].x
							add x2 256
							rotatepoint sprite[].x sprite[].y x2 sprite[].y sprite[].ang x y
							setsprite THISACTOR x y sprite[].z
							seta[].htmovflag 0
						}
					}
				}
			}
		}
		else
		{
			ifl xydist 256
				state getaflagnode
			else
			ifnotmoving ifg xydist 1560
				set navpoint -1
				
		}
	}
ends



defstate navigationsmart

// this version is for actors who can move in one direction while firing in another
	ifg gametype 0
	{
		ife bonus_screen 1 killit
		sleeptime -1
		set navmode 2
		ife gametype CTF ifg sprite[].xvel 40 ifl sprite[].xvel 160 seta[].xvel 160
	}
	else
	ifn bottarget -1
	{
		ife navmode 3 { set navpoint -1 break }
	}
	ifg crumbwait 0 sub crumbwait 1
	ife navmode 0 break

	ifg redtimer 0 sub redtimer 1
	
	ifg navpoint 0
	{
		geta[].z z
		sub z 4096
		cos mycos angvel
		sin mysin angvel
		hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 hitsector hitwall hitsprite hitx hity hitz 16777281
		
		ifn actorvar[navpoint].initsprite -1
		ifn gametype -1
		{
			set x sprite[].x
			sub x hitx
			mul x x
			set y2 sprite[].y
			sub y2 hity
			mul y2 y2
			add x y2
			sqrt x x
			ife redtimer 0
			ifl actorvar[navpoint].initsprite 10
			{
				ifn hitwall -1
				{
					ifl x 1560 
					{
						getw[hitwall].nextsector temp
						ifn temp -1
						{
							operatesectors temp THISACTOR 
							set redtimer 30 
						}
					}
				}
			}
			
			ifn redtimer 30
			ifnotmoving ifrnd 8 operate
		}
		else
		ifnotmoving 
		iffloordistl 8
		{
			geta[].htmovflag temp
			ifn temp 0
			{
				// hit something
				add temp 16384
				ifl temp 16384 ifg temp -1 
				{
					ifn actorvar[temp].monstatus 1
					{
						set navpoint -1
						set crumbwait 8
					}
				}
				else
				{
					ifn navpoint -1
					ifl actorvar[navpoint].SPRITELOTAG 999
					{
						set navpoint -1
						set crumbwait 8
					}
				}
			}
		}
		
		ifn hitsprite -1
		ifg sprite[].xvel 0
		ife actorvar[hitsprite].monstatus 1
		ife actorvar[hitsprite].team team
		{
			getincangle temp sprite[hitsprite].ang angvel
			abs temp
			ifg temp 768
			{
				// ifn navpoint actorvar[hitsprite].navpoint
				// {
					set angvar angvel
					add angvar 512
					state moveatangvar
				// }
			}
		}
		ifg sprite[].xvel 0
			state strafecheck
	}
	
	ife navmode 4 // pursue player but also use navpoints
	{
		ifg gametype 0 set navmode 2
		else
		{
			set savedvalue navpoint
			set navpoint -1
			set B -1
			ife seeplayer YES { ifpdistg 8192 state crumbcode }
			else
			state crumbcode
			
			ife B -1
			{
				set navpoint savedvalue
				state getanode
				state defaultwandercode
			}
			
			
		}
	}
	else
	ife navmode 3 // random wander mode
	{
		state getanode
		state defaultwandercode
		
		ifl gametype 1
		ifl navpoint 0
		ifactornotstayput
		{
			ife seeplayer YES { iffloordistl 32 ifpdistg 8192 state crumbcode }
			else
			state crumbcode
		}
	}
	else
	ife navmode 2 // goal seeking mode
	{
		ife gametype CONTROL // control
		{
			state getanode
			state getflagcode
		}
		else
		ife gametype DM
		{
			state getanode
			state getflagcode
		}
		else
		ife gametype SURVIVAL // horde arena mode
		{
			state getanode
			// state hordepursuitcode
			state getflagcode
			// edge cases of flag code should work for horde mode navigation
		}
		else
		ife gametype CTF // capture the flag
		{
			state getanode
			state getflagcode
		}
		else // default code
		{
			state getanode
			ifn team 0 ife gametype -1 ife botclip 10 state getflagcode
			else
			state defaultwandercode
		}
	}

ends

defstate navigation

	ifg gametype 0
	{
		ife bonus_screen 1 killit
		sleeptime -1
		set navmode 2
	}
		
	ifg crumbwait 0 sub crumbwait 1
	ifle navmode 0 break
	
	ife botclip 10 ife initflags 2 break // hack for arena guide

	// coming into this code, the actor may have a combat target (bottarget)
	// rules of engagement:
	// if your navpoint is your own flag or base, then drop your target
	// if wandering, fight instead
	// if playing CTF:
	// if enemy is in front of you on your path, fight
	// if enemy is not in front of you and has a different target, ignore
	// if enemy is far away ignore

	ifg navpoint -1 ifn sprite[navpoint].picnum NAVSPRITE 
	ife actorvar[navpoint].team team
		set bottarget -1
	
	ifn bottarget -1
	{
		ife navmode 3 { set navpoint -1 break } else
		ife gametype CONTROL { set navpoint -1 break } else
		ife gametype SURVIVAL { set navpoint -1 break } else
		ife gametype DM { set navpoint -1 break } else
		ife navmode 2
		{
			// references to flag carriers in non-CTF are harmless
			ldist xydist THISACTOR bottarget
			ife redcarrier THISACTOR ifg xydist 4096 set bottarget -1 else
			ife bluecarrier THISACTOR ifg xydist 4096 set bottarget -1
			
			ifn bottarget -1
			ifn bottarget redcarrier ifn bottarget bluecarrier
			{
				// is enemy directly in my path?
				geta[bottarget].x x2
				geta[bottarget].y y2

				sub x2 sprite[].x
				sub y2 sprite[].y
				getangle angvar x2 y2
				
				ifg navpoint -1 
				{
					geta[navpoint].x x
					geta[navpoint].y y
					sub x sprite[].x
					sub y sprite[].y
					getangle temp x y
				}
				else set temp sprite[].ang
				
				getincangle tempb angvar temp
				abs tempb			
				set tempe 1048576
				ife xydist 0 set xydist 1
				div tempe xydist
				ifg tempe 512 set tempe 512
				ifg tempb tempe
				{
					// possibly drop target
					ifg xydist 6144 set bottarget -1 else
					ifn actorvar[bottarget].bottarget -1
						ifn actorvar[bottarget].bottarget THISACTOR
							set bottarget -1
				}
			}
		}
	}
	ifn bottarget -1 ifn navmode 1
	break
	
	ifg redtimer 0 sub redtimer 1
	ifg navpoint 0
	ifn navmode 1
	{
		geta[].z z
		sub z 4096
		cos mycos sprite[].ang
		sin mysin sprite[].ang
		hitscan sprite[].x sprite[].y z sprite[].sectnum mycos mysin 0 hitsector hitwall hitsprite hitx hity hitz 16777281
		
		ifn actorvar[navpoint].initsprite -1
		ifn gametype -1
		{
			set x sprite[].x
			sub x hitx
			mul x x
			set y2 sprite[].y
			sub y2 hity
			mul y2 y2
			add x y2
			sqrt x x
			ife redtimer 0
			// ifl actorvar[navpoint].initsprite 10
			ifn actorvar[navpoint].initsprite 20
			{		
				ifn hitwall -1
				{
					ifl x 1560 
					{
						getw[hitwall].nextsector temp
						ifn temp -1
						{
							operatesectors temp THISACTOR 
							set redtimer 30 
						}
					}
				}
			}
			ifn redtimer 30
			{
			ifnotmoving 
			{ 
				ifrnd 16 operate 
				ifrnd 4 { set navpoint -1 set crumbwait 8 } 
			}
			else ifg sprite[].xvel 0 ifl x 1280 ifn hitwall -1 { ifrnd 32 operate ifg sprite[].xvel 32 seta[].xvel 32 }
			}
		}
		else
		ifnotmoving 
		iffloordistl 8
		{
			geta[].htmovflag temp
			// hit something
			add temp 16384
			
			ifl temp 16384 ifg temp -1
			{
				ife actorvar[temp].monstatus 1
				ife actorvar[temp].team team
				ifn team 3
				{
					set x2 sprite[].x
					add x2 128
					rotatepoint sprite[].x sprite[].y x2 sprite[].y sprite[].ang x y
					setsprite THISACTOR x y sprite[].z
					seta[].htmovflag 0
				}
			}
			else
			ifrnd 10
			{
				set navpoint -1
				set crumbwait 8
			}
		}
		
		ifn hitsprite -1
		ifg sprite[].xvel 0
		ife actorvar[hitsprite].monstatus 1
		ife actorvar[hitsprite].team team
		{
			getincangle temp sprite[hitsprite].ang sprite[].ang
			abs temp
			ifg temp 768
			{
				// ifn navpoint actorvar[hitsprite].navpoint
				// {
					geta[].ang angvar
					add angvar 512
					state moveatangvar
				// }
			}
		}
		
		ifg sprite[].xvel 0
			state strafecheck
	}
	
	ife navmode 3 // random wander mode
	{
		state getanode
		state defaultwandercode
		
		ifl navpoint 0
		ifactornotstayput
		{
			ifg sprite[].xvel 0
			{
				ife seeplayer YES { iffloordistl 32 ifpdistg 8192 state crumbcode }
				else
				state crumbcode
			}
		}	
	}
	else
	ife navmode 2 // goal seeking mode
	{
		ife gametype CONTROL // control
		{
			state getanode
			state getflagcode
		}
		else
		ife gametype DM 
		{
			state getanode
			state getflagcode
		}
		else
		ife gametype SURVIVAL // horde arena
		{
			state getanode
			// state hordepursuitcode
			state getflagcode
			// edge cases of flag code should work for horde mode navigation
		}
		else
		ife gametype CTF // capture the flag
		{
			state getanode
			state getflagcode
		}
		else // default code
		{
			state getanode
			ifn team 0 ife gametype -1 ife botclip 10 state getflagcode
			else
			state defaultwandercode
		}
	}
	else
	ife navmode 1 // directed wander mode
	{
		state getanode
		state tanknavcode
	}

ends

defstate summondespawn

	ifg FEMKILLCOUNT 0
	ife bottarget -1
	{
		sub FEMKILLCOUNT 1
		ifn cutcam -1 set FEMKILLCOUNT 0
		ifle FEMKILLCOUNT 0
		{
			sound TELEPORTER
			spawn GLARESTAR
			state spawnoutline
			killit
		}
	}

ends

defstate jumppadmove

	set FEMFALLDMG 0
	cos xvel padang
    sin yvel padang
    
	mul xvel jumpadxvel
	mul yvel jumpadxvel
	
	seta[].xvel 0
	div xvel 15000
	div yvel 15000
	// shiftr xvel 14
	// shiftr yvel 14
	
	ifg burning -1
	ifn monstatus 2
	{
		switch sprite[].picnum
		case COMMANDER
		case NEWCOMM
			fall
		break
		case OCTABRAIN case MEGABRAIN case DRONE case NEWRECON case NEWSENTRY
		case DEVOURER case SCUBATROOP case BATBOSS
			ifvarand player[].player_par 1 fall
		break
		case NEWTROOP
			ifaction ANEWTJETPACK ifvarand player[].player_par 1 fall
		break
		case ARMLIZTROOP
			ifaction ARMLIZJET ifvarand player[].player_par 1 fall
		break
		endswitch
	}
	
	geta[].zvel z
	sub z 32
	seta[].zvel z // gravity difference compensation

	movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN
	
	
	sub padmove 1
	iffloordistl 8 nullop else ife padmove 0 set padmove 1
	
	ife padmove 0 set navpoint -1
	
ends

defstate spawn_crushed
	set RETURN 0
	switch sprite[].picnum
	case LIZTROOP case LIZTROOPDUCKING
	case NEWTROOP case NEWTROOPDUCKING
	case ARMLIZTROOP
		espawn CRUSHLIZTROOP
	break
	case PIGCOP case PIGCOPDIVE
	case NEWPIG case NEWPIGDIVE
		espawn CRUSHPIGCOP
	break
	case ARMPIG case EDFPIG
		espawn CRUSHARMPIG
	break
	case LIZELITE case LIZELITECROUCH
		espawn CRUSHLIZELITE
	break
	case NEWBEAST case NEWBEASTCROUCH
	case CYBERBEAST
		espawn CRUSHNEWBEAST
	break
	case MECHBRAIN
		espawn CRUSHMECHBRAIN
	break
	case LIZMAN
		espawn CRUSHLIZMAN
	break
	case LIZDOG
		espawn CRUSHLIZDOG
	break
	case COMMANDER case NEWCOMM
		espawn CRUSHCOMMANDER
	break
	case OCTABRAIN case MEGABRAIN
		espawn CRUSHOCTABRAIN
	break
	case LIZRANGER case LIZRANGERDUCKING
		espawn CRUSHLIZRANGER
	break
	case SPACEBULL case SPACEBULLDUCKING
		espawn CRUSHSPACEBULL
	break
	case ARMYANT case ARMYANTCRAWL
		espawn CRUSHANT
	break
	case ZOMBIE
		espawn CRUSHZOMBIE
	break
	case CRAZYLADY
		spritepal 2
		espawn CRUSHZOMBIE
		getlastpal
	break
	case BOSS1 case NEWBATLORD
		espawn CRUSHBATLORD
	break
	
	endswitch
	ifn RETURN 0 
	{
		setav[RETURN].myspawner THISACTOR
		seta[RETURN].pal sprite[].pal
	}
ends

defstate alphapulse
	ifactor SIDEGUN break
	set temp player[].player_par
	add temp monxp
	
	// shiftvarl temp 3
	mul temp 6
	
	sin tempb temp
	ifl tempb 0 mul tempb -1
	shiftr tempb 6
	ifg tempb 255 set tempb 255
	seta[].alpha tempb

ends

// DEANOTE3#

defstate shellyperkcheck

	set savz NO
	ife pchar 1 ife sprite[].htowner player[].i set savz YES else
	ife sprite[].htowner myshelly
	{
		ife sprite[myshelly].picnum SHELLY set savz YES else
		ife sprite[myshelly].picnum SHELLYCROUCH set savz YES
	}
	
	ife savz YES
	{
		set savz sprite[].htextra
		mul savz 100
		div savz inithp
		add stun savz
	}

ends

defstate wesperkcheck

	set savz NO
	ife pchar 2 ife sprite[].htowner player[].i set savz YES else
	ife sprite[].htowner myshelly
	{
		ife sprite[myshelly].picnum WESBOT set savz 2 else
		ife sprite[myshelly].picnum WESBOTCROUCH set savz 2
	}
	
	ifn savz NO
	{
		switch sprite[].picnum
		case ZOMBIE case ZOMBIEGIDUP case CORRUPT
		case CRONEN case CRAZYLADY
		case OCTABRAIN case MEGABRAIN
		case BATBOSS case OCTOBABY
			set temp sprite[].htextra
			mul temp 2
			seta[].htextra temp
			ife savz YES add leach temp else
			ife savz 2 add botleach temp
		break
		endswitch
	}

ends

defstate deaperkcheck

	set savz NO
	ife pchar 4 ife sprite[].htowner player[].i set savz YES else
	ife sprite[].htowner myshelly
	{
		ife sprite[myshelly].picnum DEABOT set savz 2 else
		ife sprite[myshelly].picnum DEABOTCROUCH set savz 2
	}
	
	ifn savz NO
	{
		switch sprite[].picnum
		case LIZTROOP case LIZTROOPDUCKING case NEWTROOP case NEWTROOPDUCKING
		case LIZMAN case LIZMANDUCKING
		case LIZDOG case LIZRANGER case LIZBOSS case LIZRANGERDUCKING
		case LIZELITE case LIZELITECROUCH case LIZTURRET
		case COMMANDER case NEWCOMM
			set temp sprite[].htextra
			mul temp 5 div temp 4
			seta[].htextra temp
		break
		endswitch
	}
ends

defstate addfriendflag

rand temp 8
	switch temp
	case 0 orvar monstflags 16 break // speedy
	case 1 orvar monstflags 128 break // multishot
	case 2 orvar monstflags 1024 break // healing aura
	case 3 orvar monstflags 2 break // rapid ROF
	case 4 orvar monstflags 8 break // energy barrier
	case 5 orvar monstflags 512 break // sideguns
	case 6 orvar monstflags 16384 break // vampirism
	case 7 orvar monstflags 2048 break // ghostly
	case 8 orvar monstflags 64 break // double damage
	endswitch
ends

defstate addmonstflag

	ifrnd 64
	ifn sprite[].picnum LIZTURRET
	ifn sprite[].picnum EDFTURRET
	ifn sprite[].picnum ROTATEGUN
	orvar monstflags 32 // strafes when moving forward
			
	rand temp 100

	ifl temp 10
		ifn sprite[].picnum ROTATEGUN
		ifn sprite[].picnum LIZTURRET
		ifn gametype 1
		{
			ifvarand monstflags 16 nullop else { mul monxp 5 div monxp 4 }
			orvar monstflags 16 // speedy
			
			ife initflags 0
			ifspritepal 0 spritepal 36
		}
	else ifl temp 15
		ifn sprite[].picnum ROTATEGUN
		ifn sprite[].picnum ZOMBIE
		{
			ifvarand monstflags 4096 nullop else { mul monxp 5 div monxp 4 }
			orvar monstflags 4096 // radioactive
			ife initflags 0
			spritepal 76
		}
	else ifl temp 25
		ifn sprite[].picnum ZOMBIE
		ifn sprite[].picnum SHARK
		{
			ifvarand monstflags 128 nullop else { mul monxp 4 div monxp 3 }
			orvar monstflags 128 // multishot
			ife initflags 0 spritepal 64
		}
	else ifl temp 30
		ifn sprite[].picnum NEWRECON
		{
			ifvarand monstflags 1024 nullop else { mul monxp 5 div monxp 3 }
			orvar monstflags 1024 // healing aura
			ife initflags 0
			spritepal 22
		}
	else ifl temp 35
		ifn sprite[].picnum NEWBEAST ifn sprite[].picnum DRONE ifn sprite[].picnum ROTATEGUN ifn sprite[].picnum DEANOVA
		ifn sprite[].picnum SITH ifn sprite[].picnum SYTH ifn sprite[].picnum CORRUPT
		ifn sprite[].picnum LIZTURRET ifn sprite[].picnum EDFTURRET ifn sprite[].picnum SCUBATROOP 
		ifn sprite[].picnum COMBINEDMEN ifn sprite[].picnum SMALLMAN ifn sprite[].picnum LARGEMAN 
		ifn sprite[].picnum SHARK
		{
			ifvarand monstflags 2 nullop else { mul monxp 4 div monxp 3 }
			orvar monstflags 2 // rapid ROF
		}
	else ifl temp 45	
		ifn sprite[].picnum SHARK
		{
			ifvarand monstflags 8 nullop else { mul monxp 5 div monxp 4 }
			orvar monstflags 8  // energy barrier
		}
	
	else ifl temp 55
		{
			ifvarand monstflags 16384 nullop else { mul monxp 5 div monxp 4 }
			orvar monstflags 16384  // vampirism
		}
	else ifl temp 60
		{
			ifvarand monstflags 1048576 nullop else { mul monxp 4 div monxp 3 }
			orvar monstflags 1048576 // electric aura
		}
	else ifl temp 70
	ifn gametype 1 ifn gametype 3
		{
			ifvarand monstflags 256 nullop else { mul monxp 4 div monxp 3 }
			orvar monstflags 256  // gigantism
		}
	else ifl temp 80
		{
			ifvarand monstflags 512 nullop else { mul monxp 4 div monxp 3 }
			orvar monstflags 512 // sideguns
			ife initflags 0
			ifspritepal 0 spritepal 14
		}
	else ifl temp 85
	ifn sprite[].picnum ROTATEGUN
	ifn sprite[].picnum LIZTURRET
	ifn sprite[].picnum EGG
	ifn sprite[].picnum BIGTURRET
	ifn sprite[].picnum GUNSHIP
	ifn sprite[].picnum SHIPTURRET
	ifn sprite[].picnum GRAVESNPC
	ifl monxp 2000
	ifn gametype 2
		{
			ifvarand monstflags 32768 nullop else { mul monxp 3 div monxp 2 }
			orvar monstflags 32768 // darkness
			geta[].htflags temp, orvar temp 4, seta[].htflags temp
		}
	else ifl temp 95
		{
			ifvarand monstflags 64 nullop else { mul monxp 4 div monxp 3 }
			orvar monstflags 64  // double damage
			ife initflags 0
			spritepal 49
		}
	else
	ife gametype 0
		{	
			ifvarand monstflags 2048 nullop else { mul monxp 3 div monxp 2 }
			orvar monstflags 2048 // ghostly
			ife initflags 0
			spritepal 15
		}

ends

defstate botblocking
	ifinwater
	{
		geta[].cstat temp
		ifvarand temp 1
		{
			xorvar temp 1
			seta[].cstat temp
		}
	}
	else
	ifpdistl 1024
	{
		geta[].cstat temp
		ifvarand temp 1
		{
			xorvar temp 1
			seta[].cstat temp
		}
	}
	else
	ifn monstatus 2
	ifle sprite[].alpha 164
		cstator 1
ends

defstate monsterai

ifl monstatus 1
{
  geta[].htflags temp, orvar temp 8192, seta[].htflags temp
  
  ifn team 1 ifn team 3 ifn sprite[].htpicnum RESPAWN ifn sprite[].htpicnum sprite[].picnum
  ife sprite[].htactorstayput -1
  ife sprite[].htextra -1 add maxkills 1
//   { add maxkills 1 al THISACTOR geta[].htpicnum picnum al picnum }
  
  ife startmode -1
  {
	changespritestat THISACTOR 2
	break
  }
  ifvarand monstflags 131072
	nullop
  else
  {
	seta[].yvel 200
	rand bluetimer 6
	switch sprite[].picnum
	
	case PIGCOP case PIGCOPDIVE case NEWPIG case NEWPIGDIVE
	case PIGCOPSTAYPUT case NEWPIGSTAYPUT
	set monxp 200
	ifspritepal 21 { orvar initflags 32 addstrength PIGCOPSTRENGTH sound PIGWARN add monxp 150 }
	break
	
	case OCTABRAIN
	case OCTABRAINSTAYPUT
		set monxp 200
		ifspritepal 17 { orvar initflags 16 addstrength 100 sizeat 36 32 add monxp 100 } else
		ifspritepal 19 { orvar initflags 64 addstrength 25 add monxp 50 }
	break
	
	case RECON
	case POLYMORPH
	set monxp 300
	break
	
	case LIZRANGER case LIZRANGERDUCKING
	set monxp 200 break
	
	case MECHBRAIN
		set monxp 400
		ifspritepal 14 { orvar initflags 2 add monxp 150 }
		ifspritepal 21 { orvar initflags 2 add monxp 150 }
	break
	
	case COMMANDER case EDFPIG
	case CYBERBEAST case NEWRECON
		set monxp 400 
		ifspritepal 24 { add monxp 200 orvar initflags 2 }
	break
	case NEWCOMM
		set monxp 500 
		ifspritepal 24 { add monxp 200 orvar initflags 2 }
	break
	
	case BIGTURRET
		set monxp 500
	break
	
	case LIZELITE case LIZELITECROUCH
		set monxp 600 
	break
	case SITH case SYTH
	case MEGABRAIN case PIGSUV
	set monxp 650 break
	
	case CHEERBOT
		ifspritepal 43 set monxp 1000 else
		set monxp 600 
	break
		
	case MANDOFETT case MANDOCROUCH
		orvar initflags 2
		set monxp 800
	break
	
	case DEANOVA 
		orvar initflags 2
		set monxp 800
	break
	
	case TANK
		set monxp 800
	break
	
	case PODHEAD
		set monxp 800
		ifspritepal 3 { set monxp 2000 orvar initflags 2 }	
	break
	
	case NURGLE
		set monxp 1000
	break
	
	case LIZDOG
		ifspritepal 104 { orvar initflags 32 set monxp 800 } else
		ifspritepal 17 set monxp 200 else
		set monxp 150
	break
	
	case ROBOSHARK
		set monxp 250
	break
	
	case LIZMAN
	case LIZMAN2
		set monxp 250
		ifvarand initflags 64 add monxp 200
		else
		ifspritepal 20 { orvar initflags 32 addstrength LIZSTRENGTH add monxp 200 }
		else
		ifspritepal 42 { orvar initflags 8 addstrength LIZSTRENGTH add monxp 200 } 
	break
		
	case LIZTROOP case LIZTROOPDUCKING
		set monxp 100
		ifspritepal 16 { orvar initflags 16 addstrength 50 add monxp 100 }
	break
	
	case NEWTROOP case NEWTROOPDUCKING
		set monxp 150
		ifspritepal 16 { orvar initflags 16 addstrength 50 add monxp 100 }
		ifspritepal 24 { orvar initflags 2 add monxp 150 }
		ifspritepal 21 { orvar initflags 2 add monxp 50 }
	break
	
	case NEWBEAST
		set monxp 300
		ifspritepal 21 orvar initflags 4
		ifvarand initflags 4 { addstrength 100 add monxp 100 }
	break
	
	case TERMINATOR case TERMINATORDUCKING
		set monxp 350
		ifvarand initflags 32 { add monxp 200 addstrength 150 }
	break
	
	case TERMINATORCRAWLING
		set monxp 100
	break
	
	case ARMPIG
	case ARMLIZTROOP
		ife mtype 2 set monxp 400 else set monxp 550
		ifspritepal 21 { orvar initflags 32 add monxp 200 addstrength 200 }
	break
	
	case LIZTURRET
	case SPACEBULL case SPACEBULLDUCKING
	case NEWSENTRY
	case FIGHTFEM case FIGHTFEMCROUCH case FIGHTMALE case FIGHTMALECROUCH
		set monxp 300 
	break
	
	case ARMYANT case ARMYANTCRAWL case ARMYANTJUMP
	case SCUBATROOP
	case CRAZYLADY
		set monxp 150 break
	
	case DRONE
		set monxp 100
		ifspritepal 19 { orvar initflags 8 addstrength 50 add monxp 100 }
		ife mtype 1 { strength 40 set monxp 0 }
	break
	
	case ROTATEGUN
	case CORRUPT
		set monxp 100
	break
	
	case SHARK
	case ZOMBIE
	case ZOMBIEGIDUP
	case SIDEGUN
	case OCTOBABY
		set monxp 75 break
	case EGG case EGGYOUNG set monxp 30 break
		
	case BOSS1 case BOSS2 case BOSS3 case BOSS4
	case DRPROTON case PSPIDER
	ifspritepal 0 { set monxp 2000 orvar initflags 2 }
	else set monxp 1000
	break
	
	case QUEEN
	ifspritepal 0 { set monxp 2500 orvar initflags 2 }
	else ifspritepal 42 { set monxp 4000 orvar initflags 2 }
	else set monxp 1250
	break
	
	case NEWBOSS1
	ifspritepal 0 { set monxp 2500 orvar initflags 2 }
	else set monxp 1250
	break
	
	case PIGBOSS
	ifspritepal 0 { orvar initflags 2 set monxp 2500 } else 
	ifspritepal 42 { orvar initflags 2 set monxp 3000 } else 
	set monxp 1250
	break
	
	case NEWBATLORD 
	ifspritepal 0 { set monxp 2500 orvar initflags 2 } else ifspritepal 42 set monxp 1500 else set monxp 1250
	break
	
	case LIZBOSS 
	ifspritepal 60 { set monxp 2500 orvar initflags 2 } else
	ifspritepal 0 { set monxp 2500 orvar initflags 2 } else ifspritepal 20 { orvar initflags 2 set monxp 1500 } else set monxp 1250
	break
	
	case GUNSHIP
	ifspritepal 0 set monxp 4000 else set monxp 2500
	break
	
	case SHIPTURRET set monxp 500
	break
	
	case REPAIRDRONE set monxp 25 orvar monstflags 64
	break
	
	case LARGEMAN case SMALLMAN
	case COMBINEDMEN
		set monxp 1250
	break
	
	case CANHEAD
		ifspritepal 0 { set monxp 2000 orvar initflags 2 } else set monxp 1500
	break
	
	case NEWMECH
		ifspritepal 40 { set monxp 3000 orvar initflags 2 } else set monxp 2000
	break
	
	case BOSS2FLY set monxp 2000
	break
	
	case CRONEN
		set monxp 150
		ifvarand initflags 32 add monxp 200
	break
	
	case DEVOURER
		ifspritepal 0
		{ orvar initflags 2 set monxp 3000 }
		else ifspritepal 19 set monxp 400 else set monxp 200
	break
	
	case BATBOSS
		ifspritepal 21 { orvar initflags 2 set monxp 4000 } else set monxp 1000
	break
	
	case CYCLOIDMAX
		ifspritepal 0 { orvar initflags 2 set monxp 5000 } else set monxp 2500
	break
	
	default set monxp 100 break
	
	endswitch
	
	ifge monstflags 2
	ifge SKILL 4 set savedvalue YES
	
	
	ifn attmode NO
	// ife team 0
	ifn team 1
	ifn team 3
	ifl monstflags 2 // don't add more if they are set in the map
	{
		ifg mlevel 1 ifg VOLUME 3 ifn attmode YES nullop else
		ifg plevel 1
		{
			set TMP_A plevel
			mul TMP_A 2
			set B plevel, add B 5, ifg TMP_A B set TMP_A B
			set TMP_B plevel
			div TMP_B 2, set B plevel, sub B 3, ifl TMP_B B set TMP_B B ifl TMP_B 1 set TMP_B 1
			ifvarand initflags 2 ifl TMP_B plevel set TMP_B plevel
			rand mlevel TMP_A
			ifl mlevel TMP_B set mlevel TMP_B
		}
		ife challenge YES add mlevel 1
		// add monstflags based on plevel here
		
		ifvarand perks 4096 ifvarand startmode 8 
		ife mybounty -1
		ife team 0
		{
			add bountycount 1
			ifge bountycount BOUNTY
			ifn sprite[].picnum EGG
			ifn sprite[].picnum SIDEGUN
			ifn sprite[].picnum SHARK
			ifn sprite[].picnum DOPEFISH
			ifn sprite[].picnum EGGYOUNG
			ifn sprite[].picnum FLYINGFIST
			ifn sprite[].picnum ROTATEGUN
			{
				set mybounty THISACTOR
				set bountycount 0
				espawn BOUNTYICON
				setav[RETURN].myspawner THISACTOR
				add mlevel 3
				ife bigmsgcount 0
				{
					set bigmsg 1401
					set bigmsgcount 90
				}
			}
		}
		
		ifg plevel 1
		ifn sprite[].picnum SIDEGUN
		ifn sprite[].picnum SHARK
		ifn sprite[].picnum DOPEFISH
		ifn sprite[].picnum EGGYOUNG
		ifn sprite[].picnum FLYINGFIST
		ifn sprite[].picnum PODHEAD
		ifn sprite[].picnum PODTAIL
		{
			ifrnd 84 ifn sprite[].picnum EGG 
			
			ifn sprite[].picnum ROTATEGUN
			ifn sprite[].picnum LIZTURRET
			ifn sprite[].picnum EDFTURRET
			orvar monstflags 32 // strafes when moving forward
			
			set TMP_A plevel
			sub TMP_A 1
			clamp TMP_A 1 7
			ife SKILL 3 add TMP_A 1 else
			ife SKILL 4 add TMP_A 2 else
			ife SKILL 5 add TMP_A 3 else
			ife SKILL 6 add TMP_A 3
			
			set tempI TMP_A
			
/*
			rand TMP_B 100
			ifl TMP_B TMP_A
			ifn sprite[].picnum EGG
			{
				orvar monstflags 2 // increased HP
				mul monxp 4 div monxp 3
				ifn sprite[].picnum BOSS1 ifn sprite[].picnum BOSS2 ifn sprite[].picnum BOSS3 ifn sprite[].picnum BOSS4
				ifn sprite[].picnum NEWBATLORD ifn sprite[].picnum QUEEN
				ifn sprite[].picnum DEANOVA
				ifspritepal 0 spritepal 12
			}
*/		
			rand TMP_B 100
			ifl TMP_B TMP_A
			ifn sprite[].picnum EGG
			ifn sprite[].picnum ROTATEGUN
			ifn sprite[].picnum LIZTURRET
			ifn sprite[].picnum PODHEAD
			ifn sprite[].picnum PODTAIL
			{
				ifrnd 128 orvar monstflags 2097152 else
				orvar monstflags 16 // speedy
				mul monxp 5 div monxp 4
				ife initflags 0
				ifspritepal 0 spritepal 36
				sub TMP_A 1
			}
			
			rand TMP_B 110
			ifl TMP_B TMP_A
			ifn sprite[].picnum EGG
			ifn sprite[].picnum PODHEAD
			ifn sprite[].picnum PODTAIL
			{
				orvar monstflags 8  // energy barrier
				mul monxp 5 div monxp 4
				sub TMP_A 1
			}
			
			sub TMP_A 1 // ***START TIER 2***
			
			rand TMP_B 100
			
			ifl TMP_B TMP_A
			ifn sprite[].picnum EGG
			ifn sprite[].picnum ZOMBIE
			{
				orvar monstflags 128 // multishot
				mul monxp 5 div monxp 4
				ife initflags 0
				spritepal 64
				sub TMP_A 1
			}
			
			rand TMP_B 110
			// ifg attbeaten 0
			ifl TMP_B TMP_A
			ifn sprite[].picnum EGG
			{
				orvar monstflags 16384  // vampirism
				mul monxp 5 div monxp 4
				sub TMP_A 1
			}
			
			rand TMP_B 140
			ifge SKILL 3
			ifl TMP_B TMP_A
			{
				orvar monstflags 1048576 // electric aura
				mul monxp 4 div monxp 3
				sub TMP_A 1
			}
			
			sub TMP_A 1  // ***START TIER 3***
			
			rand TMP_B 140
			ifl TMP_B TMP_A
			ifn sprite[].picnum PODHEAD
			ifn sprite[].picnum PODTAIL
			{
				orvar monstflags 256  // gigantism
				mul monxp 4 div monxp 3
				sub TMP_A 1
			}
			
			rand TMP_B 120
			ifl TMP_B TMP_A
			ifn sprite[].picnum NEWRECON
			ifn sprite[].picnum PODHEAD
			ifn sprite[].picnum PODTAIL
			{
				orvar monstflags 1024 // healing aura
				mul monxp 4 div monxp 3
				ife initflags 0
				spritepal 22
				sub TMP_A 1
			}
			
			rand TMP_B 120
			ifl TMP_B TMP_A
			ifn sprite[].picnum ROTATEGUN
			ifn sprite[].picnum ZOMBIE
			{
				orvar monstflags 4096 // radioactive
				mul monxp 5 div monxp 4
				ife initflags 0
				spritepal 76
				sub TMP_A 1
			}
			
			
			sub TMP_A 1  // ***START TIER 4***
			
			rand TMP_B 100
			ifl TMP_B TMP_A
			ifn sprite[].picnum EGG
			{
				orvar monstflags 512 // sideguns
				mul monxp 4 div monxp 3
				ife initflags 0
				ifspritepal 0 spritepal 14
				sub TMP_A 1
			}
/*
			rand TMP_B 95
			ifl TMP_B TMP_A
			ifn sprite[].picnum EGG
			{
				orvar monstflags 4 // double HP
				mul monxp 4 div monxp 3
				ife initflags 0
				ifspritepal 0 spritepal 35
			}
*/	
			
			rand TMP_B 95
			ifvarand monstflags 128 nullop else
			ifl TMP_B TMP_A
			ifn sprite[].picnum NEWBEAST ifn sprite[].picnum DRONE ifn sprite[].picnum ROTATEGUN ifn sprite[].picnum DEANOVA
			ifn sprite[].picnum SITH ifn sprite[].picnum SYTH ifn sprite[].picnum CORRUPT
			ifn sprite[].picnum LIZTURRET ifn sprite[].picnum EDFTURRET ifn sprite[].picnum SCUBATROOP 
			ifn sprite[].picnum COMBINEDMEN ifn sprite[].picnum SMALLMAN ifn sprite[].picnum LARGEMAN 
			ifn sprite[].picnum EGG
			ife initflags 0
			{
				orvar monstflags 2 // rapid ROF
				mul monxp 4 div monxp 3
				sub TMP_A 1
			}
			
			ifn marathon 2
			// ifge attbeaten 4
			ifge plevel 4
			ifn sprite[].htpicnum RESPAWN
			ifn sprite[].picnum ROTATEGUN
			ifn sprite[].picnum EGG
			ifn sprite[].picnum LIZTURRET
			ifn sprite[].picnum DRONE
			ifn sprite[].picnum NEWBATLORD
			ifn sprite[].picnum CANHEAD
			ifn sprite[].picnum BOSS2
			ifn sprite[].picnum BOSS3
			ifn sprite[].picnum BOSS4
			ifn sprite[].picnum LIZBOSS
			ifn sprite[].picnum PIGBOSS
			ifn sprite[].picnum NURGLE
			ifn sprite[].picnum DEANOVA
			ifn sprite[].picnum BATBOSS
			ifn sprite[].picnum QUEEN
			ifn sprite[].picnum NEWMECH
			ifn sprite[].picnum OCTOBABY
			ife sprite[].htactorstayput -1
			ifl monxp 2000
			{
				rand TMP_B 169
				ifl TMP_B TMP_A
				{
					orvar monstflags 131072 // mimic
					ifvarand monstflags 2 xorvar monstflags 2
					set inithp plevel
					add inithp SKILL
					sub inithp 3
					set mlevel plevel
					mul inithp 100
					add inithp 200
					set bluebaseval inithp
					set monxp inithp
					seta[].extra inithp
					set spawnprotect 0
				}
			}
			
			sub TMP_A 1  // ***START TIER 5***
			rand TMP_B 90
			ifvarand monstflags 128 nullop else
			ifvarand monstflags 2 nullop else
			ifl TMP_B TMP_A
			ifn sprite[].picnum EGG
			{
				orvar monstflags 64  // double damage
				mul monxp 4 div monxp 3
				ife initflags 0
				spritepal 49
				sub TMP_A 1
			}
			
			rand TMP_B 120
			ifl TMP_B TMP_A
			// ifg attbeaten 1
			ifn sprite[].picnum ROTATEGUN
			ifn sprite[].picnum LIZTURRET
			ifn sprite[].picnum EGG
			ifn sprite[].picnum BIGTURRET
			ifn sprite[].picnum PODHEAD
			ifn sprite[].picnum PODTAIL
			ifn sprite[].picnum GRAVESNPC
			ifl monxp 2000
			{
				orvar monstflags 32768 // darkness
				mul monxp 4 div monxp 3
				geta[].htflags temp, orvar temp 4, seta[].htflags temp
				sub TMP_A 1
			}
			
			rand TMP_B 100
			ifn attmode 0 ifge monxp 2000 set TMP_B 100
			ifl TMP_B TMP_A
			ifn sprite[].picnum PODHEAD
			ifn sprite[].picnum PODTAIL
			{
				ifvarand monstflags 1024 // don't add ghostly if has healing aura
				{
					orvar initflags 32
					orvar monstflags 512
				}
				else
				orvar monstflags 2048 // ghostly
				mul monxp 4 div monxp 3
				ife initflags 0
				spritepal 15
				sub TMP_A 1
			}
			
			ifvarand monstflags 131072 nullop else
			ifg ppowcount 60
			ifg monxp 100 ifl monxp 1900
			ifg plevel 3
			ifn sprite[].picnum SCUBATROOP
			ife attmode YES
			ifn challenge YES
			ifn sprite[].picnum PODHEAD
			ifn sprite[].picnum PODTAIL
			{
				set ppowcount -60
				orvar monstflags 4
				ifrnd 128 orvar monstflags 128 else orvar monstflags 16
				ifrnd 128 orvar monstflags 512 else orvar monstflags 64
				ifrnd 128 orvar monstflags 1024 else orvar monstflags 4096
				ifg plevel 10 { ifrnd 128 orvar monstflags 2048 else orvar monstflags 256 }
				ifrnd 128 orvar initflags 32
				orvar monstflags 32
				orvar monstflags 65536
				spritepal 92
				add monxp 500
			}
			
			ifge monxp 1000
			ifle monstflags 1
			ifge plevel 5
			{
				ifrnd 84 { orvar monstflags 256 mul monxp 4 div monxp 3 } else
				ifrnd 128 { orvar monstflags 16 mul monxp 5 div monxp 4 } else
				{ orvar monstflags 64 mul monxp 4 div monxp 3 }
				ifn sprite[].pal 0 spritepal 49
			}
			
		}
		
	}
	else 
	{
		ifg mlevel 1 ifg VOLUME 3 ifn attmode YES nullop else
		{
			set mlevel plevel
			ife marathon YES 
			{
				add mlevel mlevel_bonus
				ife attmode NO
				ifg mlevel 1
				{
					set TMP_A mlevel
					sub TMP_A 1
					set B TMP_A
					mul B 5
					add inithp B
					mul TMP_A 10
					add TMP_A 100
					mul inithp TMP_A
					div inithp 100
				}
			}
		}
		ife team 1
		ifg FEMKILLCOUNT 0
		ifge plevel 5 state addfriendflag
	}
	ifge SKILL 4 ifn sprite[].picnum EGG
	ifn sprite[].picnum EGGYOUNG ifn sprite[].picnum EGGMEDIUM
	ifn sprite[].picnum SIDEGUN 
	ifn sprite[].picnum PODHEAD ifn sprite[].picnum PODTAIL
	ifn sprite[].picnum EGGYOUNG ifn sprite[].picnum EGGMEDIUM
	ifn gametype -1
	{
		ife SKILL 4 ifrnd 192 nullop else
		{
			ife team 0 
			ifl monstflags 2
			{
				// ife SKILL 5 { ifrnd 32 state addmonstflag } else
				state addmonstflag
			}
			else ife team 1 ifn gametype 0 state addmonstflag
		}
		
	}
	ife mybounty THISACTOR state addmonstflag
	geta[].extra inithp
	// apply some flag settings
	
  }
    set monstatus 1
	ifrnd 96 orvar monstflags 262144
	ifvarand monstflags 8 // energy barrier
	{
		espawn EBARRIER
		setav[RETURN].myspawner THISACTOR
		ifrnd 128 seta[RETURN].pal 21
		ife gametype DM setav[RETURN].teamspawned 99999
	}
	ifvarand monstflags 4 { add inithp 150 mul inithp 3 div inithp 2 }
	ifvarand monstflags 64 { add inithp 50 mul inithp 4 div inithp 3 }
	ifvarand monstflags 128 { add inithp 50 mul inithp 4 div inithp 3 }
	ifvarand monstflags 256 
	{
		add inithp 100
		mul inithp 2
		set upscaled NO
	}
	ifvarand monstflags 512 // side guns
	{
		espawn SIDEGUN
		setav[RETURN].myspawner THISACTOR
		setav[RETURN].botclip -384
		rand safecount 5
		setav[RETURN].mtype safecount
		espawn SIDEGUN
		setav[RETURN].myspawner THISACTOR
		setav[RETURN].botclip 384
		setav[RETURN].mtype safecount
		ife gametype DM setav[RETURN].teamspawned 99999
		
		ifvarand monstflags 256 nullop else
		ifvarand monstflags 4 nullop else
		{
			mul inithp 4 div inithp 3
		}
	}
	ifvarand monstflags 1024 // healing aura
	{
		espawn HEALINGAURA
		setav[RETURN].myspawner THISACTOR
		add inithp 100
		ifvarand monstflags 256 nullop else
		{
			mul inithp 4 div inithp 3
		}
	}
	ifvarand monstflags 4096 // radiation aura
	{
		espawn RADAURA
		setav[RETURN].myspawner THISACTOR
		// seta[RETURN].pal 22
	}
	ifvarand monstflags 1048576
	{
		espawn SHOCKAURA
		setav[RETURN].myspawner THISACTOR
	}
	ifvarand monstflags 2 // rapid ROF
	{
		add inithp 50
		mul inithp 5 div inithp 4
	}
	ifvarand monstflags 32768 // darkness
	{
		sound FLAMEDRAWIN
		add inithp 100
		state spawnoutline
	}
	
	// ifg mlevel 1
	ife savedvalue YES
	{
		add mlevel 2
		ifge SKILL 5 add mlevel 2
		set savedvalue -1
	}
	ifn attmode NO
	{
		ifvarand monstflags 131072 nullop else
		ifn THISACTOR mynaamah
		{
			ifl SKILL 5
			{
				mul inithp 3
				div inithp 4
			}
			div monxp 2
			
			set TMP_A mlevel
			sub TMP_A 1
			set B TMP_A
			mul B 6 // 5
			add inithp B
			ifg mlevel 7 mul TMP_A 16 else
			mul TMP_A 14 // 12
			add TMP_A 100
			mul inithp TMP_A
			div inithp 100
			
			set TMP_A mlevel
			sub TMP_A 1
			mul TMP_A 15
			add TMP_A 100
			mul monxp TMP_A
			div monxp 100
		}
	}
	ifg inithp 32767 set inithp 32767
	ifvarand monstflags 131072 
	{
		set inithp bluebaseval
		ifn redflagval 0
		seta[].extra redflagval
	}
	else
	seta[].extra inithp
	set blueiteration 0
	
	ifg gametype 0 set spawnprotect 40
	ife team 1 set monxp 0
}

ife player[].actorsqu THISACTOR
  ife player[].knee_incs 14
		state spawn_crushed

ife upscaled YES // ensures that upscaled monsters don't get too big
{
	ifg sprite[].xrepeat init_xrepeat ifg init_xrepeat 4 seta[].xrepeat init_xrepeat
	ifg sprite[].yrepeat init_yrepeat ifg init_yrepeat 4 seta[].yrepeat init_yrepeat
}
else
ifvarand monstflags 256
{
	ifmove 0 nullop else
	{
		set upscaled YES
		
		ife init_xrepeat 0 set temp YES else set temp NO
		
		ife init_xrepeat 0
		geta[].xrepeat x
		else set x init_xrepeat
		
		mul x 3, div x 2, ifg x 255 set x 255
		seta[].xrepeat x
		set init_xrepeat x

		ife init_yrepeat 0
		geta[].yrepeat y
		else set y init_yrepeat
		
		mul y 3, div y 2, ifg y 255 set y 255
		seta[].yrepeat y
		set init_yrepeat y

		
		ife temp YES
		{
			state spawnoutline
			spawn GLARESTAR
			sound ACTOR_GROWING
		}
		
	}
}

ifcansee set seeplayer YES else set seeplayer NO

// ifn team 3
// ifn monstatus 2 ife mysignpost -1 
// ifn sprite[].picnum EGG // to prevent bots blowing up nearby civilians
// ifn sprite[].picnum EGGYOUNG
// state spawnmysignpost

	// ifonwater
	// {
		// geta[].picnum picnum
		// switch picnum
		// case LIZTROOP case ZOMBIETROOP
		// case PIGCOP case PIGCOPDIVE
		// case LIZMAN case NEWBEAST
		// case BOSS1 case BOSS2 case BOSS3
		// geta[].htflags temp
		// orvar temp 16
		// seta[].htflags temp
		// seta[].mdflags 16
		// set float YES
		// break
		// endswitch
	// }
	// else seta[].mdflags 0

ifg stun 0 
{
	sub stun 1
	ifge SKILL 4 sub stun 1
	set temp inithp
	ifg inithp 800
	{
		div temp 800
		ifg temp 7 set temp 7
		sub stun temp
	}
	ifl stun 0 set stun 0
}


ifg dodgetime 0 sub dodgetime 1

ifg thirdbasetimer 0 
{
	sub thirdbasetimer 1 // countdown until saber ammo can be spent on this enemy
	ifg thirdbasetimer 99 seta[].htpicnum HEADJIB1 // hack to make headshots work with lightsaber
}

// SPECIAL KICK CHECKING CODE

ifge sidekick 100
ife kicktarg -1
ife monstatus 1
ifl sprite[].alpha 128
{
	ife seeplayer YES
	ifpdistl 3072
	{
		set angvar initkickang
		add angvar 1024
		getincangle temp sprite[].ang angvar
		abs temp
		ifl temp 128 set kicktarg THISACTOR
	}
}

// BRUTALITY TARGETING

ifle pchar 1
ifp palive
ife monstatus 1
ife pdown NO
ife stasis 0
ifn team 1
ife zombieonplayer -1
ife brutalcount 0
ife shrunken 0
ife vendor_screen 0
ife onturret -1
ife qk_proxy 0
ifp pfacing
ifn sector[].lotag 2
ifpdistl 2560 // 2048
ifcansee
ifcanshoottarget
ifn sprite[].pal 1
ifvarand sprite[].cstat 256
{
	set tempb inithp, div tempb 2
	ife pchar 0 ifn sprite[].sectnum player[].cursectnum nullop else
	ifp pshrunk nullop else
	ifle sprite[].extra tempb
	{
		set temp NO
		ifactor NEWTROOP set temp YES
		ifactor NEWTROOPDUCKING set temp YES
		ifactor LIZMAN set temp YES
		ifactor LIZMANDUCKING set temp YES
		ifactor ARMLIZTROOP ife mtype 2 set temp YES
		ifactor ARMLIZTROOPDUCK ife mtype 2 set temp YES 
		ifactor NEWPIG set temp YES
		ifactor NEWPIGDIVE set temp YES
		ifactor NEWBEAST set temp YES
		ife temp YES
		{
			set brutalvictim THISACTOR
			ife monid THISACTOR set monid -1
			ifvarand gametips 262144
			ifl subtitle_time 2
			{
				set subtitle_time 15
				set subtitle_numlines 1
				set subtitle_start 1577
			}
			geta[].mdflags temp
			orvar temp 16
			seta[].mdflags temp
			ifhitspace
			{
				set brutalcount 1
				set stun 150
				ifstrength 10 strength 10
				seta[].htextra 1
				seta[].htowner player[].i
				seta[].htpicnum KNEE
				seta[].htang player[].ang
			}
		}
	}
}
else
ife brutalvictim THISACTOR
{
	ifg brutalcount 0 break
	set brutalvictim -1
	ife subtitle_start 1577 set subtitle_time 0
}


ife monstatus 1
	ife seeplayer YES
	ifl sprite[].alpha 128
{
	ifn sprite[].picnum RECON
	// ifn sprite[].picnum PIGSUV
	ifn sprite[].picnum ROTATEGUN
	// ifn sprite[].picnum SIDEGUN
	{
		state kickcheckcode	
	}
	
	set temp NO
	ife pchar 0 ifvarand dukeupgrades[RPG_WEAPON] 4 set temp YES // MULTI ROCKETS
	ife pchar 1 ifvarand shellyupgrades[RPG_WEAPON] 4 set temp YES // MULTI ROCKETS
	
	ife temp YES
	ife zoomin YES
	ife player[].curr_weapon RPG_WEAPON
	ifg player[].ammo_amount RPG_WEAPON 0
	ife player[].kickback_pic 0
	ife player[].weapon_pos 0
	ife targetwait 0
	// ifn THISACTOR targetlock[0]
	// ifn THISACTOR targetlock[1]
	// ifn THISACTOR targetlock[2]
	ifn actorvar[player[].i].team team
	{
		geta[].x x2
		geta[].y y2
		sub x2 player[].posx
		sub y2 player[].posy
		getangle angvar x2 y2
		
		getincangle temp angvar player[].ang
		abs temp
		ifl temp 16
		{
			ife targetlock[0] -1
			{
				set targetwait 10
				sound TARGETLOCK
				setarray targetlock[0] THISACTOR
				geta[THISACTOR].mdflags temp
				orvar temp 16
				seta[THISACTOR].mdflags temp
			}
			else
			ife targetlock[1] -1
			ifg player[].ammo_amount RPG_WEAPON 1
			{
				set targetwait 10
				sound TARGETLOCK
				setarray targetlock[1] THISACTOR
				geta[THISACTOR].mdflags temp
				orvar temp 16
				seta[THISACTOR].mdflags temp
			}
			else
			// ife targetlock[2] -1
			ifg player[].ammo_amount RPG_WEAPON 2
			{
				set B NO
				
				ife targetlock[0] targetlock[1]
				ifn targetlock[0] THISACTOR
				{
					setarray targetlock[1] THISACTOR
					set B YES
				}
				else
				ife targetlock[1] targetlock[2]
				ifn targetlock[1] THISACTOR
				{
					setarray targetlock[2] THISACTOR
					set B YES
				}
				else
				ife targetlock[0] targetlock[2]
				ifn targetlock[0] THISACTOR
				{
					setarray targetlock[2] THISACTOR
					set B YES
				}
				else
				ife targetlock[2] -1 { setarray targetlock[2] THISACTOR set B YES }
				
				ife B YES
				{
					set targetwait 10
					sound TARGETLOCK
					geta[THISACTOR].mdflags temp
					orvar temp 16
					seta[THISACTOR].mdflags temp
				}
			}
		}
	}
}

	state spawnprotectcode

ife padang 131314 { seta[].htpicnum RPG seta[].htowner player[].i seta[].htextra 100 }
ifg padmove 0 state jumppadmove
else ifvarand monstflags 16 // super speed
{
	ifmove STOPPED nullop else
	ifmove STOPPEDFORPLAYER nullop else
	{
		geta[].xvel xvel
		ifg xvel 32
		{
			// ifg xvel 32 
			ifl xvel 768 add xvel 64
			// ifl xvel -32 ifg xvel -256 sub xvel 32
			seta[].xvel xvel
			ifvarand sprite[].cstat 32768 nullop else
			ife team 0
			state makespeedblur
		}
	}
}

ifg monstflags 0
{
	ifvarand monstflags 16384 // vampirism
	{
		ifwasweapon CAPTUREPLUS
		{
			seta[].htpicnum SHOTSPARK1
			
			set safecount 0
			whilevarn safecount 8
			{
				espawn CAPTUREPLUS
				ifn RETURN -1
				{
					seta[RETURN].pal 21
					
					rand x2 1024
					sub x2 512
					add x2 sprite[].x
					seta[RETURN].x x2
					seta[RETURN].htbposx x2
					
					rand x2 1024
					sub x2 512
					add x2 sprite[].y
					seta[RETURN].y x2
					seta[RETURN].htbposy x2
					
				}
				add safecount 1
			}
		}
	}

	ifvarand monstflags 32768 // darkness
	{
		geta[].htflags temp, orvar temp 4, seta[].htflags temp
		ife monstatus 1
		ife shrunken 0
		{
			seta[].shade 35 
			set temp player[].player_par
			add temp THISACTOR
			modvar temp 30
			ife temp 0
			{
				espawn BIGSMOKE2
				seta[RETURN].htflags 4
				seta[RETURN].shade 28
			}
			// retaliate with dark projectiles
			ifg sprite[].htextra sprite[].extra // 5
			ifn sprite[].htowner -1
			ifn actorvar[sprite[].htowner].team team
			{
				setprojectile[RADPROJ].workslike 69634
				setprojectile[RADPROJ].vel 412
				
				set safecount inithp // sprite[].htextra
				sqrt safecount safecount
				ifg safecount 64 set safecount 64
				ifl safecount 3 set safecount 3
				
				whilevarn safecount 0
				{
					// set temp sprite[].htextra
					// ifg sprite[].htextra inithp set temp inithp
					// div temp 5, ifl temp 5 set temp 5
					// ifg temp 25 set temp 25
					setprojectile[RADPROJ].extra 10
					eshoot RADPROJ
					sound RADHIT
					setav[RETURN].bottarget sprite[].htowner
					setav[RETURN].mtype 1
					seta[RETURN].pal 10
					seta[RETURN].blend 0
					seta[RETURN].cstat 128
					rand angvar 2048 sub angvar 1024 add angvar sprite[].ang
					seta[RETURN].ang angvar
					rand z 1024
					sub z 1024
					seta[RETURN].zvel z
					sub safecount 1
				}
				
				setprojectile[RADPROJ].workslike 69890
				setprojectile[RADPROJ].extra 20
				setprojectile[RADPROJ].vel 512
			}
			add mysignpost 1
			
			ifrnd 1
			ifn zombieonplayer THISACTOR
			// iffloordistl 4
			ife sprite[].htextra -1
			ife shrunken 0
			ifn redcarrier THISACTOR
			ifn bluecarrier THISACTOR
			ifge mysignpost 150
			{
				set mysignpost sprite[].picnum
				sound FLAMEDRAWIN
				cactor MONSHADOW
				geta[].yrepeat damflash
				geta[].mdflags temp
				orvar temp 16
				seta[].mdflags temp
				randvar angvar 2047
				seta[].ang angvar
				break
			}
		}
		else
		seta[].shade 20
		
	}
	
	ifvarand monstflags 2097152 // quikdash
	{
		ifrnd 2
		ifn bottarget -1
		ife dashtime 0
		ife dodgetime 0
		ifn monstatus 2
		{
			set temp NO
			ifvarand monstflags 1 set temp YES
			ifn sprite[].xvel 0 set temp YES
			ife temp YES
			{
				sound QUIKDASH sound QUIKDASH
				set dashtime 3
				set temp sprite[].mdflags
				orvar temp 16
				seta[].mdflags temp
			}
		}
		ifg dashtime 0
		{
			state makespeedblur
			
			cos xvel sprite[].ang
			sin yvel sprite[].ang
				  
			shiftr xvel 3
			shiftr yvel 3
			
			movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN
			
			sub dashtime 1
		}
	}

	ifvarand monstflags 2
	ife monstatus 1
	{
		ifle sprite[].xvel 64
		ifge sprite[].xvel -64
		{
			set temp player[].player_par
			modvar temp 3
			ife temp 0
			{
				set tempb sprite[].htg_t 2
				add tempb 1
				seta[].htg_t 2 tempb
			}
		}
	}
	
	ifvarand monstflags 2048 // ghostly
	{
		ife monstatus 2 
		{
			seta[].alpha 0
			xorvar monstflags 2048
		}
		else
		{
			state alphapulse
			geta[].cstat temp
			ifg sprite[].alpha 164 // 164
			{
				ifvarand temp 256 xorvar temp 256
				ifvarand temp 1 xorvar temp 1
				ifn zombieonplayer THISACTOR
				{
					seta[].htextra -1
					ife bottarget player[].i 
					{
						set bottarget -1
						set bluetimer 1
						set seemytarget NO
						set shootmytarget NO
						set targetdist 99999
						set targetalive NO
					}
				}
				
			}
			else
			{
				ifvarand temp 32768 nullop else
				{
					orvar temp 256
					ifn team 1 orvar temp 1
				}
			}
			seta[].cstat temp
			ifspritepal 1 // frozen
			{
				cstator 257
				seta[].alpha 0
				xorvar monstflags 2048
			}
		}
	}

	ifvarand monstflags 8192 // suicide bomber
	{
		ife spawnprotect 0
		{
			ifspritepal 6 getlastpal
			
			set temp player[].player_par
			modvar temp 5
			ife temp 0 spritepal 6
		}
		
		set temp NO
		
		ifn bottarget -1
		ifn actorvar[bottarget].team team
		ife seemytarget YES
		ifl targetdist 1024
		set temp YES
		
		ifn sprite[].htowner -1
		ifn actorvar[sprite[].htowner].team team
		ifge sprite[].htextra sprite[].extra
		set temp YES
		
		ife temp YES
		{
			xorvar monstflags 8192
			ifspritepal 6 getlastpal
			hitradius 2048 30 45 60 75
			
			ifn bottarget -1
			{
				set temp inithp
				ifg temp 150 set temp 150
				ife pchar 0 set tempc dweaplevel[GROW_WEAPON] else 
				ife pchar 2 set tempc wweaplevel[GROW_WEAPON] else
				ife pchar 3 set tempc mweaplevel[GROW_WEAPON] else
				ife pchar 4 set tempc nweaplevel[GROW_WEAPON] else
				set tempc bweaplevel[GROW_WEAPON]
				add tempc 6
				mul tempc 10
				add temp tempc
				geta[bottarget].htextra tempb
				add tempb temp
				seta[bottarget].htextra tempb
				seta[bottarget].htpicnum RPG
				ife team 1
				seta[bottarget].htowner player[].i else
				seta[bottarget].htowner THISACTOR
				seta[bottarget].htang sprite[].ang
			}
			
			strength 1
			seta[].htextra 100
			seta[].htpicnum RPG
			seta[].htowner THISACTOR
			
			ifrnd 128
			sound PIPEBOMB_EXPLODE
			else
			sound ROBOT_EXPLODE
			spawn EXPLOSION3
			
		}
	}

	ifmove STOPPED nullop else
	ifn monstatus 2
	ifg sprite[].extra 0
	{
		ifvarand monstflags 32
		{
			ife targetalive YES
			ife seemytarget YES
			ifn bottarget -1
			ifl targetdist 12288
			ifg sprite[].xvel 31
			{
				set temp player[].player_par
				add temp THISACTOR
				shiftl temp 5
				sin tempb temp

				shiftr tempb 5
				
				ifinwater shiftr tempb 1
				
				geta[bottarget].x x2
				geta[bottarget].y y2
				sub x2 sprite[].x
				sub y2 sprite[].y
				getangle angvar x2 y2
				
				ifvarand THISACTOR 1
				add angvar 512
				else
				sub angvar 512
				
				cos xvel angvar
				sin yvel angvar
					  
				shiftr xvel 5
				shiftr yvel 5
				
				mul xvel tempb
				mul yvel tempb
				
				shiftr xvel 5
				shiftr yvel 5
			
				mul xvel sprite[].xvel
				mul yvel sprite[].xvel
				
				// shiftr xvel 14
				// shiftr yvel 14
				div xvel 12288
				div yvel 12288
				movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN
			}
		}
		ifvarand monstflags 65536
		{
			ifg ppowcount 0 set ppowcount 0
			ife seeplayer YES ifpdistl 16384 
			{
				ifle prating 800
				ifrnd 2
				{
					spawn GLARESTAR
					sound TELEPORTER
					killit
				}
			}
			else
			ifrnd 2
			ife bottarget -1
			{
				set B -1
				headspritestat spriteid 999
				whilevarn spriteid -1
				{
					ldist tempc player[].i spriteid
					ifg tempc 2560 
					{
						canseespr spriteid player[].i temp
						ife temp YES
						set B spriteid
					}
					
					nextspritestat spriteid spriteid
					ifn B -1 set spriteid -1
				}
				ifn B -1
				{
					spawn GLARESTAR
					setsprite THISACTOR sprite[B].x sprite[B].y sprite[B].z
					spawn GLARESTAR
					sound TELEPORTER
					seta[].htactorstayput -1
				}
			}
		}
	}
}

state predamage

ifg sprite[].htextra 0
{
	ife sprite[].htowner THISACTOR 
	{
		ifn sprite[].htpicnum SHOTSPARK1
			seta[].htextra -1
	}
	else
	{
		geta[].htowner spriteid
		ifn spriteid -1 
		{
			ife team actorvar[spriteid].team
			ifn actorvar[spriteid].monstatus 0
			{
				set temp sprite[].htextra
				ife gametype DM set temp -1
				else { mul temp 2 div temp 3 }
				ifl temp 1 set temp 1
				seta[].htextra temp
			}
			else
			ifvarand monstflags 1048576
			ife monstatus 1
			ifn sprite[].htpicnum STUCKARROW
			ifn sprite[].htpicnum RADWOUND 
			ifn sprite[].htpicnum BURNING
			{
				geta[].ang safecount
				state facesprite
				set xvel 768
				geta[spriteid].z zdist
				sub zdist sprite[].z 
				mul zdist xvel
				ldist xydist THISACTOR spriteid
				ifvare xydist 0 setvar xydist 1 
				divvarvar zdist xydist
				ezshoot zdist SHOCKPROJ
				rand angvar 4
				sub angvar 2
				add safecount angvar
				seta[].ang safecount
			}
		}
	}
	
}

ifg sprite[].htextra -1
{
	ife bottarget -1 ifg bluetimer 0 set bluetimer 0
	
	set temp sprite[].htextra
	ife sprite[].htowner player[].i
	{
		set TMP_A NO
		// ifg combotime 0 set TMP_A YES
		ifg switchboost 0 set TMP_A YES
		ife TMP_A YES
		{
			
			mul temp 3
			div temp 2
			seta[].htextra temp
			ifn sprite[].htpicnum BURNING
			ifn sprite[].htpicnum FREEZEBLAST
			ifn sprite[].htpicnum KNEE
			ifn sprite[].htpicnum SHRINKSPARK
			ifn sprite[].htpicnum GROWSPARK
			{
				seta[].htpicnum RPG
				sound AMPHIT
			}
		}
		else ife switchboost 0 add damagecount temp
	}
	ife DAMAGEFLASH YES
	ifg sprite[].extra 3
	ife sawfleshtime 0
	ife sprite[].htowner player[].i
	{
		geta[].mdflags tempb
		orvar tempb 16
		seta[].mdflags tempb
		set tempc player[].player_par
		sub tempc 1
		ifn tempc damflash
		ifn sprite[].htpicnum STUCKARROW
		ifn sprite[].htpicnum RADWOUND 
		ifn sprite[].htpicnum FORCECHOKE
		set damflash player[].player_par
	}
	
	
	set blueiteration 90 // this is a countdown timer

	switch sprite[].htpicnum
	
	case RPG
		ifvarand shellyupgrades[RPG_WEAPON] 1 nullop else
		{
			ife pchar 1
			ife player[].curr_weapon RPG_WEAPON
			ife sprite[].htowner player[].i
			{
				ife rpgtype 1 { ifl burning 60  seta[].htpicnum FREEZEBLAST }
				else ife rpgtype 0
				{
					geta[].htextra temp
					shiftl temp 1
					add burning temp
					shiftr temp 2
					seta[].htextra temp
				}
			
			}
		}
		
		ifn sprite[].picnum BOSS1
		ifn sprite[].picnum BOSS2
		ifn sprite[].picnum BOSS3
		ifn sprite[].picnum BOSS4
		ifn sprite[].picnum DEVOURER
		ifn sprite[].picnum RECON
		ifn sprite[].picnum NEWRECON
		{
			geta[].xvel xvel
			mulvar xvel -1
			seta[].xvel xvel	
		}
		ifvarand perks 256 state shellyperkcheck
	break
	
	case RADIUSEXPLOSION
		
		ifn sprite[].picnum BOSS1
		ifn sprite[].picnum BOSS2
		ifn sprite[].picnum BOSS3
		ifn sprite[].picnum BOSS4
		ifn sprite[].picnum DEVOURER
		ifn sprite[].picnum RECON
		ifn sprite[].picnum NEWRECON
		{
			geta[].xvel xvel
			mulvar xvel -1
			seta[].xvel xvel	
		}
		ifvarand perks 256 state shellyperkcheck
	break
	
	case KNEE
	
		ifn shrunken 0
		{
			geta[].htextra temp
			shiftl temp 4
			seta[].htpicnum RPG
		}
		geta[].htowner spriteid
		set B NO
		ife sprite[spriteid].picnum DUKEBOT set B YES
		ife sprite[spriteid].picnum SHELLY set B YES
		ife B YES
		{
			ifn team 1
			ife monstatus 1
			{
				geta[].htextra temp
				add temp KNEE_WEAPON_STRENGTH
				seta[].htextra temp
				
				// ifn sprite[].picnum BOSS1
				// ifn sprite[].picnum BOSS2
				// ifn sprite[].picnum BOSS3
				// ifn sprite[].picnum BOSS4
				// ifn sprite[].picnum PSPIDER
				// ifn sprite[].picnum CYCLOIDMAX
				// ifn sprite[].picnum NEWBATLORD
				// ifn sprite[].picnum QUEEN
				// ifn sprite[].picnum PIGBOSS
				// ifn sprite[].picnum LIZBOSS
				// ifn sprite[].picnum TERMINATORCRAWLING
				// ifn sprite[].picnum EGG
				// ifn sprite[].picnum EGGYOUNG
				// ifn sprite[].picnum ROTATEGUN
				// ifn sprite[].picnum SIDEGUN
				// ifn sprite[].picnum RECON
				// ifn sprite[].picnum NEWRECON
				// ifn sprite[].picnum PIGSUV
				// ifn sprite[].picnum TANK
				// {
					
					set temp sprite[].htextra
					div temp 5
					add stun temp
				// }

			}
		}
		else
		ife sprite[].htowner player[].i
		{
			ife kneecharge FULLKNEE 
			ife slidekick 0
			ife slidehit NO
			ife monstatus 1
			ife sidekick 0
			{
				ifn sprite[].picnum BOSS1
				ifn sprite[].picnum BOSS2
				ifn sprite[].picnum BOSS3
				ifn sprite[].picnum BOSS4
				ifn sprite[].picnum PSPIDER
				ifn sprite[].picnum CYCLOIDMAX
				ifn sprite[].picnum NEWBATLORD
				ifn sprite[].picnum QUEEN
				ifn sprite[].picnum PIGBOSS
				ifn sprite[].picnum LIZBOSS
				ifn sprite[].picnum TERMINATORCRAWLING
				ifn sprite[].picnum EGG
				ifn sprite[].picnum EGGYOUNG
				ifn sprite[].picnum ROTATEGUN
				ifn sprite[].picnum SIDEGUN
				ifn sprite[].picnum RECON
				ifn sprite[].picnum NEWRECON
				ifn sprite[].picnum PIGSUV
				ifn sprite[].picnum TANK
				{
					seta[].xvel -512 // -1024
					seta[].zvel -1024 // -2048
					geta[].z z
					sub z 1536 // 3072
					seta[].z z
				}
				geta[].htextra temp
				add temp KNEE_WEAPON_STRENGTH
				seta[].htextra temp
				set kneecharge 0
			}
		}
	break
	
	case FREEZEBLAST
		set tempc sprite[].htextra
		set temp tempc
		mul temp 3 div temp 4 
		ifl temp 1 set temp 1
		seta[].htextra temp
		ifl tempc 2 set tempc 2
		shiftl tempc 2
		sub burning tempc
	break
	
	case GOOBULLET
		ifle gooify 0 add stun 10
		ifg gooify -1
		{
			add gooify sprite[].htextra
			add gooify sprite[].htextra
			add gooify sprite[].htextra
		}
		set temp sprite[].extra
		div temp 2
		ifge gooify temp
		{
			ife stun 10 set stun 20
			geta[].mdflags tempb
			orvar tempb 16
			seta[].mdflags tempb
			
			ifvarand novaupgrades[FREEZE_WEAPON] 1
			{
				espawn BLOODPOOL2
				seta[RETURN].pal 126
				setav[RETURN].mtype 1
			}
			else
			{
				espawn BLOODPOOL
				seta[RETURN].pal 126
			}
		}
	break
	
	case SHOCK_ACTOR
		espawn SHOCK_ACTOR
		setav[RETURN].myspawner THISACTOR
		setav[RETURN].mtype 1
	break
	
	case SHOTSPARK1
	case SABERPROJ
	case SAWPROJ
		findplayer xydist
		geta[].htowner spriteid
		// ife sprite[spriteid].picnum APLAYER
		ife spriteid player[].i
		ife player[].curr_weapon KNEE_WEAPON
		ifl xydist 1408
		{
			ife gotsaw YES
			ifn pchar 2
			ifn pchar 4
			{
				sub sawammo 1
				ifl sawammo 0 set sawammo 0
				ife sawammo 0
					state sawoff
				
				set TMP_A sprite[].htextra
				mul TMP_A 10
				div TMP_A inithp
				add stun TMP_A
				ifg stun 15 set stun 15
			}
			else
			{
				set saberdash 0
				
				ife pchar 4
				ifn switchboost 0
				{
					set TMP_A sprite[].htextra
					mul TMP_A 10
					div TMP_A inithp
					ifl TMP_A 2 set TMP_A 2
					add stun TMP_A
					ifg stun 30 set stun 30
				}
				
				ifg sprite[].htextra sprite[].extra
				ifrnd 64
				ifn sprite[].htpicnum HEADJIB1
				{
					seta[].htpicnum HEADJIB1
					ifg gotsaber 0 ifn pchar 2 ifn pchar 4 
					{
						sub gotsaber 1
						set thirdbasetimer 6
					}
				}
				else
				ife thirdbasetimer 0 
				{ 
					ifg gotsaber 0 ifn pchar 2 ifn pchar 4
					{
						sub gotsaber 1 
						set thirdbasetimer 6 // saber ammo usage timer
					}
				}
			}
		}
	break
	
	endswitch
	
	geta[].htowner spriteid
	ifn spriteid -1
	ifn monstatus 2
	ifn sprite[spriteid].picnum NAAMAH
	ifn sprite[spriteid].picnum REPAIRDRONE
	{
		ife team actorvar[spriteid].team 
		{
			setav[spriteid].myvictim -2
			// geta[].htextra temp ifg temp 1 { shiftr temp 1 seta[].htextra temp }
		}
		else
		ife actorvar[spriteid].monstatus 1
		setav[spriteid].myvictim THISACTOR
	}
	ifg sprite[].htextra 0 
	{
		ifvarand perks 512 state wesperkcheck
		ifvarand perks 8192 state deaperkcheck
	}
	ifl sprite[].htextra sprite[].extra ife padang 1337 ife padmove 0 set padang 0
}
else ifg blueiteration 0 sub blueiteration 1

ife team 1 state botblocking
state damagepushenemy

ifn gooify 0 state imgooified
ifg burning 0 state imonfire
else ifl burning 0
{
	set temp sprite[].extra
	mul temp -1
	ifl burning temp
	{
		geta[].mdflags temp
		orvar temp 16
		seta[].mdflags temp
		changespritestat THISACTOR 2
		sleeptime 32767
	}
	add burning 1
	ifl burning -150 add burning 1
	ife stasis 0
	ifge burning 0 { changespritestat THISACTOR 1 sleeptime 100 }
}

ifvarand monstflags 131072 // mimic
ifn monstatus 2
{
	add redbaseval 2
	
	ifactor SITH ife mtype 1 nullop else
	ifactor SYTH ife mtype 1 nullop else
	add redbaseval sprite[].htextra
	
	set tempb bluebaseval
	div tempb 3
	ifge redbaseval tempb
	ifn sprite[].pal 1
	ifl sprite[].htextra sprite[].extra
	ifg redbaseval 150
	{
		set picnum -1
		set B NO
		// ifp phigher set B YES
		iffloordistl 32 nullop else set B YES
		ife B NO
		{
			rand temp 43
			switch temp
			case 0 set picnum NEWTROOP break
			case 1 set picnum NEWPIG break
			case 2 set picnum LIZMAN break
			case 3 set picnum COMMANDER break
			case 4 set picnum NEWCOMM break
			case 5 set picnum SPACEBULL break
			case 6 set picnum NEWBEAST break
			case 7 set picnum LIZBOSS break
			case 8 set picnum PIGBOSS break
			case 9 set picnum OCTABRAIN break
			case 10 set picnum MEGABRAIN break
			case 11 set picnum TANK break
			case 12 set picnum NEWTROOPJETPACK break
			case 13 set picnum LIZRANGER break
			case 14 set picnum SYTH break
			case 15 set picnum SITH break
			case 16 set picnum NEWPIG break
			case 17 set picnum BOSS3 break
			case 18 set picnum QUEEN break
			case 19 set picnum ZOMBIE break
			case 20 set picnum ARMPIG break
			case 21 set picnum NEWSENTRY break
			case 22 set picnum CANHEAD break
			case 23 set picnum PSPIDER break
			case 24 set picnum ARMYANT break
			case 25 set picnum LIZELITE break
			case 26 set picnum CYBERBEAST break
			case 27 set picnum TERMINATOR break
			case 28 set picnum SMALLMAN break
			case 29 set picnum NEWTROOP break
			case 30 set picnum LIZMAN break
			case 31 set picnum NEWBATLORD break
			case 32 set picnum LARGEMAN break
			case 33 set picnum MECHBRAIN break
			case 34 set picnum EDFPIG break
			case 35 set picnum DUKEBOT break
			case 36 set picnum SHELLY break
			case 37 set picnum CHEERBOT break
			case 38 set picnum DEANOVA break
			case 39 set picnum FIGHTFEM break
			case 40 set picnum FIGHTMALE break
			case 41 set picnum ROBOSHARK break
			case 42 set picnum BIGTURRET break
			case 43 set picnum LIZDOG break
			endswitch
		}
		else
		{
			rand temp 12
			switch temp
			case 0 set picnum COMMANDER break
			case 1 set picnum NEWCOMM break
			case 2 set picnum LIZBOSS break
			case 3 set picnum OCTABRAIN break
			case 4 set picnum MEGABRAIN break
			case 5 set picnum NEWTROOPJETPACK break
			case 6 set picnum NEWSENTRY break
			case 7 set picnum FIGHTMALE break
			case 8 set picnum ARMYANTJUMP break
			case 9 set picnum DUKEBOT break
			case 10 set picnum SHELLY break
			case 11 set picnum DEANOVA break
			case 12 set picnum FIGHTFEM break
			endswitch
		}
		ifactorsound THISACTOR SABERIDLE stopactorsound THISACTOR SABERIDLE
		ifactorsound THISACTOR HANDBLADE_LOOP stopactorsound THISACTOR HANDBLADE_LOOP
		set mid_spawn YES
		espawnvar picnum
		set mid_spawn NO
		setav[RETURN].spawnprotect 10
		setav[RETURN].initflags initflags
		setav[RETURN].monstflags monstflags
		setav[RETURN].mlevel plevel
		rand pal 17
		add pal 7
		seta[RETURN].pal pal
		ife sprite[RETURN].picnum DUKEBOT seta[RETURN].pal 17
		ife sprite[RETURN].picnum SHELLY seta[RETURN].pal 17
		ife sprite[RETURN].picnum FIGHTFEM seta[RETURN].pal 17
		ife sprite[RETURN].picnum FIGHTMALE seta[RETURN].pal 17
		ife sprite[RETURN].picnum DEANOVA seta[RETURN].pal 17
		ifg sprite[].htextra 0
		{
			set temp sprite[].extra
			sub temp sprite[].htextra
			seta[].extra temp
		}
		setav[RETURN].bluebaseval bluebaseval
		setav[RETURN].monxp monxp
		seta[RETURN].extra sprite[].extra
		setav[RETURN].redflagval sprite[].extra
		seta[RETURN].cstat 257
		setav[RETURN].monstatus -1
		seta[RETURN].statnum 1
		seta[RETURN].zvel sprite[].zvel
		setav[RETURN].burning burning
		set monstatus 2
		spawn AIRSHOCK
		set monxp 0
		killit
	}
	ifawayfromwall nullop else
	ifgapzl 128 ifnotmoving ifg sprite[].xrepeat 24
	{
		sizeto 24 24
		spawn FRAMEEFFECT1
	}
}

ife monstatus 1
ifp pfacing
ifl sprite[].cstat 32768
ifn brutalvictim THISACTOR
{
	ife scannedsprite THISACTOR
	{ set monid THISACTOR set monidtime 8 } 
	else
	{
		ife seeplayer YES
		ife seemytarget YES
		 ifn team 3
		 {
			ife monid -1 { set monid THISACTOR set monidtime 8 }
		 }
	}
}

ifactor GUNSHIP break
ifactor PIGSUV break
ifactor DUKEBOT break
ifactor DUKEBOTCROUCH break
ifactor SHELLY break
ifactor SHELLYCROUCH break
ifactor WESBOT break
ifactor WESBOTCROUCH break

ifn shrunken 0
{
  ife shrunken 10
  { 
	geta[].extra temp 
	div temp 3
	seta[].extra temp 
	geta[].mdflags temp, orvar temp 16, seta[].mdflags temp
  }
  ifg shrunken 31
  {
    ifl shrunken SHRUNKCOUNT
	{
		ifg sprite[].z player[].posz
		{
			ifpdistl SQUISHABLEDISTANCE
			ifn team 1 ifn team 3
			{
				ifactor DRONE { ife player[].knee_incs 0 setp[].knee_incs 1 setp[].actorsqu THISACTOR }
				else
				ifactor TANK { ife player[].knee_incs 0 setp[].knee_incs 1 setp[].actorsqu THISACTOR }
				else
				ifactor TERMINATOR { ife player[].knee_incs 0 setp[].knee_incs 1 setp[].actorsqu THISACTOR }
				else
				ifactor TERMINATORCRAWLING { ife player[].knee_incs 0 setp[].knee_incs 1 setp[].actorsqu THISACTOR }
				else
				ifactor CHEERBOT { ife player[].knee_incs 0 setp[].knee_incs 1 setp[].actorsqu THISACTOR }
				pstomp
			}
		}
		
		ife team 0 ife monstatus 1
		ifn myshelly -1 ifg sprite[myshelly].xrepeat 12
		{
			findnearactorz SHELLY 644 6144 spriteid
			ifn spriteid -1 { seta[].htpicnum RPG seta[].htextra 1000 seta[].htowner spriteid state spawn_crushed }
			else
			findnearactorz DUKEBOT 644 6144 spriteid
			ifn spriteid -1 { seta[].htpicnum RPG seta[].htextra 1000 seta[].htowner spriteid state spawn_crushed }
			else
			findnearactorz WESBOT 644 6144 spriteid
			ifn spriteid -1 { seta[].htpicnum RPG seta[].htextra 1000 seta[].htowner spriteid state spawn_crushed }
			else
			findnearactorz DEABOT 644 6144 spriteid
			ifn spriteid -1 { seta[].htpicnum RPG seta[].htextra 1000 seta[].htowner spriteid state spawn_crushed }
		}
		
		ifg sprite[].htextra 0 ifn sprite[].htpicnum FREEZEBLAST
		ifn sprite[].htpicnum SHRINKSPARK ifrnd 80 seta[].htpicnum RPG
	}
  }
  else
  {
    ifg sprite[].xrepeat 64 { sizeto MINXSTRETCH MINYSTRETCH }
	ifg sprite[].xrepeat 38 { sizeto MINXSTRETCH MINYSTRETCH }
	
	set temp tiledata[sprite[].picnum].ysize
	
    // ife upscaled YES
	ifg temp 95
	{
		ifg sprite[].xrepeat MINXUPSTRETCH spawn FRAMEEFFECT1
		sizeto MINXUPSTRETCH MINYUPSTRETCH
	}
	else
	{
		sizeto MINXSTRETCH MINYSTRETCH
		spawn FRAMEEFFECT1
	}
  }
  add shrunken 1
  ife shrunken SHRUNKCOUNT
  {
	geta[].extra temp
	mul temp 3
	seta[].extra temp
	sound UNSHRINK
  }
  ifg shrunken SHRUNKCOUNT
  {
    switch sprite[].picnum
	case OCTABRAIN ifvarand initflags 16 sizeto 36 32 else sizeto 24 22 break
	case PIGCOP sizeto 40 40 break
	case CHEERBOT
	case COMMANDER
	case NEWCOMM sizeto 30 28 break
	case ARMPIG case EDFPIG case POLYMORPH sizeto 26 24 break
	case FEMCIV case FEMCIVCROUCH case FEMCIV2 case FEMCIV2CROUCH case FEMCIV3 case FEMCIV3CROUCH
	case FEMCIV5 case FEMCIV5CROUCH
	case MALECIV1 case MALECIV1CROUCH case MALECIV2 case MALECIV2CROUCH 
	case MALECIV4 case MALECIV4CROUCH case MALECIV5 case MALECIV5CROUCH
	case MALECIV6 case MALECIV6CROUCH
	case NAKEDBABE case NAKEDBABECROUCH case SHOWERGIRL case GUARD case GUARDCROUCH
	case STRIPPER case STRIPPERCROUCH case KBABE case KBABECROUCH case CHEERLEADER
	case CAVEGIRL case CAVEGIRLCROUCH case BIKINIBABE case BIKINIBABE2
	case CRYSTAL case CHEERLEADERCROUCH case HOOKER case HOOKERCROUCH case POLEDANCER sizeto 28 26 break
	case TERMINATOR case TERMINATORDUCKING ifspritepal 57 sizeto 36 32 else sizeto 28 24 break
	case POLESTRIPPER case BLUEHANGBABE case NEWSLIMEBABE case NEWSLIMEBABE2 case SCUBAGIRL
	case LARRY case GARFIELD case ORCHID case CHUNLI case FEM12 case FEM13 case FEM14
	case FEM16 case FEM17 case FEM18 case FEM19 case FEM20 case FEM21 case BETTY
	case SLAVE1 case SLAVE2 case SLAVE3 case HELLONURSE
	sizeto 28 26 break
	case FEM11 sizeto 28 28 break
	case MECHBRAIN sizeto 40 38 break
	case SPACEBULL case SPACEBULLDUCKING sizeto 26 26 break
	case TANK { sizeto 60 60 sizeto 60 60 } break
	case RECON case NEWRECON case ARMYANT case ARMYANTCRAWL sizeto 24 24 break
	case SHARK sizeto 40 40 break
	case BOSS2 ifspritepal 0 { sizeto 80 64 sizeto 80 64 } else sizeto 40 32 break
	case BOSS1 case BOSS3 case BOSS4
	ifspritepal 0 { sizeto 128 128 sizeto 128 128 } else sizeto 40 40
	break
	case LIZRANGER case LIZRANGERDUCKING sizeto 30 28 break
	case LIZBOSS
		ifspritepal 0 sizeto 64 56 else sizeto 32 28 break
	case PIGBOSS ifspritepal 0 sizeto 66 60 else ifspritepal 42 sizeto 66 60 
		else sizeto 33 30
		break
	case EDFTROOP sizeto 25 22 break
	case EDFSNIPER case ZOMBIE case CRAZYLADY sizeto 28 26 break
	case CYBERBEAST sizeto 32 28 break
	case LIZELITE case LIZELITECROUCH sizeto 23 23 break
	case NEWTROOP case NEWTROOPDUCKING 
	case ARMLIZTROOP case ARMLIZTROOPDUCK
		sizeto 24 22
	break
	
	case NEWPIG case NEWPIGDIVE
		sizeto 28 26
	break
	
	case LIZMAN case ARMEDF case CORRUPT
		sizeto 28 26
	break
	case LIZDOG case MANDOFETT case MANDOCROUCH
		sizeto 26 24
	break
	case BATBOSS sizeto 32 30 break
	case NURGLE sizeto 32 28 break
	case NEWBATLORD ifspritepal 0 sizeto 96 80 else sizeto 48 40 break
	case QUEEN ifspritepal 0 sizeto 96 80 else sizeto 42 40 break
	case DEVOURER ifspritepal 19 sizeto 30 28 else sizeto 18 16 break
	case OCTOBABY sizeto 34 28 break
	default sizeto 40 40 break
	endswitch

	ifg shrunken SHRUNKDONECOUNT 
	{
		set shrunken 0 
		seta[].htpicnum SHOTSPARK1 
		ife upscaled YES
		{
			seta[].xrepeat init_xrepeat
			seta[].yrepeat init_yrepeat
		}
	}
  }
  geta[].xrepeat x mul x 3
  ifg sprite[].xvel x seta[].xvel x
  mul x -1
  ifl sprite[].xvel x seta[].xvel x
  ifl sprite[].zvel -64 seta[].zvel -64
}

ifactor NEWTROOPTARGET break
ifactor NEWPIGTARGET break
ifactor RECON break
// ifactor SHARK break
ifactor NEWRECON break
ifactor SITH ife mtype 1 break // blocking
ifactor SYTH ife mtype 1 break
ifactor DEANOVA ife mtype 1 break

set tempb YES
getp[].cursectnum temp
ifn temp -1
ife sector[temp].lotag 2
{
	set tempb NO
	ifinwater set tempb YES
}
ife monstatus 2 set tempb NO
ife monstatus 3 set tempb NO
ife team 3 set tempb NO
ife tempb YES
ife navmode 0
ifl bluetimer 30
{
	ife shrunken 0
	ife stun 0 ifl sprite[].htextra 1
	// ife player[].holoduke_on -1
	ifactornotstayput
	{
		ifg sprite[].xvel 0
		{
			ife seeplayer YES { iffloordistl 32 ifpdistg 8192 state crumbcode }
			else
			state crumbcode
		}
		else
		ifvarand monstflags YES
		{
			ife seeplayer YES { iffloordistl 32 ifpdistg 8192 state crumbcode }
			else
			state crumbcode
		}
	}
}

// ifn shellyinmap 0
// ife crumbwait 0
ife monstatus 1
ifn sprite[].picnum DRPROTON
ifn sprite[].picnum PSPIDER
ifn sprite[].picnum PSPIDERJUMPING
{

	// infighting trigger
	ife team 0 ifg sprite[].htextra 0
	ife gametype 0
	ifn sprite[].htowner -1
	{
		ifn sprite[sprite[].htowner].picnum TANK
		ife actorvar[sprite[].htowner].team 0
		{
			set temp NO
			ifge SKILL 4 { ifrnd 16 set temp YES } else { ifrnd 32 set temp YES }
			ife disable_infighting YES set temp NO
			ife temp YES
			{
				set bottarget sprite[].htowner
				set bluetimer 6
			}
		}
		else ifn bottarget -1
		ife team actorvar[bottarget].team
			set bottarget -1
	}
	
	state targetsearch
	ifactornotstayput 
	ife dodgetime 0
	ife padmove 0
	ifn sprite[].picnum ROTATEGUN
	ifn sprite[].picnum LIZTURRET ifn sprite[].picnum EDFTURRET
	ifn sprite[].picnum SIDEGUN
	ifn sprite[].picnum BIGTURRET ifn sprite[].picnum SHIPTURRET
	{
		ifvarand monstflags YES
		state navigationsmart
		else
		state navigation
	}
	
	ifn bottarget -1
	{
		// distance management
		
		ifmove STOPPED
		ifn bottarget player[].i
		{
			ifvarand monstflags 1 nullop else
			{
				set temp NO
				ifl targetdist 512 set temp YES
				else
				ife targethigher YES
				{
					ldist tempb THISACTOR bottarget
					ifl tempb 844 set temp YES
				}
				ife temp YES
					seta[].xvel -128
			}
			
		}
		
		ife dodgetime 0
		{
			// if an actor uses commands such as faceplayer, seekplayer, then
			// do NOT make them face a player target this way
			
			set temp YES
			
			ife bottarget player[].i 
			{
				set ptargeted 10
				switch sprite[].picnum
				case EDFTROOP case EDFTROOPCROUCH
				case EDFDRONE case NEWSENTRY case SIDEGUN
				case ARMEDF
				case SPACEBULL case SPACEBULLDUCKING
				case EDFSNIPER case EDFSNIPERCROUCH
				case LIZELITE case LIZELITECROUCH
				case MANDOFETT case MANDOCROUCH
				case NEWBOSS1
				case QUEEN
				case CYCLOIDMAX case FLYINGFIST
				case SMALLMAN	
				case SCHOOLGIRL
				case NEWMECH
				case FIGHTMALE case FIGHTMALECROUCH case FIGHTFEM case FIGHTFEMCROUCH
				case GRAVESNPC case GRAVESNOGUN
					set temp YES
				break
				default 
					set temp NO
				break
				endswitch
			}
			else ife bottarget myshelly set ptargeted 10
				
			ife temp YES
			{
				switch sprite[].picnum
				case EDFDRONE
				case NEWSENTRY
				// case SIDEGUN
				case COMBINEDMEN
				case LARGEMAN
				case NEWBOSS1
				case CYCLOIDMAX
				case FLYINGFIST 
				case QUEEN
				case LILY
					state turntotarget 
				break
				case EDFTANK case EDFTANKTURRET
				case GUNSHIP case SHIPTURRET
				case BIGTURRET
				case BLACKHAWK
				case NEWMECH
				case POLYMORPH
				case PODHEAD
				break
				default
					geta[bottarget].x x
					geta[bottarget].y y
					sub x sprite[].x
					sub y sprite[].y
					getangle angvar x y
					seta[].ang angvar
				break
				endswitch
			}
		}
		
	}
	
}

	// ifmove BACKUP ifcount 20 move STOPPED geth
	ifn pchar 4
	ifn player[].holoduke_on -1
	ife monstatus 1
	ifn team actorvar[player[].i].team
	ifstrength 2000
	ifn gametype CTF ifn gametype CONTROL
	ifg sprite[].yvel 0
	{
		ifn bottarget -1 dist temp THISACTOR bottarget
		else dist temp THISACTOR player[].i
		dist tempc THISACTOR player[].holoduke_on
		ifvarvarl tempc temp
		{
			getp[].holoduke_on spriteid
			geta[].z z
			subvar z 8192
			seta[].z z
			geta[spriteid].z tempb
			subvar tempb 8192
			seta[spriteid].z tempb
			canseespr THISACTOR spriteid temp
			add z 8192
			seta[].z z
			add tempb 8192
			seta[spriteid].z tempb
			ife temp 1
			{
				ifl tempc 1024 ifg sprite[].xvel 0 seta[].xvel -40
				ifg tempc 512
				{
					geta[spriteid].x x
					geta[spriteid].y y
					sub x sprite[].x
					sub y sprite[].y
					getangle angvar x y
					seta[].ang angvar
					set bottarget player[].holoduke_on
					setav[player[].holoduke_on].monstatus 1
				}
				else seta[].ang lastang
				
			}
		}
		geta[].yvel temp, sub temp 1, ifl temp 0 set temp 0, seta[].yvel temp
		ife temp 0 ife bottarget player[].holoduke_on set bottarget -1
	}
	
	ifn bottarget -1
	{
		ifn bottarget player[].i
		{
			geta[].z z
			subvar z 8192
			
			
			ifle sprite[bottarget].z z set targethigher YES else set targethigher NO
			
			set seemytarget YES set shootmytarget YES
			dist targetdist THISACTOR bottarget
			ifn actorvar[bottarget].monstatus 2 set targetalive YES
			else set targetalive NO
		}
		else // player is target
		{
			geta[].z z
			subvar z 8192
			ifle sprite[player[].i].z z set targethigher YES else set targethigher NO
			
			// ifp phigher set targethigher YES else set targethigher NO
			
			// ife team actorvar[player[].i].team // player ally
			// {
				// set seemytarget NO
				// set shootmytarget NO
				// set targetdist 99999
				// set targetalive NO
			// }
			// else
			// ife actorvar[player[].i].team 3 // neutral team
			// {
				// set seemytarget NO
				// set shootmytarget NO
				// set targetdist 99999
				// set targetalive NO
			// }
			// else
			// {
				// ifcansee 
				set seemytarget YES 
				// ifcanshoottarget 
				set shootmytarget YES
				findplayer targetdist
				ifp pshrunk set targetalive YES else ifp palive set targetalive YES
				else set targetalive NO
			// }
		}
	}

	else
	{
		getav[player[].i].team tempc

		ife team tempc
		{
			set seemytarget NO
			set shootmytarget NO
			set targetdist 99999
			set targetalive NO
		}
		else
		{
			ifvarand monstflags YES set temp YES else set temp NO
			
			ifg navpoint -1
			ife temp NO
			{
				// don't force player as target if the actor is using a navigation point
				set seemytarget NO
				set shootmytarget NO
				set targetdist 99999
				set targetalive NO
			}
			else
			{
				findplayer targetdist
				// ife seeplayer YES ifcanshoottarget ifl targetdist MAXRANGE
				// {
					// ifp phigher set targethigher YES else set targethigher NO
					// set seemytarget YES 
					// set shootmytarget YES
					// ifp pshrunk set targetalive YES else
					// ifp palive set targetalive YES else set targetalive NO
					// ife targetalive YES set bottarget player[].i
				// }
				// else
				// {
					set seemytarget NO
					set shootmytarget NO
					// set targetdist 999999
					// set targetalive NO
					ifp palive set targetalive YES else set targetalive NO
				// }
				ifge sprite[].picnum BOSS2 ifle sprite[].picnum BOSS3
				ife seeplayer YES ifcanshoottarget ifl targetdist MAXRANGE
				{
					ifp phigher set targethigher YES else set targethigher NO
					set seemytarget YES 
					set shootmytarget YES
					ifp pshrunk set targetalive YES
					ife targetalive YES set bottarget player[].i
				}
			}
		}

	}

	ifn monstatus 2
	state avoidwater
	
	geta[].ang lastang

ends

defstate jib_sounds

  set TMP_A YES
  switch sprite[].picnum
  case EGG case EGGYOUNG case EGGMEDIUM case PODTAIL
  case POLYMORPH case POLYGORE1 case POLYGORE2 case POLYGORE3 case POLYGORE4 case POLYGORE5
  case POLYPOLE case POLYMORPHPAD case POLYMORPHPOD case OCTOBABY 
  case FEM1 case FEM2 case FEM3 case FEM4 case FEM7 case FEM8 case FEM9 case FEM10 case FEM11
  case FEM16
  case SNIPERCAUGHT case SNIPERHANG case NEWFEM5 case NEWFEM8 case NEWFEM11 case NEWPODFEM2
  case NEWFEM6 case NEWFEM7 case NEWFEM10 case NEWPODFEM1 case NEWFEM9 case NEWNAKED1 case NEWNAKED2
  case HELLONURSE case BETTY case NEWHANGBABE case POLESTRIPPER case NEWSLIMEBABE case NEWSLIMEBABE2
  case FEM12 case FEM13 case ORCHID case CHUNLI case BLUEHANGBABE case SCUBAGIRL case LARATRAPPED case LARATRAPPED2
  case WALLFEM1 case WALLFEM2 case HANGBABEDEAD case FEM6DEAD case FEM5DEAD case TOUGHGAL
  case BLOODYPOLE case BLOODYPOLE2 case BLOODYPOLE3 case BLOODYPOLE4 case TIFA
  case BLOODLESSPOLE case BLOODLESSPOLE2 case BLOODLESSPOLE3 case BLOODLESSPOLE4 case NEWFEM6PAD case EMPTYPOD
	set TMP_A NO
	break
  endswitch
  
  ife TMP_A NO break

  set spriteid sprite[].htowner
  ife spriteid -1 set spriteid player[].i
  ife spriteid player[].i
  ifrnd SWEARFREQUENCY
  ife jibsound -1
  {
    ife pchar 1
	{
		ife VOLUME 6 ifl LEVEL 11 rand temp 18
		else
		rand temp 15
		add temp 1
		ife temp 1 set jibsound B_JIB1
		ife temp 2 set jibsound B_JIB2
		ife temp 3 set jibsound B_JIB3
		ife temp 4 set jibsound B_JIB4
		ife temp 5 set jibsound B_JIB5
		ife temp 6 set jibsound B_JIB6
		ife temp 7 set jibsound B_JIB7
		ife temp 8 set jibsound B_JIB8
		ife temp 9 set jibsound B_JIB9
		ife temp 10 set jibsound B_IMGOOD
		ife temp 11 set jibsound B_SUCKIT
		ife temp 12 set jibsound B_NEVERGETSOLD
		ife temp 13 set jibsound B_RIP
		ife temp 14 set jibsound B_WHOSENEXT
		ife temp 15 set jibsound B_SURGERY
		ife temp 16 set jibsound B_SUCKA
		// VACA JIBS
		ife temp 17 set jibsound B_BAIT
		ife temp 18 set jibsound B_FISHFOOD
		ife temp 19 set jibsound B_ONTHEHOUSE
		
		set jibsound_delay 10
	}
	else
	ife pchar 2
	{
		rand temp 14
		ife temp 0 set jibsound WESSTAYDOWN
		ife temp 1 set jibsound WESGETTINGFUN
		ife temp 2 set jibsound WESARMYOFME
		ife temp 3 set jibsound WESAWWYEAH
		ife temp 4 set jibsound WESBEATDOWN
		ife temp 5 set jibsound WESBIOHAZARD
		ife temp 6 set jibsound WESDOTHISALLDAY
		ife temp 7 set jibsound WESFOOLS
		ife temp 8 set jibsound WESHOLYSHIT
		ife temp 9 set jibsound WESMADEPOINT
		ife temp 10 set jibsound WESMESSY
		ife temp 11 set jibsound WESWANTSOMEOFME
		ife temp 12 set jibsound WESYEAHBITCH
		ife temp 13 set jibsound WESOHSMACK
		ife temp 14 set jibsound WESIMONFIRE
		
		set jibsound_delay 10
	}
	else
	ife pchar 3
	{
		ife jibsound_delay 0
		{
			rand temp 12
			set jibsound_delay 15
			ife temp 0 setvar jibsound MANDO_AMATEUR else
			ife temp 1 setvar jibsound MANDO_CORPSES else
			ife temp 2 setvar jibsound MANDO_PATHETIC else
			ife temp 3 setvar jibsound M_GOBLEED else
			ife temp 4 setvar jibsound M_IFITBLEEDS else
			ife temp 5 setvar jibsound M_LAUGH else
			ife temp 6 setvar jibsound M_SAYMYNAME else
			ife temp 7 setvar jibsound M_WASTEMYTIME else
			ife temp 8 setvar jibsound M_SAIDDIFFICULT else
			ife temp 9 setvar jibsound M_VERYNICE else
			ife temp 10 setvar jibsound M_RUNDIETIRED else
			ife temp 11 setvar jibsound M_MOTTO else
			ife temp 12 setvar jibsound  M_THISISWAY
		}
	}
	else ife pchar 4
	{
		rand temp 12
		switch temp
		case 0 setvar jibsound DEA_GIBTAUNT1 break
		case 1 setvar jibsound DEA_GIBTAUNT2 break
		case 2 setvar jibsound DEA_GIBTAUNT3 break
		case 3 setvar jibsound DEA_CONSCRIPTS break
		case 4 setvar jibsound DEA_RIP break
		case 5 setvar jibsound DEA_GIBTAUNT5 break
		case 6 setvar jibsound DEA_GIBTAUNT6 break
		case 7 setvar jibsound DEA_GIBTAUNT7 break
		case 8 setvar jibsound DEA_GIBTAUNT8 break
		case 9 setvar jibsound DEA_SUFFENDS break
		case 10 setvar jibsound DEA_VOIDWELCOMES break
		case 11 setvar jibsound DEA_NOTENJOY break
		case 12 setvar jibsound DEA_LOOKEDPAINFUL break
		endswitch
		set jibsound_delay 15
	}
	else
	{
		ife VOLUME 6 ifl LEVEL 11 rand temp 18
		else
		rand temp 15
		add temp 1
		ife temp 1 set jibsound JIBBED_ACTOR12
		ife temp 2 set jibsound JIBBED_ACTOR1
		ife temp 3 set jibsound JIBBED_ACTOR9
		ife temp 4 set jibsound JIBBED_ACTOR14
		ife temp 5 set jibsound SMACKED
		ife temp 6 set jibsound JIBBED_ACTOR2
		ife temp 7 set jibsound MDEVSPEECH
		ife temp 8 set jibsound JIBBED_ACTOR5
		ife temp 9 set jibsound JIBBED_ACTOR11
		ife temp 10 set jibsound JIBBED_ACTOR13
		ife temp 11 set jibsound JIBBED_ACTOR3
		ife temp 12 set jibsound JIBBED_ACTOR8
		ife temp 13 set jibsound JIBBED_ACTOR6
		ife temp 14 set jibsound JIBBED_ACTOR4
		ife temp 14 set jibsound JIBBED_ACTOR10
		ife temp 15 set jibsound JIBBED_ACTOR15
		ife temp 16 set jibsound JIBBED_ACTOR7
		// DUKE VACA JIBS
		ife temp 17 set jibsound D_BAIT
		ife temp 18 set jibsound D_FISHFOOD
		ife temp 19 set jibsound D_ONTHEHOUSE
		
		set jibsound_delay 5
	}
	// DEANOTE4#
  }

ends

defstate troop_body_jibs

	ifl sprite[].yrepeat 12 break
	ife padang 1337 break
	ifge padang 131313 ifle padang 131314 spritepal 27

	ifspritepal 1
    guts HEADJIB1 1
	else
	{
	  rand zdist 1024
	  sub zdist 3500
	  ife upscaled YES 
	  { 
		  setprojectile[TROOPHEADPROJ].xrepeat init_xrepeat 
		  setprojectile[TROOPHEADPROJ].yrepeat init_yrepeat 
	  }
	  ifactor NEWTROOP ezshoot zdist NEWTROOPHEADPROJ
	  else
	  ezshoot zdist TROOPHEADPROJ
	  ife upscaled YES { seta[RETURN].xrepeat init_xrepeat seta[RETURN].yrepeat init_yrepeat }
	  rand angvar 512
	  sub angvar 256
	  add angvar sprite[].htang
	  seta[RETURN].ang angvar
	  seta[RETURN].pal sprite[].pal
	}

    guts LEGJIB1 2

    guts ARMJIB1 1
  ifrnd 48
  ife shrunken 0
  {
    ifspritepal 1 spawn BLOODPOOL else
    spawn BLOODPOOL2
  }
ends

defstate armliz_body_jibs

	rand zdist 1024
	sub zdist 3500
	ezshoot zdist NEWTROOPHEADPROJ
	rand angvar 512
	sub angvar 256
	add angvar sprite[].htang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist ARMLIZCHESTPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist ARMLIZARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist ARMLIZLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal

ends

defstate liz_body_jibs

	ifl sprite[].yrepeat 12 break
	ife padang 1337 break
	ifge padang 131313 ifle padang 131314 spritepal 27

	ifspritepal 1
    guts LIZMANHEAD1 1
	else
	{
	  rand zdist 1024
	  sub zdist 3500
	  ezshoot zdist LIZHEADPROJ
	  ife upscaled YES { seta[RETURN].xrepeat init_xrepeat seta[RETURN].yrepeat init_yrepeat }
	  rand angvar 512
	  sub angvar 256
	  add angvar sprite[].htang
	  seta[RETURN].ang angvar
	  seta[RETURN].pal sprite[].pal
	}

    guts LIZMANLEG1 2

    guts LIZMANARM1 1
  ifrnd 48
  ife shrunken 0
  {
    ifspritepal 1 spawn BLOODPOOL else
    spawn BLOODPOOL2
  }
ends

defstate ranger_body_jibs

	ifl sprite[].yrepeat 12 break
	ife padang 1337 break
	ifge padang 131313 ifle padang 131314 spritepal 27

	rand zdist 1024
	sub zdist 3500
	ezshoot zdist RANGERHEADPROJ
	rand angvar 512
	sub angvar 256
	add angvar sprite[].htang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist RANGERLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist RANGERARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist RANGERARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132

ends

defstate comm_body_jibs

	ifl sprite[].yrepeat 12 break
	ife padang 1337 break
	ifge padang 131313 ifle padang 131314 spritepal 27
	
	rand zdist 1024
	sub zdist 3500
	ifactor NEWCOMM ezshoot zdist NEWCOMMHEADPROJ
	else
	ezshoot zdist COMMHEADPROJ
	rand angvar 512
	sub angvar 256
	add angvar sprite[].htang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist COMMARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist COMMARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132
ends

defstate pig_body_jibs

	ifl sprite[].yrepeat 12 break
	ife padang 1337 break
	ifge padang 131313 ifle padang 131314 spritepal 27
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist PIGHEADPROJ
	rand angvar 512
	sub angvar 256
	add angvar sprite[].htang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist PIGLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist PIGLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist PIGARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist PIGARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132

ends

defstate armpig_body_jibs

	ifl sprite[].yrepeat 12 break
	ife padang 1337 break
	ifge padang 131313 ifle padang 131314 spritepal 27

	ife B YES
	{
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist PIGHEADPROJ
	rand angvar 512
	sub angvar 256
	add angvar sprite[].htang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	}
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist ARMPIGFOOTPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist ARMPIGLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist ARMPIGARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	ifn mtype 987
	{
		rand zdist 1024
		sub zdist 3500
		ezshoot zdist ARMPIGARMPROJ
		rand angvar 2047
		seta[RETURN].ang angvar
		seta[RETURN].pal sprite[].pal
		seta[RETURN].cstat 132
	}

ends

defstate bull_body_jibs

	ifl sprite[].yrepeat 12 break
	ife padang 1337 break
	ifge padang 131313 ifle padang 131314 spritepal 27

	ife B YES
	{
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BULLHEADPROJ
	rand angvar 512
	sub angvar 256
	add angvar sprite[].htang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	}
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BULLARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BULLLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BULLLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	

ends

defstate bigboi_body_jibs

	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BBHEADJIBPROJ
	rand angvar 512
	sub angvar 256
	add angvar sprite[].htang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal

	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BBARMJIBPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BBARMJIBPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BBLEGJIBPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BBLEGJIBPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal

ends

defstate beast_armslegs

	ifl sprite[].yrepeat 12 break
	ife padang 1337 break
	ifge padang 131313 ifle padang 131314 spritepal 27

	rand angvar 512
	sub angvar 256
	add angvar sprite[].htang
	seta[RETURN].ang angvar
	ifactor CYBERBEAST ifspritepal 24 seta[RETURN].pal 21 else
	ifspritepal 0 seta[RETURN].pal 15 else
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BEASTLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	ifactor CYBERBEAST ifspritepal 24 seta[RETURN].pal 21 else
	ifspritepal 0 seta[RETURN].pal 15 else
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BEASTLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	ifactor CYBERBEAST ifspritepal 24 seta[RETURN].pal 21 else
	ifspritepal 0 seta[RETURN].pal 15 else
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BEASTARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	ifactor CYBERBEAST ifspritepal 24 seta[RETURN].pal 21 else
	ifspritepal 0 seta[RETURN].pal 15 else
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BEASTARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	ifactor CYBERBEAST ifspritepal 24 seta[RETURN].pal 21 else
	ifspritepal 0 seta[RETURN].pal 15 else
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132

ends

defstate beast_body_jibs

	ifl sprite[].yrepeat 12 break
	ife padang 1337 break
	ifge padang 131313 ifle padang 131314 spritepal 27

	rand zdist 1024
	sub zdist 3500
	ezshoot zdist BEASTHEADPROJ
	ifactor NEWBEAST
	ifspritepal 0 seta[RETURN].pal 15 else
	seta[RETURN].pal sprite[].pal
	state beast_armslegs

ends

defstate arrow_bits

	rand zdist 1024
	sub zdist 3072
	ezshoot zdist ARROWBIT1
	rand angvar 1024
	add angvar 512
	add angvar sprite[].ang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3072
	ezshoot zdist ARROWBIT2
	rand angvar 1024
	add angvar 512
	add angvar sprite[].ang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	rand zdist 1024
	sub zdist 3072
	ezshoot zdist ARROWBIT3
	rand angvar 1024
	add angvar 512
	add angvar sprite[].ang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal

ends

defstate sawblade_bits

	rand zdist 1024
	sub zdist 3072
	ezshoot zdist ARROWBIT1
	rand angvar 1024
	add angvar 512
	add angvar sprite[].ang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3072
	ezshoot zdist ARROWBIT1
	rand angvar 1024
	add angvar 512
	add angvar sprite[].ang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	debris SCRAP6 4

ends

defstate randgetweapsnds
  ife pchar 4 ifactor HBOMBAMMO { ifrnd 128 globalsound PICKUP_DOLL else globalsound DEA_ADORABLE break }
  ife VOLUME 6 ifl LEVEL 11 ifl pchar 2 rand temp 18
  else
  rand temp 12
  switch temp
  case 0 globalsound BIGGUNS break
  case 1 case 2 globalsound DUKE_GETWEAPON2 break
  case 3 case 4 globalsound DUKE_GETWEAPON3 break
  case 5 case 6 globalsound DUKE_GETWEAPON4 break
  case 7 case 8 globalsound DUKE_GETWEAPON5 break
  case 9 case 10 globalsound DUKE_GETWEAPON1 break
  case 11 case 12 globalsound DUKE_GETWEAPON6 break
  case 13 case 14 globalsound VACA_GETWEAP1 break
  case 15 case 16 globalsound VACA_GETWEAP2 break
  case 17 case 18 globalsound VACA_GETWEAP3 break
  endswitch
ends

defstate standard_jibs

  ife padang 1337 { state spawnoutline break }
  
  ifge padang 131313 ifle padang 131314 spritepal 27
  
  rand zdist 1024
  sub zdist 3500
  ezshoot zdist HEARTPROJ
  rand angvar 512
  sub angvar 256
  add angvar sprite[].htang
  seta[RETURN].ang angvar
  seta[RETURN].pal sprite[].pal

  guts JIBS2 1
  guts JIBS3 2
  guts JIBS4 3
  guts JIBS5 2
  guts JIBS6 3
  ifrnd 6
  {
    guts JIBS1 1
    ifspritepal 1 spawn BLOODPOOL else
    spawn BLOODPOOL2
  
  }         // a badly drawn spine

  ifn team 3
  ifn team 1
  state jib_sounds
ends

state mando_body_jibs

	ifn sprite[].picnum APLAYER ifge padang 131313 ifle padang 131314 spritepal 27

	rand zdist 1024
	sub zdist 3500
	ezshoot zdist MANDOHEADPROJ
	rand angvar 512
	sub angvar 256
	add angvar sprite[].htang
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist MANDOLEGPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist MANDOCHESTPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist MANDOARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	
	rand zdist 1024
	sub zdist 3500
	ezshoot zdist MANDOARMPROJ
	rand angvar 2047
	seta[RETURN].ang angvar
	seta[RETURN].pal sprite[].pal
	seta[RETURN].cstat 132

ends

defstate lite_jibs

  ife padang 1337 { state spawnoutline break }
  
  ifge padang 131313 ifle padang 131314 spritepal 27

  guts JIBS2 1
  guts JIBS3 1
  guts JIBS4 1
  guts JIBS5 1
  guts JIBS6 2
  ifrnd 6
  {
    guts JIBS1 1
    ifspritepal 1 spawn BLOODPOOL else
    spawn BLOODPOOL2
  }
  
  rand zdist 1024
  sub zdist 3500
  ezshoot zdist HEARTPROJ
  rand angvar 512
  sub angvar 256
  add angvar sprite[].htang
  seta[RETURN].ang angvar
  seta[RETURN].pal sprite[].pal

  state jib_sounds
ends

defstate standard_pjibs
  guts JIBS1 1
  guts JIBS3 2
  guts JIBS4 1
  guts JIBS5 1
  guts JIBS6 2
  ife pchar 3 state mando_body_jibs
  else
  {
  guts DUKETORSO 1
  guts DUKELEG 2
  guts DUKEGUN 1
  }
  ife gametype 0 ifrnd 16 money 1
ends

defstate tech_debris

	ifge padang 131313 ifle padang 131314 spritepal 27

	rand zdist 844
	sub zdist 2560
	ezshoot zdist MECHDEBRIS1
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	
	set zdist sprite[].xrepeat
	set temp tiledata[sprite[].picnum].xsize
	add temp tiledata[sprite[].picnum].ysize
	mul zdist temp
	shiftr zdist 8
	sub zdist 4
	ifl zdist 9 set zdist 9, ifg zdist 255 set zdist 255
	seta[RETURN].xrepeat zdist
	seta[RETURN].yrepeat zdist
	
	rand zdist 844
	sub zdist 2560
	ezshoot zdist MECHDEBRIS2
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	
	set zdist sprite[].xrepeat
	set temp  tiledata[sprite[].picnum].xsize
	add temp tiledata[sprite[].picnum].ysize
	mul zdist temp
	shiftr zdist 8
	sub zdist 4
	ifl zdist 9 set zdist 9, ifg zdist 255 set zdist 255
	seta[RETURN].xrepeat zdist
	seta[RETURN].yrepeat zdist
	
	rand zdist 644
	sub zdist 768
	ezshoot zdist MECHDEBRIS3
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	
	set zdist sprite[].xrepeat
	set temp  tiledata[sprite[].picnum].xsize
	add temp tiledata[sprite[].picnum].ysize
	mul zdist temp
	shiftr zdist 9
	sub zdist 2
	ifl zdist 7 set zdist 7, ifg zdist 255 set zdist 255
	seta[RETURN].xrepeat zdist
	seta[RETURN].yrepeat zdist
	
	rand zdist 644
	sub zdist 768
	ezshoot zdist MECHDEBRIS3
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	
	set zdist sprite[].xrepeat
	set temp tiledata[sprite[].picnum].xsize
	add temp tiledata[sprite[].picnum].ysize
	mul zdist temp
	// shiftr zdist 9
	div zdist 768
	sub zdist 2
	ifl zdist 7 set zdist 7, ifg zdist 255 set zdist 255
	seta[RETURN].xrepeat zdist
	seta[RETURN].yrepeat zdist
ends

defstate wood_debris

	rand zdist 844
	sub zdist 2560
	ezshoot zdist WOODDEBRIS
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	
	rand zdist 844
	sub zdist 2560
	ezshoot zdist WOODDEBRIS
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	
	rand zdist 844
	sub zdist 2560
	ezshoot zdist WOODDEBRIS
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	
	rand zdist 844
	sub zdist 2560
	ezshoot zdist WOODDEBRIS
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140

ends

defstate pottery_debris

	rand zdist 844
	sub zdist 2560
	ezshoot zdist POTDEBRIS1
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	seta[RETURN].pal sprite[].pal
	seta[RETURN].alpha sprite[].alpha
	
	rand zdist 844
	sub zdist 2560
	ezshoot zdist POTDEBRIS2
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	seta[RETURN].pal sprite[].pal
	seta[RETURN].alpha sprite[].alpha
	
	rand zdist 844
	sub zdist 2560
	ezshoot zdist POTDEBRIS3
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	seta[RETURN].pal sprite[].pal
	seta[RETURN].alpha sprite[].alpha
	
	rand zdist 844
	sub zdist 2560
	ezshoot zdist POTDEBRIS4
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	seta[RETURN].pal sprite[].pal
	seta[RETURN].alpha sprite[].alpha
	
	rand zdist 844
	sub zdist 2048
	ezshoot zdist POTDEBRIS1
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	seta[RETURN].pal sprite[].pal
	seta[RETURN].alpha sprite[].alpha
	
	rand zdist 844
	sub zdist 2048
	ezshoot zdist POTDEBRIS2
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	seta[RETURN].pal sprite[].pal
	seta[RETURN].alpha sprite[].alpha
	
	rand zdist 844
	sub zdist 2048
	ezshoot zdist POTDEBRIS3
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	seta[RETURN].pal sprite[].pal
	seta[RETURN].alpha sprite[].alpha
	
	rand zdist 844
	sub zdist 2048
	ezshoot zdist POTDEBRIS4
	rand zdist 2048
	seta[RETURN].ang zdist
	rand zdist 3
	ife zdist 0 seta[RETURN].cstat 128 else
	ife zdist 1 seta[RETURN].cstat 132 else
	ife zdist 2 seta[RETURN].cstat 136 else
	ife zdist 3 seta[RETURN].cstat 140
	seta[RETURN].pal sprite[].pal
	seta[RETURN].alpha sprite[].alpha

ends

defstate splatcode
	ifmove 0
	{
		geta[].ang angvar
		add angvar 1024
		seta[].ang angvar
		move STOPPED
		ifactor CRUSHANT sizeat 6 6 else
		ifactor CRUSHOCTABRAIN sizeat 2 2 else
		ifactor CRUSHLIZDOG sizeat 5 5 else
		ifactor CRUSHMECHBRAIN sizeat 5 5 else
		sizeat 4 4
		cstat 32
		cstator 256
		strength 10
		ifn sector[].floorslope 0 killit
	}
	fall
	ifhitweapon
	{
		ifdead { guts JIBS6 6 screensound SQUISHED killit }
		else guts JIBS6 2
		
	}
	ifcount 2 ifn myspawner -1 ife sprite[myspawner].statnum 1
	ife actorvar[myspawner].monstatus 1 killit
ends

useractor notenemy CRUSHARMPIG 20 state splatcode enda
useractor notenemy CRUSHLIZELITE 20 state splatcode enda
useractor notenemy CRUSHNEWBEAST 20 state splatcode enda
useractor notenemy CRUSHMECHBRAIN 20 state splatcode enda
useractor notenemy CRUSHLIZMAN 20 state splatcode enda
useractor notenemy CRUSHCOMMANDER 20 state splatcode enda
useractor notenemy CRUSHOCTABRAIN 20 state splatcode enda
useractor notenemy CRUSHLIZRANGER 20 state splatcode enda
useractor notenemy CRUSHSPACEBULL 20 state splatcode enda
useractor notenemy CRUSHPIGCOP 20 state splatcode enda
useractor notenemy CRUSHLIZTROOP 20 state splatcode enda
useractor notenemy CRUSHANT 20 state splatcode enda
useractor notenemy CRUSHZOMBIE 20 state splatcode enda
useractor notenemy CRUSHBATLORD 20 state splatcode enda
useractor notenemy CRUSHLIZDOG 20 state splatcode enda

action ASABDETH1	 0  1  1  1  50
action ASABDETH2_6	 1  6  1  1  18
action ASABDETH2_5   1  5  1  1  18
action ASABDED_6  	 6  1  1  1  10
action ASABDED_5  	 5  1  1  1  10

state sabdethcode

	fall
	ifmove 0
	{
		move STOPPED
		cstator 256
		seta[].htflags 8388611
		getp[].max_actors_killed temp
		sub temp 1
		setp[].max_actors_killed temp
	}
	set temp NO
	ifaction ASABDED_6 set temp YES
	ifaction ASABDED_5 set temp YES
	ife temp YES
	{
		ifvarand sprite[].cstat 256
		{
			geta[].cstat temp
			xorvar temp 256
			seta[].cstat temp
		}
		state predamage
		ifhitweapon
		{
			strength 0
			set temp NO
			ifwasweapon RADIUSEXPLOSION set temp YES
			ifwasweapon RPG set temp YES
			ife temp YES
			{
				sound SQUISHED
				state standard_jibs
				killit
			}	
		}
		break
	}
	ifaction ASABDETH1
	{
		ifactioncount 1
		{
			ife countvar 6 action ASABDETH2_6 else
			ife countvar 5 action ASABDETH2_5
			ifhitweapon { } strength 0
		}
		break
	}
	ifaction ASABDETH2_5 ifactioncount 5 { sound THUD action ASABDED_5 } else
	ifaction ASABDETH2_6 ifactioncount 6 { sound THUD action ASABDED_6 }

ends

useractor enemy NEWTSABERDEATH 0 ASABDETH1 set countvar 6 state sabdethcode enda
useractor enemy LIZMANSABERDEATH 0 ASABDETH1 set countvar 6 state sabdethcode enda
useractor enemy NEWPIGSABERDEATH 0 ASABDETH1 set countvar 6 state sabdethcode enda
useractor enemy DEASABERDEATH 0 ASABDETH1 set countvar 5 state sabdethcode enda
useractor enemy MANDOSABERDEATH 0 ASABDETH1 set countvar 5 state sabdethcode enda
useractor enemy SYTHSABERDEATH 0 ASABDETH1 set countvar 5 state sabdethcode enda
useractor enemy SITHSABERDEATH 0 ASABDETH1 set countvar 5 state sabdethcode enda

defstate genericshrunkcode

  
  ifcount SHRUNKMINUSONE sound UNSHRINK
  ifcount 32
  {
    ifpdistl SQUISHABLEDISTANCE
	{
		ifn team 1 ifn team 3
		{
			pstomp
			ifactor STRIPPER
			ifn initsprite 0
			{
				seta[].hitag initsprite
				respawnhitag
				set initsprite 0
			}
			ifactor HOOKER
			ifn initsprite 0
			{
				seta[].hitag initsprite
				respawnhitag
				set initsprite 0
			}
			ifactor KBABE
			ifn initsprite 0
			{
				seta[].hitag initsprite
				respawnhitag
				set initsprite 0
			}
			ifactor CAVEGIRL
			ifn initsprite 0
			{
				seta[].hitag initsprite
				respawnhitag
				set initsprite 0
			}
			ifactor POLEDANCER
			ifn initsprite 0
			{
				seta[].hitag initsprite
				respawnhitag
				set initsprite 0
			}
			ifactor NAKEDBABE
			ifn initsprite 0
			{
				seta[].hitag initsprite
				respawnhitag
				set initsprite 0
			}
		}
	}
	else ife team 0 ife monstatus 1
	{
		findnearactorz SHELLY 644 6144 spriteid
		ifn spriteid -1 ifg sprite[spriteid].xrepeat 12 { seta[].htpicnum RPG seta[].htextra 1000 seta[].htowner spriteid }
		else
		findnearactorz DUKEBOT 644 6144 spriteid
		ifn spriteid -1 ifg sprite[spriteid].xrepeat 12 { seta[].htpicnum RPG seta[].htextra 1000 seta[].htowner spriteid }
		else
		findnearactorz DEANOVA 644 6144 spriteid
		ifn spriteid -1 ifg sprite[spriteid].xrepeat 12 { seta[].htpicnum RPG seta[].htextra 1000 seta[].htowner spriteid }
		else
		findnearactorz WESBOT 644 6144 spriteid
		ifn spriteid -1 ifg sprite[spriteid].xrepeat 12 { seta[].htpicnum RPG seta[].htextra 1000 seta[].htowner spriteid }
	}
  }
  else
  {
    ifg sprite[].xrepeat 64 { sizeto MINXSTRETCH MINYSTRETCH }
	ifg sprite[].xrepeat 40 { sizeto MINXSTRETCH MINYSTRETCH }
	
	ife upscaled YES
	{
		sizeto MINXUPSTRETCH MINYUPSTRETCH
	}
	else
    sizeto MINXSTRETCH MINYSTRETCH
    spawn FRAMEEFFECT1
  }
ends

defstate spawnbabe
	globalsound NEWBABE
	espawn TRANSPORTERSTAR 
	seta[RETURN].cstat 32768 
	seta[RETURN].pal 91
	rand B 24
	switch B
	case 0 set B FEMCIV break
	case 1 set B FEMCIV2 break
	case 2 set B STRIPPER break
	case 3 case 4 set B KBABE break
	// case 4 set B HOOKER break
	case 5 set B CHEERLEADER break
	case 6 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B MALECIV1
	break
	case 7 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B MALECIV2 
	break
	case 8 set B CAVEGIRL break
	case 9 set B BIKINIBABE break
	case 10 set B BIKINIBABE2 break
	case 11 case 12 set B NAKEDBABE break
	case 13 set B CRYSTAL break
	case 14 set B FEMCIV3 break
	case 15 set B SCHOOLGIRL break
	case 16 set B FEMCIV4 break
	case 17 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B ALIENCIVFEM break
	case 18 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B ALIENCIVMALE break
	case 19 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B MALECIV3 break
	case 20 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B GUARD break
	case 21 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B HOOKER2 break
	case 22 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B MALECIV4 break
	case 23 set B FEMCIV5 break
	case 24 ifactor NEWPIG set B PIGSTRIPPER 
		 else set B MALECIV5 break
	default set B FEMCIV break
	endswitch
	
	ifactor ARMYANT set B ANT
	ifactor ARMYANTCRAWL set B ANT
	espawnvar B
	ife B ANT espawn MALECIV3
	rand pal 13
	add pal 10
	ife pal 17 set pal 0 else
	ife pal 19 set pal 0 else
	ife pal 20 set pal 0

	ifvarand dukeupgrades[GROW_WEAPON] 1 
	{
		set pal 49
		setav[RETURN].monstflags 8192
		setav[RETURN].inithp 100
		setav[RETURN].team 1
	}
	seta[RETURN].pal pal
	setav[RETURN].teamspawned 99999
ends

defstate makeally

	ife gametype 0
	{
	globalsound NEWBABE
	espawn TRANSPORTERSTAR 
	seta[RETURN].cstat 32768 
	seta[RETURN].pal 91
	ai 0
	move 0
	action 0
	cstator 256
	getlastpal
	spritepal 85
	set monxp 0
	seta[].extra inithp
	set monstatus 1
	ifn team 1 { set team 1 sub maxkills 1 }
	set botclip 0
	set countvar 0
	set countvarb 0
	set countvarc 0
	set myspawner -1
	set myvictim -1
	set bottarget -1
	set initsprite 0
	set stun 0
	set burning 0
	set gooify 0
	set bleeding 0
	set bluetimer 0
	set FEMKILLCOUNT 2400
	ifactor SITH set mtype 0
	ifactor SYTH set mtype 0
	ifactor EGG sizeat 40 40
	ifactor RECON sizeat 24 24
	ifactor COMMANDER sizeat 30 28
	set startx 0
	set shotpitch 0
	ifvarand monstflags 131072 xorvar monstflags 131072
	}
	else
	{
		sound NUKESOUND
		setactorsoundpitch THISACTOR NUKESOUND 512
		
		hitradius 5120 50 80 110 150
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			dist temp THISACTOR spriteid
			ifle temp 5120 seta[spriteid].htowner player[].i
			nextspritestat spriteid spriteid
		}
		espawn EXPLOSION2
		setav[RETURN].mtype BOMBSECTOR
		killit
	}
	

ends

defstate genericgrowcode

  ifl burning 0 set burning 0
  ifcount 32
  {
    guts JIBS4 2
    guts JIBS6 4
	//state standard_jibs
	//ifactor LIZTROOP state troop_body_jibs
	//ifactor LIZMAN state liz_body_jibs
	//ifactor NEWBEAST state liz_body_jibs
	ifn team 1 ifn team 3
		addkills 1 
	state enemy_death
	
    sound SQUISHED
    // sound PIPEBOMB_EXPLODE
    hitradius 2048 30 35 40 45
	headspritestat spriteid 1
	whilevarn spriteid -1
	{
		ife actorvar[spriteid].team 3
		{
			dist xydist THISACTOR spriteid
			ifle xydist 2048 seta[spriteid].htextra -1
		}
		ife sprite[spriteid].picnum SCHOOLGIRL seta[spriteid].htextra -1
		nextspritestat spriteid spriteid
	}

	
	ife pchar 4
	{
		ifrnd 96 state makeally else
		{
			state spawnbabe
			killit
		}
	}
	else
	{
		ifvarand dukeupgrades[GROW_WEAPON] 2
		state makeally else
		{
			state spawnbabe
			killit
		}
	}
	
  }
  else
  {
    ifcount 3 nullop else ifcount 2 
	{ 
		espawn GROUNDSHOCK 
		seta[RETURN].pal 49
	}
    ifspritepal 91 getlastpal else
	spritepal 91
	
    ifactor COMMANDER
	{
	  // ife upscaled YES sizeto 80 50 else
      sizeto 160 100
	}
    else
      ifactor SHARK
	{
	  // ife upscaled YES sizeto 42 42 else
        sizeto 84 84
	}
    else
	{
	  // ife upscaled YES sizeto 64 64 else
	  sizeto 128 MAXYSTRETCH
      // sizeto MAXXSTRETCH MAXYSTRETCH
	}
	geta[].xrepeat init_xrepeat
	geta[].yrepeat init_yrepeat
  }
ends

useractor notenemy MONSHADOW 0

	set temp player[].player_par
	add temp THISACTOR
	modvar temp 30
	ife temp 0
	{
		espawn BIGSMOKE2
		seta[RETURN].htflags 4
		seta[RETURN].shade 28
	}
	ife damflash 4 ife player[].heat_on YES cstat 258 else
	{ cstat 2 seta[].htextra -1 }

	ifg damflash 4 sub damflash 1
	
	cos xvel sprite[].ang
	sin yvel sprite[].ang
		  
	shiftr xvel 6
	shiftr yvel 6
	
	espawn SPEEDBLUR
	setav[RETURN].mtype sprite[].htdispicnum
	seta[RETURN].xrepeat sprite[].xrepeat
	seta[RETURN].yrepeat 4
	seta[RETURN].pal 4
	seta[RETURN].alpha 160
	seta[RETURN].mdflags 16
		 
	ifactornotstayput
	{
		movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN
		ifn RETURN 0 { rand angvar 2047 seta[].ang angvar }
		else ifrnd 4 { rand angvar 2047 seta[].ang angvar }
	}
	ife damflash 4
	{
		ifrnd 2
		{
			sound FLAMEDRAWIN
			seta[].picnum mysignpost
			set mysignpost 0 // also a counter
			cstat 257
		}
		else ifpdistl 2048
		ifrnd 6
		{
			sound FLAMEDRAWIN
			seta[].picnum mysignpost
			set mysignpost 0 // also a counter
			cstat 257
		}
		else ifhitweapon
		{
			sound FLAMEDRAWIN
			seta[].picnum mysignpost
			set mysignpost 0 // also a counter
			cstat 257
		}
	}

enda


state headhitstate

// Unrem the following line to invoke screen tilting during
// low player hitpoint damage.

// wackplayer

ends

state random_ooz
  ifrnd 128
    spawn OOZ2
  else
    spawn OOZ
ends

state random_wall_jibs
  ifrnd 96
    shoot BLOODSPLAT1
  ifrnd 96
    shoot BLOODSPLAT2
  ifrnd 96
    shoot BLOODSPLAT3
  ifrnd 96
    shoot BLOODSPLAT4
  ifrnd 96
    shoot BLOODSPLAT1
ends

defstate drop_ammo
  ifg gametype 0 break
  
  ifvarand charsel 4
  {
	ifvarand wesupgrades[PISTOL_WEAPON] 4 nullop else
	{
		ifrnd 80 { spawn FIRSTGUNSPRITE break }
	}
  }
  ife player[].gotweapon PISTOL_WEAPON NO
  {
    ifrnd SPAWNAMMOODDS { spawn FIRSTGUNSPRITE break }
  }
  ifrnd 24
  {
	state rand_db_bow
	break
  }
  ifrnd SPAWNAMMOODDS
    spawn AMMO
  else
  ifvarand initflags 16
    spawn AMMO
	
ifvarand inven_upgrades 32
  ifle cover_amount 200
  ife random_items NO
	ifrnd 64
		spawn COVERSPRITE
else
	ifle player[].holoduke_amount 1200
	ife random_items NO
	ifrnd 24
	{
		espawn HOLODUKE
		setav[RETURN].initsprite YES
	}
ends

defstate drop_battery
  ifg gametype 0 break
  ifrnd SPAWNAMMOODDS
    spawn BATTERYAMMO
ends
defstate drop_sgshells
  ifg gametype 0 break
  ifrnd SPAWNAMMOODDS
    spawn SHOTGUNAMMO
ends
defstate drop_shotgun
  ifg gametype 0 break
  ifrnd SPAWNAMMOODDS
  {
    ifrnd 48
	{
		state rand_db_bow
	}
	else
	{
		espawn SHOTGUNSPRITE
		setav[RETURN].droptile PIGCOP
	}
	sound ENDSEQVOL2SND1
  }
  else ifvarand initflags 8
  {
	espawn SHOTGUNSPRITE
	setav[RETURN].droptile PIGCOP
	sound ENDSEQVOL2SND1
  }
ends


state drop_chaingun
  ifg gametype 0 break
  ifrnd SPAWNAMMOODDS
  {
    ifactor LIZMAN ifvarand initflags 8 { espawn GROWSPRITEICON break }
    ifrnd 32
	{
      spawn CHAINGUNSPRITE
	  sound ENDSEQVOL2SND1
	}
    else
	ifrnd 32
	{
		state rand_db_bow
	}
	else 
      spawn BATTERYAMMO
  }
ends

defstate giftcheck
	ife pchar 0
	ifvarand perks 128
	ife botclip 0
	{
		set botclip YES
		quote 1359
		
		ifrnd 128
		{
			ifrnd 128 espawn AMMO else
			espawn COLA
		}
		else
		{
			state spawn_goodie2
			geta[RETURN].z z, sub z 8192, seta[RETURN].z z
			espawn TRANSPORTERSTAR
			geta[RETURN].z z, sub z 8192, seta[RETURN].z z
		}
	}
ends

actor KNEE KNEE_WEAPON_STRENGTH enda
actor SPIT SPIT_WEAPON_STRENGTH enda
actor CHAINGUN CHAINGUN_WEAPON_STRENGTH enda
actor SHOTGUN SHOTGUN_WEAPON_STRENGTH enda
actor FIRELASER FIRELASER_WEAPON_STRENGTH enda
actor HEAVYHBOMB HANDBOMB_WEAPON_STRENGTH enda
actor BOUNCEMINE BOUNCEMINE_WEAPON_STRENGTH enda
actor MORTER MORTER_WEAPON_STRENGTH enda
actor SHRINKSPARK SHRINKER_WEAPON_STRENGTH enda

move TOPLAYER 32
actor GROWSPARK GROWSPARK_WEAPON_STRENGTH

ifmove 0 
{
	move TOPLAYER faceplayer 
	ifspawnedby LOVEBOMB cstator 130 
}

  ifcount 18
    killit
  else
    ifcount 9
  {
    sizeto 0 0
    sizeto 0 0
    sizeto 0 0
    sizeto 0 0
  }
  else
  {
    ifspawnedby LOVEBOMB { sizeto 10 10 sizeto 10 10 }
	else
	{
    sizeto 28 28
    sizeto 28 28
    sizeto 28 28
    sizeto 28 28
	}
  }
enda

actor RPG RPG_WEAPON_STRENGTH 

	ifn myvictim -1 // hold position
	{
		
		getactor[myvictim].x x
		getactor[myvictim].y y
		getactor[myvictim].ang angvar
		subvarvar angvar angvel
		setvarvar x2 x
		addvarvar x2 mtype
		rotatepoint x y x2 y angvar x y
		setactor[].x x
		setactor[].y y

		setactor[].ang angvar
		getactor[myvictim].z z
		subvarvar z shotpitch
		setactor[].z z
		
		set spriteid myvictim
		state facesprite
		
		ife sprite[myvictim].statnum 1024 set countvar 30
		ife actorvar[myvictim].monstatus 2 set countvar 30
		add countvar 1
		ifge countvar 30
		{
			spawn EXPLOSION2
			sound RPG_EXPLODE
			hitradius RPGBLASTRADIUS 30 60 100 RPG_WEAPON_STRENGTH
			headspritestat spriteid 1
			whilevarn spriteid -1
			{
				dist xydist THISACTOR spriteid
				ifle xydist RPGBLASTRADIUS
				{
					seta[spriteid].htpicnum RPG
					seta[spriteid].htowner player[].i
				}
				nextspritestat spriteid spriteid
			}
			ifpdistl RPGBLASTRADIUS
			{
				seta[player[].i].htextra -1
				seta[player[].i].htpicnum RPG
				seta[player[].i].htowner player[].i
			}
			killit
		}
		
	}

enda
actor FREEZEBLAST FREEZETHROWER_WEAPON_STRENGTH enda
actor DEVISTATORBLAST FREEZETHROWER_WEAPON_STRENGTH enda
actor COOLEXPLOSION1 COOL_EXPLOSION_STRENGTH enda

action COOLFRAMES -2  20  1  1  4
useractor notenemy COOLEXPLOSION2 0 COOLFRAMES

	ifmove 0
	{
		move STOPPEDFORPLAYER
		cstat 130
		seta[].blend 1
		sizeat 48 42
		sound WEIRDLOOP
	}
	ifactioncount 20 killit
	
	ifcansee
	ifpdistl 8192
	ife pdown NO
	{
		set spriteid player[].i
		geta[spriteid].x x2
		geta[spriteid].y y2
		sub x2 sprite[].x
		sub y2 sprite[].y
		getangle angvar x2 y2
		add angvar 1024
		cos xvel angvar
		sin yvel angvar
		mul xvel 48
		mul yvel 48
		add xvel player[].posxv
		add yvel player[].posyv
		setplayer[].posxv xvel
		setplayer[].posyv yvel
	}
	
	headspritestat spriteid 1
	whilevarn spriteid -1
	{
		dist xydist THISACTOR spriteid
		ifl xydist 8192
		{
			geta[].z savz
			sub savz 10240
			seta[].z savz
			canseespr THISACTOR spriteid temp
			add savz 10240
			seta[].z savz
			ife temp YES
			{
				ifn actorvar[spriteid].team team
				ifn actorvar[spriteid].monstatus 2
				ifn actorvar[spriteid].monstatus 100
				{
					geta[spriteid].x x2
					geta[spriteid].y y2
					sub x2 sprite[].x
					sub y2 sprite[].y
					getangle angvar x2 y2
					add angvar 1024
					cos xvel angvar
					sin yvel angvar
					div xvel 40
					div yvel 40
					movesprite spriteid xvel yvel 0 CLIPMASK0 RETURN
				}
			}
		}
		nextspritestat spriteid spriteid
	}
	
enda

actor TRIPBOMB TRIPBOMB_STRENGTH enda

defstate clawclashsound

	ifg player[].player_par clawclashtime
	{
		ifrnd 84 sound DEAHITMETAL else
		ifrnd 128 sound DEAHITMETAL2 else
		sound DEAHITMETAL3
		set clawclashtime player[].player_par
		add clawclashtime 5
	}

ends

defstate checkbleeding
	
	
	ifspawnedby APLAYER
	{
		set temp NO
		ife player[].curr_weapon PISTOL_WEAPON
		{
			ife pchar 0 ifvarand dukeupgrades[PISTOL_WEAPON] 1 set temp YES
			ife pchar 1 ifvarand shellyupgrades[PISTOL_WEAPON] 1 set temp YES
			ife pchar 2 ifvarand wesupgrades[PISTOL_WEAPON] 1 set temp YES
		}
		
		ifvarand gotshock 2 nullop else
		ife player[].curr_weapon CHAINGUN_WEAPON
		{
			ife pchar 0 ifvarand dukeupgrades[CHAINGUN_WEAPON] 2 set temp YES
			ife pchar 1 ifvarand shellyupgrades[CHAINGUN_WEAPON] 2 set temp YES
			ife pchar 2 ifvarand wesupgrades[CHAINGUN_WEAPON] 2 set temp YES
			ife pchar 3 ifvarand mandoupgrades[CHAINGUN_WEAPON] 2 set temp YES
		}
		// ife player[].curr_weapon GROW_WEAPON ife pchar 2 set temp YES
		
		ife sprite[hitsprite].picnum ARMPIG ife actorvar[hitsprite].mtype 0 break
		ife sprite[hitsprite].picnum ARMLIZTROOP ife actorvar[hitsprite].mtype 0 break
		
		ife temp YES
		{
			ifn hitsprite -1
			ife sprite[hitsprite].htpicnum SHOTSPARK1
			ifg sprite[hitsprite].htextra 1
			ifn actorvar[hitsprite].monstatus 2
			{
				ife actorvar[hitsprite].team 1
				ifvarand perks 8 nullop else
				{
					geta[hitsprite].htextra temp
					ife temp -1 set temp 0
					shiftr temp 1
					getav[hitsprite].bleeding tempb
					ifl tempb 0 mul tempb -1
					add tempb temp
					setav[hitsprite].bleeding tempb
					seta[hitsprite].htowner player[].i
					espawn WOUNDSPRITE
					geta[hitsprite].picnum picnum
					switch picnum // should still be set from list that brought us here
						case NEWBEAST
						case CYBERBEAST case CRONEN
						case ZOMBIE case ARMYANT case ARMYANTCRAWL
						case EGG
						case BOSS4
							seta[RETURN].pal 6 // 8
						break
					endswitch
				}
			}
		}
		
		espawn JIBS6
		seta[RETURN].zvel 0
		seta[RETURN].xvel 24
		randvar temp 2047
		seta[RETURN].ang temp
		seta[RETURN].xrepeat 14
		seta[RETURN].yrepeat 14
		geta[hitsprite].picnum picnum
		switch picnum // should still be set from list that brought us here
			case NEWBEAST
			case CYBERBEAST case CRONEN
			case ZOMBIE case ARMYANT case ARMYANTCRAWL
			case EGG
			case BOSS4
				seta[RETURN].pal 6 // 8
			break
		endswitch

		ifrnd 48
		{
			ifrnd 64 espawn BLOODSPLASH1 else
			ifrnd 128 espawn BLOODSPLASH2 else
			espawn BLOODSPLASH3
			geta[hitsprite].picnum picnum
			switch picnum // should still be set from list that brought us here
			case NEWBEAST
			case CYBERBEAST case CRONEN
			case ZOMBIE case ARMYANT case ARMYANTCRAWL
			case BOSS4
			case EGG
				seta[RETURN].pal 6 // 8
			break
			endswitch
		}
	}

ends

// DUKE ALT COSTUME PLAYER ACTIONS
action ALTDUKEGROWING   7681
action ALTDUKESTAND     7681   1   5   1  1
action ALTDUKEEXPLODE   7771   5   1   1   10
action ALTDUKEEXPLODEAD   7776   1   1
action ALTDUKEJPHOUVER  7686   1   5   1
action ALTDUKEWALK    7691   4   5   1   16
action ALTDUKERUN     7691   4   5   1   10
action ALTDUKEWALKBACK  7706   4   5  -1   16
action ALTDUKERUNBACK   7706   4   5  -1   10
action ALTDUKEJUMPING   7721   3   5   1   30
action ALTDUKEFALLING   7731   1   5
action ALTDUKEDUCKING   7736   1   5
action ALTDUKECRAWLING  7736   3   5   1   20
action ALTDUKEKICKING  7711   2   5   1   25
action ALTDUKEFLINTCH  7771  1   1   1   10
action ALTDUKETHROWNBACK  7771  5   1   1   18
action ALTDUKEFROZEN     7691  1   5
action ALTDUKELYINGDEAD   7776  1   1

action ALTDUKEDOWN 7788 2  5  1  50

action ALTDUKESWIMMINGGO   7751   1   5   1   10
action ALTDUKESWIMMING   7751   4   5   1   13
action ALTDUKESWIMMINGWAIT 7756   1   5   1   13
action ALTDUKETREDWATER  7761   2   5   1   24


// BOMBSHELL PLAYER ACTIONS

action APSHELLYGROWING		5281
action APSHELLYSTAND		5281 1  5  1  1
action APSHELLYEXPLODE	    5371 5  1  1  10
action APSHELLYEXPLODEAD	5376 1  1  1  1
action APSHELLYHOUVER		5316 1  5  1  1
action APSHELLYWALK			5286 4  5  1  16
action APSHELLYRUN			5286 4  5  1  10
action APSHELLYWALKBACK		5301 4  5  -1  16
action APSHELLYRUNBACK		5301 4  5  -1 10
action APSHELLYJUMPING		5316 2  5  1  45 // changed from Duke
action APSHELLYFALLING		5321 1  5  1  1
action APSHELLYDUCKING		5326 1  5  1  1
action APSHELLYCRAWLING	    5331 4  5  1  18 // changed from Duke
action APSHELLYKICKING		5306 2  5  1  25
action APSHELLYFLINTCH	   	5371 1  1  1  10
action APSHELLYTHROWNBACK  	5371 5  1  1  18
action APSHELLYFROZEN		5286 1  5
action APSHELLYLYINGDEAD	5376 1  1

action APSHELLYSWIMMINGGO	5351 1  5  1  10
action APSHELLYSWIMMING		5351 4  5  1  13

action APSHELLYSWIMMINGWAIT		5366 1  5  1  13 // changed from Duke
action APSHELLYTREDWATER	5351 4  5  1  13 // changed from Duke

action APSHELLYDOWN		   5390 2  5  1  50
// END OF BOMBSHELL PLAYER ACTIONS

// WES PLAYER ACTIONS

action APWESGROWING		18071
action APWESGUNDOWN	    18076 1  5  1  1
action APWESSTAND		18081 1  5  1  1
action APWESEXPLODE	    18241 6  1  1  10
action APWESEXPLODEAD	18247 1  1  1  1
action APWESHOUVER		18106 1  5  1  1
action APWESWALK		18086 4  5  1  16
action APWESRUN			18086 4  5  1  10
action APWESWALKBACK	18101 4  5  -1  16
action APWESRUNBACK		18101 4  5  -1 10
action APWESJUMPING		18106 2  5  1  45
action APWESFALLING		18111 1  5  1  1
action APWESDUCKING		18116 1  5  1  1
action APWESCRAWLING	18121 4  5  1  18
action APWESTURN1		18161 4  5  1  8
action APWESTURN2		18181 3  5  1  16
action APWESKICKING		18171 5  5  1  8
action APWESFLINTCH	   	18242 1  1  1  10
action APWESTHROWNBACK  18241 6  1  1  18
action APWESFROZEN		18071 1  5
action APWESLYINGDEAD	18247 1  1

action APWESSWIMMINGGO	18141 1  5  1  10
action APWESGLIDING     18146 1  5  1  10
action APWESSWIMMING	18141 4  5  1  13

action APWESSWIMMINGWAIT 18156 1  5  1  13 // changed from Duke
action APWESTREDWATER	18141 4  5  1  13 // changed from Duke

action APWESDOWN		18248 2  5  1  50
// END OF WES PLAYER ACTIONS

// MANDO PLAYER ACTIONS

action APMANGROWING		12675
action APMANGUNDOWN	    12675 1  5  1  1
action APMANSTAND		12710 1  5  1  1
action APMANEXPLODE	    12800 6  1  1  10
action APMANEXPLODEAD	12811 1  1  1  1
action APMANHOUVER		12745 1  5  1  1
action APMANWALK		12715 4  5  1  16
action APMANRUN			12715 4  5  1  10
action APMANWALKBACK	12730 4  5  -1  16
action APMANRUNBACK		12730 4  5  -1 10
action APMANJUMPING		12745 2  5  1  45
action APMANFALLING		12750 1  5  1  1
action APMANDUCKING		12755 1  5  1  1
action APMANCRAWLING	12760 4  5  1  18

action APMANKICKING		12735 2  5  1  25
action APMANFLINTCH	   	12800 1  1  1  10
action APMANTHROWNBACK  12800 6  1  1  18
action APMANFROZEN		12675 1  5
action APMANLYINGDEAD	12805 1  1

action APMANSWIMMINGGO	12780 1  5  1  10
action APMANGLIDING     12785 1  5  1  10
action APMANSWIMMING	12780 4  5  1  13

action APMANSWIMMINGWAIT 12795 1  5  1  13 // changed from Duke
action APMANTREDWATER	12780 4  5  1  13 // changed from Duke

action APMANDOWN		13889  2  5  1  50
// END OF MANDO PLAYER ACTIONS

// DEA PLAYER ACTIONS

action APDEAGROWING		20616 // 18071
action APDEASTAND		20611 1  5  1  1  // with gun
action APDEAEXPLODE	    20811 6  1  1  10
action APDEAEXPLODEAD	20817 1  1  1  1
action APDEAHOUVER		20736 1  5  1  1
action APDEAWALK		20616 4  5  1  16  // with gun
action APDEAWALKBACK	20631 4  5  -1  16 // with gun
action APDEARUN			20616 4  5  1  10
action APDEARUNBACK  20631  4  5  -1  16

action APDEASTANDCLAW	20646  1  5  1  1  	// BLADES
action APDEACLAWING		20651  6  5  1  8
action APDEASTAB		20681  3  5  1  20
action APDEASTUCK		20691  1  5  1  10
action APDEARUNCLAW		20706  4  5  1  10
action APDEARUNBACKCLAW		20721 4  5  -1 10  // with blades
action APDEAJUMPING		20696 1  5  1  45  // with blades
action APDEAFALLING		20701 1  5  1  1   // with blades
action APDEADUCKING		20771 1  5  1  1   // with gun
action APDEACRAWLING	20771 4  5  1  18  // with gun

action APDEAKICKING		20818 2  5  1  25  // with gun
action APDEABLOCK		20741 1  5  1  10  // with blades
action APDEAFLINTCH	   	20746 2  1  1  10
action APDEATHROWNBACK  20811 6  1  1  18  // no weapon
action APDEAFROZEN		20616 1  5
action APDEALYINGDEAD	20817 1  1

action APDEASWIMMINGGO	20791 1  5  1  10  // with gun
action APDEAGLIDING     20796 1  5  1  10
action APDEASWIMMING	20791 4  5  1  13

action APDEASWIMMINGWAIT 20806 1  5  1  13 // changed from Duke
action APDEATREDWATER	20791 4  5  1  13 // changed from Duke

action APDEADOWN		20746 2  5  1  50
// END OF DEA PLAYER ACTIONS

action PGROWING   0
action PSTAND     0   1   5   1  1
action PEXPLODE   106   5   1   1   10
action PEXPLODEAD   113   1   1
action PJPHOUVER  15   1   5   1
action PWALK    20   4   5   1   16
action PRUN     20   4   5   1   10
action PWALKBACK  45   4   5  -1   16
action PRUNBACK   45   4   5  -1   10
action PJUMPING   50   4   5   1   30
action PFALLING   65   1   5
action PDUCKING   86   1   5
action PCRAWLING  86   3   5   1   20
action PAKICKING  40   2   5   1   25
action PFLINTCHING  106  1   1   1   10
action PTHROWNBACK  106  5   1   1   18
action PFROZEN     20  1   5
action PLYINGDEAD   113  1   1

action PSWIMMINGGO   375   1   5   1   10
action PSWIMMING   375   4   5   1   13
action PSWIMMINGWAIT 395   1   5   1   13
action PTREDWATER  395   2   5   1   17
action PDUKEDOWN 6161 2  5  1  50

move PSTOPED
move PSHRINK // used as a var only

defstate check_pstandard
  
  
  ife pchar 4
  {
    ifaction APDEACLAWING break
    ifaction APDEASTAB break
	ifaction APDEASTUCK break
	ifaction APDEABLOCK break
	// ife player[].curr_weapon KNEE_WEAPON action APDEASTANDCLAW else 
	ifp pstanding
	action APDEASTAND
  }
  ifp pwalking
  {
	ife pchar 1 action APSHELLYWALK else
	ife pchar 2 action APWESWALK else
	ife pchar 3 action APMANWALK else
	ife pchar 4 { 
	// ife player[].curr_weapon KNEE_WEAPON action APDEARUNCLAW else 
	action APDEAWALK } else
	ifvarand altcostume 2 action ALTDUKEWALK else
    action PWALK
  }
  else
    ifp pkicking
	{
	  ife pchar 1 action APSHELLYKICKING else
	  ife pchar 2 action APWESKICKING else
	  ife pchar 3 action APMANKICKING else
	  ife pchar 4 action APDEAKICKING else
	  ifvarand altcostume 2 action ALTDUKEKICKING else
      action PAKICKING
	}
  else
    ifg qk_proxy 10
  {
	  ife pchar 1 action APSHELLYKICKING else
	  ife pchar 2 action APWESKICKING else
	  ife pchar 3 action APMANKICKING else
	  ife pchar 4 action APDEAKICKING else
	  ifvarand altcostume 2 action ALTDUKEKICKING else
      action PAKICKING
  }
  else
    ifp pwalkingback
	{
	  ife pchar 1 action APSHELLYWALKBACK else
	  ife pchar 2 action APWESWALKBACK else
	  ife pchar 3 action APMANWALKBACK else
	  ife pchar 4 { 
	  // ife player[].curr_weapon KNEE_WEAPON action APDEARUNBACKCLAW else 
	  action APDEAWALKBACK } else
	  ifvarand altcostume 2 action ALTDUKEWALKBACK else
      action PWALKBACK
	}
  else
    ifp prunning
	{
	  ife pchar 1 action APSHELLYRUN else
	  ife pchar 2 action APWESRUN else
	  ife pchar 3 action APMANRUN else
	  ife pchar 4 { 
	  // ife player[].curr_weapon KNEE_WEAPON action APDEARUNCLAW else 
	  action APDEARUN } else
	  ifvarand altcostume 2 action ALTDUKERUN else
      action PRUN
	}
  else
    ifp prunningback
	{
	  ife pchar 1 action APSHELLYRUNBACK else
	  ife pchar 2 action APWESRUNBACK else
	  ife pchar 3 action APMANRUNBACK else
	  ife pchar 4 { 
	  // ife player[].curr_weapon KNEE_WEAPON action APDEARUNBACKCLAW else 
	  action APDEARUNBACK } else
	  ifvarand altcostume 2 action ALTDUKERUNBACK else
      action PRUNBACK
	}
  else
    ifp pjumping
	{
	  ife pchar 1 action APSHELLYJUMPING else
	  ife pchar 2 action APWESJUMPING else
	  ife pchar 3 action APMANJUMPING else
	  ife pchar 4 action APDEAJUMPING else
	  ifvarand altcostume 2 action ALTDUKEJUMPING else
      action PJUMPING
	}
  else
    ifp pducking
	{
	  ife pchar 1 action APSHELLYDUCKING else
	  ife pchar 2 action APWESDUCKING else
	  ife pchar 3 action APMANDUCKING else
	  ife pchar 4 action APDEADUCKING else
	  ifvarand altcostume 2 action ALTDUKEDUCKING else
      action PDUCKING
	}
	  
ends


defstate altdukeactions

	ifaction PGROWING action ALTDUKEGROWING
	ifaction PSTAND action ALTDUKESTAND
	ifaction PEXPLODE action ALTDUKEEXPLODE
	ifaction PEXPLODEAD action ALTDUKEEXPLODEAD
	ifaction PJPHOUVER action ALTDUKEJPHOUVER
	ifaction PWALK action ALTDUKEWALK
	ifaction PWALKBACK action ALTDUKEWALKBACK
	ifaction PRUN action ALTDUKERUN
	ifaction PRUNBACK action ALTDUKERUNBACK
	ifaction PJUMPING action ALTDUKEJUMPING
	ifaction PFALLING action ALTDUKEFALLING
	ifaction PDUCKING action ALTDUKEDUCKING
	ifaction PCRAWLING action ALTDUKECRAWLING
	ifaction PAKICKING action ALTDUKEKICKING
	ifaction PFLINTCHING action ALTDUKEFLINTCH
	ifaction PTHROWNBACK action ALTDUKETHROWNBACK
	ifaction PLYINGDEAD action ALTDUKELYINGDEAD
	ifaction PSWIMMINGGO action ALTDUKESWIMMINGGO
	ifaction PSWIMMING action ALTDUKESWIMMING
	ifaction PSWIMMINGWAIT action ALTDUKESWIMMINGWAIT
	ifaction PTREDWATER action ALTDUKETREDWATER
	ifaction PDUKEDOWN action ALTDUKEDOWN
	
	geta[].mdflags temp
	orvar temp 16
	seta[].mdflags temp

ends

defstate shellyactions

	ifaction PGROWING action APSHELLYGROWING
	ifaction PSTAND action APSHELLYSTAND
	ifaction PEXPLODE action APSHELLYEXPLODE
	ifaction PEXPLODEAD action APSHELLYEXPLODEAD
	ifaction PJPHOUVER action APSHELLYHOUVER
	ifaction PWALK action APSHELLYWALK
	ifaction PWALKBACK action APSHELLYWALKBACK
	ifaction PRUN action APSHELLYRUN
	ifaction PRUNBACK action APSHELLYRUNBACK
	ifaction PJUMPING action APSHELLYJUMPING
	ifaction PFALLING action APSHELLYFALLING
	ifaction PDUCKING action APSHELLYDUCKING
	ifaction PCRAWLING action APSHELLYCRAWLING
	ifaction PAKICKING action APSHELLYKICKING
	ifaction PFLINTCHING action APSHELLYFLINTCH
	ifaction PTHROWNBACK action APSHELLYTHROWNBACK
	ifaction PLYINGDEAD action APSHELLYLYINGDEAD
	ifaction PSWIMMINGGO action APSHELLYSWIMMINGGO
	ifaction PSWIMMING action APSHELLYSWIMMING
	ifaction PSWIMMINGWAIT action APSHELLYSWIMMINGWAIT
	ifaction PTREDWATER action APSHELLYTREDWATER
	
	geta[].mdflags temp
	orvar temp 16
	seta[].mdflags temp

ends

defstate manactions

	ife player[].ftq 47 { setp[].ftq 1403 ife player[].holoduke_on mylily setp[].fta 0 } else
	ife player[].ftq 48 { setp[].ftq 1404 ife player[].holoduke_on mylily setp[].fta 0 }

	ifge jumpjet 35 { action APMANGLIDING break }
	ifaction PGROWING action APMANGROWING
	ifaction PSTAND 
	{
		ifvarand bits 4 action APMANSTAND else
		ifn player[].kickback_pic 0 action APMANSTAND else
		action APMANGUNDOWN
	}
	ifaction PEXPLODE action APMANEXPLODE
	ifaction PEXPLODEAD action APMANEXPLODEAD
	ifaction PJPHOUVER action APMANHOUVER
	ifaction PWALK action APMANWALK
	ifaction PWALKBACK action APMANWALKBACK
	ifaction PRUN action APMANRUN
	ifaction PRUNBACK action APMANRUNBACK
	ifaction PJUMPING action APMANJUMPING
	ifaction PFALLING action APMANFALLING
	ifaction PDUCKING action APMANDUCKING
	ifaction PCRAWLING action APMANCRAWLING
	ifaction PAKICKING action APMANKICKING
	ifaction PFLINTCHING action APMANFLINTCH
	ifaction PTHROWNBACK action APMANTHROWNBACK
	ifaction PLYINGDEAD action APMANLYINGDEAD
	ifaction PSWIMMINGGO action APMANSWIMMINGGO
	ifaction PSWIMMING action APMANSWIMMING
	ifaction PSWIMMINGWAIT action APMANSWIMMINGWAIT
	ifaction PTREDWATER action APMANTREDWATER
	
	ife pchar 3
	{
		ifaction APMANSTAND
		ifactioncount 2
		{
			ifvarand bits 4 nullop else
			ifn player[].kickback_pic 0 nullop else
			action APMANGUNDOWN
		}
		else ifaction APMANGUNDOWN
		{
			ifvarand bits 4 action APMANSTAND else
			ifn player[].kickback_pic 0 action APMANSTAND
		}
	}
	geta[].mdflags temp
	orvar temp 16
	seta[].mdflags temp

ends

defstate deaactions

	ifaction APDEASTAB
	{
		ifactioncount 3 action APDEASTAND
	}
	ifaction APDEACLAWING
		ife saberpos 0 action APDEASTAND
		
	ifge saberpos 85 ifle saberpos 86
		action APDEABLOCK else
	// ifn saberpos 0 action APDEACLAWING
	// else
	ifaction APDEABLOCK action APDEASTAND
	
	ifaction PGROWING action APDEAGROWING
	ifaction PSTAND 
	{
		// ife player[].curr_weapon KNEE_WEAPON action APDEASTANDCLAW else
		action APDEASTAND
	}
	ifaction PEXPLODE action APDEAEXPLODE
	ifaction PEXPLODEAD action APDEAEXPLODEAD
	ifaction PJPHOUVER action APDEAHOUVER
	ifaction PWALK 
	{
		// ife player[].curr_weapon KNEE_WEAPON action APDEARUNCLAW else
		action APDEAWALK
	}
	
	ifaction PWALKBACK 
	{
		// ife player[].curr_weapon KNEE_WEAPON action APDEARUNBACKCLAW else
		action APDEAWALKBACK
	}
	
	ifaction PRUN
	{
		// ife player[].curr_weapon KNEE_WEAPON action APDEARUNCLAW else
		action APDEARUN
	}
	
	ifaction PRUNBACK 
	{
		// ife player[].curr_weapon KNEE_WEAPON action APDEARUNBACKCLAW else
		action APDEARUNBACK
	}
	
	ifaction PJUMPING action APDEAJUMPING
	ifaction PFALLING action APDEAFALLING
	ifaction PDUCKING action APDEADUCKING
	ifaction PCRAWLING action APDEACRAWLING
	ifaction PAKICKING action APDEAKICKING
	ifaction PFLINTCHING action APDEAFLINTCH
	ifaction PTHROWNBACK action APDEATHROWNBACK
	ifaction PLYINGDEAD action APDEALYINGDEAD
	ifaction PSWIMMINGGO action APDEASWIMMINGGO
	ifaction PSWIMMING action APDEASWIMMING
	ifaction PSWIMMINGWAIT action APDEASWIMMINGWAIT
	ifaction PTREDWATER action APDEATREDWATER
	
	geta[].mdflags temp
	orvar temp 16
	seta[].mdflags temp

ends


defstate wesactions

	ifaction PGROWING action APWESGROWING
	ifaction PSTAND 
	{
		ifvarand bits 4 action APWESSTAND else
		ifn player[].kickback_pic 0 action APWESSTAND else
		action APWESGUNDOWN
	}
	ifaction PEXPLODE action APWESEXPLODE
	ifaction PEXPLODEAD action APWESEXPLODEAD
	ifaction PJPHOUVER action APWESHOUVER
	ifaction PWALK action APWESWALK
	ifaction PWALKBACK action APWESWALKBACK
	ifaction PRUN action APWESRUN
	ifaction PRUNBACK action APWESRUNBACK
	ifaction PJUMPING action APWESJUMPING
	ifaction PFALLING action APWESFALLING
	ifaction PDUCKING action APWESDUCKING
	ifaction PCRAWLING action APWESCRAWLING
	ifaction PAKICKING action APWESKICKING
	ifaction PFLINTCHING action APWESFLINTCH
	ifaction PTHROWNBACK action APWESTHROWNBACK
	ifaction PLYINGDEAD action APWESLYINGDEAD
	ifaction PSWIMMINGGO action APWESSWIMMINGGO
	ifaction PSWIMMING action APWESSWIMMING
	ifaction PSWIMMINGWAIT action APWESSWIMMINGWAIT
	ifaction PTREDWATER action APWESTREDWATER
	
	ife pchar 2 
	{
		ifaction APWESSTAND
		ifactioncount 2
		{
			ifvarand bits 4 nullop else
			ifn player[].kickback_pic 0 nullop else
			action APWESGUNDOWN
		}
		else ifaction APWESGUNDOWN
		{
			ifvarand bits 4 action APWESSTAND else
			ifn player[].kickback_pic 0 action APWESSTAND
		}
		ifaction APWESTURN1
		{
			ifactioncount 4 action APWESTURN2
		}
		else
		ifaction APWESTURN2
		{
			ifactioncount 3 action APWESSTAND
		}
		ifg sidekick 0 ifl sidekick 10 { ifaction APWESTURN1 nullop else action APWESTURN1 }
		ifge sidekick 10 ifle sidekick 27 { ifaction APWESTURN2 nullop else action APWESTURN2 }
	}
	geta[].mdflags temp
	orvar temp 16
	seta[].mdflags temp

ends

defstate playerscorecheck

	ife gametime -1 break
	
	ifaction PEXPLODEAD set B 0 else
	ifaction PLYINGDEAD set B 1 else
	ifaction ALTDUKEEXPLODEAD set B 2 else
	ifaction ALTDUKELYINGDEAD set B 3 else
	set B 4
	
	ife gametype DM
	{
		ifactor APLAYER
		{
			ife pchar 0 add duke_deaths 1
			ife pchar 1 add shelly_deaths 1
			ife pchar 2 add wes_deaths 1
			ife pchar 3 add mando_deaths 1
		}
		else
		{
			ife pchar 0 add shelly_deaths 1
			ife pchar 1 add duke_deaths 1
			ife pchar 2 add wes_deaths 1
			ife pchar 3 add mando_deaths 1
		}
		
		geta[].htowner spriteid
		ifactor APLAYER set spriteid mykiller
		
		
		ifn spriteid -1
		{
			ifn actorvar[spriteid].team team
			{
				set temp NO
				ife sprite[spriteid].picnum MANDOFETT set temp YES
				ife sprite[spriteid].picnum MANDOCROUCH set temp YES
				ife temp YES
				{
					add enemy1_kills 1
					stopallsounds
					rand temp 4
					ife enemy1_kills 1 set temp 4 else
					ife enemy1_kills 2 set temp 0 else
					ife enemy1_kills 3 set temp 1 else
					ife enemy1_kills 4 set temp 2 else
					ife enemy1_kills 5 set temp 3
					ife temp 0 { globalsound MANDO_AMATEUR set subtitle_time 60 set subtitle_numlines 1 set subtitle_start 586 
					set cutcamtime player[].player_par
					set emp_overlay 60
					set emp_overlay_tile 15270
					}
					else
					ife temp 1 { globalsound MANDO_CORPSES set subtitle_time 120 set subtitle_numlines 1 set subtitle_start 587 
					set cutcamtime player[].player_par
					set emp_overlay 120
					set emp_overlay_tile 15270
					}
					else
					ife temp 2 { globalsound MANDO_LEVELS set subtitle_time 90 set subtitle_numlines 1 set subtitle_start 588 
					set cutcamtime player[].player_par
					set emp_overlay 90
					set emp_overlay_tile 15270
					
					}
					else
					ife temp 3 { globalsound MANDO_PATHETIC set subtitle_time 60 set subtitle_numlines 1 set subtitle_start 589 
					set cutcamtime player[].player_par
					set emp_overlay 60
					set emp_overlay_tile 15270
					
					}
					else
					ife temp 4 { globalsound MANDO_RESPAWNTOWN set subtitle_time 150 set subtitle_numlines 1 set subtitle_start 590 
					set cutcamtime player[].player_par
					set emp_overlay 150
					set emp_overlay_tile 15270
					
					}
				}
				ife sprite[spriteid].pal 12 add enemy1_kills 1
				ife sprite[spriteid].pal 10 add enemy2_kills 1
			}
			else
			{
				ife spriteid player[].i
				{
					ife pchar 0 { sub duke_kills 1 sub bluescore 1 }
					ife pchar 1 { sub shelly_kills 1 sub bluescore 1 }
					ife pchar 2 { sub wes_kills 1 sub bluescore 1 }
					ife pchar 3 { sub mando_kills 1 sub bluescore 1 }
					
				}
				ife spriteid myshelly
				{
					ifge sprite[myshelly].picnum SHELLY ifle sprite[myshelly].picnum SHELLYCROUCH { sub shelly_kills 1 sub bluescore 1 }
					ifge sprite[myshelly].picnum DUKEBOT ifle sprite[myshelly].picnum DUKEBOTCROUCH { sub duke_kills 1 sub bluescore 1 }
					ifge sprite[myshelly].picnum WESBOT ifle sprite[myshelly].picnum WESBOTCROUCH { sub wes_kills 1 sub bluescore 1 }
				}
				ifl duke_kills 0 set duke_kills 0
				ifl shelly_kills 0 set shelly_kills 0
				ifl wes_kills 0 set wes_kills 0
				ifl mando_kills 0 set mando_kills 0
				ifl bluescore 0 set bluescore 0
			}

		}
	}
	
	
	ifn gametype SURVIVAL
	{
		ifge bluescore scorelimit ifg bluescore redscore { setp[].timebeforeexit 180 set endgametime gametime set gametime -1 }
		ifge redscore scorelimit ifg redscore bluescore { setp[].timebeforeexit 180 set endgametime gametime set gametime -1 }
		
		ife gametime 0 ifn bluescore redscore { setp[].timebeforeexit 180 set endgametime gametime set gametime -1 }
	}
	ife gametype SURVIVAL ifactor APLAYER
	{
		set lastclock totalclock

		ife shellyinmap 0
		{
			set endgametime gametime
			set gametime -1
			set bluescore 0
			set redscore 1000
		}
	}

ends

gamevar random_sound 0 0
gamevar sound_temp 0 0

onevent EVENT_LOGO

stopsound FLY_BY

endevent

onevent EVENT_RECOGSOUND

ifl actorvar[].burning 0 set RETURN -1

endevent

onevent EVENT_SOUND

ifn soundstopper 0 { set RETURN -1 break }

// ifsound PROT_BIGSPEECH { set RETURN -1 break }
// ifsound UNBALANCED { set RETURN -1 break }
// ifsound DOMINATION { set RETURN -1 break }
// ifsound DENIED { set RETURN -1 break }
// ifsound HEELTURN { set RETURN -1 break }
// ifsound ONLINEPOLL { set RETURN -1 break }
// ifsound DONTGO { set RETURN -1 break }
// ifsound ITSFINE { set RETURN -1 break }
// ifsound FUNNIEST { set RETURN -1 break }
// ifsound MANDO_ASSIST  { set RETURN -1 break }
// ifsound 2710 { set RETURN -1 break }
// ifsound 2711 { set RETURN -1 break }
// ifsound 2712 { set RETURN -1 break }
// ifsound 2713 { set RETURN -1 break }
// ifsound 2714 { set RETURN -1 break }
// ifsound 2715 { set RETURN -1 break }

set D RETURN

switch RETURN
case FLY_BY
	ifand player[].gm 4 set RETURN OLD_FLYBY
break

case SHOCKBALLIMPACT
	ifpdistl 6144 nullop else ifsound SHOCKBALLIMPACT set RETURN -1
break

case BOOKEM 
	ife VOLUME 3 ife LEVEL 42
	set RETURN SHAKYGROUNDS3
break

case DUKE_WALKINDUCTS
	ifactor APLAYER set RETURN -1
break

case RIPHEADNECK
	ifg gametype 0 set RETURN -1	
break

case KICK_HIT
	ifand player[].gm 1 set RETURN MENU_CHANGE 
	else ifsound KICK_HIT set RETURN -1
break

case SQUISHED
	ife actorvar[].padang 1337 set RETURN DISINJIB
	else
	{
		displayrandvar random_sound 5
		switch random_sound
		case 0 set RETURN SQUISHED1 break
		case 1 set RETURN SQUISHED2 break
		case 2 set RETURN SQUISHED3 break
		case 3 set RETURN SQUISHED4 break
		case 4 set RETURN SQUISHED5 break
		case 5 set RETURN SQUISHED6 break
		endswitch
	}
break

case PIPEBOMB_BOUNCE
	ife sprite[THISACTOR].picnum HEAVYHBOMB
	ife initsprite THERMAL set RETURN THERMALBOUNCE
break

case SHRINKER_FIRE

	ife player[].curr_weapon SHRINKER_WEAPON
	ifn pchar 2 ifn pchar 4
	{
		set temp NO
		ifvarand dukeupgrades[SHRINKER_WEAPON] 1 set temp YES
		ife temp YES
		set RETURN BFGFIRE
	}
break

case WHIPYOURASS
	ife attmode YES ifl player[].player_par 60
	set RETURN -1
break

case DUKE_LAND set RETURN -1

case OGUS_GOTCHA case OGUS_SOLD case OGUS_DONTASK case OGUS_DONTELL case OGUS_GAMEBREAKER
	ife VOLUME 4 ifg LEVEL 9 set RETURN -1
break

endswitch

// exit if sound has been changed
ifn D RETURN break

geta[THISACTOR].picnum sound_temp 

ife player[].gm 8
{
	ife charsel 4
	{
		ife RETURN BONUS_SPEECH1 set RETURN WESBOOYA
		ife RETURN BONUS_SPEECH2 set RETURN WESSWEET
		ife RETURN BONUS_SPEECH3 set RETURN WESARMYOFME
		ife RETURN BONUS_SPEECH4 set RETURN WESALLCLEAR
		ife RETURN SHOTGUN_COCK set RETURN -1
	}
}
else
ifn sound_temp DUKEBOT
ifn sound_temp DUKEBOTCROUCH
// ife sound_temp APLAYER
ifn pchar 0
{
	switch RETURN
	case WHIPYOURASS // one eyed freak line
		ife pchar 4 set RETURN DEA_THREATCYCLOID else
		ife pchar 3 set RETURN M_EARNMYPAY else
		ifvarand startmode 4 set RETURN WESBEATYOASS
	break
	case DUKE_USEMEDKIT 
		ife pchar 1 set RETURN B_USEMEDKIT else
		ife pchar 2 set RETURN WESYEAAAH else
		ife pchar 3 set RETURN M_OHYEAH else
		ife pchar 4 set RETURN DEA_AHHH
	break
	case DUKE_CRACK_FIRST
		ife pchar 3 set RETURN WRISTBUTTON
	break
	case DUKE_SEARCH
	
		ife pchar 1
		{
			ifrnd 128
			set RETURN B_GRUNT else set RETURN B_GRUNT2
		}
		else ife pchar 2
		{
			ifrnd 128 set RETURN WESGRUNT else
			set RETURN WESLAND3
		}
		else ife pchar 3
		{
			ifrnd 128 set RETURN M_HARDLAND1 else
			set RETURN M_LIFTING
			
		}
		else ife pchar 4
		{
			ifrnd 128 set RETURN DEA_EFFORT1 else
			set RETURN DEA_FALL1 
		}
	break
	
	case DUKE_GRUNT 
		
		ife pchar 1
		set RETURN B_GRUNT 
		else ife pchar 2
		set RETURN WESGRUNT
		else ife pchar 3
		set RETURN M_HARDLAND1
		else ife pchar 4
		set RETURN DEA_EFFORT2
		
	break
	
	case DUKE_SEARCH2 
		ife pchar 1
		set RETURN B_SEARCH 
		else ife pchar 2
		set RETURN WESLAND3
		else ife pchar 3
		set RETURN M_WHEREISIT
		else ife pchar 4
		{
			ifrnd 128 set RETURN DEA_HMMM else
			set RETURN DEA_WHEREISIT
		}
		
	break
	
	case DUKE_LONGTERM_PAIN 
	ife pchar 4 set RETURN DEA_LONGPAIN_2 else
	ife pchar 3 set RETURN M_EXERT2 else ife pchar 2 set RETURN WESPAIN3 else { ifrnd 128 set RETURN B_GRUNT else set RETURN B_GASP } 
	break
	
	case DUKETALKTOBOSS 
	ife pchar 4 set RETURN DEA_BOSSKILL1 else ife pchar 3 set RETURN M_IFITBLEEDS else ife pchar 2 set RETURN WESBEATYOASS else set RETURN B_KICKYOURASS break
	
	case DUKE_SCREAM 
	ife pchar 4 set RETURN DEA_SCREAM else ife pchar 3 set RETURN M_LAUGH else ife pchar 2 set RETURN WESSCREAM else set RETURN B_FALLING break
	
	case DUKE_GETWEAPON1 
	ifn jibsound_delay 0 set RETURN -1 else
	{
	ife pchar 4 set RETURN DEA_PICKWEAP1 else ife pchar 3 set RETURN M_YES else ife pchar 2 set RETURN WESHELLYEAH else set RETURN B_FUCKYEAH 
	
	set jibsound RETURN
	set jibsound_delay 1
	}
	break
	
	case DUKE_GETWEAPON2
	ifn jibsound_delay 0 set RETURN -1 else
	{
	ife pchar 4 set RETURN DEA_PICKWEAP2 else ife pchar 3 set RETURN M_IFITBLEEDS else ife pchar 2 set RETURN WESNICE else set RETURN B_NICE 
	
	set jibsound RETURN
	set jibsound_delay 1
	}
	break
	
	case DUKE_GETWEAPON3
	
	ifn jibsound_delay 0 set RETURN -1 else
	{
	ife pchar 4 set RETURN DEA_EXCELLENT else ife pchar 3 set RETURN M_OHYEAH else ife pchar 2 set RETURN WESTALKINGABOUT else { set RETURN B_GROOVY } 
	set jibsound RETURN
	set jibsound_delay 1
	}
	break
	
	case DUKE_GETWEAPON4 
	
	ifn jibsound_delay 0 set RETURN -1 else
	{
	ife pchar 4 set RETURN DEA_PICKWEAP4 else ife pchar 3 set RETURN M_FRESHHARDWARE else ife pchar 2 set RETURN WESYEAAAH else set RETURN B_YEAHBABY 
	set jibsound RETURN
	set jibsound_delay 1
	}
	break
	
	case DUKE_GETWEAPON5 
	
	ifn jibsound_delay 0 set RETURN -1 else
	{
	ife pchar 4 set RETURN DEA_PICKWEAP5 else ife pchar 3 set RETURN M_VERYNICE else ife pchar 2 set RETURN WESBOOYA else set RETURN B_KICKASS 
	set jibsound RETURN
	set jibsound_delay 1
	}
	break
	
	case DUKE_GETWEAPON6 
	ifn jibsound_delay 0 set RETURN -1 else
	{
	ife pchar 4 set RETURN DEA_PICKWEAP3 else ife pchar 3 set RETURN M_IMPRESSIVE else ife pchar 2 set RETURN WESGETFUN else set RETURN B_HAILQUEEN 
	set jibsound RETURN
	set jibsound_delay 1
	}
	break
	
	case DUKE_HIT_STRIPPER1 ife pchar 4 set RETURN DEA_KILLCIV1 else ife pchar 3 set RETURN M_CHECKMYFIRE else ife pchar 2 set RETURN WESDAMN else set RETURN B_WHOOPS 
	
	break
	
	case DUKE_HIT_STRIPPER2 ife pchar 4 set RETURN DEA_KILLCIV2 else ife pchar 3 set RETURN M_GOYEHFAH else ife pchar 2 set RETURN WESOHSMACK else set RETURN B_MYBAD break
	
	case GENERIC_AMBIENCE23 ife pchar 4 set RETURN DEA_VEHICLE1 else ife pchar 3 set RETURN M_NOTPAIDENOUGH else ife pchar 2 set RETURN WESIMMAD else set RETURN B_MYRIDE break
	
	case GENERIC_AMBIENCE13 ife pchar 4 set RETURN DEA_VEHICLE2 else ife pchar 3 set RETURN M_NOTAGAIN else ife pchar 2 set RETURN WESIMMAD else set RETURN B_MYRIDE break
	
	case DUKE_GASP ife pchar 4 set RETURN DEA_EMERGE else ife pchar 3 set RETURN M_BREATH else ife pchar 2 set RETURN WESGASP else set RETURN B_GASP break
	
	case DUKE_PISSRELIEF ife pchar 4 set RETURN DEA_AHHH else ife pchar 3 set RETURN M_FELTGOOD else ife pchar 2 set RETURN -1 else set RETURN B_USEMEDKIT break
	
	case DUKE_LAND_HURT 
	ife pchar 4 set RETURN DEA_FALL2 else ife pchar 3 set RETURN M_HARDLAND2 else ife pchar 2 set RETURN WESLAND3 else set RETURN B_HARDLAND break
	
	case DUKE_CRACK 
	ife pchar 4 set RETURN DEA_IDLE1 else ife pchar 3 set RETURN M_LETSGO else ife pchar 2 set RETURN WESWANNAGO else set RETURN B_AFK1 break
	
	case DUKE_CRACK2 
	ife pchar 4 set RETURN DEA_IDLE2 else ife pchar 3 set RETURN M_STANDAROUND else ife pchar 2 set RETURN WESEVERYBODY else set RETURN B_AFK2 break
	
	case DUKE_GOTHEALTHATLOW 
	ife pchar 4 set RETURN DEA_MUCHBETTER else ife pchar 3 { ifrnd 128 set RETURN M_JUSTWHATINEEDED else set RETURN M_FELTGOOD } else ife pchar 2 set RETURN WESYEAAAH else set RETURN B_NEEDEDTHAT break
	
	case JIBBED_ACTOR1 ife pchar 4 set RETURN DEA_GIBTAUNT1 else ife pchar 3 set RETURN MANDO_PATHETIC else ife pchar 2 set RETURN WESMESSY else set RETURN B_EWW
	break
	
	case JIBBED_ACTOR9 ife pchar 4 set RETURN DEA_IMUDEATH else ife pchar 3 set RETURN M_ANOTHERPAYOFF else ife pchar 2 set RETURN WESSTAYDOWN else ife pchar 1 set RETURN B_TERMINATED
	break
	
	case JIBBED_ACTOR4 ife pchar 4 set RETURN DEA_REVOLTING else ife pchar 3 set RETURN -1 else ife pchar 2 set RETURN WESHOLYSHIT else set RETURN B_JIB1 break
	
	// DAMN I'M GOOD
	case JIBBED_ACTOR5 ife pchar 4 set RETURN DEA_GIBTAUNT3 else ife pchar 3 set RETURN M_LOVETHISJOB else ife pchar 2 set RETURN WESMADEPOINT else set RETURN B_IMGOOD break
	
	// PIECE OF CAKE
	case JIBBED_ACTOR6 ife pchar 4 set RETURN DEA_GIBTAUNT1 else ife pchar 3 set RETURN M_SAIDDIFFICULT else ife pchar 2 set RETURN WESMADEPOINT else set RETURN B_HAILQUEEN break
	
	case BOSS4_FIRSTSEE ife pchar 4 set RETURN DEA_THREATQUEEN else ife pchar 3 set RETURN M_QUEENJACKSHIT else ife pchar 2 set RETURN WESBEATYOASS else set RETURN B_KICKYOURASS break
	
	case MOUSEANNOY ife pchar 4 set RETURN DEA_DECONSTRUCTED ife pchar 3 set RETURN M_NUISANCE else ife pchar 2 set RETURN WESYEAHBITCH else set RETURN B_ANNOYING break
	
	case WAR_AMBIENCE5 ife pchar 4 set RETURN DEA_FASCINATING else ife pchar 3 set RETURN M_MOSTIMPRESSIVE else ife pchar 2 set RETURN -1 else set RETURN B_FORCERECKON break
	
	case WAR_AMBIENCE7 ife pchar 4 set RETURN DEA_PRIMITIVETECH else ife pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else set RETURN B_TERMINATED break
	
	case WAR_AMBIENCE8 ife pchar 4 set RETURN DEA_SPACEMAN else ife pchar 3 set RETURN M_WASTEMYTIME else ife pchar 2 set RETURN WESEVERYBODY else set RETURN B_KARAOKE break
	
	case WAR_AMBIENCE9 ife pchar 4 set RETURN DEA_FORBROTHER else ife pchar 3 set RETURN M_IFITBLEEDS else ife pchar 2 set RETURN WESBEATYOASS else set RETURN B_AVENGE break
	
	case WAR_AMBIENCE10 ife pchar 4 set RETURN DEA_SPREE else ife pchar 3 set RETURN M_GOTOWORK else ife pchar 2 set RETURN -1 else set RETURN B_KICKCHEW break
	
	case ENDSEQVOL3SND6 set RETURN -1 break
	
	case EATFOOD ife pchar 4 set RETURN DEA_INEDIBLE else ife pchar 3 set RETURN M_NOEATTHIS else ife pchar 2 set RETURN WESDINNER else set RETURN B_NOTEATING break
	
	case DUKE_DEAD ife pchar 4 set RETURN DEA_DEATH1 else ife pchar 3 set RETURN M_DEATH1 else ife pchar 2 set RETURN WESDEATH1 else set RETURN B_DIE break
	
	case DUKE_KILLED1 ife pchar 4 set RETURN DEA_DEATH2 else ife pchar 3 set RETURN M_GOYEHFAH else ife pchar 2 set RETURN WESDEATH3 else set RETURN B_KILLED1 break
	
	case DUKE_KILLED2 ife pchar 4 set RETURN DEA_DEATH3 else ife pchar 3 set RETURN M_NOTPAIDENOUGH else ife pchar 2 set RETURN WESBS else set RETURN B_DAMNFUCK break
	
	case DUKE_KILLED3 ife pchar 4 set RETURN DEA_DEATH4 else ife pchar 3 set RETURN M_GOYEHFAH else ife pchar 2 set RETURN WESRUIN else set RETURN B_YOUGUYSUCK break
	
	case DUKE_KILLED4 ife pchar 4 set RETURN DEA_DEATH else ife pchar 3 set RETURN M_DEATH2 else ife pchar 2 set RETURN WESDEATH2 else set RETURN B_KILLED4 break
	
	case DUKE_KILLED5 ife pchar 4 set RETURN DEA_DEATH1 else ife pchar 3 set RETURN M_DEATH3 else ife pchar 2 set RETURN WESDEATH3 else set RETURN B_KILLED5 break
	
	case PARTY_SPEECH ife pchar 4 set RETURN DEA_MYKINDAPARTY else 
	ife pchar 3 { ifrnd 96 set RETURN M_PLAYAROUND else set RETURN M_NOTWHILEWORKING }
	else ife pchar 2 set RETURN WESPLACEISCRAZY else set RETURN B_PARTY break
	
	case DUKE_STEPONFECES ife pchar 4 set RETURN DEA_REVOLTING else ife pchar 3 set RETURN -1 else ife pchar 2 set RETURN WESJUSTAINTRIGHT else { ifrnd 128 set RETURN B_EWW else set RETURN B_SHITHAPPENS } break
	
	case DUKE_TIP1 ifn jibsound_delay 0 set RETURN -1 else ife pchar 4 set RETURN DEA_SHOWYOURMOVES else ife pchar 3 set RETURN M_MOVE else ife pchar 2 set RETURN WESDANCE else set RETURN B_WANNADANCE break
	
	case DUKE_TIP2 ifn jibsound_delay 0 set RETURN -1 else ife pchar 4 set RETURN DEA_FASCINATING else ife pchar 3 set RETURN M_NEWDANCECLASS else ife pchar 2 set RETURN WESDAYUM else set RETURN B_SHAKEIT break
	
	case YOHOO2 ife pchar 4 set RETURN -1 else ife pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else { set RETURN B_PIRATEWALK } break
	
	case VACATIONSPEECH ife pchar 4 set RETURN -1 else ife pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else set RETURN B_VACATIONSPEECH break
	
	case GENERIC_AMBIENCE20 ife pchar 4 set RETURN DEA_TACTICAL else ife pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else set RETURN B_HAVETHECON break
	
	case GENERIC_AMBIENCE16 ife pchar 4 set RETURN DEA_GIBTAUNT8 else ife pchar 3 set RETURN M_FALLINGONJOB else ife pchar 2 set RETURN WESJUSTAINTRIGHT else set RETURN B_DOOMED break
	
	case SNAKESPEECH ife pchar 4 set RETURN DEA_GROSS1 else ife pchar 3 set RETURN M_ANUMBER1 else ife pchar 2 set RETURN WESJUSTAINTRIGHT else set RETURN B_ESCAPELA break
	
	case GETBACKTOWORK ife pchar 4 set RETURN DEA_USELESS else ife pchar 3 set RETURN M_GOTOWORK else ife pchar 2 set RETURN -1 else set RETURN B_SLACKER break
	
	case KTIT ife pchar 4 set RETURN DEA_ACLEAR else ife pchar 3 set RETURN M_SAIDDIFFICULT else ife pchar 2 set RETURN -1 else set RETURN B_KTIT break
	
	case JIBBED_ACTOR11 ife pchar 4 set RETURN DEA_VOIDWELCOMES else ife pchar 3 set RETURN M_NOHALO else ife pchar 2 set RETURN WESOHSMACK else set RETURN -1 
	
	ifn jibsound_delay 0 set RETURN -1 else ifn RETURN -1 set jibsound_delay -60
	break
	
	case JIBBED_ACTOR12 ife pchar 4 set RETURN DEA_VOIDWELCOMES else ife pchar 3 set RETURN M_SAYMYNAME else ife pchar 2 set RETURN WESGETTINGFUN else ife pchar 1 set RETURN B_SUCKIT else set RETURN -1 break
	
	case YIPPEE1 ife pchar 4 set RETURN -1 else ife pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else set RETURN B_YIPPEE break
	
	case DUKE_LOOKINTOMIRROR 
		ife pchar 4
		{
			ifrnd 128 set RETURN DEA_MIRROR1
			else set RETURN DEA_MIRROR2
		}
		else ife pchar 3 set RETURN M_SHARPDRESSED else ife pchar 2 set RETURN WESARMYOFME else set RETURN B_LOOKGOOD1 
	break
	
	case RIPHEADNECK ife pchar 4 set RETURN DEA_THREATCYCLOID else ife pchar 3 set RETURN M_BIGGAME else ife pchar 2 set RETURN WESBEATYOASS else set RETURN B_RIPHEADNECK 
	
	ifn jibsound_delay 0 set RETURN -1 else set jibsound_delay -60
	
	break
	
	case DUKE_TALKTOBOSSFALL ife pchar 4 set RETURN DEA_FORBROTHER else ife pchar 3 set RETURN M_ANOTHERPAYOFF else ife pchar 2 set RETURN WESMADEPOINT else set RETURN B_TALKTOBOSSFALL 
	
	ifn jibsound_delay 0 set RETURN -1 else set jibsound_delay -60
	
	break
	
	case BOSS4_DEADSPEECH ife pchar 4 set RETURN DEA_THREATQUEEN else ife pchar 3 set RETURN M_QUEENJACKSHIT else ife pchar 2 set RETURN WESWHATISTHING else set RETURN B_ABORTSPECIES 
	break
	
	case BONUS_SPEECH1 ife pchar 4 set RETURN DEA_EXCELLENT else ife pchar 3 set RETURN M_GOTOWORK else ife pchar 2 set RETURN WESGOTIT else set RETURN B_LETSROCK break
	
	case BONUS_SPEECH2 ife pchar 4 set RETURN DEA_EXCELLENT else ife pchar 3 set RETURN M_ANOTHERPAYOFF else ife pchar 2 set RETURN WESIMONIT else set RETURN SHELLYREADY break
	
	case BONUS_SPEECH3 ife pchar 4 set RETURN DEA_EXCELLENT else ife pchar 3 set RETURN M_LOVETHISJOB else ife pchar 2 set RETURN -1 else set RETURN B_JIB10 break
	
	case BONUS_SPEECH4 ife pchar 4 set RETURN DEA_EXCELLENT else ife pchar 3 set RETURN M_LETSDANCE else ife pchar 2 set RETURN WESYEAAAH else set RETURN B_KICKASS break
	
	case DUKE_TAKEPILLS 
		ife pchar 4 set RETURN B_TAKEPILLS else
		ife pchar 1 set RETURN B_TAKEPILLS 
	break
	
	case BIGGUNS 
		ifn jibsound_delay 0 set RETURN -1 else
		{
		ife pchar 4 set RETURN DEA_EXCELLENT else ife pchar 3 set RETURN M_MOSTIMPRESSIVE else ife pchar 2 set RETURN WESTALKINGABOUT else set RETURN B_BIGGUNS 
		set jibsound RETURN
		set jibsound_delay 1
		}
	break
	
	case YOURUGLY ife pchar 4 set RETURN DEA_FORBROTHER else ife pchar 3 set RETURN M_EARNMYPAY else ife pchar 2 set RETURN WESWHATISTHING else set RETURN B_UGLYMOFO break
	
	case JIBBED_ACTOR3 ife pchar 4 set RETURN DEA_FASCINATING else ife pchar 3 set RETURN M_IMPRESSIVE else ife pchar 2 set RETURN WESHOLYSHIT else set RETURN B_JIB1 
	
	ifn jibsound_delay 0 set RETURN -1 else ifn RETURN -1 set jibsound_delay -60
	break
	
	case DUKE_BOOBY
	case GENERIC_AMBIENCE14
	case GENERIC_AMBIENCE15
	case WAR_AMBIENCE6
	case SUPERMARKET
	case MAKEMYDAY
	case YOHOO1
	case AREA51SPEECH
	case DOGROOMSPEECH
	case BOOKEM
	case SUNSTORM_SOUND09
	case SUNSTORM_SOUND12
	case SUNSTORM_SOUND14
	case SUNSTORM_SOUND17
	case SUNSTORM_SOUND18
	case SUNSTORM_SOUND19 
	case POSTAL_SPEECH
	case INTRO4_6
	  ifvarand startmode 1 nullop else
		set RETURN -1
	  
	break
	
	case FOUNDJONES
	ife pchar 4 set RETURN DEA_ANCIENTS else
	ife pchar 3 set RETURN M_BELONGMUSEUM else
	ife pchar 0 nullop else
		set RETURN -1
	break
	
	case GENERIC_AMBIENCE17 ife pchar 3 set RETURN M_PLAYAROUND else set RETURN -1 break
	// CARIBBEAN VACATION SOUNDS
	case SUNSTORM_SOUND01 ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else { set RETURN B_LOVEBOAT } break
	case SUNSTORM_SOUND02 ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else { set RETURN B_SURFINSAFARI } break
	case SUNSTORM_SOUND03 ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else { set RETURN B_CRASHPARTY } break
	case SUNSTORM_SOUND04 ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else { set RETURN B_HATEDISCO } break
	case SUNSTORM_SOUND05 ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else { set RETURN B_STAYINALIVE } break
	case SUNSTORM_SOUND06 ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else { set RETURN B_LOOKINTOSCORE } break
	case SUNSTORM_SOUND07 ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else { set RETURN B_DOORONE } break
	case SUNSTORM_SOUND08 ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else { set RETURN B_HOTBABES } break
	// case SUNSTORM_SOUND09 no Bombshell version
	case SUNSTORM_SOUND10 ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else { set RETURN B_WOOHOO } break
	case SUNSTORM_SOUND11 ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else { set RETURN B_DAPLANE } break
	// case SUNSTORM_SOUND12 no Bombshell version
	case SUNSTORM_SOUND13 ifge pchar 3 set RETURN -1 else ife pchar 2 { } else { set RETURN B_GOESMYRIDE } break
	// case SUNSTORM_SOUND14 no Bombshell version
	case SUNSTORM_SOUND15 case SUNSTORM_SOUND16
		ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else { set RETURN B_DECISIONS } break
	// case SUNSTORM_SOUND17 no Bombshell version
	// case SUNSTORM_SOUND18 no Bombshell version
	// case SUNSTORM_SOUND19 no Bombshell version
	case VACA_GETWEAP1 ifge pchar 3 set RETURN M_VERYNICE else ife pchar 2 set RETURN -1 else { set RETURN B_WOOHOO } break
	case VACA_GETWEAP2 ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else { set RETURN B_CRASHPARTY } break
	case VACA_GETWEAP3 ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else { set RETURN B_YEAHBABY } break
	case VACA_DIE1 ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else set RETURN B_EWW break
	case VACA_DIE2 ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else set RETURN B_VACATIONSUCKS break
	case D_BAIT ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else set RETURN B_BAIT break
	case D_FISHFOOD ifge pchar 2 set RETURN -1 else { set RETURN B_FISHFOOD } break
	case D_ONTHEHOUSE ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else set RETURN B_ONTHEHOUSE break
	case D_ASSWIPE ifge pchar 3 set RETURN -1 else ife pchar 2 set RETURN -1 else set RETURN B_SUNASSWIPE break
	case ENDSEQVOL3SND2 // game over
		ifvarand startmode 1 nullop else set RETURN -1 break
	endswitch
}

endevent

defstate landsounds

	set stepcount -32768
	
	
	ife player[].spritebridge YES
	{ 
		getp[].sbs spriteid // GET THE FLATSPRITE'S ID TAG
		geta[spriteid].picnum picnum // CHECK IT'S TEXTURE
	}
	else
	{
		getplayer[].posz z
		addvar z 6144
		getzrange player[].posx player[].posy z player[].cursectnum z2 tempb temp spriteid 256 CLIPMASK0
		subvar spriteid 49152
		ifvarg spriteid -1 ifvarl spriteid 16384
			geta[spriteid].picnum picnum
		else
		gets[].floorpicnum picnum
	}

	set TILETYPE 7 // default
	state tiletype
	
	ife TILETYPE 8 ifge raining 0 set TILETYPE 7

	ifvare TILETYPE 1 sound LANDWOOD else
	ifvare TILETYPE 2 
	{
		ifge picnum BMWM4 ifle picnum ROVER sound LANDCAR else
		sound LANDMETAL 
	}
	else
	ifvare TILETYPE 3 sound LANDMETAL else
	ifvare TILETYPE 4 sound LANDDIRT else
	ifvare TILETYPE 6 sound LANDCARPET else
	ifvare TILETYPE 7 sound LANDNORMAL else
	ifvare TILETYPE 8 sound LANDSNOW else
	ifvare TILETYPE 9 sound LANDWATER else
	ifvare TILETYPE 11 sound PL_SQUISH2 else
	sound LANDNORMAL
ends

defstate stepsounds

	ife TILETYPE 8 ifge raining 0 set TILETYPE 7
	
	

	switch TILETYPE	

		case 0
		case 7
		// normal step
		randvarvar temp 3
		ife temp 0 sound PL_STEP1 else
		ife temp 1 sound PL_STEP2 else
		ife temp 2 sound PL_STEP3 else
		ife temp 3 sound PL_STEP4
		break
		
		case 1
		// wood step
		randvarvar temp 3
		ife temp 0 sound PL_WOOD1 else
		ife temp 1 sound PL_WOOD2 else
		ife temp 2 sound PL_WOOD3 else
		ife temp 3 sound PL_WOOD4
		break
		
		case 2
		// metal step
		ifge picnum BMWM4 ifle picnum ROVER nullop else
		ifsound DUKE_WALKINDUCTS nullop else
		{
			randvarvar temp 3
			ife temp 0 sound PL_METAL1 else
			ife temp 1 sound PL_METAL2 else
			ife temp 2 sound PL_METAL3 else
			ife temp 3 sound PL_METAL4
		}
		break
		
		case 3
		// grate step
		// sound DUKE_WALKINDUCTS
			randvarvar temp 3
			
			
			switch picnum
				case PANNEL1 case PANNEL2 case 4206 case 6941 case 7043 
				case 7070 case 12545 case 12546 case 12570 case 12714
				ife temp 0 sound PL_DUCT1 else
				ife temp 1 sound PL_DUCT2 else
				ife temp 2 sound PL_DUCT3 else
				ife temp 3 sound PL_DUCT4
			break
			
			default
				ife temp 0 sound PL_GRATE1 else
				ife temp 1 sound PL_GRATE2 else
				ife temp 2 sound PL_GRATE3 else
				ife temp 3 sound PL_GRATE4
			break
			endswitch
			
		break
		
		case 4
		// grass step
		randvarvar temp 3
		ife temp 0 sound PL_GRASS1 else
		ife temp 1 sound PL_GRASS2 else
		ife temp 2 sound PL_GRASS3 else
		ife temp 3 sound PL_GRASS4
		break
		
		case 5
		// tile step
		randvarvar temp 3
		ife temp 0 sound PL_TILE1 else
		ife temp 1 sound PL_TILE2 else
		ife temp 2 sound PL_TILE3 else
		ife temp 3 sound PL_TILE4
		break
		
		case 6
		// carpet step
		randvarvar temp 3
		ife temp 0 sound PL_CARPET1 else
		ife temp 1 sound PL_CARPET2 else
		ife temp 2 sound PL_CARPET3 else
		ife temp 3 sound PL_CARPET4
		
		break
		
		case 8
		// snow step
		rand temp 5
		ife temp 0 sound PL_SNOW1 else
		ife temp 1 sound PL_SNOW2 else
		ife temp 2 sound PL_SNOW3 else
		ife temp 3 sound PL_SNOW4 else
		ife temp 4 sound PL_SNOW5 else
		ife temp 5 sound PL_SNOW6 else
		ifactor APLAYER
		{
			  setp[].footprintcount 2
			  setp[].footprintpal 33
			  setp[].footprintshade 0
		}
		break
		
		case 9 
		// soundonce DUKE_ONWATER
		break
		
		case 11
		// squishy
		randvarvar temp 3
		ife temp 0 sound STEPORG1 else
		ife temp 1 sound STEPORG2 else
		ife temp 2 sound STEPORG3 else
		sound STEPORG4
		break
		
		case 12
		// dirt
		randvarvar temp 3
		ife temp 0 sound PL_DIRT1 else
		ife temp 1 sound PL_DIRT2 else
		ife temp 2 sound PL_DIRT3 else
		ife temp 3 sound PL_DIRT4
		break
		
		default 
		// normal step
		randvarvar temp 3
		ife temp 0 sound PL_STEP1 else
		ife temp 1 sound PL_STEP2 else
		ife temp 2 sound PL_STEP3 else
		ife temp 3 sound PL_STEP4
		break	
		endswitch	

ends

defstate stepsoundstuff

	ifinwater break
	ifonwater break
	iffloordistl 8 nullop else break
	// ifp pducking break
	ifp pjetpack break

	ifp pstanding { set stepcount 32000 break }
	ife pchar 4 ifl cloak 0 break

	getp[].posxv x
	div x 644
	mulvarvar x x
	getp[].posyv y
	div y 644
	mulvarvar y y
	add x y
	sqrt x x
	ifg x 4400 set x 4400 // max stepping speed
	add stepcount x

	ife player[].spritebridge YES
	{ 
		getp[].sbs spriteid // GET THE FLATSPRITE'S ID TAG
		geta[spriteid].picnum picnum // CHECK IT'S TEXTURE
	}
	else
	{
		getplayer[].posz z
		addvar z 6144
		getzrange player[].posx player[].posy z player[].cursectnum z2 tempb temp spriteid 256 CLIPMASK0
		subvar spriteid 49152
		ifvarg spriteid -1 ifvarl spriteid 16384
			geta[spriteid].picnum picnum
		else
		gets[].floorpicnum picnum
	}
	
	
	set TILETYPE 7
	state tiletype

	ifg stepcount 32768
	{
		subvar stepcount 32768	
		ife TILETYPE 8 sub stepcount 16384
		state stepsounds
	}

ends

defstate checkhitscan

getp[].cursectnum mysector
ifl mysector 0 
	break
ifg mysector 4095 
    break

getp[].ang angvar
getp[].horiz zdist
sub zdist 100

getp[].weapon_pos temp
abs temp
mul temp 3
sub zdist temp

mul zdist -2048
cos mycos angvar
sin mysin angvar

// horiz at 0 z angle is 100; pos for up, neg for down


hitscan player[].posx player[].posy player[].posz mysector mycos mysin zdist hitsector hitwall hitsprite hitx hity hitz CLIPMASK1 // clipmask

set scannedsprite hitsprite

// set hudnumber sprite[hitsprite].picnum
// set hudnumber2 hitx
// set hudnumber3 hity

// espawn LASERDOT
// setsprite RETURN hitx hity hitz

ifn monid -1
{
	ifg sprite[monid].statnum 2 set monid -1 else
	ifn actorvar[monid].monstatus 1 set monid -1
}

ife autoaim -1 getp[].auto_aim autoaim

ifn onturret -1 
{
	ifn player[].auto_aim NO getp[].auto_aim autoaim
	setp[].auto_aim NO
}
else
ife player[].curr_weapon KNEE_WEAPON
{
	ifn player[].auto_aim 0
	{
		getp[].auto_aim autoaim
		setp[].auto_aim NO
	}
}
else
ifn scannedsprite -1
ife actorvar[scannedsprite].monstatus 1
{
	ife dashtarg -1 ifn saberdash 0
		set dashtarg scannedsprite 
		
	ife kicktarg -1 ifg sidekick 2
		set kicktarg scannedsprite
		
	ifn player[].auto_aim 0
	{
		getp[].auto_aim autoaim
		setp[].auto_aim NO
	}
	
	ife zoomin YES
	ife player[].curr_weapon RPG_WEAPON
	ifg player[].ammo_amount RPG_WEAPON 0
	ife player[].kickback_pic 0
	ife player[].weapon_pos 0
	ife targetwait 0
	ifn scannedsprite targetlock[0]
	ifn scannedsprite targetlock[1]
	ifn scannedsprite targetlock[2]
	ifn actorvar[scannedsprite].team team
	ifn actorvar[scannedsprite].team 3
	{
		// clean up array first
		ifn targetlock[2] -1 ife targetlock[1] -1 
		{ setarray targetlock[1] targetlock[2] setarray targetlock[2] -1 }
		ifn targetlock[1] -1 ife targetlock[0] -1 
		{ setarray targetlock[0] targetlock[1] setarray targetlock[1] -1 }
		
		set temp NO
		ife pchar 0 ifvarand dukeupgrades[RPG_WEAPON] 4 set temp YES
		ife pchar 1 ifvarand shellyupgrades[RPG_WEAPON] 4 set temp YES
		ife targetlock[0] -1
		{
			sound TARGETLOCK
			setarray targetlock[0] scannedsprite
			geta[scannedsprite].mdflags temp
			orvar temp 16
			seta[scannedsprite].mdflags temp
		}
		else
		ife temp YES
		ife targetlock[1] -1
		ifg player[].ammo_amount RPG_WEAPON 1
		{
			sound TARGETLOCK
			setarray targetlock[1] scannedsprite
			geta[scannedsprite].mdflags temp
			orvar temp 16
			seta[scannedsprite].mdflags temp
		}
		else
		ife temp YES
		ife targetlock[2] -1
		ifg player[].ammo_amount RPG_WEAPON 2
		{
			sound TARGETLOCK
			setarray targetlock[2] scannedsprite
			geta[scannedsprite].mdflags temp
			orvar temp 16
			seta[scannedsprite].mdflags temp
		}
	}
}
else ife zoomin NO
		setp[].auto_aim autoaim

set scandist sprite[].x
sub scandist hitx
mul scandist scandist
set tempb sprite[].y
sub tempb hity
mul tempb tempb
add scandist tempb
sqrt scandist scandist
set tempc 0
ifn hitsector -1
{
	gets[hitsector].ceilingz z
	sub z hitz
	ifg z -1024
	{
		ifvarand sector[hitsector].ceilingstat 1 mul scandist -1
		set tempc 1 // hit ceiling
	}
	ifg scandist 0
	{
		ifn hitwall -1
		{
			getwall[hitwall].nextsector temp
			ifn temp -1
			{
				gets[temp].ceilingz z
				
				// sub z hitz
				ifg z hitz // -1024
				{
					ifvarand sector[temp].ceilingstat 1 mul scandist -1
				}
			}
		}
		// laser tripbomb place on floor code
		ifvarand sector[hitsector].floorstat 1 nullop else
		ife triphack -1
			ifp palive
			ife tempc 0 ifl scandist 1024
			ifp ponground iffloordistl 16
			ife sector[hitsector].floorslope 0
			ife hitwall -1
			ifvarand bits 4
			ifl PLAYERONTHEBIKE 1
			ife player[].curr_weapon 8
			ife player[].transporter_hold 0
			ife player[].kickback_pic 0
			ife player[].weapon_pos 0
			ifg player[].ammo_amount 8 0
			ife hitsprite -1
			ife vendor_screen 0
		{
			set tripz hitz
			set tripx hitx
			set tripy hity
			set triphack hitsector
			setp[].kickback_pic 1
		}
	}
}

/*
ife player[].heat_on NO
ifg scandist 0
ife currentweapon PISTOL_WEAPON
ife LASERMODE NO
ife PISTOLDOT YES
ife pchar 0
ifn startmode -1
ife movecam -1
{
	getp[].ang angvar
	getp[].horiz zdist
	sub zdist 135

	getp[].weapon_pos temp
	abs temp
	mul temp 3
	sub zdist temp
	
	set temp gun_pos
	div temp -2
	sub zdist temp
	
	ifp pstanding nullop else
	{
		set temp weapon_xoffset
		div temp 2
		add angvar temp
	}
	
	mul zdist -2048
	cos mycos angvar
	sin mysin angvar

	hitscan player[].posx player[].posy player[].posz mysector mycos mysin zdist hitsector hitwall hitsprite hitx hity hitz CLIPMASK0
	
	
	espawn LASERDOT
	set dotsprite RETURN
	setsprite RETURN hitx hity hitz
	
	
	ifn hitsprite -1 seta[RETURN].cstat 8322 else
	ifn hitwall -1 seta[RETURN].cstat 8322 else
	ifn hitsector -1
	{
		ife tempc 1 { ife sector[hitsector].ceilingslope 0 seta[RETURN].cstat 8354 else seta[RETURN].cstat 8322 }
		else { ife sector[hitsector].floorslope 0 seta[RETURN].cstat 8354 else seta[RETURN].cstat 8322 }
	}
	seta[RETURN].mdflags 16
	ife sprite[RETURN].cstat 8322
	{
		getp[].ang angvar
		add angvar 1024
		set x sprite[RETURN].x
		set temp scandist
		shiftr temp 3
		ifg temp 128 set temp 128
		add x temp
		rotatepoint sprite[RETURN].x sprite[RETURN].y x sprite[RETURN].y angvar x2 y2
		setsprite RETURN x2 y2 sprite[RETURN].z
	}
	updatesectorz sprite[RETURN].x sprite[RETURN].y sprite[RETURN].z tempb
	ifvarn tempb -1
	{
		getflorzofslope tempb sprite[RETURN].x sprite[RETURN].y temp
		sub temp 512
		ifg sprite[RETURN].z temp seta[RETURN].z temp
		changespritesect RETURN tempb
	}
	
}
*/

ends

onevent EVENT_DISPLAYROOMS

ifn SAVEDANGCOUNT 0 
{
	ife player[].look_ang 0
	set cameraang SAVEDANG
	else
	ifg look_ang_wait 0
	{
		set cameraang SAVEDANG
		add cameraang last_look_ang
	}
	setp[].ang SAVEDANG
	ifn deaonwall -1 ifl camerahoriz 54 set camerahoriz 54
}

ife player[].movement_lock 31
ife cutcam -1
ife thiscam -1
ife movecam -1
ife player[].on_crane -1
{
	set cameraang oang
	set camerahoriz 100
}

ifn thiscam -1 
{
	ifn goalang ocameraang
	{
		getincangle angvar goalang ocameraang
		
		set temp framerate
		div temp 30
		ifl temp 1 set temp 1
		div angvar temp
		sub ocameraang angvar
	}
	set cameraang ocameraang
	break
}

ifvarg PLAYERONTHEBIKE 0 
{
	set camerahoriz bikehoriz
	// set cameraang bikeang
	
	ifn bikeang ocameraang
	{
		getincangle angvar bikeang ocameraang
		
		set temp framerate
		div temp 30
		ifl temp 1 set temp 1
		div angvar temp
		sub ocameraang angvar
	}
	set cameraang ocameraang

	set cameraz bikez
	// setp[].rotscrnang bikerot
}

// ifn player[].ang ocameraang
// ife cutcam -1
// ife movecam -1
// ife player[].movement_lock 0
// ife player[].over_shoulder_on NO
// ife player[].newowner -1
// {
	// getincangle angvar player[].ang ocameraang
		
	// set temp framerate
	// div temp 30
	// ifl temp 1 set temp 1
	// div angvar temp
	// sub ocameraang angvar
	
	// set cameraang ocameraang
// }
// else
// ife player[].ang cameraang set ocameraang player[].ang

ifn cutcam -1
ifg cutcamtime 0
{
	set camerax sprite[cutcam].x
	set cameray sprite[cutcam].y
	set cameraz sprite[cutcam].z
	set cameraang sprite[cutcam].ang
}

ifge jumpjet 35
ife pchar 3
{
	set cameraang jumpjet_ang
	setp[].ang jumpjet_ang
}

ifn pchar 0 ifn pchar 2 ifn pchar 3
{
	ifn player[].transporter_hold 0
	ife player[].holster_weapon YES
	ifsound DUKE_URINATE
	{
		add cameraang 1024
		add cameraz 3072
	}
	ifn player[].newowner -1
	{
		set cameratoggle YES
		getp[].i spriteid
		seta[spriteid].cstat 32768
	}
}

// ifn player[].newowner -1 set cameraang sprite[player[].newowner].ang

ifg portaltime 150
{
	set temp viewingrange
    set tempb portaltime
	sub tempb 150
	mul tempb 768
    // add temp tempb
	sub temp tempb
    setaspect temp yxaspect
}
else
ifn vr -1 ife zoomin YES // player[].heat_on YES
	setaspect vr yxaspect
	
// ife shellycam YES
// ife pdown YES
// ifn myshelly -1
// {
	// set camerax sprite[myshelly].x
	// set cameray sprite[myshelly].y
	// set cameraz sprite[myshelly].z
	// sub cameraz 8192
	
	// set cameraang sprite[myshelly].ang
	// set camerasect sprite[myshelly].sectnum
	

// }

ifn movecam -1
{
	set camerax sprite[movecam].x
	set cameray sprite[movecam].y
	set cameraz sprite[movecam].z
	set cameraang sprite[movecam].ang
	set camerasect sprite[movecam].sectnum
	
	
	set temp actorvar[movecam].mtype
	sub temp 50
	mul temp 2
	add temp 100
	
	set camerahoriz temp
}
// else
// ife zoomin YES
// {

	// ifn cameraang oang
	// {
		// getincangle angvar cameraang oang
		// shiftr angvar 1
		// add cameraang angvar
	// }
	// set camerahoriz ohoriz
// }
else
ifp pducking nullop else
ifn slidekick 0 add cameraz 2048

ife pdown YES sub cameraz 4096

ifg shipcam -1
{
	getactor[shipcam].z z
	sub z 8192
	
	getav[shipcam].droptile z2
	sub z2 player[].posz
	sub z z2
	
	getp[].posx x2
	getp[].posy y2
	getav[shipcam].startx x
	getav[shipcam].starty y

	subvarvar x2 x
	subvarvar y2 y
	getangle angvar x2 y2 // angvar is now the displacement angle
	
	add angvar shipangoff
	
	set xydist x
	sub xydist player[].posx
	mul xydist xydist
	sub y player[].posy
	mul y y
	add xydist y
	sqrt xydist xydist
	
	set xvel sprite[shipcam].x
	add xvel xydist
	
	add angvar shipang // sprite[shipcam].ang
	
	rotatepoint sprite[shipcam].x sprite[shipcam].y xvel sprite[shipcam].y angvar x2 y2

	set tempH sprite[shipcam].sectnum
	updatesector x2 y2 tempH
	ife tempH -1 set tempH sprite[shipcam].sectnum

	getav[shipcam].mtype angvar
	
	ifn angvar shipang
	{
		getincangle tempd angvar shipang
		shiftr tempd 1
		sub shipang tempd
	}
	set angvar shipang
	
	add angvar player[].ang
	ifn shipangstart 999999
	sub angvar shipangstart

// code to bob up and down
/*	
	subvar z 2048		
	setvarvar temp player[].player_par
	
	// shiftvarl temp 5
	mul temp 24
	sin tempb temp
	shiftvarr tempb 2 // 4	
	subvarvar z tempb
	
*/
	
/*
	getav[shipcam].shotpitch temp
	shiftr temp 6 // temp is now goal for shiphoriz
	ifg temp 64 set temp 64, ifl temp -64 set temp -64
	ifg temp shiphoriz add shiphoriz 1 else
	ifl temp shiphoriz sub shiphoriz 1

	getincangle temp sprite[shipcam].ang angvar
	abs temp
	ifg temp 512
		sub temp 1024
	
	
	set tempb shiphoriz
	shiftr temp 6
	div tempb temp
	
	add tempb camerahoriz
	ifg tempb 299 set tempb 299
	ifl tempb -99 set tempb -99
*/	

	// showview x2 y2 z angvar camerahoriz tempH 0 0 319 199
	
	showviewunbiased x2 y2 z angvar camerahoriz tempH 0 0 319 199
	
}
else
ifvarg portalview 0
ifvarn portalcam -1
{
	getactor[portalcam].x x
	getactor[portalcam].y y
	getactor[portalcam].z z
	getactor[portalcam].ang angvar
	
	getactorvar[portalcam].teamspawned spriteid
	getactor[spriteid].ang tempc
	
	ife sprite[portalcam].pal 2
	{
		set x2 sprite[spriteid].x
		sub x2 camerax
		set y2 sprite[spriteid].y
		sub y2 cameray
		set z2 sprite[spriteid].z
		sub z2 cameraz, add z2 6144
		
		add x x2
		add y y2
		sub z z2
	}
	
	getplayer[screenpeek].ang tempb
	
	getincangle tempd tempc tempb
	addvarvar angvar tempd
	// addvar angvar 1024
	
	getp[].posz z2
	sub z2 portalzoffset
	add z z2
	
	
	getactor[portalcam].sectnum mysector
	// getactorvar[portalcam].countvar temp
	getplayer[screenpeek].horiz temp
	showviewunbiased x y z angvar temp mysector 0 0 319 199
}
endevent

defstate cursorcoords
	getinput[].q16horz temp
	getu .mouseflip tempb
	ife tempb 1 sub q16_cursory temp else ife tempb 0 add q16_cursory temp
	getinput[].q16avel temp div temp 3
	add q16_cursorx temp
	set cursorx q16_cursorx
	set cursory q16_cursory

	clamp q16_cursorx 0 20971520
	clamp q16_cursory 0 13107200

	shiftvarr cursorx 16
	shiftvarr cursory 16

	clamp cursorx 0 320
	clamp cursory 0 200


ends

defstate in_menu
	setp[].knuckle_incs 0
	setp[].crack_time 0
	setp[].movement_lock 31
	set cmode 0
	ifg sprite[].htextra 0
	{
		geta[].htextra temp
		div temp 2
		seta[].htextra temp
	}
	ifn vendor_screen 8 // 8 == weapon wheel
	{
		setp[].kickback_pic 0
		set LASERFIRE 0
		setp[].jumping_counter 0
		setp[].weapon_pos 10
		setp[].quick_kick 0
		set qk_proxy 0
	}
	// getp[].ang temp
	// set tempb oang
	// getincangle angvar temp tempb
	// div angvar 3
	// sub cursorx angvar
	setp[].ang oang // player[].oang
	// ifl cursorx 0 set cursorx 0
	// ifg cursorx 320 set cursorx 320
	
	// getp[].horiz temp
	// set tempb ohoriz
	// sub temp tempb
	// getuserdef[].mouseflip tempc
	// ife tempc 0
	// add cursory temp
	// else
	// sub cursory temp
	// ifl cursory 0 set cursory 0
	// ifg cursory 200 set cursory 200
	setp[].horiz 100
	
	state cursorcoords
ends

defstate checksquished
  ifsquished
  {
	ifn team 1 ifn team 3
		addkills 1
	state enemy_death
    sound SQUISHED
    state standard_jibs
    state random_ooz
    killit
  }
ends

defstate deadsquished
	ifsquished
	{
		sound SQUISHED
		state standard_jibs
		state random_ooz
		killit
	}
ends

state rf
  ifrnd 128
    cstat 4
  else
    cstat 0
ends

/*
state aim_bottarget

	// ife shellyinmap 0 break
	
	ifn bottarget -1 break
	ife bottarget player[].i break
	
	geta[].owner spriteid
	ifn spriteid -1
	ifn actorvar[spriteid].bottarget -1
	ifn actorvar[spriteid].bottarget player[].i
	{
		getav[spriteid].bottarget bottarget
			
		geta[bottarget].x x2
		geta[bottarget].y y2
		sub x2 sprite[].x
		sub y2 sprite[].y
		getangle angvar x2 y2
		seta[].ang angvar
		
		seta[].ang sprite[spriteid].ang
		
		geta[bottarget].z zdist
		sub zdist 5120
		sub zdist sprite[].z
		ldist xydist THISACTOR bottarget
		ife xydist 0 setvar xydist 1
		mul zdist sprite[].xvel
		div zdist xydist
		seta[].zvel zdist
	}
	

ends
*/

defstate aim_bottarget

	ifn bottarget -1 break
	ifactor FLAKPROJ break
	
	geta[].owner spriteid
	ifn spriteid -1
	ifn actorvar[spriteid].bottarget -1
	ifn sprite[].htpicnum ROLLYTURRET
	{
		getav[spriteid].bottarget bottarget
		
		geta[bottarget].x x2
		geta[bottarget].y y2
		sub x2 sprite[].x
		sub y2 sprite[].y
		getangle angvar x2 y2
		seta[].ang angvar
		
		geta[bottarget].z zdist
		ifactor MORTER sub zdist 8192
		sub zdist sprite[].z 
		
		geta[bottarget].picnum picnum
		
		set z2 tiledata[picnum].ysize
		mul z2 sprite[bottarget].yrepeat
		shiftl z2 1
		// z2 is proportional to height of enemy sprite
		
		sub zdist z2

		mul zdist sprite[].xvel
		ldist xydist THISACTOR bottarget
		ifvare xydist 0 setvar xydist 1 
		divvarvar zdist xydist
		
		seta[].zvel zdist
	}
ends

/*
state aim_holoduke
	dist temp THISACTOR player[].i
	dist tempc THISACTOR player[].holoduke_on
	ifvarvarl tempc temp
	{
		getp[].holoduke_on spriteid
		geta[].z z
		subvar z 8192
		seta[].z z
		geta[spriteid].z tempb
		sub tempb 8192
		seta[spriteid].z tempb
		canseespr THISACTOR spriteid temp
		add z 8192
		seta[].z z
		add tempb 8192
		seta[spriteid].z tempb
		ifvare temp 1
		{
			geta[spriteid].x x
			geta[spriteid].y y
			sub x sprite[].x
			sub y sprite[].y
			getangle angvar x y
			seta[].ang angvar
		}
	}
ends
*/

defstate randtraj

	geta[].ang angvar
	rand temp 32
	sub temp 16
	ifspawnedby CANHEAD { rand temp 64 sub temp 32 }
	sub angvar temp
	seta[].ang angvar
	geta[].xvel xvel
	randvarvar zdist xvel
	geta[].zvel z
	ifrnd 128 add z zdist else sub z zdist
	seta[].zvel z
	
ends

defstate randtraj2
	geta[].ang angvar
	rand temp 16
	sub temp 8
	sub angvar temp
	seta[].ang angvar
	geta[].xvel xvel
	randvarvar zdist xvel
	shiftr zdist 1
	geta[].zvel z
	ifrnd 128 add z zdist else sub z zdist
	seta[].zvel z
ends

state checkrandtraj

	set B NO
	ifp prunning ifg forwinput 5 set B YES
	ifp prunningback ifg backinput 5 set B YES
	ifp pfalling set B YES
	ife B NO break
	
	// randomize trajectory
	state randtraj
ends

defstate upscaleme

// for 2X upscaled sprites
	
ifg sprite[].xrepeat 4
{
	geta[].xrepeat init_xrepeat
	geta[].yrepeat init_yrepeat
	shiftr init_xrepeat 1
	shiftr init_yrepeat 1
	seta[].xrepeat init_xrepeat
	seta[].yrepeat init_yrepeat
}
set upscaled YES

ends

state upscale_visual

	geta[].mdflags temp
	orvar temp 16
	seta[].mdflags temp
	set upscaled 2

ends

defstate add_ant_code
	set antcount 0
	add sub_maxactors 1
	espawn ARMYANT
	seta[RETURN].htpicnum sprite[RETURN].picnum
	ifrnd 64 ifg plevel 3 seta[RETURN].pal 40
	seta[RETURN].xrepeat 24
	seta[RETURN].yrepeat 24
	seta[RETURN].cstat 257
	seta[RETURN].extra ARMYANTSTRENGTH
	ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
	
	ifoutside nullop else
	{
		getceilzofslope sprite[].sectnum sprite[].x sprite[].y z
		geta[RETURN].z zdist
		sub zdist z
		ifle zdist 262144
		{
			add z 9728
			seta[RETURN].z z
			seta[RETURN].cstat 265
			setav[RETURN].initsprite YES
			seta[RETURN].picnum ARMYANTCRAWL
		}
	}
ends

defstate buddy_position
	set x sprite[].x
	add x 512
	set y sprite[].y
	add y 512
	set mysector sprite[].sectnum
	updatesector x y mysector
	ife mysector sprite[].sectnum
	{
		seta[RETURN].x x
		seta[RETURN].y y
	}
	else
	{
		sub x 1024
		sub y 1024
		set mysector sprite[].sectnum
		updatesector x y mysector
		ife mysector sprite[].sectnum
		{
			seta[RETURN].x x
			seta[RETURN].y y
		}
	}
ends

onevent EVENT_EGS

ifn sprite[].owner -1
{
	ife sprite[].statnum 4
	ifg sprite[].xvel 256
	{
		ifn sprite[].picnum SHOCKPROJ
		ifvarand actorvar[sprite[].owner].monstflags 64 // double shot power
		{
			orvar monstflags 64
			seta[].mdflags 16
		}
		ifvarand actorvar[sprite[].owner].monstflags 1048576 // electric
		{
			orvar monstflags 1048576
			seta[].mdflags 16
		}
		ifvarand actorvar[sprite[].owner].monstflags 128 // multishot
		ife mid_spawn NO
		{
			set mid_spawn YES
			eshootvar sprite[].picnum
			ife RETURN -1 set mid_spawn NO
			else
			{
			geta[sprite[].owner].ang angvar 
			ifg actorvar[sprite[].owner].targetdist 8192 sub angvar 14 else sub angvar 24
			seta[RETURN].ang angvar
			seta[RETURN].extra sprite[].extra
			seta[RETURN].xvel sprite[].xvel
			seta[RETURN].zvel sprite[].zvel
			seta[RETURN].yvel sprite[].yvel
			seta[RETURN].owner sprite[].owner
			seta[RETURN].htowner sprite[].htowner
			seta[RETURN].htpicnum sprite[].htpicnum
			seta[RETURN].pal sprite[].pal
			setthisprojectile[RETURN].pal sprite[].pal
			seta[RETURN].xrepeat sprite[].xrepeat
			seta[RETURN].yrepeat sprite[].yrepeat
			seta[RETURN].z sprite[].z
			}
			
			set mid_spawn YES
			eshootvar sprite[].picnum
			ife RETURN -1 set mid_spawn NO
			else
			{
			geta[sprite[].owner].ang angvar 
			ifg actorvar[sprite[].owner].targetdist 8192 add angvar 14 else add angvar 24
			seta[RETURN].ang angvar
			seta[RETURN].extra sprite[].extra
			seta[RETURN].xvel sprite[].xvel
			seta[RETURN].zvel sprite[].zvel
			seta[RETURN].yvel sprite[].yvel
			seta[RETURN].owner sprite[].owner
			seta[RETURN].htowner sprite[].htowner
			seta[RETURN].htpicnum sprite[].htpicnum
			seta[RETURN].pal sprite[].pal
			setthisprojectile[RETURN].pal sprite[].pal
			seta[RETURN].xrepeat sprite[].xrepeat
			seta[RETURN].yrepeat sprite[].yrepeat
			seta[RETURN].z sprite[].z
			}
			set mid_spawn NO
			
		}
		ifvarand actorvar[sprite[].owner].monstflags 256 // gigantism
		{
			orvar monstflags 256
			seta[].mdflags 16
		}
		ifvarand actorvar[sprite[].owner].monstflags 4096 // radioactive
		{
			orvar monstflags 4096
		}
		// 128 == multi shots and shot angle randomization
		// 256 == guided shots with limited tracking
	}
	else
	ifvarand actorvar[sprite[].owner].monstflags 64 // double shot power
	ife sprite[sprite[].owner].statnum 4
	{
		orvar monstflags 524288 // double size rendering flag
		seta[].mdflags 16
	}
}

ifspawnedby RESPAWN
{
	geta[].owner spriteid
	ifvarn spriteid -1 
	{
		ifn sprite[].picnum BOSS1
			seta[].pal sprite[spriteid].pal
		getav[spriteid].SPRITELOTAG SPRITELOTAG
		getav[spriteid].monstflags monstflags
		getav[spriteid].mlevel mlevel
		ife actorvar[spriteid].team 1 set team 1
		
		switch sprite[].picnum
		case FIRSTGUNSPRITE
		case SHOTGUNSPRITE
		case CHAINGUNSPRITE
		case RPGSPRITE
		case HBOMBAMMO
		case FREEZESPRITE
		case SHRINKERSPRITE
		case HEAVYHBOMB
		case TRIPBOMBSPRITE
		case DEVISTATORSPRITE
		case AMMO
		case GROWSPRITEICON
		case SHOTGUNAMMO
		case BATTERYAMMO
		case RPGAMMO
		case GROWAMMO
		case BLOODAMMO
		case CRYSTALAMMO
		case DEVISTATORAMMO
		case FREEZEAMMO
		case COLA
		case SIXPAK
		case ATOMICHEALTH
		case FIRSTAID
		case SHIELD
		case STEROIDS
		case HOLODUKE
		case AIRTANK
		case JETPACK
		case HEATSENSOR
		case BOOTS
		case SABERSPRITE
		case DBSPRITE
		case DBAMMO
		case PLASMASPRITE
		case PLASMAAMMO
		case GLOCKSPRITE
		case ATOMICSHOTTY
		case BOWSPRITE case QUIVERSPRITE
		case RAILGUNAMMO
		case NUKESPRITE
			ife random_items YES
			state randomize_item
		break
		// case GREENSLIME
		// case EGG
		case NEWPIG
		case NEWPIGSTAYPUT
		case NEWPIGGUARD
		case NEWPIGDIVE
		case NEWPIGPISS
		case NEWPIGDONUT
		case CRAZYLADY
		case NEWCOMM case NEWCOMMSTAYPUT
		case NEWTROOPSTAYPUT
		case NEWTROOPJETPACK
		case NEWTROOP
		case NEWTROOPGUARD
		case NEWTROOPDUCKING
		case NEWTROOPONTOILET
		case NEWTROOPJUSTSIT
		case NEWTROOPRUNNING
		case ARMLIZTROOP
		case ARMLIZSTAYPUT
		case ARMLIZTROOPDUCK
		case NURGLE
		case NURGLESTAYPUT
		case SYTH
		case SITH
		case LIZTROOPSTAYPUT
		case LIZTROOPJETPACK
		case LIZTROOP
		case LIZTROOPSHOOT
		case LIZTROOPRUNNING
		case LIZTROOPDUCKING
		case LIZTROOPONTOILET
		case LIZTROOPJUSTSIT
		case OCTABRAIN
		case OCTABRAINSTAYPUT
		case OCTATROOP
		case DRONE
		case COMMANDER
		case COMMANDERSTAYPUT
		case TANK
		case PIGCOP
		case PIGCOPSTAYPUT
		case PIGCOPDIVE
		case RECON case NEWRECON
		case LIZMAN
		case LIZMANSTAYPUT
		case LIZMAN2
		case LIZMAN2STAYPUT
		case LIZMAN2JUMP
		case LIZMANGUARD
		case LIZMANJUMP
		case LIZMANSPITTING
		case ROTATEGUN
		case BOSS2FLY
		case BOSS2FLYPUT
		case ROBOSHARK case ROBOSHARKSTAYPUT
		case LIZDOG case LIZDOGSTAYPUT
		case BOSS1
		case BOSS1STAYPUT
		case NEWBATLORD
		case NEWBATLORDSTAYPUT
		case BOSS2
		case BOSS2STAYPUT
		case BOSS3
		case BOSS3STAYPUT
		case BOSS4
		case CYCLOIDMAX
		case CMAXSTAYPUT
		case QUEEN
		case PIGPISSING
		case LIZTURRET
		case 8875
		case NEWBEAST
		case NEWBEASTCROUCH
		case NEWBEASTSTAYPUT
		case NEWBEASTHANG
		case NEWBEASTJUMP
		case LIZRANGER 
		case LIZRANGERDUCKING 
		case LIZRANGERSTAYPUT 
		case LIZRANGERGUARD
		case CHEERBOT
		case CHEERBOTSTAYPUT
		case ARMYANT
		case ARMYANTJUMP
		case ARMYANTCRAWL
		case ARMYANTCRAWLPUT
		case NEWSENTRY
		case LIZBOSS
		case PIGBOSS
		case PIGBOSSSTAYPUT
		case ARMPIG
		case EDFPIG
		case POLYMORPH
		case POLYPOLE
		case POLYMORPHPAD
		case POLYMORPHPOD
		case POLYGORE1 case POLYGORE2 case POLYGORE3 case POLYGORE4 case POLYGORE5
		case MECHBRAIN
		case MECHBRAINSTAYPUT
		case BATBOSS
		case PROTONSTAND
		case DRPROTON
		case PSPIDER
		case ZOMBIE
		case ZOMBIEGIDUP
		case CORRUPT
		case CYBERBEAST
		case MEGABRAIN 
		case MEGABRAINSTAYPUT
		case TERMINATOR
		case TERMINATORSTAYPUT
		case TERMINATORDUCKING
		case TERMINATORCRAWLING
		case DEVOURER
		case CANHEAD
		case NEWMECH
		case GUNSHIP
		case LIZELITE
		case SPACEBULL	
		case SPACEBULLSTAYPUT
		case SPACEBULLDUCKING
		case SCUBATROOP
		case SCUBATROOPSIT
		case COMBINEDMEN
			set lastcrumb 0
			changespritestat THISACTOR 2 // STASISSTAT
			set stasis 40
			set stun 40
			set damflash 257
			seta[].cstat 0
			geta[].mdflags temp
			orvar temp 16
			seta[].mdflags temp
			seta[].htpicnum RESPAWN // failsafe
			set targetdist -1 // extra failsafe
			set instasis YES
		break
		case TRANSPORTERSTAR
			geta[spriteid].hitag initsprite
		break
		endswitch
	}
		
	ifactor TEAMSPAWNER
	{
		set mtype 2
		cstat 32768
		set SPRITELOTAG 0
		sizeat 32 32
	}
}

switch sprite[].picnum

case JUMPAD // ERROR!!!

	geta[].owner spriteid
	geta[spriteid].picnum picnum 
	al picnum
	cactor SMALLSMOKE
	cstat 32768
	changespritestat THISACTOR 1
break

case 1068
    set value 10
	state spawnimpcoins
	sound VENT_BUST
break

case APLAYER
	ife mirror_thismap YES
		state mirrorplayer
	
break

case JIBS1
case JIBS2
case JIBS3
case JIBS4
case JIBS5
case JIBS6



case 2246 case 2247 case 2248 case 2249
case 2251 case 2252 case 2253 case 2254
case 2256 case 2257 case 2258 case 2259
case 2261 case 2262 case 2263 case 2264
case 2266 case 2267 case 2268 case 2269
case 2287 case 2288 case 2289 case 2290 case 2291 case 2292 case 2293
	geta[].xrepeat init_xrepeat
	div init_xrepeat 2
	seta[].xrepeat init_xrepeat
	geta[].yrepeat init_yrepeat
	div init_yrepeat 2
	seta[].yrepeat init_yrepeat
	
	geta[].owner spriteid
	ifn spriteid -1
	{
		getav[spriteid].shrunken shrunken
		seta[].pal sprite[spriteid].pal
		randvar lastang 128 // angle change per tic
		sub lastang 64

		ifactor JIBS6
		{
			ife sprite[spriteid].picnum BEASTHEADPROJ spritepal 6
			ife sprite[spriteid].picnum BEASTARMPROJ spritepal 6
			ife sprite[spriteid].picnum BEASTLEGPROJ spritepal 6
			ife sprite[spriteid].picnum ANTHEADPROJ spritepal 6
			ife sprite[spriteid].picnum BBHEADJIBPROJ spritepal 6
			ife sprite[spriteid].picnum BBARMJIBPROJ spritepal 6
			ife sprite[spriteid].picnum BBLEGJIBPROJ spritepal 6
			ife sprite[spriteid].picnum DEVOURER spritepal 6
			ife sprite[spriteid].picnum ARMYANT spritepal 6
			ife sprite[spriteid].picnum ARMYANTCRAWL spritepal 6
			
			ifg shrunken 20 ifl shrunken SHRUNKCOUNT cstat 32768
			geta[spriteid].picnum picnum
			ife picnum SHOTSPARK1
			{
				geta[spriteid].htg_t 8 hitsprite
				ife sprite[hitsprite].picnum EGG spritepal 6
				ife sprite[hitsprite].picnum NEWBEAST spritepal 6
				ife sprite[hitsprite].picnum CYBERBEAST spritepal 6
				ife sprite[hitsprite].picnum ARMYANT spritepal 6
				ife sprite[hitsprite].picnum ARMYANTCRAWL spritepal 6
			}
			ifn sprite[].pal 6 seta[].blend 130
			ife sprite[spriteid].picnum DEANOVA
			ife actorvar[spriteid].mtype 1 cstat 32768
			
			ife sprite[spriteid].picnum BLOODEXP
			{
				geta[].z z
				add z 8192
				seta[].z z
				seta[].htbposz z
				spritepal 61
			}
		}
		ife sprite[spriteid].picnum BOSS4 spritepal 6
	}

break

case HEADJIB1
case ARMJIB1
case LEGJIB1

	geta[].owner spriteid
	getav[spriteid].shrunken shrunken
	seta[].pal sprite[spriteid].pal
	randvar lastang 128 // angle change per tic
	sub lastang 64
	// ife actorvar[spriteid].upscaled YES
	//	state upscaleme
break

case LIZMANHEAD1
	geta[].owner spriteid
	getav[spriteid].shrunken shrunken
	seta[].pal sprite[spriteid].pal
	randvar lastang 128 // angle change per tic
	sub lastang 64
break
case LIZMANARM1
case LIZMANLEG1

	geta[].owner spriteid
	getav[spriteid].shrunken shrunken
	seta[].pal sprite[spriteid].pal
	randvar lastang 128 // angle change per tic
	sub lastang 64
	// ife actorvar[spriteid].upscaled YES
	//	state upscaleme
break

case PIGHEADPROJ case ANTHEADPROJ
case BULLHEADPROJ
geta[].owner spriteid
	getav[spriteid].shrunken shrunken
	seta[].pal sprite[spriteid].pal
ifrnd 128 cstator 4
break

case PIGARMGROUND case PIGLEGGROUND case PIGHEADGROUND
case BULLHEADGROUND case BULLLEGGROUND case BULLARMGROUND
case EGGJIBGROUND case TROOPHEADGROUND case NEWTROOPHEADGROUND
case COMMHEADGROUND case COMMARMGROUND case NEWCOMMHEADGROUND
case LIZRANGERHEAD case LIZHEADGROUND
case RANGERLEGPROJ case RANGERLEGGROUND
case ANTHEADGROUND case ARMPIGARMGROUND case ARMPIGFOOTGROUND case ARMPIGLEGGROUND
case BEASTHEADGROUND case BEASTLEGGROUND case BEASTARMGROUND
case ZOMBIEHEADGROUND case CRAZYHEADGROUND case MANDOCHESTGROUND case MANDOLEGGROUND
case MANDOARMGROUND case MANDOHEADGROUND
case TERMLEGPART1GROUND case TERMLEGPART2GROUND case TERMLEGPART3GROUND
case REDARMGROUND case BLUEARMGROUND
case NEWMECHARMGROUND case MECHESTGROUND
case ARMLIZCHESTGROUND case ARMLIZARMGROUND case ARMLIZLEGGROUND
	geta[].owner spriteid
	getav[spriteid].shrunken shrunken
	getav[spriteid].countvarc countvarc
	seta[].pal sprite[spriteid].pal
	seta[].xrepeat sprite[spriteid].xrepeat
	seta[].yrepeat sprite[spriteid].yrepeat
	geta[spriteid].cstat temp
	ifvarand temp 4 cstator 4

break

case JIBS7
	geta[].owner spriteid
	seta[].pal sprite[spriteid].pal
break

case FIRSTGUNSPRITE
case FREEZESPRITE
case RPGSPRITE
case SHOTGUNSPRITE
case CHAINGUNSPRITE
case SHRINKERSPRITE
case DEVISTATORSPRITE
	ifspawnedby APLAYER ifg gametype 0 { cactor SMALLSMOKE sizeat 0 0 cstat 32768 }
break

case ICEBEAMTRAIL case BEAMTRAIL 
case RAINSPRITE case SNOWSPRITE
case BLUERING
cstat 32768 break


case SHOTSPARK1 

ifspawnedby APLAYER
ifn player[].curr_weapon FREEZE_WEAPON
// ifn player[].curr_weapon GROW_WEAPON
{
	ife pchar 4 ife player[].curr_weapon SHRINKER_WEAPON
		cstat 32768
	else
	ifn shootswitch 0
		cstat 32768
	else
	{
		ldist xydist3 THISACTOR player[].i
		ifg xydist3 3584 // 4608
		{
			ife player[].curr_weapon CHAINGUN_WEAPON
			ife zoomin YES
			espawn TRACER2
			else
			ife player[].curr_weapon SHOTGUN_WEAPON
			ife zoomin YES
			espawn TRACER2
			else
			ifn onturret -1
			espawn TRACER2
			else
			ife player[].curr_weapon DEVISTATOR_WEAPON
			{
				set RETURN -1
				ife WEAPON7_SHOOTS BARRETPROJ
				{
					ife zoomin YES
						espawn TRACER2
					else
						espawn TRACER
				}
				ife WEAPON7_SHOOTS EXPBULLET
				espawn TRACER
			}
			else
			ife player[].curr_weapon GROW_WEAPON
			{
				set RETURN -1
				ife pchar 2 
				{
					espawn TRACER
					seta[RETURN].blend 1
					seta[RETURN].pal 1
				}
			}
			else
			espawn TRACER
			
			ifn RETURN -1
			{
				ife player[].curr_weapon PISTOL_WEAPON
				ifg player[].kickback_pic 4 seta[RETURN].cstat 4
				
				ife pchar 2
				{
					ife player[].curr_weapon CHAINGUN_WEAPON
					ifvarand wesupgrades[CHAINGUN_WEAPON] 1
					ifrnd 128 seta[RETURN].cstat 4
					
					ife player[].curr_weapon DEVISTATOR_WEAPON
					{
						ife player[].hbomb_hold_delay 0 seta[RETURN].cstat 4
					}
				}
				else
				ife pchar 3
				{
					ife player[].curr_weapon SHOTGUN_WEAPON
					ife player[].kickback_pic WEAPON2_FIREDELAY
					{
						ife rightDB_weapcount WEAPON2_FIREDELAY ifrnd 128 nullop else
						seta[RETURN].cstat 4
					}
					ife player[].curr_weapon CHAINGUN_WEAPON
					ifvarand mandoupgrades[CHAINGUN_WEAPON] 1
					ifrnd 128 seta[RETURN].cstat 4
				}
				else
				ife pchar 4
				{
					ife player[].curr_weapon PISTOL_WEAPON seta[RETURN].pal 125
				}
				
				
				geta[].z z
				getp[].posz zdist
				sub zdist z
				// negative numbers mean lower than player, positive mean higher
				
				// 3584 is a certain percentage of xydist3
				// we want that percentage and we want to multiply zdist by it
				set temp 35840000 // 40960000
				div temp xydist3
				
				mul zdist temp
				div zdist 10000
				getp[].posz z
				sub z zdist
				seta[RETURN].z z
				geta[].x x2
				geta[].y y2
				sub x2 player[].posx
				sub y2 player[].posy
				getangle angvar x2 y2
				// this is the angle to make player face the shotspark1
				// we can't assume it is the current player angle due to autoaim
				
				set x player[].posx
				add x 3584 // 4096
				rotatepoint player[].posx player[].posy x player[].posy angvar tempb tempc
				seta[RETURN].x tempb
				seta[RETURN].y tempc
				changespritesect RETURN player[].cursectnum
			}
		}
		
	}
	
}

	geta[].z z
	geta[].owner spriteid
	ifn spriteid -1 
	{
		set team actorvar[spriteid].team
		geta[spriteid].z z2
		ife sprite[spriteid].picnum APLAYER sub z2 8192 else
		{
			set zdist tiledata[sprite[spriteid].picnum].ysize
			mul zdist sprite[spriteid].yrepeat
			shiftl zdist 1
			sub z2 zdist 
		}
		sub z z2
		ldist xydist3 THISACTOR spriteid
		shiftvarr z 4
		getangle shotpitch xydist3 z	
		ifg shotpitch 1023 sub shotpitch 2048
	}
	ifspawnedby APLAYER
	{
		getp[].i spriteid
		ifn spriteid -1
		setav[spriteid].shotpitch shotpitch
	}
	
break

case PLASMEXPB
	ifspawnedby SHOTSPARK1	
	{
		geta[].owner myspawner
		cstat 32768
	}

break

case TRANSPORTERSTAR
	set tempe sprite[].owner
	ifn tempe -1
	ife sprite[tempe].statnum 4
	{
		ifn sprite[tempe].picnum PLAYERPLASMA 
		ifn sprite[tempe].picnum MANDOLASER
		ifn sprite[tempe].picnum PLASMAPROJ 
		ifn sprite[tempe].picnum FREEZEBLAST 
		ifn sprite[tempe].picnum FIRELASER 
		ifn sprite[tempe].picnum FIRELASER2 
		ifn sprite[tempe].picnum FIRELASER3 
		ifn sprite[tempe].picnum EDFLASER 
			set mtype 3
	}
break

case BULLETHOLE
getactor[].owner myspawner
ifn myspawner -1
{
	ife sprite[myspawner].picnum SHOTSPARK1
		state changetodecal	
}
break

case KNEE 
	operate 
	ife pchar 4
	ifn deaonwall -1
	{
		set deaonwall -1
		set dashing 2
		setp[].poszv -4096
		getp[].ang dashang
		add dashang 1024
	}

break

case HEAVYHBOMB
ifspawnedby APLAYER
{
  set myspawner player[].i
  geta[].xvel xvel
  ife pchar 2
  {
	  cactor WESBOMB
	  set team 1
	  
	  sizeat 8 8
	  action 0
	  cstat 256
	  changespritestat THISACTOR 1
	  
	  
	  geta[].ang angle2
	  add angle2 1024
	  seta[].ang angle2
	  getp[].horiz mtype
	  sub mtype 100
	  mul mtype -64
	  sub mtype 512
	  ifl mtype -20000 set mtype -20000
	  ifg mtype 4069 set mtype 4096
	  set dodgetime pipehold
	  
	  ifg burstfired 0
	  {
	    geta[].z z
		add z 1024
		seta[].z z
		seta[].htbposz z
		add dodgetime 30
		sub burstfired 1
		ifg burstfired 0
		{
			set temp player[].kickback_pic
			sub temp 2
			setp[].kickback_pic temp
			getp[].ammo_amount HANDBOMB_WEAPON temp
			add temp 1
			setp[].ammo_amount HANDBOMB_WEAPON temp
		}
	  }
	  else
	  {
	  espawn WESBOMB
	  set angle2 player[].ang
	  sub angle2 48
	  seta[RETURN].ang angle2
	  setav[RETURN].team 1
	  rand B 512
	  sub B 256
	  add B mtype
	  setav[RETURN].mtype B
	  setav[RETURN].dodgetime dodgetime
	  
	  espawn WESBOMB
	  set angle2 player[].ang
	  add angle2 48
	  seta[RETURN].ang angle2
	  setav[RETURN].team 1
	  rand B 512
	  sub B 256
	  add B mtype
	  setav[RETURN].mtype B
	  setav[RETURN].dodgetime dodgetime
	  set pipehold 0
	  }
  }
  else ife pchar 3
  {
	  getp[].ammo_amount HANDBOMB_WEAPON temp
	  sub temp 1
	  ifl temp 1 set temp 0
	  setp[].ammo_amount HANDBOMB_WEAPON temp
	  // cactor THERMAL
	  set team 1
	  seta[].mdflags 16
	  sizeat 10 10
	  
	  ife burstfired THERMAL 
	  {
		set xvel 312 set pipehold 30 
	  }
	  set temp pipehold
	  mul temp 9 div temp 5
	  ifinwater shiftvarr temp 1
	  add xvel temp
	  seta[].xvel xvel
	  set pipehold 0
	  set initsprite THERMAL
	  set countvarc THERMAL
	  set countvarb player[].player_par
  }
  else
  ife pchar 1
  {
	  getp[].ammo_amount HANDBOMB_WEAPON temp
	  sub temp 1
	  ifl temp 1
	  {
		set temp 0
		add turret_leftover 75
	  }
	  setp[].ammo_amount HANDBOMB_WEAPON temp
	  cactor ROLLYTURRET
	  set myspawner player[].i
	  set team 1
	  ifvarand shellyupgrades[HANDBOMB_WEAPON] 1 set initsprite 1
	  sizeat 30 26
	  action 0
	  cstat 256
	  changespritestat THISACTOR 1
	  ifp pducking nullop else
	  {
		  geta[].z z
		  add z 3072
		  seta[].z z
	  }
	  geta[].ang angvar
	  add angvar 1024
	  seta[].ang angvar
	  getp[].horiz mtype
	  sub mtype 100
	  mul mtype -64
	  sub mtype 512
	  ifl mtype -12800 set mtype -12800
	  ifg mtype 4069 set mtype 4096
	  clipdist 48
	  set dodgetime pipehold
	  set pipehold 0
  }
  else
  ife pchar 4
  {
	  cactor DOLLBOMB
	  // ife pipemode 2 spritepal 24
	  set myspawner player[].i
	  set team 1
	  sizeat 32 32
	  action 0
	  cstat 256
	  ifrnd 128 cstator 4
	  changespritestat THISACTOR 1
	  ifp pducking nullop else
	  {
		  geta[].z z
		  add z 3072
		  seta[].z z
	  }
	  geta[].ang angvar
	  add angvar 1024
	  seta[].ang angvar
	  getp[].horiz mtype
	  sub mtype 100
	  mul mtype -64
	  sub mtype 512
	  ifl mtype -12800 set mtype -12800
	  ifg mtype 4069 set mtype 4096
	  clipdist 48
	  set dodgetime pipehold
	  set pipehold 0
  }
  else
  {
	  set temp pipehold
	  mul temp 9 div temp 5
	  ifinwater shiftvarr temp 1
	  add xvel temp
	  seta[].xvel xvel
	  set pipehold 0
	  ifvarand dukeupgrades[HANDBOMB_WEAPON] 1
		seta[].mdflags 16
  }
}
break

case LOBTRAIL ife pchar 3 cstat 32768 break

case RPG
ifspawnedby APLAYER 
{
	ife player[].curr_weapon RPG_WEAPON
	ifn nukeselect 1
	{
		set temp NO
		ife pchar 0 ifvarand dukeupgrades[RPG_WEAPON] 1 set temp YES
		ife pchar 1 ifvarand shellyupgrades[RPG_WEAPON] 1 set temp YES
		ife temp YES
			strength 175
			
		ife pchar 3 { strength 75 sizeat 24 24 }
	}
		
	ife player[].curr_weapon RPG_WEAPON
	ife nukeselect 1
	{
		state checkrandtraj
		sizeat 64 64
		spritepal 47
		sound NUKEFIRE
		strength 1000
		sub nukeamount 1
		ifle nukeamount 0 
		{
			set nukeamount 0
			set nukeselect -2
			setp[].ammo_amount RPG_WEAPON 1
		}
	}
	else
	ifn player[].curr_weapon DEVISTATOR_WEAPON 
	{
		state checkrandtraj 
		ife pchar 2
		{
			ife zoomin NO
			{
				sizeat 48 48
				spritepal 11
				sound NUKEFIRE
				strength 500
			}
			else
			sizeat 32 32
		}
		ifvarand shellyupgrades[RPG_WEAPON] 1 nullop else
		ife pchar 1
		{
			ife rpgtype 0 spritepal 2
			ife rpgtype 1 spritepal 1
		}
		ife pchar 0 ifvarand dukeupgrades[RPG_WEAPON] 2
		{
			geta[].xvel xvel mul xvel 3 div xvel 2 seta[].xvel xvel
			geta[].zvel z mul z 3 div z 2 seta[].zvel z
		}
		ife pchar 1 ifvarand shellyupgrades[RPG_WEAPON] 2
		{
			geta[].xvel xvel mul xvel 3 div xvel 2 seta[].xvel xvel
			geta[].zvel z mul z 3 div z 2 seta[].zvel z
		}
	}
	ifn targetlock[0] -1 
	{
		set targetwait 20
		set mtype TARGETLOCK
		set bottarget targetlock[0]
		setarray targetlock[0] -1
	}
	else
	ifn targetlock[1] -1 
	{
		set targetwait 20
		set mtype TARGETLOCK
		set bottarget targetlock[1]
		setarray targetlock[1] -1
	}
	else
	ifn targetlock[2] -1 
	{
		set targetwait 20
		set mtype TARGETLOCK
		set bottarget targetlock[2]
		setarray targetlock[2] -1
	}
	ifg loadrox 0
	{
		ife player[].kickback_pic WEAPON4_FIREDELAY
		{
			// FIRST ROCKET
			ife loadrox 4 set loadrox 8
			ife loadrox 3 set loadrox 7
			ife loadrox 2 { geta[].zvel z add z 512 seta[].zvel z }
		}
		ife loadrox 7 { geta[].ang angvar ifn burstfired MANDOFETT sub angvar 16 seta[].ang angvar }
		ife loadrox 6 { geta[].ang angvar ifn burstfired MANDOFETT add angvar 16 seta[].ang angvar set loadrox 2 }
		sub loadrox 1
	}
	ife player[].curr_weapon DEVISTATOR_WEAPON
	ife pchar 0
	{
		ifvarand dukeupgrades[DEVISTATOR_WEAPON] 2
		{
			ife devside 0
			{
				getp[].ammo_amount 7 temp
				add temp 1
				setp[].ammo_amount 7 temp
				geta[].z z, sub z 2048 seta[].z z
				set devside 1
			}
			else set devside 0
		}
		
		ifvarand dukeupgrades[DEVISTATOR_WEAPON] 1
		{
			cstat 32768
			set initsprite 666
		}
	}
	
}
else
{
	geta[].owner spriteid
	ifn spriteid -1
	{
		// ifn sprite[spriteid].pal 0 ifg sprite[].extra 50 seta[].extra 50
		getav[spriteid].shrunken shrunken
		ifg shrunken 20 ifl shrunken SHRUNKCOUNT
		{
			seta[].mdflags 16
			seta[].extra 1
			geta[].z z
			add z 1024
			seta[].z z
			seta[].x sprite[spriteid].x
			seta[].y sprite[spriteid].y
		}
		ifspawnedby CANHEAD
		{
			set mtype CANHEAD
			sizeat 36 36
		}
		ifspawnedby BOSS2
		{
			ife actorvar[spriteid].initsprite 1996
			{
				cactor CBPROJ
				seta[].extra 80
				setthisprojectile[].extra 80
				setthisprojectile[].spawns CBPROJEXP
				setthisprojectile[].isound BREAKROCK
				setthisprojectile[].workslike 32770
				setthisprojectile[].hitradius 1816
				sizeat 64 64
				setthisprojectile[].xrepeat 64
				setthisprojectile[].yrepeat 64
				geta[].xvel xvel mul xvel 3 div xvel 2 seta[].xvel xvel
				geta[].zvel yvel mul yvel 3 div yvel 2 seta[].zvel yvel
			}
		}
		state aim_bottarget
		// ifvarn player[].holoduke_on -1
		// state aim_holoduke
		
		
	}
}
break

// case FIREBOLT
// ifspawnedby APLAYER
// {
	// geta[].z z
	// add z 512
	// seta[].z z
// }
// break

case PLAYERPLASMA
case MANDOLASER
ifspawnedby APLAYER
{
	set xvel player[].posxv
	abs xvel
	set x player[].posyv
	abs x
	add xvel x
	ifge xvel 999999
	state randtraj2
	geta[].xvel xvel
	geta[].zvel z2	
	shiftr z2 4
	getangle tempb xvel z2
	seta[].pitch tempb
}
break

case BLADEPROJ

	ifg sawspeed 25
	{
		geta[].xvel xvel
		mul xvel 3, div xvel 2
		seta[].xvel xvel
		geta[].zvel z
		mul z 3, div z 2
		seta[].zvel z
	}

	geta[].z z
	add z 2048
	seta[].z z
	geta[].xvel xvel
	geta[].zvel z2	
	shiftr z2 4
	getangle tempb xvel z2
	seta[].pitch tempb
break

case ARCBALLPROJ
case FTPROJ
case RADPROJ
case BLOODBULLET
case SHOCKPROJ
case PLASGOOPROJ
case GOOBULLET
case REPAIRPROJ
case SWIRLPROJ
	seta[].blend 1
break

case PLASPELPROJ
case MINIBOLT
case NOVAPLASBOLT
	seta[].blend 1
	cstator 2
	
	state randtraj
	
	geta[].xvel xvel
	geta[].zvel z2	
	shiftr z2 4
	getangle tempb xvel z2
	seta[].pitch tempb
break

case DEALASER
	seta[].blend 1
	cstator 2
	
	ifspawnedby APLAYER
	{
		ife WEAPON3_SHOTSPERBURST 3
		state randtraj2 
	}
	else
	{
		state aim_bottarget
		state randtraj
	}
	
	geta[].xvel xvel
	geta[].zvel z2	
	shiftr z2 4
	getangle tempb xvel z2
	seta[].pitch tempb
break

case BLASTBALL
	seta[].blend 1
	cstator 2
	state randtraj
	// ife pchar 3
	ifspawnedby APLAYER
	{
		ife player[].curr_weapon DEVISTATOR_WEAPON set mtype BLASTBALL
		geta[].z z
		add z 1530
		seta[].z z
		ife devside 0 
		{
			add halfpoint 1
			set devside 1 
			setprojectile[BLASTBALL].offset 65408
			ifg player[].ammo_amount DEVISTATOR_WEAPON 1
			ife player[].kickback_pic WEAPON7_FIREDELAY
			ifge halfpoint 2
			ifvarand player[].ammo_amount DEVISTATOR_WEAPON 1
			{
				ifvarand mandoupgrades[DEVISTATOR_WEAPON] 2 set halfpoint -1 else
				set halfpoint 0
				getp[].ammo_amount DEVISTATOR_WEAPON temp
				sub temp 1
				setp[].ammo_amount DEVISTATOR_WEAPON temp
			}
		}
		else
		{
			set devside 0
			setprojectile[BLASTBALL].offset 128
		}
		
		
	}
break

case FLAMEPROJ
	state randtraj
	ifrnd 128 cstator 4
	ifrnd 128 cstator 8
	cstator 512
	seta[].alpha 128
	seta[].blend 1
break

case FLAMEPROJ2
	state randtraj2
	ifrnd 128 cstator 4
	ifrnd 128 cstator 8
	seta[].alpha 64
	seta[].blend 1
	sizeat 1 1
	cstat 32768
	geta[].z z, add z 512 seta[].z z
break

case BUBBLEPROJ
	geta[].ang angvar
	rand temp 16
	sub temp 8
	sub angvar temp
	seta[].ang angvar
	// seta[].blend 1
break

case COOLEXPROJ
case MEGAPROJ
case TIDALPROJ
case SLIMEPROJ
case KINETICPROJ
	seta[].blend 1
	state aim_bottarget
break

case PURPPROJ
	seta[].blend 1
	state aim_bottarget
	state randtraj
break

case COOLEXPLOSION1
	seta[].blend 1
	cstator 2
	// state aim_bottarget
break

case SMARTBOMB
	
	seta[].blend 1
	cstator 130
	getav[sprite[].owner].team team
break

case ARCBALLPROJ2
	ifspawnedby APLAYER set myspawner player[].i
	seta[].blend 1
break

case GREENLASER

	state aim_bottarget
	state randtraj2
	geta[].xvel xvel
	geta[].zvel z2	
	shiftr z2 4
	getangle tempb xvel z2
	seta[].pitch tempb
break

case PLASROCKET
case RAGNAROCKET
	geta[].xvel xvel
	geta[].zvel z2	
	shiftr z2 4
	getangle tempb xvel z2
	seta[].pitch tempb
	
	ife pchar 4
	ifspawnedby APLAYER
	{
		geta[].ang angvar
		geta[].zvel z
		set initsprite angvar
		set lastangvel z
		ife burstfired 3 { sub angvar 165 set angvel 36 set shotpitch 0 } else
		ife burstfired 2 { add angvar 165 set angvel -36 set shotpitch 0 } else
		ife burstfired 1 { sub z 1280 set shotpitch 256 set angvel 0 } else
		{ add z 1280 set shotpitch -256 set angvel 0 }
		ifg burstfired 0 sub burstfired 1
		seta[].ang angvar
		seta[].zvel z
	}
break

case BIGBOIPROJ
	geta[].xvel xvel
	geta[].zvel z2	
	shiftr z2 4
	getangle tempb xvel z2
	seta[].pitch tempb
	ifspawnedby SMALLMAN { geta[].z z add z 512 seta[].z z }
	ifspawnedby APLAYER { set myspawner player[].i geta[].z z sub z 2048 seta[].z z cstat 0 }
	ifspawnedby NEWTRIPBOMB 
	{ 
		seta[].owner player[].i 
		seta[].htpicnum APLAYER 
		seta[].mdflags 16	
	}
	ifspawnedby GUNSHIP seta[].mdflags 16
	ife rendmode 0 { cstator 2 seta[].blend 1 spritepal 23 }
break

case GRENADEPROJ
case WESGRENADE
	geta[].zvel z
	sub z 1280
	seta[].zvel z
	ifspawnedby APLAYER 
		set team 1
break

case FLAKPROJ
	ifspawnedby APLAYER getp[].i myspawner
	state randtraj
break

case STICKYPROJ
	ifspawnedby CHEERBOT getav[sprite[].owner].myspawner myspawner
	else
	ifspawnedby APLAYER getp[].i myspawner
	else 
	{
		geta[].owner myspawner
		geta[].z z
		add z 2048
		seta[].z z
		geta[].zvel z
		sub z 1024
		seta[].zvel z
	}
	state randtraj
	ifn sprite[].htowner -1
	getav[sprite[].htowner].team team
break

case SCUBAPROJ
	state aim_bottarget
	ifspawnedby NEWBOSS1 state randtraj
break

case FREEZEBOLT
case GENERICBOLT
	state aim_bottarget
	state randtraj2
break

case BIGPLASMA
	state aim_bottarget
	// ifvarn player[].holoduke_on -1
	// state aim_holoduke
	state randtraj
break

case BMFGPROJ
    set team 1
	geta[].owner spriteid
	ifn spriteid -1
		getav[spriteid].team team
break

case BMFGIMPACT
	geta[].owner spriteid
	ifn spriteid -1
	{
		getav[spriteid].team team
		seta[].pal sprite[spriteid].pal
	}
break

case COMETEXP
case ENERGYIMPACT
	geta[].owner spriteid
	ifn spriteid -1
	{
		seta[].pal sprite[spriteid].pal
		getav[spriteid].bottarget bottarget
	}
break

case TANKSHELL
	state aim_bottarget
break

case ARROWPROJ
 
 ifspawnedby APLAYER
 {
	
	ifrnd 84 sound BOWSHOOT else ifrnd 128 sound BOWSHOOT2
	else sound BOWSHOOT3
	set droptile APLAYER
	geta[].zvel z
	sub z 512
	seta[].zvel z
	getp[].player_par last_fired
	ife arrowtype 5 set arrowview THISACTOR
	// 0 = regular; 1 = burning; 2 = explosive; 3 = multi; 4 = freeze; 5 = spy; 6 = electric
	// 7 = blood; 8 = radioactive
	
 }
 
break

case STAKEPROJ
case CASTERPROJ
	ifspawnedby APLAYER
		set droptile APLAYER
		
	geta[].zvel z
	sub z 640
	seta[].zvel z
	
	geta[].xvel xvel
	geta[].zvel z2	
	shiftr z2 4
	getangle tempb xvel z2
	seta[].pitch tempb
 
break

case TRIPBOMB
	ifspawnedby APLAYER
	{
		// ife pchar 0 
		ifvarand dukeupgrades[TRIPBOMB_WEAPON] 4 { cactor NEWTRIPBOMB changespritestat THISACTOR 1 sizeat 12 12 }
		// ife pchar 1 ifvarand shellyupgrades[TRIPBOMB_WEAPON] 4 { cactor NEWTRIPBOMB changespritestat THISACTOR 1 sizeat 12 12 }
		// ife pchar 2 ifvarand wesupgrades[TRIPBOMB_WEAPON] 4 { cactor NEWTRIPBOMB changespritestat THISACTOR 1 sizeat 12 12 }
	}
break

case EXPLOSION2
case EXPLOSION2BOT

	ifspawnedby RPG
	{
		geta[].owner spriteid
		ifn spriteid -1
		{
			ife sprite[spriteid].pal 1
			{
				spritepal 1
				set mtype 1
				ifactor EXPLOSION2
				{
					headspritestat spriteid 1
					whilevarn spriteid -1
					{
						dist xydist THISACTOR spriteid
						ifl xydist 5120
						ifn sprite[spriteid].htpicnum RPG
						{
							set xydist2 5120
							sub xydist2 xydist
							shiftr xydist2 6
							ifl xydist2 10 set xydist2 10
							ifg xydist2 120 set xydist2 120
							seta[spriteid].htpicnum FREEZEBLAST
							geta[spriteid].htextra temp
							add temp xydist2
							seta[spriteid].htextra temp
							ifn myshelly -1 ife pchar 0
							seta[spriteid].htowner myshelly
							else
							seta[spriteid].htowner player[].i
						}
						nextspritestat spriteid spriteid
					}
					set B 0
					set x sprite[].x
					add x 1024
					whilevarn B 8
					{
						espawn BIGSMOKE
						setav[RETURN].mtype 1
						seta[RETURN].pal 89
						rotatepoint sprite[].x sprite[].y x sprite[].y angvar x2 y2
						setsprite RETURN x2 y2 sprite[].z
						add angvar 256
						add B 1
					}
					lotsofglass 30
				}
			}
			else
			ife sprite[spriteid].pal 2
			{
				set mtype 1
				ifactor EXPLOSION2
				{
					headspritestat spriteid 1
					whilevarn spriteid -1
					{
						dist xydist THISACTOR spriteid
						ifl xydist 5120
						ifn sprite[spriteid].htpicnum RPG
						ife actorvar[spriteid].monstatus 1
						{
							set xydist2 5120
							sub xydist2 xydist
							shiftr xydist2 4
							ifl xydist2 30 set xydist2 10
							ifg xydist2 120 set xydist2 120
							getav[spriteid].burning temp
							add temp xydist2
							setav[spriteid].burning xydist2
						}
						nextspritestat spriteid spriteid
					}
					set B 0
					set x sprite[].x
					add x 640
					set z sprite[].z
					add z 1024
					whilevarn B 8
					{
						espawn QUICKFLAME
						rotatepoint sprite[].x sprite[].y x sprite[].y angvar x2 y2
						setsprite RETURN x2 y2 z
						add angvar 256
						add B 1
					}
					
					set B 0
					set x sprite[].x
					add x 1280
					whilevarn B 16
					{
						espawn QUICKFLAME
						rotatepoint sprite[].x sprite[].y x sprite[].y angvar x2 y2
						setsprite RETURN x2 y2 z
						add angvar 128
						add B 1
					}
				}
			}
			else
			ife sprite[spriteid].pal 11
				set mtype WESBOT
			
		}
	}
	ifspawnedby HEAVYHBOMB
	{
		geta[].htowner spriteid
		ifn spriteid -1 
		getav[spriteid].myspawner myspawner // should be a player sprite
		ife pchar 0
		{
			ifvarand dukeupgrades[HANDBOMB_WEAPON] 1
			{
				set countvar 18
				set angvel 0
				whilevarn countvar 0
				{
					seta[].ang angvel
					rand zdist 2048
					sub zdist 6144
					ezshoot zdist BOMBLET
					add angvel 113
					set xvel sprite[RETURN].xvel
					rand temp 384
					sub xvel temp
					seta[RETURN].xvel xvel
					sub countvar 1
					setav[RETURN].team 1
				}
			}
			else
			ifvarand dukeupgrades[HANDBOMB_WEAPON] 4
			ife myspawner player[].i
			{
				spawn FIREBALL3D
				set initsprite THERMAL
			}
		}
		ife pchar 3 // THERMAL DETONATOR
		ife myspawner player[].i
		{
			set initsprite THERMAL
			spawn FIREBALL3D	
		}
	}
	geta[].owner spriteid
	ifn spriteid -1
	{
		ife sprite[spriteid].picnum TRIPBOMB
		{
			geta[spriteid].owner temp
			ifn temp -1
			ife sprite[temp].picnum APLAYER
			{
				ife actorvar[spriteid].mtype 1 setav[spriteid].mtype 2 else
				{
					seta[].ang sprite[spriteid].ang
					setprojectile[FLAKPROJ].velmult 2
					shoot FLAKPROJ shoot FLAKPROJ shoot FLAKPROJ shoot FLAKPROJ
					shoot FLAKPROJ shoot FLAKPROJ shoot FLAKPROJ shoot FLAKPROJ
					shoot FLAKPROJ shoot FLAKPROJ shoot FLAKPROJ shoot FLAKPROJ
					shoot FLAKPROJ shoot FLAKPROJ shoot FLAKPROJ shoot FLAKPROJ
					setprojectile[FLAKPROJ].velmult 1
					eshoot RPG
					seta[RETURN].xvel 1024
					seta[RETURN].ang sprite[spriteid].ang
				}
			}
		}
	}
	

break

case EXPLOSION5
ifn sprite[].owner -1
ife sprite[sprite[].owner].pal 1 spritepal 1
break

case FREEZEBLAST

	ifspawnedby LIZRANGER 
	{
		cstat 32768 set mtype 1 
		geta[].owner spriteid
		ifn spriteid -1
		ifn actorvar[spriteid].bottarget -1
			getav[spriteid].bottarget bottarget
		else set bottarget player[].i
	}
	else
	ifspawnedby LIZRANGERDUCKING 
	{ 
		cstat 32768 set mtype 1 
		geta[].owner spriteid
		ifn spriteid -1
		ifn actorvar[spriteid].bottarget -1
			getav[spriteid].bottarget bottarget
		else set bottarget player[].i
	} 
	else
	ifspawnedby APLAYER state checkrandtraj
	else
	state aim_bottarget

break

case SHRINKSPARK

seta[].blend 1
seta[].mdflags 16
spritepal 11
cstator 2
ifspawnedby APLAYER state checkrandtraj
else
state aim_bottarget

break

case FIRELASER2
ifspawnedby APLAYER 
{
	state checkrandtraj
	set myspawner player[].i
}
else
	state aim_bottarget
break

case FIRELASER
case NEWFIRELASER
case FIRELASER3
	seta[].blend 1
	cstator 2
ifspawnedby APLAYER state checkrandtraj else
	state aim_bottarget
break

case EDFLASER state randtraj
break

case RANGERPROJ
case MORTER2
case PLASMAPROJ
	state aim_bottarget
break

case CBPROJ
	state aim_bottarget
	ifspawnedby LILY 
	{
		seta[].mdflags 16
		geta[].xvel xvel
		geta[].zvel z2	
		shiftr z2 4
		getangle tempb xvel z2
		seta[].pitch tempb
	}
break

case NEWPLASMA
	seta[].blend 1
	state aim_bottarget
break

case RANGERTRAIL 
case BOLT_TRAIL 
case BIGSMOKE2
cstat 32768
break

case LASERLINE
geta[].owner myspawner
geta[myspawner].picnum mtype
break

case MORTER
	geta[].owner spriteid
	ifn spriteid -1
	{
		getav[spriteid].shrunken shrunken
		ifg shrunken 20 ifl shrunken SHRUNKCOUNT
		{
			seta[].mdflags 16
			seta[].extra 1
		}
		geta[].xvel xvel
		add xvel 128
		seta[].xvel xvel
		geta[].zvel z
		sub z 1024
		shiftr z 1
		seta[].zvel z
		state aim_bottarget
		// ifvarn player[].holoduke_on -1
		// state aim_holoduke
	}
break

case SPIT
	geta[].owner spriteid
	ifn spriteid -1
	{
		getav[spriteid].shrunken shrunken
		ifg shrunken 20 ifl shrunken SHRUNKCOUNT
		{
			seta[].mdflags 16
			seta[].extra 1
			geta[].z z
			add z 1024
			seta[].z z
		}
		getav[spriteid].initflags initflags
		ifvarand initflags 8
		{
			geta[].xvel xvel
			add xvel 128
			seta[].xvel xvel
			geta[].zvel z
			sub z 1024
			shiftr z 1
			seta[].zvel z
		}
	}

break


case GREENSLIME set monstatus 1 break

case TANK // Fix tank and newbeast attributes when spawn
  cstat 257
  sizeat 60 60
  clipdist 100
break

case NEWBEAST
case NEWBEASTCROUCH
	cstator 257
    sizeat 32 30
break

case SPACEBULL
	sizeat 26 26
	cstator 257
break

case DEANOVA
	sizeat 28 25
	cstator 257
break

case LIZELITE
	sizeat 23 23
	cstator 257
break

case NEWCOMM 
	sizeat 30 28
	cstator 257
break

case SYTH
case SITH
	sizeat 30 27
	cstator 257
break

case MANDOFETT
	sizeat 26 24
	cstator 257
break

case CYBERBEAST
	sizeat 32 28
	cstator 257
break

case COMBINEDMEN
	sizeat 50 48
	cstator 257
break

case CANHEAD
	sizeat 42 40
	cstator 257
break

case QUEEN
	ifspritepal 0 sizeat 96 80 else
	ifspritepal 42 sizeat 124 120 else
	sizeat 42 40
	cstator 257
break

case NEWBATLORD
	// sizeat 36 30
	cstator 257
break

case SISTERS
sizeat 42 40
break

case MARIO
case LUIGI
sizeat 40 40
break

case SERIOUSBOMB
sizeat 32 32
break

case SAMUS
case TIFA
sizeat 29 28
break

case LARATOWEL
sizeat 34 32
break

case EGG // Possibility to spawn egg using RESPAWN
ifspawnedby RESPAWN
	{ sizeat 40 40 ifrnd 128 cstator 4 }
ifspawnedby APLAYER
	{ sizeat 40 40 ifrnd 128 cstator 4 }
ifspawnedby DEVOURER
	{ geta[].z z sub z 8192 seta[].z z sizeat 42 42 ifrnd 128 cstator 4 }
break

case RECON // Possibility to spawn RECON using RESPAWN (fixes E1L2 missing monster)
      ifspawnedby RESPAWN
      { cstat 257
        sizeat 24 24
        clipdist 32
        changespritestat THISACTOR 1
        sound RECO_RECOG
      }
break

case WATERDRIP
	state checkfloordist
	ifl temp 8192 set initsprite 1
break

case PIGCOP
case NEWPIG
	geta[].owner spriteid
	getav[spriteid].shrunken shrunken
	break
	
case AIRFLASH1
	cstat 32768
	geta[].owner spriteid
	geta[spriteid].ang angvar
	geta[].z z
	sub z 8192
	ife sprite[spriteid].picnum SHELLY sub z 512
	ife sprite[spriteid].picnum DUKEBOT sub z 512
	ife sprite[spriteid].picnum ROLLYTURRET add z 4300
	ife sprite[spriteid].picnum LIZELITE sub z 1024
	seta[].z z
	set x sprite[].x
	ife sprite[spriteid].picnum ROLLYTURRET add x 192 else
	add x 384
	rotatepoint sprite[].x sprite[].y x sprite[].y angvar x2 y2
	seta[].x x2
	seta[].y y2
break

// case BEACHBALL
// case BEACHBALLPROJ
	// ifn sprite[].owner -1 
	// { 
		// geta[].owner spriteid 
		// seta[].xrepeat sprite[spriteid].xrepeat seta[].yrepeat sprite[spriteid].yrepeat
		// seta[].pal sprite[spriteid].pal
	// }
// break
	
case IMPCOIN
	geta[].owner spriteid
	ifn spriteid -1 seta[].pal sprite[spriteid].pal
break

case SHOCK_ACTOR
case LIGHTNING_TRAIL1
	cstat 32768
	sizeat 1 1
break

case CBPROJEXP
case MOLTENROCK
	geta[].owner spriteid
	ifn spriteid -1 
	{ 
		seta[].xrepeat sprite[spriteid].xrepeat 
		seta[].yrepeat sprite[spriteid].yrepeat
		seta[].pal sprite[spriteid].pal
	}
break

case SHOCKBALL_EXP
	ifn sprite[].owner -1
	getav[sprite[].owner].myspawner myspawner
break

case GLAREANIM
	cstat 130
	seta[].blend 1
	seta[].alpha 96
break

case AIRSHOCK
	geta[].owner spriteid
	ifn spriteid -1
	{
		set myspawner sprite[spriteid].owner
		seta[].pal sprite[spriteid].pal
		ife sprite[spriteid].pal 0
		set mtype 1
		
		ife sprite[spriteid].picnum RADPROJ
		ife sprite[spriteid].pal 10
		set mtype 2
	}
break

case FAKEDUKE
	ifspawnedby RESPAWN 
		set mtype 1

break

case GREEN_EXP
	geta[].owner spriteid
	ifn spriteid -1
	{
		set myspawner sprite[spriteid].owner
		ife sprite[myspawner].picnum GUNSHIP spritepal 122
	}
break

case BUBBEXP
	geta[].owner spriteid
	ifn spriteid -1
	{
		set myspawner sprite[spriteid].owner
		seta[].pal sprite[spriteid].pal
		getav[spriteid].team team
	}
break

case PLASDISKPROJ
	seta[].blend 1
	espawn PLASMADISK
	setav[RETURN].myspawner THISACTOR
	seta[RETURN].mdflags 16
	seta[RETURN].cstat 176 // 8
	set myspawner RETURN
break

default
	ifn sprite[].owner -1
	{
		getav[sprite[].owner].shrunken shrunken
		ifg shrunken 20 ifl shrunken SHRUNKCOUNT
		{
			ifn sprite[].picnum AMMO
			// ifn sprite[].picnum SHOTGUNSPRITE
			// ifn sprite[].picnum SHOTGUNAMMO
			// ifn sprite[].picnum CHAINGUNSPRITE
			// ifn sprite[].picnum BATTERYAMMO
			seta[].mdflags 16
			ife sprite[].statnum 4 
			{
				seta[].extra 1
				geta[].z z
				add z 1024
				seta[].z z
				seta[].x sprite[sprite[].owner].x
				seta[].y sprite[sprite[].owner].y
			}
		}
	}
break

endswitch
endevent

defstate stayput_replace
	
	set upscaled NO
	rand pal 13
	add pal 10
	ifge pal 17 ifle pal 20 set pal 0
	rand temp 12
	ifle temp 2
		set picnum LIZRANGERSTAYPUT
	else
	ifle temp 4
		set picnum TERMINATORSTAYPUT
	else
	ifle temp 6
	{
		set picnum MECHBRAINSTAYPUT
		ifrnd 84 set pal 0
		else ifrnd 128 set pal 3 else
		set pal 14
	}
	ifle temp 8
	{
		set picnum SPACEBULLSTAYPUT
		rand tempb 6
		ife tempb 0 set pal 13 else ife tempb 1 set pal 14 else
		ife tempb 2 set pal 16 else ife tempb 3 set pal 21 else
		ife tempb 4 set pal 40 else ife tempb 5 set pal 19 else set pal 51
		set upscaled NO
	}
	else
	ifle temp 10
		set picnum NEWCOMMSTAYPUT
	else
		set picnum CHEERBOTSTAYPUT
ends

defstate select_water_enemy

	set upscaled NO
	rand pal 13
	add pal 10
	ifge pal 17 ifle pal 20 set pal 0

		set picnum SCUBATROOP
		
	ifrnd 40 
	{
		set picnum DEVOURER
		ife pal 0 set pal 21
	}

ends

defstate select_norm_enemy

	ifn sprite[].htactorstayput -1 { state stayput_replace break }
	
	ife challenge YES ifactor NEWPIG ifspritepal 21
	{
		set pal 19
		set picnum SPACEBULL
		set upscaled NO
		break
	}

	rand temp 12
	ifl plevel 4 rand temp 3
	
	ifle temp 1
	{
		set picnum ROBOSHARK
		ifrnd 96 set pal 24 else set pal 0
	}
	else ifle temp 3
	{
		set picnum SPACEBULL
		// 40, 51, 16, 21, 13, 14, 19
		rand temp 6
		ife temp 0 set pal 13 else ife temp 1 set pal 14 else
		ife temp 2 set pal 16 else ife temp 3 set pal 21 else
		ife temp 4 set pal 40 else ife temp 5 set pal 19 else set pal 51
		set upscaled NO
	} 
	else ife temp 4
	{
		set picnum LIZELITE
		ifrnd 128 set pal 21 else set pal 12
		set upscaled NO
	} 
	else ife temp 5
	{
		set pal 0
		set picnum NEWCOMM 
		set upscaled NO
	}
	else ife temp 6
	{
		set picnum MECHBRAIN
		ifrnd 64 set pal 14
		ifrnd 64 set pal 3
		set upscaled NO
	}
	else ife temp 7
	{
		ifrnd 128 set picnum SITH else
		set picnum SYTH
		ifrnd 128 set pal 21 else set pal 15
		set upscaled NO
	} 
	else ife temp 8
	{
		set picnum MANDOFETT
		set pal 21
		set upscaled NO
	} 
	else ife temp 9
	{
		set picnum CYBERBEAST
		set pal 24
		set upscaled NO
	} 
	else ife temp 10
	{
		set picnum DEANOVA
		set pal 17
		set upscaled NO
	}
	else ife temp 11
	{
		ifrnd 128 set picnum FIGHTFEM else set picnum FIGHTMALE
		set pal 17
	}
	else // ife temp 11
	{
		set picnum CHEERBOT
		set pal 21
		set upscaled NO
	}


ends

state select_tough_enemy

	// ifge attbeaten 3 set tempb 11 else set tempb 10
	set tempb 11
	
	rand temp tempb
	
	switch temp
	case 0
		ifactornotstayput
		set picnum BATBOSS
		else set picnum CANHEADSTAYPUT
		set pal 10
		rand tempc 10
		add pal tempc
		ife picnum BATBOSS
		ife pal 21 set pal 19
	break
	case 1
		ifactornotstayput
		set picnum PSPIDER
		else
		set picnum BOSS2STAYPUT
		ifrnd 128 set pal 3 else set pal 46
		set upscaled NO
	break
	case 2
		ifactornotstayput
		set picnum CANHEAD
		else set picnum CANHEADSTAYPUT
		set pal 21
		set upscaled NO
	break
	case 3
		ifactornotstayput
		set picnum COMBINEDMEN
		else set picnum BOSS3STAYPUT
		set pal 21
		set upscaled NO
	break
	case 4
		set picnum QUEEN
		set pal 3
		ifrnd 64 set pal 21
		set upscaled NO
	break
	case 5
		ifactornotstayput ifvarand charlocked 4 ifrnd 128 { set picnum BATBOSS set pal 15 } else
		{
			ifactornotstayput set picnum BOSS2
			else set picnum BOSS2STAYPUT
			set pal 3
			ifrnd 64 set pal 21
		}
		set upscaled NO
	break
	case 6
		ifactornotstayput
		set picnum BOSS3
		else set picnum BOSS3STAYPUT
		set pal 3
	break
	case 7
		ifactornotstayput
		set picnum LIZDOG
		else set picnum PIGBOSSSTAYPUT
		set pal 104
	break
	case 8
		ifactornotstayput
		{ set picnum LIZDOG set pal 104 }
		else { set picnum CHEERBOTSTAYPUT set pal 43 }
	break
	case 9
		ifactornotstayput
		{ set picnum ROBOSHARK set pal 41 }
		else { set picnum NEWBATLORDSTAYPUT set pal 42 }
	break
	case 10
		ifactornotstayput
		set picnum NEWMECH
		else set picnum NEWMECHSTAYPUT
		ifrnd 84 set pal 21 else ifrnd 128 set pal 11 else set pal 0
	break
	case 11
		ifactornotstayput
		set picnum NURGLE
		else set picnum PIGBOSSSTAYPUT
		ifrnd 128 set pal 24 else
		ife picnum PIGBOSS set pal 21 else
		ife picnum PIGBOSSSTAYPUT set pal 21 else
		set pal 0
	break
	default
		al temp
		set picnum BOSS3
		set pal 3
	break
	endswitch
ends

defstate rand_monst_replace

	ifge SPRITELOTAG 10 break

	ifge SKILL 5 ife attmode 2 ifg plevel 4 nullop else
	ife marathon YES ifg plevel 5 nullop else
	ifn attmode YES break
	ife mid_spawn YES break // don't run another instance if already spawning
	ife VOLUME 6 ifg LEVEL 10 ifl LEVEL 38 break
	
	add replacecount 1
	ifn monstflags 0 break // don't replace if already flagged
	
	set TMP_B 30 // 45 highest possible interval between replacements
	set TMP_A plevel

	mul TMP_A 2 // 3
	ifg TMP_A 18 set TMP_A 18
	sub TMP_B TMP_A
	
	ifactor BOSS1 ifrnd 85 ifge plevel 3 set TMP_B 0
	ifactor NEWBATLORD ifrnd 85 ifge plevel 3 set TMP_B 0
	ifactor NEWBATLORDSTAYPUT ifrnd 85 ifge plevel 3 set TMP_B 0
	
	ifactor NEWPIG ifspritepal 21 ife challenge YES set TMP_B 0
	
	ifge replacecount TMP_B
	{
		set picnum -1
		switch sprite[].picnum
		case BOSS1STAYPUT case NEWBATLORDSTAYPUT
		case BOSS1 case BOSS2 case BOSS3 case BOSS4
		case NEWBATLORD case PIGBOSS case LIZBOSS
			ifspritepal 0 set picnum -1 // abort
			else state select_tough_enemy
		break
		case DEVOURER case DRPROTON case CANHEAD case CANHEADNOARMS 
		case PIGSUV case ROLLYTURRET case RECON case NEWRECON case GREENSLIME
		case ROTATEGUN case MEGABRAIN case NEWMECH case CHEERBOT case BIGTURRET
		case MECHBRAIN case MANDOFETT case LIZELITE case LIZTURRET case EDFTURRET
		case NEWBOSS1 case BOSS2FLY case CYCLOIDMAX case DUKEBOT case WESBOT case DEABOT
		case SHELLY case EDFTROOP case EDFSNIPER case EDFDRONE
		case ARMEDF case GUARD case NEWCOMM case NEWCOMMSTAYPUT
		case ARMPIG case EDFPIG case QUEEN case ARMLIZTROOP
		set picnum -1
		break
		
		case DRONE
			set picnum NEWSENTRY
			set pal 0
		break
		
		case COMMANDER case COMMANDERSTAYPUT

			ifrnd 160 set picnum NEWSENTRY else
			set picnum MEGABRAIN
			set pal 0
		break
		
		default 
			
			set pal 3
			ifinwater state select_water_enemy else
			ifgapzl 128 state select_norm_enemy else
			ifg plevel 4 
			iffloordistl 64
			{
				add toughcount 1
				
				set temp 9
				sub temp SKILL
				
				
				ifge toughcount temp // 5
				ifge prating 300
				{
					set toughcount 0
					set droptile SIXPAK
					state select_tough_enemy
				}
				else
				state select_norm_enemy 
			}
			else
			state select_norm_enemy 
		break
		
		endswitch
		
		ife picnum -1 break // abort process
		set mid_spawn YES
		espawnvar picnum
		ife RETURN -1 set mid_spawn NO
		else
		{
			ife picnum SCUBATROOP { ifrnd 32 set replacecount 0 } else
			set replacecount 0
			seta[RETURN].htactorstayput sprite[].htactorstayput
			seta[RETURN].pal pal
			ifn droptile 0 setav[RETURN].droptile droptile
			ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
			changespritestat RETURN 1
			seta[RETURN].cstat 257
			add sub_maxactors 1
			set mid_spawn NO
			spawn GLARESTAR
			killit
		}
		
	}

ends

state randomturn
	geta[].angoff angvar
	add angvar lastang
	seta[].angoff angvar
	// geta[].pitch angvar
	// add angvar wounded
	// seta[].pitch angvar
	// geta[].roll angvar
	// add angvar wounded
	// seta[].roll angvar
ends

onevent EVENT_SPAWN

	ife do_upscale YES
	{
		// upscale size hack on old enemies

		
		ifge sprite[].picnum 1822 ifle sprite[].picnum 1877
		{
			ifn sprite[].picnum OCTADEADSPRITE
			{
				set x sprite[].xrepeat, mul x 3, div x 4, seta[].xrepeat x
				set x sprite[].yrepeat, div x 2 seta[].yrepeat x
			}
		}
		else
		ifge sprite[].picnum 1890 ifle sprite[].picnum 1910
		state upscale_visual
		else
		ifge sprite[].picnum 1915 ifle sprite[].picnum 1955
		{
			set x sprite[].xrepeat, mul x 3, div x 4, seta[].xrepeat x
			set x sprite[].yrepeat, mul x 3, div x 4, seta[].yrepeat x
		}
		else
		ifge sprite[].picnum 2066 ifle sprite[].picnum 2079
		state upscale_visual
		else
		ifge sprite[].picnum 2122 ifle sprite[].picnum 2199
		{
			ifn sprite[].picnum LIZMANDEADSPRITE
			ifn sprite[].picnum LIZMANGUARD
			{
				set x sprite[].xrepeat, mul x 3, div x 4, seta[].xrepeat x
				set x sprite[].yrepeat, mul x 3, div x 4, seta[].yrepeat x
			}
		}
		else
		ifge sprite[].picnum 2270 ifle sprite[].picnum 2299
		state upscale_visual
		else
		ifge sprite[].picnum 2301 ifle sprite[].picnum 2308
		state upscale_visual
		else
		ifge sprite[].picnum 2310 ifle sprite[].picnum 2323
		state upscale_visual
		else
		ifge sprite[].picnum 2711 ifle sprite[].picnum 2758
		{
			set x sprite[].yrepeat, mul x 2, div x 3, seta[].yrepeat x
		}
		else
		ifge sprite[].picnum 4740 ifle sprite[].picnum 4804
		state upscaleme
		else
		ifge sprite[].picnum 9231 ifle sprite[].picnum 9245
		state upscaleme
	}
	switch sprite[].picnum
	
	case FIRSTGUNSPRITE
	case SHOTGUNSPRITE
	case CHAINGUNSPRITE
	case RPGSPRITE
	case HBOMBAMMO
	case FREEZESPRITE
	case SHRINKERSPRITE
	case BMFGSPRITE
	case GROWSPRITEICON
	// case HEAVYHBOMB
	case TRIPBOMBSPRITE
	case DEVISTATORSPRITE
	case AMMO
	case SHOTGUNAMMO
	case BATTERYAMMO
	case RPGAMMO
	case GROWAMMO
	case BLOODAMMO
	case CRYSTALAMMO
	case DEVISTATORAMMO
	case FREEZEAMMO
	case JOLLYMEAL
	case COLACANSTAND
	case BLUEBALLCAN
	case SNACKSPRITE
	case COLA
	case SIXPAK
	case ATOMICHEALTH
	case FIRSTAID
	case SHIELD
	case STEROIDS
	case HOLODUKE
	case AIRTANK
	case JETPACK
	case HEATSENSOR
	case NUKECOIN
	case IMPCOIN
	case RAILGUNAMMO
	case LASERPISTOL
	case SAWAMMO
	case SAWSPRITE
	case PLASMASPRITE
	case PLASMAAMMO
	case NUKESPRITE
	case CHAINGUNUPGRADE
	case M4UPGRADE
	case PISTOLUPGRADE
	case DEUPGRADE
	case SHOTGUNUPGRADE
	case TRIPBOMBUPGRADE
	case SPIDERMINESPRITE
	case SABERSPRITE
	case BOWSPRITE
	case QUIVERSPRITE
	case DBSPRITE
	case DBAMMO
	case SHOCKRIFLESPRITE
	case RADAWAY
		// ifspritepal 0
		set monstatus 100 strength 1
		ife stasis 0
		changespritestat THISACTOR 1
	break
	
	case ACCESSCARD
		set monstatus 100
		geta[].pal initsprite
	break
	
	case BOX
	case TIRE
	case BMWM4 case COPCAR case TAXI case CRUZ case CIVIC case PORSCHE case LAMBO90
	case BEETLE case HUMMER case JEEP case LIMO case PICKUP case PICKUP2 case VAN1
	case VAN2 case WRECKEDCAR case DODGECAR case FORD case ROVER
	case BMWM3 case NANOCOOPER case TOWTRUCK case CHEVELLE case OLDCAR
	case MICROBUS case AUDIA
	
	case TREE1 geta[].xrepeat startx geta[].yrepeat starty break
	
	case EDFTANKWRECK
		ifvarand initflags 4
		{
			geta[].htflags temp
			orvar temp 4
			seta[].htflags temp
			seta[].shade droptile
			xorvar initflags 4
		}
	break

	case NAVSPRITE
		seta[].htpicnum NAVSPRITE
		changespritestat THISACTOR 979 
		// change to 980 after base value trails are set
		cstat 32768
		geta[].z z
		sub z 6144 // 8192
		seta[].z z
		set countvar nav_init
		sub nav_init 1
		ife nav_init -1 set nav_init 5
		
	break
	
	case SHELL
	ifspawnedby APLAYER
	ife pchar 2
	{
		ife player[].curr_weapon PISTOL_WEAPON
		{
			geta[].xvel xvel
			ifrnd 128 mul xvel -1
			seta[].xvel xvel
		}
	}
	break
	
	case SHOTGUNSHELL
	
	ifspawnedby APLAYER
	ife pchar 3
	{
		ifvarand gotDB 2
		{
			ife player[].kickback_pic WEAPON2_SPAWNTIME
			{
				geta[].ang angvar
				add angvar 1024
				seta[].ang angvar
			}
		}
		else
		{
			spritepal 27
			cstator 2
			seta[].blend 1
		}
	}
	break
	
	case CAMTRACK
		changespritestat THISACTOR 991
	break
	
	case JIBS6
		geta[].owner spriteid
	
		ife sprite[spriteid].statnum 4
		{
			sizeat 16 16
			seta[].zvel 0
			seta[].xvel 24
			randvar temp 2047
			seta[].ang temp	
			ife sprite[spriteid].picnum EGGJIBPROJ spritepal 8
		}
		ifspawnedby SHOTSPARK1
		{	
			geta[].htowner spriteid
			geta[spriteid].htg_t 8 temp
			ife sprite[temp].picnum ZOMBIE spritepal 8
			ife sprite[temp].picnum CRONEN spritepal 8
			ife sprite[temp].picnum ARMYANT spritepal 8
			ife sprite[temp].picnum ARMYANTCRAWL spritepal 8
		}
	break
	
	case BLOODPOOL
		ifspawnedby EGGJIBGROUND ifn sprite[].pal 1 spritepal 6
		ifspawnedby ZOMBIE ifn sprite[].pal 1 spritepal 6
		ifspawnedby CRONEN ifn sprite[].pal 1 spritepal 6
		ifspawnedby ARMYANT ifn sprite[].pal 1 spritepal 6
		insertspriteq
	break
	case GREENSLIME seta[].mdflags 16 
		set spawnprotect 0
		set monstatus -1
	break
	case SHARK
		ifrnd 32 
		{
			cactor DOPEFISH
			seta[].htpicnum DOPEFISH
		}
		else 
		ifg sprite[].xrepeat 4 sizeat 40 40
	break
	case DOPEFISH
		sizeat 60 60
		cstator 257
	break
	
	case PIGCOPDEADSPRITE cactor 17109
		sizeat 28 28	
	break
	
	case OCTADEADSPRITE cactor 1870
		sizeat 24 24
	break
	
	case LIZMANDEADSPRITE sizeat 26 26
	break
	
	case PODFEM1
		ifg sprite[].xrepeat 4 
		{ 
			action ANEWFEMANG5 cactor NEWPODFEM1 strength TOUGH 
			geta[].xrepeat x, mul x 3 div x 4 seta[].xrepeat x
			geta[].yrepeat y, mul y 3 div y 4 seta[].yrepeat y
		}
	break
	case NAKED1
		ifg sprite[].xrepeat 4 { action ANEWFEMANG5 cactor NEWNAKED1 strength TOUGH }
	break
	case FEM5
		ifg sprite[].xrepeat 4 { action ANEWFEMANG8 cactor NEWFEM5 strength TOUGH }
	break
	case FEM6
		ifg sprite[].xrepeat 4 { action ANEWFEMANG8 cactor NEWFEM6 strength TOUGH }
	break
	
	
	case PIGCOP
	case PIGCOPDIVE
	case PIGCOPSTAYPUT
		set monstatus -1
		ifspawnedby RECON
		{
			cactor NEWPIG ai 0 sizeat 28 26
			seta[].htpicnum sprite[].picnum
			clipdist 40
			ife NEWENEMIES YES ifrnd 32 spritepal 21
			set upscaled NO 
			ifg shrunken 10 ifl shrunken SHRUNKCOUNT
			{ sizeat 6 5 strength 25 }
			else
			set burning 100
		}
		else
		ifspawnedby TANK
		{
			cactor NEWPIG ai 0 sizeat 28 26
			seta[].htpicnum sprite[].picnum
			clipdist 40
			ife NEWENEMIES YES ifrnd 32 spritepal 21
			set upscaled NO 
			ifg shrunken 10 ifl shrunken SHRUNKCOUNT
			{ sizeat 6 5 strength 25 }
			else
			set burning 100
		}
		else
		ifspawnedby PIGSUV
		{
			cactor NEWPIG ai 0 sizeat 28 26 
			seta[].htpicnum sprite[].picnum
			clipdist 40
			ife NEWENEMIES YES ifrnd 32 spritepal 21
			set upscaled NO 
			ifg shrunken 10 ifl shrunken SHRUNKCOUNT
			{ sizeat 6 5 strength 25 }
			else
			set burning 100
		}
		else
		ifn sprite[].htpicnum APLAYER
		ifg sprite[].xrepeat 4
		{
			ifactor PIGCOP 
			{ 
				cstator 257
				cactor NEWPIG ai 0 sizeat 28 26
				seta[].htpicnum sprite[].picnum
				clipdist 40
				ife monstflags 0
				ife NEWENEMIES YES ifrnd 32 spritepal 21
				set upscaled NO 
			}
			ifactor PIGCOPSTAYPUT
			{
				cactor NEWPIGSTAYPUT ai 0
				seta[].htpicnum sprite[].picnum
				ife monstflags 0
				ife NEWENEMIES YES ifrnd 32 spritepal 21
				cstator 257
				sizeat 28 26
				clipdist 40
				set upscaled NO
				seta[].htactorstayput sprite[].sectnum
			}
			ifactor PIGCOPDIVE 
			{
				cstator 257
				cactor NEWPIGDIVE ai 0 sizeat 28 26
				seta[].htpicnum sprite[].picnum				
				clipdist 40
				ife monstflags 0
				ife NEWENEMIES YES ifrnd 32 spritepal 21
				set upscaled NO 
				seta[].htactorstayput sprite[].sectnum
			}
			state rand_monst_replace
			ife NEWENEMIES YES
			ife monstflags 0
			{
				add termcount 1
				ifg termcount 8
				{
					set termcount 0
					ifactornotstayput espawn TERMINATOR
					else
					espawn TERMINATORSTAYPUT
					seta[RETURN].htpicnum sprite[RETURN].picnum
					seta[RETURN].xrepeat 28 // 42
					seta[RETURN].yrepeat 24 // 36
					seta[RETURN].cstat 257
					add sub_maxactors 1
					ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
					killit
				}
				else
				{
					ifn attmode NO ifl plevel 2 set pigcount 0
					add pigcount 1
					ifg pigcount 4
					{
						set pigcount 0 
						ifrnd 160
						espawn ARMPIG
						else espawn EDFPIG
						seta[RETURN].htpicnum sprite[RETURN].picnum
						seta[RETURN].htactorstayput sprite[].htactorstayput
						seta[RETURN].xrepeat 26
						seta[RETURN].yrepeat 24
						seta[RETURN].cstat 257
						seta[RETURN].extra EDFPIGSTRENGTH
						seta[RETURN].pal sprite[].pal
						ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
						ifn attmode 0
						ifn sprite[].pal 21
						ifg plevel 4
						ifrnd 64
						{
							seta[RETURN].pal 21
							setav[RETURN].initflags 32
						}
						add sub_maxactors 1
						killit
					}
					else
					{
						ifl plevel 4 set commcount 0
						ifn attmode YES set commcount 0
						add commcount 1
						
						ifgapzl 128 nullop else
						ifg commcount 6
						{
							set commcount 0 
							{
								ifactornotstayput espawn PIGBOSS
								else
								espawn PIGBOSSSTAYPUT
								seta[RETURN].htpicnum sprite[RETURN].picnum
								seta[RETURN].pal 21
								seta[RETURN].xrepeat 33
								seta[RETURN].yrepeat 30
								setav[RETURN].droptile SIXPAK
								seta[RETURN].extra 1000
								seta[RETURN].cstat 257
								ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
								add sub_maxactors 1
								killit
							}
						}
						ifn attmode NO add dogcount 1
						ifg dogcount 11
						ifactornotstayput
						{
							set dogcount 0
							espawn LIZDOG
							seta[RETURN].htpicnum sprite[RETURN].picnum
							seta[RETURN].xrepeat 28
							seta[RETURN].yrepeat 26
							seta[RETURN].cstat 257
							seta[RETURN].extra LIZDOGSTRENGTH
							ifrnd 64 seta[RETURN].pal 17 else
							ifrnd 96 seta[RETURN].pal 3
							ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
							state buddy_position
						}
						
					}
				}
				
			}
			
		}

	break
	

	case LIZTROOP
	case LIZTROOPSTAYPUT
	case LIZTROOPDUCKING
	case LIZTROOPJETPACK
	case LIZTROOPSHOOT
	case LIZTROOPRUNNING
	set monstatus -1
	ifn sprite[].htpicnum APLAYER
	ife gametype 0
	ifg sprite[].xrepeat 4
	{
		ifactor LIZTROOP 
		{
			cstator 257
			cactor NEWTROOP ai 0 sizeat 24 22
			seta[].htpicnum sprite[].picnum	
			strength NEWTROOPSTRENGTH set upscaled NO 
			ife monstflags 0
			ife monstflags 0
			ife NEWENEMIES YES ifg plevel 2 ifrnd 24 spritepal 24
		}
		ifactor LIZTROOPSTAYPUT
		{
			ife marathon 2
			{
				cstator 257
				ai 0 sizeat 24 22
				set upscaled NO
				cactor NEWTROOPSTAYPUT
				seta[].htpicnum sprite[].picnum	
				strength NEWTROOPSTRENGTH 
				ife monstflags 0
				ife NEWENEMIES YES ifg plevel 2 ifrnd 24 spritepal 24
			}
			else
			{
				ifoutside
				{
					cstator 257 ai 0 set upscaled NO
					cactor LIZTURRET
					seta[].htpicnum sprite[].picnum	
					sizeat 24 22
					strength LIZTURRETSTRENGTH 
					
				}
				else
				{
					cstator 257
					ai 0 sizeat 24 22
					set upscaled NO
					ifceilingdistl 256
					{
						cactor NEWTROOPSTAYPUT
						seta[].htpicnum sprite[].picnum	
						strength NEWTROOPSTRENGTH 
						ife monstflags 0
						ife NEWENEMIES YES ifg plevel 2 ifrnd 24 spritepal 24
					}
					else
					{
						cactor LIZTURRET
						seta[].htpicnum sprite[].picnum	
						strength LIZTURRETSTRENGTH 
					}
				} 
				set upscaled NO 
			}
			
		}
		ifactor LIZTROOPSHOOT
		{
			cstator 257
			cactor NEWTROOPDUCKING ai 0 sizeat 24 22
			seta[].htpicnum sprite[].picnum				
			strength NEWTROOPSTRENGTH set upscaled NO
			ife monstflags 0
			ife NEWENEMIES YES ifg plevel 2 ifrnd 24 spritepal 24
		}
		ifactor LIZTROOPDUCKING 
		{
			cstator 257
			cactor NEWTROOPDUCKING ai 0 sizeat 24 22 
			seta[].htpicnum sprite[].picnum	
			strength NEWTROOPSTRENGTH set upscaled NO 
			ife monstflags 0
			ife NEWENEMIES YES ifg plevel 2 ifrnd 24 spritepal 24
		}
		ifactor LIZTROOPJETPACK
		{
			cstator 257
			cactor NEWTROOPJETPACK ai 0 sizeat 24 22
			seta[].htpicnum sprite[].picnum	
			strength NEWTROOPSTRENGTH set upscaled NO 
			ife monstflags 0
			ife NEWENEMIES YES ifg plevel 2 ifrnd 24 spritepal 24
		}
		ifactor LIZTROOPRUNNING
		{
			cstator 257
			cactor NEWTROOP ai 0 sizeat 24 22 
			seta[].htpicnum sprite[].picnum	
			strength NEWTROOPSTRENGTH set upscaled NO 
			ifspritepal 21
            addstrength NEWTROOPSTRENGTH
			set dodgetime 8
		}
		ife monstflags 0
		state rand_monst_replace
		ife NEWENEMIES YES
		ifn sprite[].picnum NEWTROOPJETPACK
		ife monstflags 0
		{
			ifn attmode NO ifl plevel 2 set troopcount 0
			add troopcount 1
			ifn attmode NO
			{
				add dogcount 1
				ifg plevel 5 add troopcount 1
			}
			ifg troopcount 4
			{
				ifrnd 96 ifg plevel 5
				{
					ifactor NEWTROOPSTAYPUT espawn ARMLIZSTAYPUT else
					espawn ARMLIZTROOP
					seta[RETURN].pal sprite[].pal
					ifn sprite[].pal 21 ifrnd 128
					{
						ifrnd 128 seta[RETURN].pal 15 else 
						seta[RETURN].pal 49
					}
					seta[RETURN].htpicnum sprite[RETURN].picnum
					seta[RETURN].extra MECHBRAINSTRENGTH
					seta[RETURN].xrepeat 24
					seta[RETURN].yrepeat 22
					seta[RETURN].cstat 257
				}
				else
				{
					ifactor NEWTROOPSTAYPUT espawn LIZRANGERSTAYPUT else
					espawn LIZRANGER
					seta[RETURN].htpicnum sprite[RETURN].picnum
					seta[RETURN].xrepeat 30
					seta[RETURN].yrepeat 28
					seta[RETURN].cstat 257
					seta[RETURN].extra RANGERSTRENGTH
					ifrnd 128 { setav[RETURN].initflags 32 seta[RETURN].pal 19 }
				}
				ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				set troopcount 0
				add sub_maxactors 1
				killit
			}
			else
			ifspritepal 21
			{
				add antcount 1
				ifg antcount 3
				{
					state add_ant_code
					ifge SKILL 4 { state add_ant_code state add_ant_code }
					killit
				}
				ifg dogcount 7
				{
					set dogcount 0
					espawn LIZDOG
					seta[RETURN].htpicnum sprite[RETURN].picnum
					seta[RETURN].xrepeat 28
					seta[RETURN].yrepeat 26
					seta[RETURN].cstat 257
					seta[RETURN].extra LIZDOGSTRENGTH
					ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
					ifrnd 64 seta[RETURN].pal 17 else
					ifrnd 96 seta[RETURN].pal 3
					state buddy_position
				}
			}
			else ifn attmode NO
			{
				ifg plevel 1 ifrnd 32 spritepal 16
				else
				ifg plevel 2
				{
					ifg dogcount 11
					ifactornotstayput
					{
						set dogcount 0
						espawn LIZDOG
						seta[RETURN].htpicnum sprite[RETURN].picnum
						seta[RETURN].xrepeat 28
						seta[RETURN].yrepeat 26
						seta[RETURN].cstat 257
						seta[RETURN].extra LIZDOGSTRENGTH
						ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
						add sub_maxactors 1
						ifrnd 64 seta[RETURN].pal 17 else
						ifrnd 96 seta[RETURN].pal 3
						killit
					}
					else
					{
						add cronencount 1
						ifge cronencount 8
						ifactornotstayput
						iffloordistl 32
						{
							set cronencount 0
							cactor CRONEN
							seta[].htpicnum sprite[].picnum
							sizeat 28 28
							ai 0
							action 0
							orvar initflags 32
						}
					}
				}
			}
		}
	}
	break

	case LIZTROOPONTOILET
	set monstatus -1
	ife gametype 0
	ifg sprite[].xrepeat 4
	{
		cstator 257
		cactor NEWTROOPONTOILET ai 0 sizeat 24 22
		seta[].htpicnum sprite[].picnum	
		strength NEWTROOPSTRENGTH set upscaled NO
		ifn sprite[].pal 21
		ife monstflags 0
			ifg plevel 1 ifrnd 32 spritepal 16
	}
	break
	
	case LIZTROOPJUSTSIT
	set monstatus -1
	ife gametype 0
	ifg sprite[].xrepeat 4
	{
		cstator 257
		cactor NEWTROOPJUSTSIT ai 0 sizeat 24 22
		seta[].htpicnum sprite[].picnum	
		strength NEWTROOPSTRENGTH set upscaled NO
		ifn sprite[].pal 21
		ife monstflags 0
			ifg plevel 1 ifrnd 32 spritepal 16
	}
	break
	
	case LIZMANJUMP
	set monstatus -1
	ife gametype 0
	ifg sprite[].xrepeat 4
	{
		sizeat 28 26
		ife monstflags 0
		state rand_monst_replace
		ife NEWENEMIES YES
		ife monstflags 0
		ife mid_spawn NO
		{
			add antcount 1
			ifg antcount 3
			{
				set antcount 0
				espawn ARMYANTJUMP
				seta[RETURN].htpicnum sprite[RETURN].picnum
				ifrnd 64 ifg plevel 3 seta[RETURN].pal 40
				seta[RETURN].xrepeat 24
				seta[RETURN].yrepeat 24
				seta[RETURN].cstat 257
				seta[RETURN].extra ARMYANTSTRENGTH
				ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				add sub_maxactors 1
				killit
			}
			else
			ifg plevel 2
			ifrnd 64
			{
				ifrnd 96 spritepal 20
				else orvar initflags 64
			}
		}
	}
	break

	case LIZMAN
	case LIZMANSPITTING
	set monstatus -1
	
	ifn sprite[].htpicnum APLAYER
	ifn sprite[].htpicnum LIZGROPE
	ife gametype 0
	ifg sprite[].xrepeat 4
	{
		sizeat 28 26
		ife monstflags 0
		state rand_monst_replace
		ife NEWENEMIES YES
		ife monstflags 0
		ife mid_spawn NO
		{
			ifg plevel 2
			ifrnd 64
			{
				ifrnd 96 spritepal 20
				else orvar initflags 64
			}
			ifn attmode NO ifl plevel 2 set termcount 0
			add termcount 1
			add antcount 1
			ifn attmode NO add dogcount 1
			ifg termcount 9
			{
				set termcount 0
				ifactornotstayput espawn TERMINATOR
				else
				espawn TERMINATORSTAYPUT
				seta[RETURN].htpicnum sprite[RETURN].picnum
				seta[RETURN].xrepeat 28 // 42
				seta[RETURN].yrepeat 24 // 36
				seta[RETURN].cstat 257
				seta[RETURN].extra TERMINATORSTRENGTH
				ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				add sub_maxactors 1
				killit
			}
			else
			ifg antcount 4
			{
				state add_ant_code
				ifge SKILL 4 { state add_ant_code state add_ant_code }
				killit
			}
			ifg dogcount 11
			ifactornotstayput
			{
				set dogcount 0
				espawn LIZDOG
				seta[RETURN].htpicnum sprite[RETURN].picnum
				seta[RETURN].xrepeat 28
				seta[RETURN].yrepeat 26
				seta[RETURN].cstat 257
				seta[RETURN].extra LIZDOGSTRENGTH
				ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				ifrnd 64 seta[RETURN].pal 17 else
				ifrnd 96 seta[RETURN].pal 3
				state buddy_position
			}
			else
			{
				add lizcount 1
				ifg lizcount 6
				ife attmode YES
				ifge plevel 3
				{
					set lizcount 0 
					ifgapzl 160
					{
						spritepal 42 orvar initflags 8 
					}
					else
					{
						espawn LIZBOSS
						seta[RETURN].htpicnum sprite[RETURN].picnum
						seta[RETURN].pal 3
						ifg plevel 4 ifrnd 64 seta[RETURN].pal 20
						seta[RETURN].extra LIZBOSSPALSTRENGTH
						seta[RETURN].xrepeat 32
						seta[RETURN].yrepeat 28
						seta[RETURN].cstat 257
						setav[RETURN].droptile SIXPAK
						ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
						add sub_maxactors 1
						killit
					}
					
				}
			}
		}
		
	}
	break
	
	case LIZMANSTAYPUT
	set monstatus -1
		ifg sprite[].xrepeat 4 
		{
			sizeat 28 26
			cstator 256
			ife monstflags 0
			ife NEWENEMIES YES ifg plevel 2 ifrnd 32 spritepal 20
			ife attmode YES
			ife monstflags 0
			{
				state rand_monst_replace
				ifrnd 32 { spritepal 42 orvar initflags 8 }
			}
		}
	break
	
	case DRONE
	set monstatus -1
	ifg sprite[].xrepeat 4
	ife monstflags 0
	ife mid_spawn NO
	{
		state rand_monst_replace
		ifactor DRONE
		{
			add dronecount 1
			ife NEWENEMIES YES ife dronecount 2
			{
				cactor NEWSENTRY
				seta[].htpicnum sprite[].picnum
				sizeat 24 22
				action 0
				ai 0
				cstator 257
				spritepal 0
				set upscaled NO
			}
			else
			ifg dronecount 3 { set dronecount 0 spritepal 19 orvar initflags 8 }
		}
	}
	break

	case OCTABRAIN
	ifg sprite[].xrepeat 4 sizeat 24 22
	set monstatus -1
	ifn sprite[].owner -1
	ifvarand actorvar[sprite[].owner].initflags 16
	nullop
	else
	ife gametype 0
	ifg sprite[].xrepeat 4
	ifn sprite[].htpicnum OCTACAVEGIRL
	ife monstflags 0
	ife mid_spawn NO
	{
		state rand_monst_replace
		ife NEWENEMIES YES
		{
			add octacount 1
			ifn attmode NO ifl plevel 3 set octacount 0
			ifgapzl 128 nullop else
			ifg octacount 5
			{ 
				set octacount 0 
				ifinwater ifrnd 128
				{
					espawn DEVOURER
					seta[].htpicnum sprite[].picnum
					seta[RETURN].pal 21
					seta[RETURN].xrepeat 18
					seta[RETURN].yrepeat 16
					seta[RETURN].cstat 257
					seta[RETURN].extra 150
					ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				}
				else
				{
					espawn MEGABRAIN
					seta[].htpicnum sprite[].picnum
					seta[RETURN].xrepeat 48
					seta[RETURN].yrepeat 40
					seta[RETURN].cstat 257
					seta[RETURN].extra MEGASTRENGTH
					ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				}
				add sub_maxactors 1
				killit
			}
			ifn attmode NO
			ifrnd 64
			{
				ifrnd 128
				{ spritepal 19 orvar initflags 64 }
				else
				{
					spritepal 17 
					orvar initflags 16 
					sizeat 36 32
				}
			}
		}
	}
	break
	
	case OCTABRAINSTAYPUT 
		set monstatus -1
		ifg sprite[].xrepeat 4
		{
			sizeat 24 22
			ife monstflags 0
			state rand_monst_replace
		}
	break

	case FIRE
	case FIRE2
	case SHRINKEREXPLOSION
	case TRANSPORTERSTAR
	case FORCERIPPLE
	case NATURALLIGHTNING
	case LIGHTNING2
		cstator 2
		seta[].blend 1
	break

	case NEWBEAST
	case NEWBEASTCROUCH
	// case NEWBEASTSTAYPUT
	case NEWBEASTJUMP
	// case NEWBEASTHANG
	set monstatus -1
	ifspawnedby BOSS4 nullop else
	ifspawnedby QUEEN nullop else
	ifn attmode NO
	ife monstflags 0
	ife mid_spawn NO
	{
		ifoutside 
		ife mid_spawn NO
		{
			add nurgcount 1
			ifg nurgcount 12
			// ifge attbeaten 3
			ifge plevel 5
			{
				set nurgcount 0
				espawn NURGLE
				seta[].htpicnum sprite[].picnum
				seta[RETURN].extra NURGLESTRENGTH
				seta[RETURN].xrepeat 32
				seta[RETURN].yrepeat 28
				seta[RETURN].cstat 257
				setav[RETURN].droptile SIXPAK
				ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				add sub_maxactors 1
				ifrnd 128 seta[RETURN].pal 24
				killit	
			}
		}
		ifrnd 32
		ife NEWENEMIES YES
		{
			spritepal 21 
			orvar initflags 4 
		}
	}
	
	ife gametype 0
	ifn sprite[].htpicnum APLAYER
	ifg sprite[].xrepeat 4
	ife monstflags 0
	ife mid_spawn NO
	{
		state rand_monst_replace
		ife NEWENEMIES YES
		{
			ifn attmode NO ifl plevel 3 set beastcount 0
			add beastcount 1
			ifg beastcount 2
			{
				set beastcount 0
				espawn CYBERBEAST
				seta[RETURN].xrepeat 32
				seta[RETURN].yrepeat 28
				ifn attmode NO ifrnd 64 { seta[RETURN].pal 24 seta[RETURN].xrepeat 34 seta[RETURN].yrepeat 30 }
				seta[RETURN].cstat 257
				ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				add sub_maxactors 1
				killit
			}	
		}
	}
	break
	
	case RECON
		ifg sprite[].xrepeat 4
		sizeat 24 24
		set spawnprotect 0
		set monstatus -1
	break
	
	case NEWRECON
		ifg sprite[].xrepeat 4
		sizeat 24 24
		set spawnprotect 0
		set monstatus -1
	break
	
	case COMMANDER case COMMANDERSTAYPUT
	case NEWCOMM case NEWCOMMSTAYPUT
		set monstatus -1
		ifg sprite[].xrepeat 4
		ifn sprite[].htpicnum APLAYER
		ife monstflags 0
		ife mid_spawn NO
		{
			ifn attmode NO add nurgcount 1
			ifg nurgcount 12
			// ifge attbeaten 3
			ifge plevel 5
			iffloordistl 64
			ife sprite[].htactorstayput -1
			{
				set nurgcount 0
				espawn NURGLE
				seta[RETURN].htpicnum sprite[RETURN].picnum
				seta[RETURN].extra NURGLESTRENGTH
				seta[RETURN].xrepeat 32
				seta[RETURN].yrepeat 28
				seta[RETURN].cstat 257
				setav[RETURN].droptile SIXPAK
				add sub_maxactors 1
				ifrnd 128 seta[RETURN].pal 24
				ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
				killit	
			}
			else
			{
				state rand_monst_replace
				ifrnd 128
				ife NEWENEMIES YES
				{
					ifactor COMMANDER 
					{ 
						set upscaled NO cactor NEWCOMM 
						sizeat 30 28 cstator 257 strength MECHBRAINSTRENGTH ai 0 
					}
					ifactor COMMANDERSTAYPUT 
					{ set upscaled NO cactor NEWCOMMSTAYPUT 
					seta[].htpicnum sprite[].picnum
					sizeat 30 28 cstator 257 strength MECHBRAINSTRENGTH ai 0 }
				}
				else 
				{
					strength COMMANDERSTRENGTH
					ife NEWENEMIES YES ifrnd 32 spritepal 24
				}
			}
		}
	break
	
	case LIZRANGER case LIZRANGERSTAYPUT case LIZRANGERSIT
	case EGG case EGGYOUNG case SIDEGUN
	case ARMPIG case EDFPIG case ARMPIGSTAYPUT case PIGSUV
	case ARMLIZTROOP
	case MECHBRAIN
	case MEGABRAIN case DRPROTON case PSPIDER
	set monstatus -1
	break
	
	case TERMINATOR case TERMINATORSTAYPUT
	set monstatus -1
	ifg sprite[].xrepeat 4 ife NEWENEMIES YES 
	ife monstflags 0
	ifrnd 32 ifg plevel 2 
	{
		spritepal 57
		sizeat 36 32
	}
	break
	
	case BOSS1 case BOSS1STAYPUT
		set monstatus -1
		ifn sprite[].htpicnum APLAYER
		// ife gametype 0
		// ifspritepal 21
		ifg sprite[].xrepeat 4
		{
			ifactor BOSS1 { cactor NEWBATLORD seta[].htpicnum sprite[].picnum }
			ifactor BOSS1STAYPUT { cactor NEWBATLORDSTAYPUT seta[].htpicnum sprite[].picnum }
			ifspritepal 0 { strength 6000 sizeat 72 60 } else 
			{ 
				sizeat 36 30 strength 1200 
				ife monstflags 0
				ife attmode YES ifrnd 70 ifg plevel 4 spritepal 42
			}
			
			set upscaled NO
			ai 0
			ifn sprite[].htpicnum RESPAWN seta[].htpicnum sprite[].picnum
			ife monstflags 0
			ifn attmode NO ifn sprite[].pal 0 state rand_monst_replace
		}
	
	break
	
	case CYBERBEAST 
		set monstatus -1
		ifg sprite[].xrepeat 4
		ife monstflags 0
		state rand_monst_replace
	break
	
	
	case BOSS2
	case BOSS2STAYPUT
		set monstatus -1
		ifg sprite[].xrepeat 4
		{
			ifspritepal 0 sizeat 80 64 else sizeat 40 32
		}
	break
	
	case BOSS3
	case BOSS3STAYPUT
	set monstatus -1
		ifg sprite[].xrepeat 4
		{
			ifspritepal 0 sizeat 64 60 else sizeat 44 38
		}
	break
	
	case CANHEAD case NEWMECH case CYCLOIDMAX case BOSS4
	case PIGBOSS case PIGBOSSSTAYPUT case LIZBOSS
	case ARMEDF case EDFSNIPER case EDFSNIPERCROUCH
	case CORRUPT
		set monstatus -1
	break
	
	case ZOMBIE case ZOMBIEGIDUP
		set monstatus -1
		ifg sprite[].xrepeat 4
		{	
			rand temp 4
			add temp 26
			seta[].xrepeat temp
			rand temp 2
			add temp 24
			seta[].yrepeat temp
			rand temp 4
			ife temp 1 spritepal 17 else
			ife temp 2 spritepal 19 else
			ife temp 3 spritepal 27 else
			ife temp 4 spritepal 28
		}
	break
	
	case CRONEN
		set monstatus -1
		ifg sprite[].xrepeat 4
		{	
			rand temp 4
			add temp 26
			seta[].xrepeat temp
			rand temp 2
			add temp 24
			seta[].yrepeat temp
			ifspritepal 0
			{
				rand temp 13
				ifrnd 224 { add temp 10 seta[].pal temp }
			}
		}
	break
	
	case NEWSENTRY
		ifg sprite[].xrepeat 4
		{
		set monstatus -1
		sizeat 24 22
		cstat 257
		}
	break
	
	case PATROLSENTRY
		set monstatus -1
		sizeat 32 30
		cstat 257
	break
	
	
	case TANK
		set monstatus -1
		
		ifn sprite[].htpicnum APLAYER
		ife gametype 0
		ifg sprite[].xrepeat 4
		ife monstflags 0
		ife mid_spawn NO
		{
			state rand_monst_replace
			ifrnd 32 spritepal 24
			ife NEWENEMIES YES
			{
				ifn attmode NO ifl plevel 4 set mechcount 0
				add mechcount 1
				
				ifn attmode NO add nurgcount 1
				ifg nurgcount 12
				// ifge attbeaten 3
				ifge plevel 5
				{
					set nurgcount 0
					espawn NURGLE
					seta[RETURN].htpicnum sprite[RETURN].picnum
					seta[RETURN].extra NURGLESTRENGTH
					seta[RETURN].xrepeat 32
					seta[RETURN].yrepeat 28
					seta[RETURN].cstat 257
					setav[RETURN].droptile SIXPAK
					add sub_maxactors 1
					ifrnd 128 seta[RETURN].pal 24
					ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
					killit	
				}
				else
				ifg mechcount 3
				{
					set mechcount 0
					espawn MECHBRAIN
					seta[RETURN].htpicnum sprite[RETURN].picnum
					seta[RETURN].xrepeat 40
					seta[RETURN].yrepeat 38
					seta[RETURN].cstat 257
					add sub_maxactors 1
					ifrnd 84 seta[RETURN].pal 3 else
					ifrnd 128 seta[RETURN].pal 14 else
					seta[RETURN].pal 21
					ifspawnedby RESPAWN seta[RETURN].htpicnum RESPAWN
					killit
				}
			}
		}

	break
	
	case LITBIGSTATUE changespritestat THISACTOR 1
	sleeptime -1
	break
	
	case CARPOINTR
	changespritestat THISACTOR 975
	break
	
	case CARPOINTL
	changespritestat THISACTOR 976
	break

	case COPTERPATH
	changespritestat THISACTOR 978
	break
	
	case SPYPATH
	changespritestat THISACTOR 977
	break
	
	default
		geta[].cstat temp
		andvar temp 48

		ife temp 32  // if it's floor-aligned
		{
			geta[].mdflags temp
			orvar temp 1  // SPREXT_NOTMD
			seta[].mdflags temp
		}

	break
	
	endswitch
	
	ifvarand monstflags 256
	ifg sprite[].xrepeat 4
	ife init_xrepeat 0
	{
		geta[].xrepeat init_xrepeat
		geta[].xrepeat x, mul x 3, div x 2, ifg x 255 set x 255
		seta[].xrepeat x
		geta[].yrepeat init_yrepeat
		geta[].yrepeat y, mul y 3, div y 2, ifg y 255 set y 255
		seta[].yrepeat y
	}
	
endevent

onevent EVENT_SETDEFAULTS
	setuserdef[].default_volume 1
	setuserdef[].textscale 300
	setuserdef[].screen_size 0
	setuserdef[].userbyteversion 5
	setuserdef[].weaponswitch 0
endevent

// RETURN is 50 when changing from game to Esc menu
// RETURN is -2 when changing from Esc menu back to game
onevent EVENT_CHANGEMENU

getp[].auto_aim autoaim

ifn vrtrip 0 
{
	ife RETURN 50
	{
		ife vrmenu NO
		{
			set vrmenu YES
			set RETURN -2
		}
		else
		ife vrmenu YES
		{
			set RETURN -2
			set vrmenu NO
			setp[].movement_lock 0
		}
	}	
		
	ife vrmenu -1
	ifn RETURN 50
	{
		set RETURN 50
		set vrmenu -2
	}
	ife vrmenu -2
	{
		ife RETURN -2 set vrmenu NO
	}
}

endevent



onevent EVENT_GETMENUTILE
 
 ifvarn rendmode 0
 {
	setvarvar temp xdim
	shiftvarl temp 3
	divvarvar temp ydim
	ifvarg temp 12 setvar RETURN 10233
	else
	setvar RETURN 10234
 }
 ifge current_menu 100 ifle current_menu 110 
	set RETURN 10487
 
endevent


onevent EVENT_ANIMATESPRITES

gettspr[].tsprowner spriteid

ife sprite[spriteid].statnum STATUESTAT 
{ settspr[].tsprpal 27 break }
else
ifn actorvar[spriteid].stasis 0
{
	set temp actorvar[spriteid].stun // STASISTIME
	sub temp actorvar[spriteid].stasis
	ifle temp 30 
	ifvarand player[].player_par 1
	{
		settspr[].tsprpal 118
		settspr[].tsprshade -125
	}
	else 
	ifle actorvar[spriteid].stasis 30
	ifvarand player[].player_par 1
	{
		settspr[].tsprpal 118
		settspr[].tsprshade -125
	}
	else
	{ settspr[].tsprxrepeat 0 settspr[].tspryrepeat 0 }
}
else
ife brutalvictim spriteid
ife brutalcount 0
{
	getp[].player_par pal
	modvar pal 30
	ifl pal 8
	{
		add pal 209
		settspr[].tsprpal pal settspr[].tsprshade -127
	}
}
else
ife player[].player_par actorvar[spriteid].damflash
{
	settspr[].tsprpal 121
	settspr[].tsprshade -100
}

ife actorvar[spriteid].upscaled 2
{
	geta[spriteid].xrepeat x
	shiftr x 1
	settspr[].tsprxrepeat x
	geta[spriteid].yrepeat y
	shiftr y 1
	settspr[].tspryrepeat y
}

ife targetlock[0] spriteid
{
	getp[].player_par temp
	modvar temp 3
	ife temp 1 settspr[].tsprpal 125
	else ife temp 2 settspr[].tsprpal 33
	settspr[].tsprshade -127
} else
ife targetlock[1] spriteid
{
	getp[].player_par temp
	modvar temp 3
	ife temp 1 settspr[].tsprpal 125
	else ife temp 2 settspr[].tsprpal 33
	settspr[].tsprshade -127
} else
ife targetlock[2] spriteid
{
	getp[].player_par temp
	modvar temp 3
	ife temp 1 settspr[].tsprpal 125
	else ife temp 2 settspr[].tsprpal 33
	settspr[].tsprshade -127
}

ifvarand actorvar[spriteid].monstflags 524288
{
	geta[spriteid].xrepeat x
	shiftl x 1
	settspr[].tsprxrepeat x
	geta[spriteid].yrepeat y
	shiftl y 1
	settspr[].tspryrepeat y
}

ifvarand actorvar[spriteid].monstflags 2097152
ifg actorvar[spriteid].dashtime 0
{
	settspr[].tsprxrepeat 0
	settspr[].tspryrepeat 0
}
	
ife sprite[spriteid].statnum 4
{
	ifvarand actorvar[spriteid].monstflags 64
	{
		geta[spriteid].xrepeat x
		shiftl x 1
		settspr[].tsprxrepeat x
		geta[spriteid].yrepeat y
		shiftl y 1
		settspr[].tspryrepeat y
	}
	ifvarand actorvar[spriteid].monstflags 1048576
	{
		settspr[].tsprpal 119
		settspr[].tsprshade -127
	}
	ifvarand actorvar[spriteid].monstflags 256
	{
		geta[spriteid].xrepeat x
		mul x 3 div x 2
		settspr[].tsprxrepeat x
		geta[spriteid].yrepeat y
		mul y 3 div y 2
		settspr[].tspryrepeat y
	}
	ife sprite[spriteid].picnum BIGBOIPROJ
	{
		gettspr[].tsprz z 
		sub z 2816 
		settspr[].tsprz z
	}
}

gettspr[].tsprpal pal

ife pal 1 ifge actorvar[spriteid].padang 131313 ifle actorvar[spriteid].padang 131314 settspr[].tsprpal 27

ifn actorvar[spriteid].shrunken 0
{
	ife pal 4 { settspr[].tsprxrepeat 0 settspr[].tspryrepeat 0 }
	// else 
	// {
		// gettspr[].tsprxrepeat tempb
		// ifg tempb 6 { settspr[].tsprxrepeat 6 settspr[].tspryrepeat 6 }
	// }
}

ifn pal 4
{
	ifn actorvar[spriteid].burning 0
	{
		getav[spriteid].burning temp
		ifg temp 0
		{
			ifn sprite[spriteid].htpicnum NOVAPLASBOLT
			ifn sprite[spriteid].htpicnum SABERSCORCH3
			settspr[].tsprpal 96
			ifg sprite[spriteid].extra 1
			settspr[].tsprshade -100
		}
		else
		{
			set tempb sprite[spriteid].extra
			mul tempb -1
			ifl temp tempb
			{
				ifge actorvar[spriteid].padang 131313
				ifle actorvar[spriteid].padang 131314
				settspr[].tsprpal 27 else
				settspr[].tsprpal 1
			}
		}
	}

	ifg actorvar[spriteid].gooify 0
	{
		set temp sprite[spriteid].extra
		div temp 2
		ifge actorvar[spriteid].gooify temp
		{
			settspr[].tsprpal 126
			settspr[].tsprshade -100
		}
	}
}
getav[spriteid].yoffset temp
ifn temp 0
{
	gettspr[].tsprz z
	add z temp
	settspr[].tsprz z
}

ifl actorvar[spriteid].bleeding 0
ife actorvar[spriteid].monstatus 1
ifvarand player[].player_par 1
	settspr[].tsprpal 76

switch sprite[spriteid].picnum

case FAKETILE
	settspr[].tsprpicnum actorvar[spriteid].droptile
break
case LIGHTHALO
	getav[spriteid].myspawner temp
	ifg temp -1
	{
		geta[temp].x x
		settspr[].tsprx x
		geta[temp].y y
		settspr[].tspry y
	}
break

case TOILET
	ife actorvar[spriteid].initsprite NEWTOILET
	settspr[].tsprpicnum NEWTOILET
break
case TOILETBROKE
	ife actorvar[spriteid].initsprite NEWTOILET
	settspr[].tsprpicnum NEWTOILETBROKE
break

case APLAYER
	ifn player[].newowner -1 
	{
		settspr[].tsprxrepeat 0
		settspr[].tspryrepeat 0
	}
	else
	ife spriteid player[].holoduke_on
	{
		ife pchar 4
		{
			settspr[].tsprxrepeat 0
			settspr[].tspryrepeat 0
		}
		ife pchar 3
		ifn mylily -1
		{
			settspr[].tsprxrepeat 0
			settspr[].tspryrepeat 0
		}
			
	}
	else
	{
		ife pdown YES settspr[].tsprcstat 257
		ife pchar 4
		{
			settspr[].tsprpal novapal
			gettspr[].tsprxrepeat x
			gettspr[].tspryrepeat y
			// default 42x 36x
			// shadow is 4y
			mul x 53
			div x 100
			mul y 57
			div y 100
			settspr[].tsprxrepeat x
			settspr[].tspryrepeat y
			// sizeat 22 20
			ifp pducking
			{
				gettspr[].tsprz z
				sub z 2048
				settspr[].tsprz z
			}
			ife player[].curr_weapon KNEE_WEAPON
			{
				ifp pducking nullop else
				ifp pjumping nullop else
				
				ifp pducking nullop else
				ife saberpos 0
				ife qk_proxy 0
				ife deaonwall -1
				{
					gettspr[].tsprpicnum picnum
					ifp pstanding add picnum 35 else
					ifp pwalking add picnum 90 else
					ifp prunning add picnum 90 else
					ifp pwalkingback add picnum 90 else
					ifp prunningback add picnum 90
					settspr[].tsprpicnum picnum
				}
				ifn deaonwall -1
				{
					gettspr[].tsprpicnum picnum
					ife picnum 22100 ife devside 0 
					{ add picnum 40 settspr[].tsprpicnum picnum }
				}
			}
		}
		else
		ife pchar 3
		{
			settspr[].tsprpal mandopal
			gettspr[].tsprxrepeat x
			gettspr[].tspryrepeat y
			// default 42x 36x
			// shadow is 4y
			mul x 53
			div x 100
			mul y 57
			div y 100
			settspr[].tsprxrepeat x
			settspr[].tspryrepeat y
			// sizeat 22 20
			ifp pducking
			{
				gettspr[].tsprz z
				sub z 2048
				settspr[].tsprz z
			}
		}
		else
		ife pchar 2
		{
			settspr[].tsprpal wespal
			gettspr[].tsprxrepeat x
			gettspr[].tspryrepeat y
			// default 42x 36x
			// shadow is 4y
			mul x 53
			div x 100
			mul y 57
			div y 100
			settspr[].tsprxrepeat x
			settspr[].tspryrepeat y
			// sizeat 22 20
		}
		else
		ife pchar 1
		{
			settspr[].tsprpal shellypal
			ifn player[].cursectnum -1
			ifg sector[player[].cursectnum].floorpal 0
			ifl sector[player[].cursectnum].floorpal 10
			settspr[].tsprpal sector[player[].cursectnum].floorpal
			
			gettspr[].tsprxrepeat x
			gettspr[].tspryrepeat y
			// default 42x 36x
			// shadow is 4y
			mul x 55
			div x 100
			mul y 59
			div y 100
			settspr[].tsprxrepeat x
			settspr[].tspryrepeat y
			// sizeat 23 21
			ifvarand altcostume 32 // bikini
			{
				gettspr[].tsprpicnum picnum
				add picnum 9984
				settspr[].tsprpicnum picnum
			}
			else
			ifvarand altcostume 4 // gladiator
			{
				gettspr[].tsprpicnum picnum
				add picnum 7018
				settspr[].tsprpicnum picnum
			}
			else
			ifvarand altcostume 1 // EDF
			{
				gettspr[].tsprpicnum picnum
				add picnum 2304
				ife pdown YES add picnum 83
				settspr[].tsprpicnum picnum
			}
			ifp pducking
			{
				gettspr[].tsprz z
				sub z 2048
				settspr[].tsprz z
			}
		}
		else ife pchar 0
		{
			settspr[].tsprpal dukepal
			ifn player[].cursectnum -1
			ifg sector[player[].cursectnum].floorpal 0
			ifl sector[player[].cursectnum].floorpal 10
			settspr[].tsprpal sector[player[].cursectnum].floorpal
			
			ifvarand altcostume 8
			{
				gettspr[].tsprpicnum picnum
				add picnum 6084
				settspr[].tsprpicnum picnum
				gettspr[].tsprxrepeat x
				gettspr[].tspryrepeat y
				// default 42x 36x
				// shadow is 4y
				mul x 60
				div x 100
				mul y 62
				div y 100
				settspr[].tsprxrepeat x
				settspr[].tspryrepeat y
				
				ifp pducking
				{
					gettspr[].tsprz z
					sub z 2048
					settspr[].tsprz z
				}
			}
			else
			ifvarand altcostume 16
			{
				gettspr[].tsprpicnum picnum
				add picnum 7298
				settspr[].tsprpicnum picnum
				gettspr[].tsprxrepeat x
				gettspr[].tspryrepeat y
				// default 42x 36x
				// shadow is 4y
				mul x 60
				div x 100
				mul y 62
				div y 100
				settspr[].tsprxrepeat x
				settspr[].tspryrepeat y
				
				ifp pducking
				{
					gettspr[].tsprz z
					sub z 2048
					settspr[].tsprz z
				}
			}
		}
	}
break

case RAT

	gettspr[].tsprpicnum picnum
	ifvarand player[].player_par 1 add picnum 20618
	else add picnum 20623
	settspr[].tsprpicnum picnum

break

case FIRELASER
	settspr[].tsprblend 1
	settspr[].tsprcstat 130
	settspr[].tsprshade -100
break

case BOWLINGPIN // correct displayed angle
	gettspr[].tsprang angvar
	add angvar 512
	settspr[].tsprang angvar
break

/*
case LIZMAN case LIZMANDUCKING

	ifvarand actorvar[spriteid].initflags 64
	{
		geta[spriteid].htdispicnum picnum
		al picnum
		ifge picnum 2080 ifle picnum 2119 add picnum 19346 else
		ifge picnum 2120 ifle picnum 2139 add picnum 19241 else
		ifge picnum 2140 ifle picnum 2149 add picnum 19276 else
		ifge picnum 2150 ifle picnum 2154 add picnum 19326 else
		ifge picnum 2155 ifle picnum 2179 add picnum 19226 else
		ifge picnum 2180 ifle picnum 2185 add picnum 19093 else
		ifge picnum 2190 ifle picnum 2199 add picnum 19216 else
		ifge picnum 2213 ifle picnum 2217 add picnum 19258 else
		ifge picnum 6561 ifle picnum 6576 add picnum 14708 else
		ifge picnum 10781 ifle picnum 10786 add picnum 10504 else
		ifge picnum 18852 ifle picnum 18856 add picnum 2529
		al picnum
		settspr[].tsprpicnum picnum
		seta[spriteid].htdispicnum picnum
	}
break
*/

case SHELLYDUMMY
	
	// DEANOTE19# 
	ife pchar 1
	{
		gettspr[].tsprxrepeat x
		gettspr[].tspryrepeat y
		// default 42x 36x
		// shadow is 4y
		mul x 68 // 72
		div x 100
		mul y 66 // 72
		div y 100 // 100
		settspr[].tsprxrepeat x
		settspr[].tspryrepeat y
		// sizeat 30 26
		
		ifvarand altcostume 32
		{
			gettspr[].tsprpicnum picnum
			add picnum 9984
			settspr[].tsprpicnum picnum
		}
		else
		ifvarand altcostume 4
		{
			gettspr[].tsprpicnum picnum
			add picnum 7018
			settspr[].tsprpicnum picnum
		}
		else
		ifvarand altcostume 1
		{
			gettspr[].tsprpicnum picnum
			add picnum 2304
			ife pdown YES add picnum 83
			settspr[].tsprpicnum picnum
		}
		ifp pducking
		{
			gettspr[].tsprz z
			sub z 2048
			settspr[].tsprz z
		}
	}
	else
	ife pchar 2
	{
		gettspr[].tsprpicnum picnum
		add picnum 12795
		settspr[].tsprpicnum picnum
		gettspr[].tsprxrepeat x
		gettspr[].tspryrepeat y
		// default 42x 36x
		// shadow is 4y
		mul x 53
		div x 100
		mul y 57
		div y 100
		settspr[].tsprxrepeat x
		settspr[].tspryrepeat y
		
		ifp pducking
		{
			gettspr[].tsprz z
			sub z 2048
			settspr[].tsprz z
		}
	}
	else
	ife pchar 3
	{
		gettspr[].tsprpicnum picnum
		add picnum 7394
		settspr[].tsprpicnum picnum
		gettspr[].tsprxrepeat x
		gettspr[].tspryrepeat y
		// default 42x 36x
		// shadow is 4y
		mul x 53
		div x 100
		mul y 57
		div y 100
		settspr[].tsprxrepeat x
		settspr[].tspryrepeat y
		
		ifp pducking
		{
			gettspr[].tsprz z
			sub z 2048
			settspr[].tsprz z
		}
	}
	else
	ife pchar 4
	{
		gettspr[].tsprpicnum picnum
		add picnum 15330
		settspr[].tsprpicnum picnum
		gettspr[].tsprxrepeat x
		gettspr[].tspryrepeat y
		// default 42x 36x
		// shadow is 4y
		mul x 68
		div x 100
		mul y 66
		div y 100
		settspr[].tsprxrepeat x
		settspr[].tspryrepeat y
		
		ifp pducking
		{
			gettspr[].tsprz z
			sub z 2048
			settspr[].tsprz z
		}
	}
	else
	ifvarand altcostume 8
	{
		gettspr[].tsprpicnum picnum
		add picnum 8484
		settspr[].tsprpicnum picnum
		gettspr[].tsprxrepeat x
		gettspr[].tspryrepeat y
		// default 42x 36x
		// shadow is 4y
		mul x 70
		div x 100
		mul y 68
		div y 100
		settspr[].tsprxrepeat x
		settspr[].tspryrepeat y
		
		ifp pducking
		{
			gettspr[].tsprz z
			sub z 2048
			settspr[].tsprz z
		}
	}
	else
	ifvarand altcostume 16
	{
		gettspr[].tsprpicnum picnum
		add picnum 9698
		settspr[].tsprpicnum picnum
		gettspr[].tsprxrepeat x
		gettspr[].tspryrepeat y
		// default 42x 36x
		// shadow is 4y
		mul x 70
		div x 100
		mul y 68
		div y 100
		settspr[].tsprxrepeat x
		settspr[].tspryrepeat y
		
		ifp pducking
		{
			gettspr[].tsprz z
			sub z 2048
			settspr[].tsprz z
		}
	}
	else
	ifvarand altcostume 2
	{
		gettspr[].tsprpicnum picnum
		add picnum 2400
		settspr[].tsprpicnum picnum
	}
	else
	{
		gettspr[].tsprpicnum picnum
		add picnum 784
		settspr[].tsprpicnum picnum
	}
	
break

case SHRINKSPARK
	gettspr[].tsprpicnum picnum
	add picnum 13860
	settspr[].tsprpicnum picnum
	gettspr[].tsprxrepeat x
	div x 2
	settspr[].tsprxrepeat x
	gettspr[].tspryrepeat y
	div y 2
	settspr[].tspryrepeat y
	
break

case SHOTGUNSPRITE
ifn rendmode 4 // voxel shade adjustment
{
	gettspr[].tsprshade shade
	ifg shade 12 set shade 12
	add shade 12
	settspr[].tsprshade shade
}

case GREENSLIME
case 2371 case 2372 case 2373 case 2374
case 2375 case 2376 case 2377
	gettspr[].tsprxrepeat x div x 2 add x 1
	settspr[].tsprxrepeat x
	gettspr[].tspryrepeat x div x 2 add x 1
	settspr[].tspryrepeat x
break

case ICESPRITE
	ifn rendmode 0
	{
		geta[spriteid].x x
		geta[spriteid].y y
		ifl camerax x add x -4
		else sub x -4
		ifl cameray y add y -4
		else sub y -4
		settspr[].tsprx x
		settspr[].tspry y
	}
break

case SPEEDBLUR
	getav[spriteid].mtype temp
	ife temp 0 { settspr[].tsprxrepeat 0 settspr[].tspryrepeat 0 al spriteid }
	else
	settspr[].tsprpicnum temp
break

case TRIPBOMBSPRITE
	settspr[].tsprpicnum TRIPBOMB
	gettspr[].tsprxrepeat x div x 4
	settspr[].tsprxrepeat x
	gettspr[].tspryrepeat y div y 4
	settspr[].tspryrepeat y
break

case LASERLINE2 settspr[].tsprshade -127 seta[].blend 1 break

case STALL
	ifn actorvar[spriteid].droptile 0
		settspr[].tsprpicnum actorvar[spriteid].droptile

break

case OUTLINE
	settspr[].tsprpicnum actorvar[spriteid].initsprite

break

case LASERHALO
	geta[spriteid].owner temp
	settspr[].tsprx sprite[temp].x
	settspr[].tspry sprite[temp].y
	settspr[].tsprz sprite[temp].z
break

case CHEERLEADER

	ifvarand sprite[spriteid].cstat 4
	{
		gettspr[].tsprcstat temp
		orvar temp 4
		settspr[].tsprcstat temp
	}
break

case EDFTROOP
case EDFTROOPCROUCH
case EDFTANK
	getav[spriteid].lastang temp
	settspr[].tsprang temp
break

case TEAMSPAWNER
	getav[spriteid].initsprite temp
	settspr[].tsprpicnum temp
break

// case LASERDOT // oh boy here we go

// ife dotsprite spriteid
// {
	// getp[].i B
	// geta[B].cstat safecount
	// seta[B].cstat 32768

	// ifg scandist 0
	// {
		// set x camerax
		// set y cameray

		// set angvar cameraang
		// set zdist camerahoriz
		// sub zdist 135 // 100

		// getp[].weapon_pos temp
		// abs temp
		// mul temp 3
		// sub zdist temp
		
		// set temp gun_pos
		// div temp -2
		// sub zdist temp
		
		// ifp pstanding nullop else
		// {
		// set temp weapon_xoffset
		// div temp 2
		// add angvar temp
		// }

		// mul zdist -2048
		// cos mycos angvar
		// sin mysin angvar
		
		// set z cameraz
		// sub z 1024
		// hitscan x y z camerasect mycos mysin zdist hitsector hitwall hitsprite hitx hity hitz CLIPMASK0
		
		
		// ife sprite[dotsprite].cstat 8322
		// {
			// set angvar cameraang
			// add angvar 1024
			// set x hitx
			// set tempb scandist
			// shiftr tempb 3
			// ifg tempb 128 set tempb 128
			// add x tempb
			
			// rotatepoint hitx hity x hity angvar x2 y2
			
			// set hitx x2
			// set hity y2
		// }
		// updatesectorz hitx hity hitz tempb
		// ifvarn tempb -1
		// {
			// getflorzofslope tempb hitx hity temp
			// sub temp 512
			// ifg hitz temp set hitz temp
		// }
		// settspr[].tsprx hitx
		// settspr[].tspry hity
		// settspr[].tsprz hitz
	// }
	// seta[B].cstat safecount
// }
// break

case SIDEGUN
	ife pal 4 settspr[].tsprcstat 34
break


case JIBS1
case JIBS2
case JIBS3
case JIBS4
case JIBS5
getav[spriteid].shrunken temp
ifg temp 20 ifl temp SHRUNKCOUNT
{
	gettspr[].tsprxrepeat x
	div x 4 ifl x MINXSTRETCH set x MINXSTRETCH
	settspr[].tsprxrepeat x
	gettspr[].tspryrepeat y
	div y 4 ifl y MINYSTRETCH set y MINYSTRETCH
	settspr[].tspryrepeat y
}
ife actorvar[spriteid].mtype YES 
{
	settspr[].tsprshade -100
	settspr[].tsprpicnum FIRELASER
}
break

case CBPROJ
	ife sprite[spriteid].htpicnum LILY
	ifn rendmode 0
	{
		settspr[].tsprpicnum RPG
		settspr[].tsprpal 10
	}
break

case HEAVYHBOMB
	getav[spriteid].countvar temp
	geta[spriteid].ang angvar
	ifl temp 0 sub angvar 64
	else add angvar 64
	settspr[].tsprang angvar
	ife pchar 0 ifvarand dukeupgrades[HANDBOMB_WEAPON] 1
	{
		geta[spriteid].cstat tempb
		ifl temp 0 settspr[].tsprcstat 0 else
		settspr[].tsprcstat 4
		settspr[].tsprpicnum 13004
	}
	
	getav[spriteid].initsprite temp
	ife temp THERMAL
	{
		ifg player[].player_par actorvar[spriteid].countvarb
		{
			set temp player[].player_par
			sub temp actorvar[spriteid].countvarb
			mul temp sprite[spriteid].xvel
			abs temp
			ifge temp 96
			{
				set tempb actorvar[spriteid].countvarc
				
				getincangle angvar sprite[].ang player[].ang
				abs angvar
				ifle angvar 512 add tempb 1 else sub tempb 1

				set tempc THERMAL, add tempc 7
				ifg tempb tempc set tempb THERMAL
				ifl tempb THERMAL set tempb tempc
				
				setav[spriteid].countvarc tempb
				setav[spriteid].countvarb player[].player_par
			}
			
		}
		settspr[].tsprpicnum actorvar[spriteid].countvarc
	}
	
break

case NEWBEAST
case NEWBEASTCROUCH
	gettspr[].tsprpal pal
	ife pal 0 settspr[].tsprpal 15
break

case MEGABRAIN
case BOSS2FLY
case OCTATROOP
	gettspr[].tsprpal pal
	ifn pal 4
	ifn actorvar[spriteid].float -1
	{
	set temp player[].player_par
	shiftl temp 5
	add temp spriteid
	sin tempb temp
	shiftr tempb 4
	geta[spriteid].z z
	
	sub z tempb
	sub z 1024
	settspr[].tsprz z
	}
break

case SCUBATROOP
	gettspr[].tsprpal pal
	ifn pal 4
	ifn actorvar[spriteid].float -1
	{
	set temp player[].player_par
	shiftl temp 5
	add temp spriteid
	sin tempb temp
	shiftr tempb 4
	geta[spriteid].z z
	
	sub z tempb
	settspr[].tsprz z
	}
break

case SHELLY
case SHELLYCROUCH
	ifvarand altcostume 1
	{
		gettspr[].tsprpicnum picnum
		ife actorvar[spriteid].monstatus 2 
		ifg sprite[spriteid].extra 0
		add picnum 2387
		else
		add picnum 2304
		settspr[].tsprpicnum picnum
	}
	else
	ifvarand altcostume 4
	{
		gettspr[].tsprpicnum picnum
		add picnum 7018
		settspr[].tsprpicnum picnum
	}
	else
	ifvarand altcostume 32
	{
		gettspr[].tsprpicnum picnum
		add picnum 9984
		settspr[].tsprpicnum picnum
	}
	ife sprite[spriteid].pal 33
		settspr[].tsprpal 33
break

case DUKEBOT
case DUKEBOTCROUCH
	ifvarand altcostume 16 // new normal
	{
		gettspr[].tsprpicnum picnum
		ife actorvar[spriteid].monstatus 2 
		ifg sprite[spriteid].extra 0
		add picnum 1627
		else
		add picnum 1616
		
		// add picnum 8914
		add picnum 7298
		
		settspr[].tsprpicnum picnum
		
		gettspr[].tsprxrepeat x
		gettspr[].tspryrepeat y
		// default 42x 36x
		// shadow is 4y
		mul x 60 // 62
		div x 100
		mul y 62 // 66
		div y 100
		settspr[].tsprxrepeat x
		settspr[].tspryrepeat y
		
		
	}
	else
	ifvarand altcostume 8 // gladiator
	{
		gettspr[].tsprpicnum picnum
		ife actorvar[spriteid].monstatus 2 
		ifg sprite[spriteid].extra 0
		add picnum 1627
		else
		add picnum 1616
		
		add picnum 6084
		
		settspr[].tsprpicnum picnum
		
		gettspr[].tsprxrepeat x
		gettspr[].tspryrepeat y
		// default 42x 36x
		// shadow is 4y
		mul x 60 // 62
		div x 100
		mul y 62 // 66
		div y 100
		settspr[].tsprxrepeat x
		settspr[].tspryrepeat y
		
	}
	else
	ifvarand altcostume 2
	{
		gettspr[].tsprpicnum picnum
		ife actorvar[spriteid].monstatus 2 
		ifg sprite[spriteid].extra 0
		add picnum 1627
		else
		add picnum 1616
		settspr[].tsprpicnum picnum
	}
	ife sprite[spriteid].pal 33
		settspr[].tsprpal 33
break

case PIGSUV
	getav[spriteid].lastang temp
	settspr[].tsprang temp
break

case SUVWHEEL
	geta[spriteid].ang angvar
	add angvar 512
	settspr[].tsprang angvar
break

case ARMYANTCRAWL

	gettspr[].tsprsectnum mysector
	ifn mysector -1
	{
		ife tspr[].tsprpal 4
		{
			geta[spriteid].z z
			sub z 8192
			settspr[].tsprz z
			settspr[].tsprxrepeat 0
			settspr[].tspryrepeat 0
		}
	}

break

case BOUNTYICON
	ife actorvar[spriteid].mtype 1
	ifn mybounty -1
	{
		geta[mybounty].picnum picnum
		settspr[].tsprpicnum picnum
	}
break

case MANDOFETT
	ifn actorvar[spriteid].mtype 0
	{
		gettspr[].tsprpicnum picnum
		ifge picnum 14115 ifle picnum 14139
		sub picnum 25
		settspr[].tsprpicnum picnum
	}
break

case MANDOCROUCH
	ifn actorvar[spriteid].mtype 0
	{
		gettspr[].tsprpicnum picnum
		ifge picnum 14160 ifle picnum 14164
		add picnum 51
		settspr[].tsprpicnum picnum
	}
break

case BATPROJ
	settspr[].tsprcstat 130
break

case BATBOSS
case BATBOSSSWOOPING
	gettspr[].tsprshade shade
	sub shade 10
	settspr[].tsprshade shade
break

case MONSHADOW
	set picnum actorvar[spriteid].mysignpost
	set temp player[].player_par
	modvar temp 21
	// rand temp 20
	add picnum temp
	seta[spriteid].htdispicnum picnum
	settspr[].tsprpicnum picnum // actorvar[spriteid].mysignpost
	ife player[].heat_on NO
		settspr[].tspryrepeat actorvar[spriteid].damflash
	settspr[].tsprpal 4
break

case THROWNOBJECT
	settspr[].tsprpicnum actorvar[spriteid].mtype
break

case NEWMECH
	getav[spriteid].countvarb temp
	ifge temp 60
	ifvarand player[].player_par 1
	{
		settspr[].tsprshade -127
		settspr[].tsprpal 118
	}
		
break

case PLASMADISK
	ifn actorvar[spriteid].myspawner -1
	{
		set tempb actorvar[spriteid].myspawner
		setsprite spriteid sprite[tempb].x sprite[tempb].y sprite[tempb].z
	}
break

case CRAWFORD
	ifg crawfordclothes 1
	{
		gettspr[].tsprpicnum picnum
		set temp crawfordclothes
		div temp 2
		add picnum temp
		ifg picnum 22697 set picnum 22697
		settspr[].tsprpicnum picnum 
	}
break

case PODHEAD
	settspr[].tsprang actorvar[spriteid].angvel
break

case GUNSHIP 
	settspr[].tsprang actorvar[spriteid].lastang
break

case SHIPTURRET
	ifn actorvar[spriteid].myspawner -1
	{
		getav[spriteid].myspawner temp
		geta[temp].z z
		add z actorvar[spriteid].starty
		settspr[].tsprz z
		settspr[].tsprx sprite[temp].x
		settspr[].tspry sprite[temp].y
	}
break

case ARMLIZTROOP case ARMLIZTROOPDUCK
	ifge actorvar[spriteid].mtype 2
	ifn actorvar[spriteid].monstatus 2
	{
		gettspr[].tsprpicnum picnum
		add picnum 75
		settspr[].tsprpicnum picnum
	}
break

default
ifn actorvar[spriteid].upscaled YES
{
	getav[spriteid].shrunken temp
	ifg temp 20 ifl temp SHRUNKCOUNT
	{
		gettspr[].tsprxrepeat x
		div x 4 ifl x MINXSTRETCH set x MINXSTRETCH
		settspr[].tsprxrepeat x
		gettspr[].tspryrepeat y
		div y 4 ifl y MINYSTRETCH set y MINYSTRETCH
		settspr[].tspryrepeat y
	}
}
break

endswitch

endevent


state spawngroundjib
	
	seta[].htflags 128
	ifactor LIZMANHEAD1
		ifspawnedby LIZRANGER
	{
		spawn LIZRANGERHEAD
		seta[RETURN].pal sprite[].pal
	}
	else
	{
		geta[].picnum picnum
		add picnum 2
		espawnvar picnum
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		seta[RETURN].pal sprite[].pal
		setav[RETURN].initsprite 1
	}
ends

defstate projectilehitscan
	
	// ifactor FIRELASER  // hitscan fails
	// {
		// ifn shellyinmap 0
		// {
			// findnearactorz SHELLY 4096 16384 target
			// ife target -1 findnearactorz SHELLYCROUCH 4096 16384 target
			// ife target -1 findnearactorz DUKEBOT 4096 16384 target
			// ife target -1 findnearactorz DUKEBOTCROUCH 4096 16384 target
			// ife target -1 findnearactorz WESBOT  4096 16384 target
			// ife target -1 findnearactorz WESBOTCROUCH  4096 16384 target
			// ife target -1 findnearactorz NAAMAH 4096 16384 target
			// ifn target -1
			// ife actorvar[target].dodgetime 0
			// {
				// geta[].owner spriteid
				// geta[].x x
				// geta[].y y
				// sub x sprite[spriteid].x
				// sub y sprite[spriteid].y
				// getangle angvar x y
				// // projectile angle
				
				// geta[target].x x
				// geta[target].y y
				// sub x sprite[].x
				// sub y sprite[].y
				// getangle temp x y
				// // angle needed to face shelly
				
				// getincangle tempb angvar temp
				// ifg tempb -32 ifl tempb 32
					// setav[target].myspawner THISACTOR
				
			// }
		// }
		// break
	// }

	geta[].ang angvar
	geta[].zvel z
	geta[].xvel x
	shiftl z 14
	ife x 0 setvar x 1
	div z x
	cos mycos angvar
	sin mysin angvar
	hitscan sprite[].x sprite[].y sprite[].z sprite[].sectnum mycos mysin z mysector temp target x2 y2 zdist 4294901809
	
	ifg sprite[].extra 30
	ifn sprite[].picnum COOLEXPLOSION1
	ifg temp -1 // strong projectile hitting a wall
	{
		switch wall[temp].overpicnum
		case GLASS
		case STAINGLASS1
		case 511
			shoot ROCKETBULLET
		break
		endswitch
	}
	else
	ifactor RPG ife target -1 ifg sprite[].zvel 0
	{
		hitscan sprite[].x sprite[].y sprite[].z sprite[].sectnum mycos mysin 0 mysector temp target x2 y2 zdist 4294901809
	}
	
	ifn target -1
	ifn sprite[].owner target
	{
		ife actorvar[target].dodgetime 0
		{
			ifvarand actorvar[target].monstflags YES
			{
				dist xydist THISACTOR target
				ifl xydist 5120
				setav[target].myspawner THISACTOR
			}
			else
			{
				switch sprite[target].picnum
				
				case SPACEBULL
				case NEWPIG
				case LIZMAN
				case NEWBATLORD
				case LIZDOG
				case ROBOSHARK
				case ARMYANT
				case ARMYANTCRAWL
				case CRAZYLADY
				case BATBOSS
				case CHEERBOT
				case COMMANDER
				case NEWCOMM
				case CYBERBEAST
				case FIGHTFEM case FIGHTMALE
				case GRAVESNPC
					dist xydist THISACTOR target
					ifactor HEAVYHBOMB { sub xydist 2560 ifl xydist 2560 set xydist 2560 }
					ifl xydist 8192 ifge xydist 2560
					setav[target].myspawner THISACTOR
					set starty zdist
				break
				case NEWTROOP
				case NEWTROOPDUCKING
				case TERMINATOR
					ifge SKILL 4
					ife actorvar[target].myspawner -1
					{
						dist xydist THISACTOR target
						ifactor HEAVYHBOMB { sub xydist 2560 ifl xydist 2560 set xydist 2560 }
						ifl xydist 8192 ifge xydist 2560
						setav[target].myspawner THISACTOR
						set starty zdist
					}
				case NEWTROOPGUARD
				case SPACEBULLGUARD
				case NEWPIGGUARD
				case LIZMANGUARD
				case LIZRANGERGUARD
					ife sprite[target].htextra -1 seta[target].htextra 0
				break
				default break
				endswitch
			}
		}
	}

ends

state validatedecal

	getwall[bottarget].nextsector mysector
	ifvarn mysector -1
	{
		setvar tempb 0
		getsector[mysector].lotag temp
		switch temp
		case 3
		case 16    // ELEVATOR PLATFORM DOWN
		case 17    // ELEVATOR PLATFORM UP
		case 18    // ELEVATOR DOWN
		case 19    // ELEVATOR UP
		case 20    // CEILING DOOR
	    case 21    // FLOOR DOOR
	    case 22    // SPLIT DOOR
	    case 23    // SWING DOOR
	    case 26    // SPLIT STAR TREK DOOR
	    case 28    // DROP FLOOR
	    case 29    // TEETH DOOR
	    case  9    // STAR TREK DOORS
	    case 25    // SLIDE DOOR
	    case 27    // BRIDGE
	    case 30    // ROTATE RISE BRIDGE
	    case 31    // 2 WAY TRAIN
	    setvar tempb 1
	    break
	    default break
	    endswitch
	    ifvare tempb 1 killit
	    
	   	headspritesect spriteid mysector
	   	whilevarn spriteid -1
	   	{
		   	ifvare sprite[spriteid].picnum SECTOREFFECTOR
		   	{
			   	getactor[spriteid].lotag tempc
			   	switch tempc
			   	case 11
			   	case 13
			   	case 15
			   	case 19
			   	case 21
			   	case 22
			   	case 25
			   	case 31
			   	case 32
			   	setvar tempb 1
			   	break
			   	endswitch
		   	}
	   		nextspritesect spriteid spriteid
	   		ifvare tempb 1 setvar spriteid -1
		}
			ifvare tempb 1 
			{
				ifactor WALLARROW
				ifvarand sprite[].cstat 16 state arrow_bits
				killit
			}
			ifawayfromwall killit
	}
ends

// gamevar gravadjust 170 0
// gamevar lastzvel 0 2

onevent EVENT_PREWORLD

	// ifn gravadjust 0
	// {
		
		// ifg player[screenpeek].poszv actorvar[player[screenpeek].i].lastzvel
		// {
			// getp[screenpeek].poszv temp
			// ife player[screenpeek].jumping_counter 721 { setp[screenpeek].jumping_counter 0 set temp 0 }
			// sub temp gravadjust sub temp 76
			// ifg player[screenpeek].poszv 0 ifl temp 32 set temp 32
			// setp[screenpeek].poszv temp
			// setav[player[screenpeek].i].lastzvel temp
		// }
		// set spriteid 0
		// for spriteid allsprites
		// {
			// ifn sprite[spriteid].statnum 1024
			// ifg sprite[spriteid].zvel actorvar[spriteid].lastzvel
			// {
				// geta[spriteid].zvel temp
				// sub temp gravadjust
				// ifg sprite[spriteid].zvel 0 ifl temp 32 set temp 32
				// seta[spriteid].zvel temp
				// setav[spriteid].lastzvel temp
			// }
			// else ife sprite[spriteid].zvel 0 setav[spriteid].lastzvel 0
		// }
		
	// }

	ifg screentime 0 sub screentime 1
	headspritestat spriteid 2
	whilevarn spriteid -1
	{
		ifg actorvar[spriteid].gooify 0
		{
			ifvarand player[0].player_par 1 
			{
				changespritestat spriteid 1
				seta[spriteid].httimetosleep 100
			}
			else
			{
				set temp actorvar[spriteid].gooify
				ifg temp 1
				{
					sub temp 1
					setav[spriteid].gooify temp
				}
			}
		}
			
		ifl actorvar[spriteid].burning 0
		{
			ifvarand player[0].player_par 1 
			{
				changespritestat spriteid 1
				seta[spriteid].httimetosleep 100
			}
			else
			{
				set temp actorvar[spriteid].burning
				add temp 1
				setav[spriteid].burning temp
				ife temp 0
				{
					changespritestat spriteid 1
					seta[spriteid].httimetosleep 100
				}
				
			}
		}
		
		ifn actorvar[spriteid].monstatus 0
		ifg sprite[spriteid].httimetosleep 32000
		ifg actorvar[spriteid].burning -2
		ifl actorvar[spriteid].gooify 2
		{
			changespritestat spriteid 1
			seta[spriteid].httimetosleep 100
		}
		nextspritestat spriteid spriteid
	}
	
	headspritestat spriteid STATUESTAT
	whilevarn spriteid -1
	{
		ifg sprite[spriteid].htextra 0
		{
			geta[spriteid].htextra temp
			getav[spriteid].jumpadxvel tempb
			
			sub tempb temp
			setav[spriteid].jumpadxvel tempb
			seta[spriteid].htextra -1
			ifl tempb 1 
			{
				changespritestat spriteid 1
				ifvarand mandoupgrades[FREEZE_WEAPON] 4
				ifn actorvar[spriteid].monstatus 0
				{
					setav[spriteid].padang 0
					seta[spriteid].extra actorvar[spriteid].inithp
					seta[spriteid].htg_t 0 0
					seta[spriteid].htg_t 1 0
					seta[spriteid].htg_t 2 0
					seta[spriteid].htg_t 3 0
					seta[spriteid].htg_t 4 0
					seta[spriteid].htg_t 5 0
					seta[spriteid].pal 85
					setav[spriteid].monxp 0
					setav[spriteid].monstatus 1
					setav[spriteid].team 1
					setav[spriteid].botclip 0
					setav[spriteid].countvar 0
					setav[spriteid].countvarb 0
					setav[spriteid].countvarc 0
					setav[spriteid].myspawner -1
					setav[spriteid].myvictim -1
					setav[spriteid].bottarget -1
					setav[spriteid].initsprite 0
					setav[spriteid].stun 0
					setav[spriteid].burning 0
					setav[spriteid].bleeding 0
					setav[spriteid].bluetimer 0
					setav[spriteid].FEMKILLCOUNT 2400
					setav[spriteid].mtype 0

					setav[spriteid].startx 0
					setav[spriteid].shotpitch 0
					ifvarand actorvar[spriteid].monstflags 131072 
					{
						set temp actorvar[spriteid].monstflags
						xorvar temp 131072
						setav[spriteid].monstflags temp
					}
				}
				else
				{
					ife actorvar[spriteid].team 0
					setav[spriteid].padang 131314
					seta[spriteid].htextra 3000
					seta[spriteid].extra 1
					seta[spriteid].htpicnum RPG
				}
			}
		}
		nextspritestat spriteid spriteid
	}
	
	ifn instasis NO
	{
		set spriteid 0
		whilevarvarn spriteid 16384 // Numsprites
		{
			ifg actorvar[spriteid].stasis 0
			{
				set temp actorvar[spriteid].stasis
				sub temp 1
				setav[spriteid].stasis temp
				ifle temp 1
				{
					setav[spriteid].stasis 0
					set tempc actorvar[spriteid].damflash
					seta[spriteid].cstat actorvar[spriteid].damflash	
					setav[spriteid].damflash 0
					
					// certain hardcoded nonactors had their statnum stored
					// in lastcumb times negative one
					ifl actorvar[spriteid].lastcrumb 0
					{
						set tempc actorvar[spriteid].lastcrumb
						mul tempc -1
						changespritestat spriteid tempc
					}
					else
					{
						changespritestat spriteid 1
						seta[spriteid].httimetosleep 100
						ifvarand novaupgrades[SHRINKER_WEAPON] 2
						ifn sprite[spriteid].htpicnum RESPAWN
						ifn actorvar[spriteid].targetdist -1
						{
							// stun stores the amount of time actor has been in stasis
							// and that will amplify the random status effects

							
							set instasis player[0].player_par
							
							set temp actorvar[spriteid].stun
							div temp 10
							set tempb nweaplevel[SHRINKER_WEAPON]
							mul tempb 10
							add temp tempb
							seta[spriteid].htextra temp
							seta[spriteid].htowner player[0].i
							
							
							// setarray nweapxp[SHRINKER_WEAPON]
							
							rand K 6
							switch K
								case 0 // freeze
									set TMP_B actorvar[spriteid].burning
									mul temp 4
									sub TMP_B temp
									setav[spriteid].burning TMP_B
									seta[spriteid].htpicnum FREEZEBLAST
								break
								case 1 // burn
									set TMP_B actorvar[spriteid].burning
									mul temp 4
									add TMP_B temp
									setav[spriteid].burning TMP_B
									seta[spriteid].htpicnum FIREBEAM
								break
								case 2 // stun & grow
									div temp 2
									setav[spriteid].stun temp
									seta[spriteid].htpicnum GROWSPARK
								break
								case 3 // stun & shrink
									div temp 2
									setav[spriteid].stun temp
									seta[spriteid].htpicnum SHRINKSPARK
								break
								case 4 // rediation burn
									set TMP_B actorvar[spriteid].bleeding
									ifg TMP_B 0 mul TMP_B -1
									sub TMP_B temp
									setav[spriteid].bleeding TMP_B
									espawn BIGSMOKE
									seta[RETURN].pal 76
									screensound RADFRY
									setsprite RETURN sprite[spriteid].x sprite[spriteid].y sprite[spriteid].z
								break
								case 5 // gooify
									seta[spriteid].htpicnum GOOBULLET
								break
								case 6 // shock
									seta[spriteid].htpicnum SHOCK_ACTOR // SHOCKBEAM
									// espawn SHOCK_ACTOR
									// setsprite RETURN sprite[spriteid].x sprite[spriteid].y sprite[spriteid].z
									// setav[RETURN].myspawner spriteid
									// setav[RETURN].mtype 1
								break
							endswitch

						}
					}
					setav[spriteid].stun 0
				}
				else
				{
					ife temp 100 globalsound MIA_REVERSE
					seta[spriteid].httimetosleep 32767
					changespritestat spriteid 2
				}
			}
			add spriteid 1
		}
	}
	
endevent

// gamevar nogame 0 0

onevent EVENT_GAME

// ifn nogame 0 break

ife sprite[].statnum 4
{
	ifg Numsprites 15360 setthisprojectile[].trail -1
	switch sprite[].picnum
	
	case COOLEXPLOSION1

	ife mtype 1
	{
		seta[].extra 80
		spawn FRAMEEFFECT1
		// sizeto 255 255
		// sizeto 255 255
		ifspritepal 6 spritepal 0 else spritepal 6
	}
	state projectilehitscan
	break
	
	case SPIT
	ifvarand initflags 8
	{
		ifspritepal 6 spritepal 0 else spritepal 6
	}
	break
	
	case CARXPLODE 
		ifrnd 96
		{
		set temp 128
		ifrnd 128 orvar temp 4
		ifrnd 128 orvar temp 8
		seta[].cstat temp
		}
		ifspawnedby TERMINATORCRAWLING sizeat 16 16
	break
	
	case POTDEBRIS1 case POTDEBRIS2 case POTDEBRIS3 case POTDEBRIS4
	case WOODDEBRIS case STONEDEBRIS
		ife sprite[].yvel 1
		{
			geta[].zvel z
			add z 256
			seta[].zvel z
		}
	break
	
	case BOMBLET
		state projectilehitscan
		ife team 1
		ifvarand dukeupgrades[HANDBOMB_WEAPON] 2
		{
			state targetsearch
			state turntotarget
		}
	break
	case FIRELASER
		state projectilehitscan
		// cstator 2
		seta[].mdflags 16
		seta[].blend 1
		
		set temp 130
		ifrnd 128 orvar temp 4
		ifrnd 128 orvar temp 8
		seta[].cstat temp
		// sizeat 6 6
	break
	case FIRELASER2
	case NEWFIRELASER
		state projectilehitscan
		seta[].blend 1
		ifn sprite[].htpicnum APLAYER
		{
			findplayer startx
			ifl startx 1560
			{
				ifn starty 0 ifg startx starty 
				ifcansee { ifactorsound THISACTOR PLASMA_FLYBY nullop else sound PLASMA_FLYBY }
				set starty startx
			}
		}
		ife myspawner player[].i
		{
			add countvar 1
			ife countvar 3 cstat 130
			ifpdistg 1560 ifg sprite[].xrepeat 32 spawn PLASMA_EXP
		}
		espawn SPEEDBLUR
		setav[RETURN].mtype sprite[].picnum
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		seta[RETURN].alpha 80
		seta[RETURN].pal sprite[].pal
		seta[RETURN].cstat 128
		seta[RETURN].mdflags 16
		seta[RETURN].xvel sprite[].xvel
		seta[RETURN].zvel sprite[].zvel
	
	break
	
	// case FIRELASER3
	// case EDFLASER
	// case FREEZEBOLT
		// state projectilehitscan
		// seta[].blend 255
	// break
	
	case FIRELASER3
	case EDFLASER
	case FREEZEBOLT
	case SCUBAPROJ
	case GENERICBOLT
		state projectilehitscan
		seta[].blend 1
	break
	
	case ARCBALLPROJ
	case ARCBALLPROJ2
	case MANDOLASER
		state projectilehitscan
	break
	
	case BLASTBALL
		state projectilehitscan
		ife mtype CASTERPROJ
		{
			state targetsearch
			ifn bottarget -1
			{
			state turntotarget
			state zveltotarget
			}
		}
		
	break
	
	case REPAIRPROJ
		ifn bottarget -1
		{
			state turntotarget
			set z sprite[bottarget].z
			sub z sprite[].z
			abs z
			ifle z 1024 set mtype 0 else
			{
				ifl sprite[bottarget].z sprite[].z set mtype -3072
				else set mtype 3072
				movesprite THISACTOR 0 0 mtype CLIPMASK0 RETURN
			}
		}
	break
	
	case COOLEXPROJ
		seta[].blend 1
		state projectilehitscan
		ife sprite[].cstat 130 cstator 4 else
		ife sprite[].cstat 134 cstator 8 else
		ife sprite[].cstat 142 cstat 138 else
		cstat 130
		
		espawn SPEEDBLUR
		setav[RETURN].mtype COOLEXPROJ
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		seta[RETURN].alpha 80
		seta[RETURN].pal sprite[].pal
		seta[RETURN].cstat 130
		seta[RETURN].htflags 4
		seta[RETURN].shade -32
		seta[RETURN].mdflags 16
	break
	
	case PLASGOOPROJ
	
		seta[].blend 1
		state projectilehitscan
		ife sprite[].cstat 130 cstator 4 else
		ife sprite[].cstat 134 cstator 8 else
		ife sprite[].cstat 142 cstat 138 else
		cstat 130
		
		espawn SPEEDBLUR
		setav[RETURN].mtype sprite[].picnum
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		seta[RETURN].alpha 80
		seta[RETURN].pal sprite[].pal
		seta[RETURN].cstat 130
		seta[RETURN].htflags 4
		seta[RETURN].shade -32
		seta[RETURN].mdflags 16
	break
	
	case KINETICPROJ
	
		seta[].blend 1
		state projectilehitscan
		ife sprite[].cstat 130 cstator 4 else
		ife sprite[].cstat 134 cstator 8 else
		ife sprite[].cstat 142 cstat 138 else
		cstat 130
	
	break
	
	case BLADEPROJ
		state projectilehitscan
		geta[].xvel xvel
		geta[].zvel z2	
		shiftr z2 4
		getangle tempb xvel z2
		seta[].pitch tempb
		
		ifl sprite[].yvel countvar
		{
			spawn SPARKFALL spawn SPARKFALL spawn SPARKFALL spawn SPARKFALL 
		}
		geta[].yvel countvar
		ifg sprite[].xvel 844 
		{
			geta[].z savz
			set z savz
			add z 2048
			seta[].z z
			state makespeedblur
			seta[].z savz
		}
	break
	
	case DEALASER
		geta[].xvel xvel
		geta[].zvel z2	
		shiftr z2 4
		getangle tempb xvel z2
		seta[].pitch tempb
		state projectilehitscan
		ife initsprite 0
		ifn target -1 // hitscanned a sprite
		ifg sprite[].yvel 1
		{
			switch sprite[target].picnum 
			case DIPSWITCH
			case 163
			case DIPSWITCH2
			case 165
			case TECHSWITCH
			case 167
			case DIPSWITCH3
			case 169
			case ALIENSWITCH
			case 1143
				seta[].yvel 1
			break
			endswitch
			
		}
	break

	case FREEZEBLAST
		ife mtype 1
		{
			add countvar 1
			ife countvar 3
			{
				ifn bottarget -1
				{
					state calczdist
					setprojectile[RANGERPROJ].workslike 36866
					mulvar zdist 844
					div zdist xydist
					ezshoot zdist RANGERPROJ
					seta[RETURN].owner sprite[].owner
					setprojectile[RANGERPROJ].workslike 32770
				}
				killit
			}
		}
		else
		{
			state projectilehitscan
			seta[].blend 1
			cstator 2
			ifl sprite[].yvel countvar
			sound FREEZEBOUNCE
			geta[].yvel countvar
		}
		
	break
	case RPG
	
		ife initsprite 666 
		{
			geta[].xvel xvel mul xvel 3 div xvel 2 
			geta[].zvel yvel mul yvel 3 div yvel 2
			
			ife devside 1
			{
				setprojectile[CBPROJ].offset 65408
				
			}
			else
			{
				setprojectile[CBPROJ].offset 128
			}
			geta[].z z
			add z 2048
			seta[].z z
			
			eshoot CBPROJ
			seta[RETURN].extra 50
			seta[RETURN].zvel yvel
			seta[RETURN].xvel xvel
			seta[RETURN].owner sprite[].owner
			seta[RETURN].ang sprite[].ang
			seta[RETURN].xrepeat 26
			seta[RETURN].yrepeat 26
			setprojectile[CBPROJ].offset -160
			killit
		}
		state projectilehitscan
		ife mtype CANHEAD
		{
			add countvar 1
			ife countvar 20 // split!
			{
				sound RPG_SPLIT
				debris SCRAP1 2
				debris SCRAP2 2
				eshoot RPG
				setav[RETURN].mtype 666
				ifspawnedby BOSS3 seta[RETURN].extra 30 else
				seta[RETURN].extra 40
				seta[RETURN].ang sprite[].ang
				eshoot RPG
				setav[RETURN].mtype 666
				ifspawnedby BOSS3 seta[RETURN].extra 30 else
				seta[RETURN].extra 40
				seta[RETURN].ang sprite[].ang
				eshoot RPG
				setav[RETURN].mtype 666
				ifspawnedby BOSS3 seta[RETURN].extra 30 else
				seta[RETURN].extra 40
				seta[RETURN].ang sprite[].ang
				eshoot RPG
				setav[RETURN].mtype 666
				ifspawnedby BOSS3 seta[RETURN].extra 30 else
				seta[RETURN].extra 40
				seta[RETURN].ang sprite[].ang
				killit
			}
		}
		else ife mtype 666
		{
			state randtraj
			state randtraj
			sizeat 20 20
		}
		// else ife mtype 69 // spiral rockets
		// {
			
			// set temp player[].player_par
			// add temp countvarb
			// mul temp 96
			// sin tempb temp
			// shiftr tempb 11
			// add tempb sprite[].ang
			// seta[].ang tempb
		// }
		ifspritepal 47
		{
			ifactorsound THISACTOR ROCKETLOOP nullop else sound ROCKETLOOP
			spawn SPARKFALL
		}
		ifspritepal 11
		{
			ifactorsound THISACTOR ROCKETLOOP nullop else sound ROCKETLOOP
		}
		ifn sprite[].htpicnum APLAYER
		{
			findplayer startx
			ifl startx 1560
			{
				ifn starty 0 ifg startx starty 
				ifcansee { ifactorsound THISACTOR RPG_MISS nullop else sound RPG_MISS }
				set starty startx
			}
		}
		ife mtype TARGETLOCK
		{
			ifn bottarget -1
			{
				ifn myspawner -1 ife actorvar[myspawner].team 0
				ifvarand player[].player_par 1 nullop else
				state turntotarget
				state zveltotarget
				ifn actorvar[bottarget].monstatus 1 ifrnd 2 set bottarget -1
				
				ife actorvar[myspawner].team 0
				{
					add countvar 1
					ifge countvar 300
					ifrnd 8
					{
						sound RPG_EXPLODE
						hitradius RPGBLASTRADIUS 35 70 105 RPG_WEAPON_STRENGTH
						spawn EXPLOSION2
						killit
					}
				}
			}
			
		}
	break
	
	case GRENADEPROJ
	case WESGRENADE
	case BLOODBOMB
		state blowupcrack
		ife team 1
		{
			state targetsearch
			ifn bottarget -1
			{
				geta[bottarget].x x2
				geta[bottarget].y y2
				sub x2 sprite[].x
				sub y2 sprite[].y
				getangle angvar x2 y2
				getincangle temp sprite[].ang angvar
				ifg temp 480 // has moved passed target
				{
					ldist xydist THISACTOR bottarget
					ifl xydist 844
					{
						geta[].z z
						sub z sprite[bottarget].z
						abs z
						ifl z 10240
						seta[].yvel 0
					}
				}
			}
		}
		state projectilehitscan
		ifactor BLOODBOMB
		{
			espawn JIBS6
			seta[RETURN].zvel 0
			seta[RETURN].xvel 24
			randvar temp 2047
			seta[RETURN].ang temp
			seta[RETURN].xrepeat 12 // 24
			seta[RETURN].yrepeat 12 // 24
			seta[RETURN].pal sprite[].pal
		}
	break
	case BIGGRENADEPROJ
	ife bottarget player[].i
	{
		geta[].z z
		sub z 2048
		getp[].posz z2
		ifg z2 z
		{
			sub z2 z
			mul z2 sprite[].xvel
			ldist temp THISACTOR bottarget
			div z2 temp
			movesprite THISACTOR 0 0 z2 CLIPMASK0 RETURN
		}
	}
	state projectilehitscan
	break
	
	case PLAYERPLASMA
		add countvar 1
		ife countvar 2
		{
			geta[].xvel xvel mul xvel 3 seta[].xvel xvel
			geta[].zvel z mul z 3 seta[].zvel z
		}
		state projectilehitscan
	break
	
	case ARROWPROJ
		getactor[].xvel xvel
		subvar xvel 2
		setactor[].xvel xvel
		getthisprojectile[].drop z
		ifvarg z -256 subvar z 1
		setthisprojectile[].drop z
		
		ife initsprite 0
		{
			// 0 = regular; 1 = burning; 2 = explosive; 3 = multi; 4 = freeze; 5 = spy; 6 = electric
			// 7 = blood; 8 = radioactive
			 setvar initsprite 1 
			 ife arrowtype 1 // burning
			 {
				 spritepal 2
				 setthisprojectile[].pal 2
			 }
			 ife arrowtype 2 // explosive
			 {
				 spritepal 7
				 setthisprojectile[].pal 7
				 setthisprojectile[].hitradius 1792
				 setthisprojectile[].extra 180 // 120
				 strength 180 // 120
				 setthisprojectile[].spawns EXPLOSION2
				 setthisprojectile[].isound RPG_EXPLODE
			 }
			 ife arrowtype 3 // multi
			 {
				 spritepal 12
				 setthisprojectile[].pal 12
				 state randtraj
			 }
			 ife arrowtype 4 // freeze
			 {
				 spritepal 1
				 setthisprojectile[].pal 1
			 }
			 ife arrowtype 5 // spy
			 {
				 spritepal 15
				 setthisprojectile[].pal 15 
			 }
			 ife arrowtype 6 // electric
			 {
				spritepal 117
				setthisprojectile[].pal 117 
			 }
			 ife arrowtype 7 // blood
			 {
				spritepal 54
				setthisprojectile[].pal 54 
			 }
			 ife arrowtype 8 // radioactive
			 {
				spritepal 6
				setthisprojectile[].pal 6 
			 }
		}

		ifspritepal 2 ifpdistg 1560 spawn STICKYFIRE
		// ifspritepal 7 spawn SMALLSMOKE
		ifspritepal 1 lotsofglass 1
		// ifspritepal 117 spawn SPARKFALL 
		ifspritepal 15
		{
			getactor[].extra temp
			addvar temp 8 ifvarg temp 800 setvar temp 800
			
			setactor[THISACTOR].extra temp
			ifvarvare arrowview THISACTOR
			{	
				// getplayer[].oang temp
				set temp oang
				getplayer[].ang tempb
				getincangle tempb temp tempb
				shiftvarr tempb 1
				getactor[].ang angvar
				addvarvar angvar tempb
				setactor[].ang angvar
				setplayer[].ang player[].oang
				
				// getplayer[].ohoriz temp
				set temp ohoriz
				getplayer[].horiz tempb
				subvarvar tempb temp
				shiftvarl tempb 4
				getactor[].zvel z
				subvarvar z tempb
				setactor[].zvel z
				setplayer[].horiz ohoriz // player[].ohoriz
				
				addvar countvar 1
				ifvarg countvar 180 setvar arrowview -1
			}
		}
		state projectilehitscan
	break
	
	case STAKEPROJ
		getactor[].xvel xvel
		subvar xvel 2
		setactor[].xvel xvel
		getthisprojectile[].drop z
		ifvarg z -256 subvar z 1
		setthisprojectile[].drop z
		state projectilehitscan
		
		add countvarb 1
		ifg countvarb 1
		{
			geta[].z savz
			geta[].z z
			add z 1024
			seta[].z z
			state makespeedblur
			seta[].z savz
		}
		
		geta[].xvel xvel
		geta[].zvel z2	
		shiftr z2 4
		getangle tempb xvel z2
		seta[].pitch tempb
		
	break
	
	case CASTERPROJ
		state projectilehitscan
		geta[].xvel xvel
		geta[].zvel z2	
		shiftr z2 4
		getangle tempb xvel z2
		seta[].pitch tempb
		
		state makespeedblur
	break
	
	case BLOODBULLET
	case GOOBULLET
		state projectilehitscan
		state makespeedblur
	break
	
	case SHRINKSPARK
	    ife initsprite 0
		{
			set initsprite YES
			ifrnd 128 cstator 8
			ifrnd 128 cstator 4
			seta[].blend 1
			seta[].mdflags 16
			cstator 2
		}
		ifspawnedby SECTOREFFECTOR
		{
			ife PSHRINKING 0
			ifp palive
			ifpdistl 844
			ife sprite[].sectnum player[].cursectnum
			{
				seta[player[].i].htpicnum SHRINKSPARK
				ife sprite[player[].i].htextra -1 seta[player[].i].htextra 0
				seta[player[].i].htang sprite[].ang
				seta[player[].i].htowner THISACTOR
			}
			
			headspritestat spriteid 1
			whilevarn spriteid -1
			{
				// ife sprite[].sectnum sprite[spriteid].sectnum
				ifn actorvar[spriteid].monstatus 0
				ifn actorvar[spriteid].monstatus 2
				{
					dist xydist THISACTOR spriteid
					ifle xydist 844
					{
						seta[spriteid].htpicnum SHRINKSPARK
						ife sprite[spriteid].htextra -1 seta[spriteid].htextra 1
						seta[spriteid].htowner THISACTOR
					}
				}
				nextspritestat spriteid spriteid
			}
		}
		state projectilehitscan
	break
	
	case LOVEBOMB
		seta[].blend 1
		cstator 2
		espawn GROWSPARK
		rand x 1024, sub x 640
		add x sprite[].x
		seta[RETURN].x x
		rand y 1024, sub y 640
		add y sprite[].y
		seta[RETURN].y y
	break
	
	
	case MEGAPROJ
	case PLASMAPROJ
	case GREENLASER
	case STICKYPROJ
	case FLAKPROJ
	case SWIRLPROJ
	case COMETPROJ
	case RANGERPROJ
	case SHOCKPROJ
	case TANKSHELL
		state projectilehitscan
	break
	
	
	
	case BIGPLASMA
	case TIDALPROJ
		state projectilehitscan
		espawn SPEEDBLUR
		setav[RETURN].mtype sprite[].picnum
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		seta[RETURN].alpha 80
		seta[RETURN].pal sprite[].pal
		seta[RETURN].cstat 128
		seta[RETURN].mdflags 16
	break
	
	case BUBBLEPROJ

		state projectilehitscan
		
		
		set temp player[].player_par
		shiftl temp 6
		add temp THISACTOR
		sin tempb temp
		shiftr tempb 5
		geta[].z z
		
		sub z tempb
		seta[].z z
		
		
		add countvar 1
		ifge countvar 3
		{
			set countvar 0
			geta[].cstat temp
			ife temp 130 set temp 134 else
			ife temp 138 set temp 138 else
			ife temp 138 set temp 142 else
			set temp 130
			seta[].cstat temp
		}
		
	break
	
	case BIGBOIPROJ
		state projectilehitscan
		ife rendmode 0
		{
			ife sprite[].cstat 130
				cstat 134 else
			ife sprite[].cstat 134
				cstat 138 else
			ife sprite[].cstat 138
				cstat 130
		}
	break
	
	case FLAMEPROJ2
		add countvar 1
		ifge countvar 2
		{
			ifpdistg 844
			{
				ifl countvar 5 cstat 642
				else
				ifvarand countvar 1
				{
					ife sprite[].cstat 642 cstat 650 else
					ife sprite[].cstat 650 cstat 654 else
					ife sprite[].cstat 654 cstat 646 else
					ife sprite[].cstat 646 cstat 642
				}
				sizeto 26 24
			}
		}
	break
	
	case CBPROJ
		ifspawnedby BOSS2 sizeat 64 64
		state projectilehitscan
		
		// espawn SPEEDBLUR
		// setav[RETURN].mtype CBPROJ
		// seta[RETURN].xrepeat sprite[].xrepeat
		// seta[RETURN].yrepeat sprite[].yrepeat
		// seta[RETURN].alpha 80
		// seta[RETURN].pal sprite[].pal
		// seta[RETURN].cstat 128
		// seta[RETURN].mdflags 16
	break
	
	case BMFGPROJ
		state projectilehitscan
		seta[].blend 1
		cstator 2
		ifspawnedby APLAYER 
		ifspritepal 22
		{
			setprojectile[BMFGPROJ].pal 0 // resets to normal in case altfire was used
			setprojectile[BMFGPROJ].hitradius 3072
			
		}
		headspritestat spriteid 1 // 990
		whilevarn spriteid -1
		{
			ife actorvar[spriteid].monstatus 1
			ifn actorvar[spriteid].team team
			ifn actorvar[spriteid].team 3
			{
				set target spriteid // actorvar[spriteid].mysignpost
				ifn target -1
				{
					dist xydist THISACTOR target
					
					ifl xydist 8192
					{
						canseespr THISACTOR target temp
						ife temp YES
						{
							geta[target].x x2
							geta[target].y y2
							sub x2 sprite[].x
							sub y2 sprite[].y
							getangle angvar x2 y2 // angle to make projectile face the target
							
							getincangle temp angvar sprite[spriteid].ang
							abs temp
							ifg temp 512
							{
								add angvar 1024
								cos xvel angvar
								sin yvel angvar
									  
								shiftvarr xvel 5
								shiftvarr yvel 5
								
								geta[].z z
								sub z sprite[target].z
								shiftr z 1
										 
								movesprite target xvel yvel z CLIPMASK0 RETURN
								
								setav[target].bottarget -1
								rand angvar 2047
								seta[target].ang angvar
								seta[target].xvel 0
								
								ifspritepal 22
								{
									ifl xydist 5120
									ife actorvar[target].shrunken 0
									ifg sprite[target].extra 0
									ife sprite[target].htextra -1
									{
										espawn SHRINKEREXPLOSION
										setav[RETURN].myvictim target
										setsprite RETURN sprite[target].x sprite[target].y sprite[target].z
										seta[target].htpicnum SHRINKSPARK
										seta[target].htowner player[].i
										seta[target].htextra 3
									}
								}
								else
								{
									ifl xydist 6144
									ifrnd 40
									{
										ife actorvar[target].stun 0
										{
											espawn SHOCK_ACTOR
											setsprite RETURN sprite[target].x sprite[target].y sprite[target].z
											setav[RETURN].myspawner target
											seta[target].htowner player[].i
										}
									}
								}
									
							}

							
						}
					}
				}
			}
			nextspritestat spriteid spriteid
		}
		
	break
	
	case SHOCKBALL
	case SHOCKBALL2
		state projectilehitscan
		seta[].blend 1
		cstator 514
		cstator 256
		spawn SHOCKBALL
		ife monstatus 2
		{
			espawn SHOCKBALL_EXP
			setav[RETURN].mtype 1
			sound SHOCKBALLIMPACT
			hitradius 4096 60 85 110 135
			headspritestat spriteid 1
			whilevarn spriteid -1
			{
				ifn spriteid myspawner
				{
					set temp NO
					ife actorvar[spriteid].monstatus 1 set temp YES
					ife spriteid myshelly set temp YES
					ife temp YES
					{
						dist xydist THISACTOR spriteid
						ifl xydist 4096
						{
							espawn SHOCK_ACTOR
							setsprite RETURN sprite[spriteid].x sprite[spriteid].y sprite[spriteid].z
							setav[RETURN].myspawner spriteid
							seta[spriteid].htowner player[].i
						}
					}
				}
				nextspritestat spriteid spriteid
			}
			killit
		}
		
	break
	
	// case FIREBOLT
		// state projectilehitscan
		// ife countvar 0
		// {
			// set countvar 1
			// geta[].zvel z
			// shiftl z 1
			// seta[].zvel z
			// geta[].xvel x
			// shiftl x 1
			// seta[].xvel x
		// }
	// break
	case RANGERHEADPROJ
	case LIZHEADPROJ
	case ZOMBIEHEADPROJ case CRAZYHEADPROJ
	case NEWTROOPHEADPROJ
	case PIGHEADPROJ
	case ANTHEADPROJ
	case BBHEADJIBPROJ
	case BBARMJIBPROJ
	case BBLEGJIBPROJ
	case MANDOARMPROJ
	case MANDOHEADPROJ
	case MANDOCHESTPROJ
	case MANDOLEGPROJ
		ifspritepal 1 { setthisprojectile[].bsound GLASSTINK setthisprojectile[].trail -1 }
		ifspritepal 27 { setthisprojectile[].bsound GLASSTINK setthisprojectile[].trail -1 }
		add countvarb 1
		ifg countvarb 15 setthisprojectile[].trail -1
		ifge countvarc 2 ife sprite[].yvel 2 seta[].yvel 0
		ifn sprite[].htmovflag 0 ifle sprite[].yvel 1 
		ifn projectile[sprite[].picnum].spawns -1
		{
			espawnvar projectile[sprite[].picnum].spawns
			killit 
		}
	break
	
	case BULLHEADPROJ
	case BULLLEGPROJ
	case BULLARMPROJ
	case COMMHEADPROJ
	case NEWCOMMHEADPROJ
	case BEASTHEADPROJ
	case EGGJIBPROJ
	case PIGLEGPROJ
	case PIGARMPROJ
	case COMMARMPROJ
	case RANGERLEGPROJ
	case RANGERARMPROJ
	case ARMPIGARMPROJ
	case ARMPIGLEGPROJ
	case ARMPIGFOOTPROJ
	case NEWMECHPART1
	case NEWMECHPART2
	case MECHESTGROUND
	case ARMLIZCHESTPROJ
	case ARMLIZARMPROJ
	case ARMLIZLEGPROJ
	case HEARTPROJ
		ifspritepal 1 { setthisprojectile[].bsound GLASSTINK setthisprojectile[].trail -1 }
		ifspritepal 27 { setthisprojectile[].bsound GLASSTINK setthisprojectile[].trail -1 }
		add countvarb 1
		ifg countvarb 15 setthisprojectile[].trail -1
		add countvar 1
		ifg countvar 6
		{
			ife sprite[].cstat 128 cstat 132 else 
			ife sprite[].cstat 132 cstat 136 else
			ife sprite[].cstat 136 cstat 140 else
			cstat 128
			set countvar 0
		}
		ifge countvarc 2 ife sprite[].yvel 2 seta[].yvel 0
		ifn sprite[].htmovflag 0 ifle sprite[].yvel 1 
		ifn projectile[sprite[].picnum].spawns -1
		{
			espawnvar projectile[sprite[].picnum].spawns
			killit 
		}
	break
	
	case ARROWBIT1 case ARROWBIT2 case ARROWBIT3
		add countvar 1
		ifg countvar 4
		{
			ife sprite[].cstat 128 cstat 132 else 
			ife sprite[].cstat 132 cstat 136 else
			ife sprite[].cstat 136 cstat 140 else
			cstat 128
			set countvar 0
		}
	break
	

	case COINPROJ
		ifpdistl 1024 { spawn NUKECOIN killit }
	break
	
	case IMPCOINPROJ
		ifpdistl 1024 { espawn IMPCOIN seta[RETURN].pal sprite[].pal killit }
	break

	case SPIDERMINEFALLING
		add countvar 1
		ifg countvar 7
		{
			set countvar 0
			geta[].cstat temp
			ifvarand temp 8 ifvarand temp 4 { xorvar temp 8 } else
			ifvarand temp 4 { xorvar temp 4 } else
			ifvarand temp 8 { orvar temp 4 } else
			orvar temp 8
			seta[].cstat temp
		}
	break
	case RADPROJ
		state projectilehitscan
		geta[].cstat temp
		ifl sprite[].zvel 0
			orvar temp 8
		else
			ifvarand temp 8 xorvar temp 8
		seta[].cstat temp
		ife team 1 // from wesgrenade
		{
			state targetsearch
			ifn bottarget -1
			{
				ifvarand player[].player_par 1
				{
					state turntotarget
					state zveltotarget
				}
				ifn actorvar[bottarget].monstatus 1 ifrnd 2 set bottarget -1
				
				state randtraj
			}
		}
		ife mtype 1
		{
			geta[].htflags temp, orvar temp 4, seta[].htflags temp
			seta[].shade 35
			seta[].blend 0
			spritepal 10
			ifn bottarget -1
			{
				ifvarand player[].player_par 1
				{
					state turntotarget
					state zveltotarget
				}
				ifn actorvar[bottarget].monstatus 1 ifrnd 2 set bottarget -1
				
				state randtraj
			}
		}
		
	break
	case PURPPROJ
		state projectilehitscan
		geta[].cstat temp
		ifl sprite[].zvel 0
			orvar temp 8
		else
			ifvarand temp 8 xorvar temp 8
		seta[].cstat temp
	break
	case PADPROJ
		seta[].blend 1
		add countvar 1
		ife countvar 3
		{
			set countvar 0
			ife sprite[].cstat 642 cstat 646 else
			ife sprite[].cstat 646 cstat 650 else
			ife sprite[].cstat 650 cstat 654 else
			cstat 642
		}
		spawn PADPROJ
	break
	case POMPROJ

		cstat 32
		cstator 16
		
		ifspawnedby NEWMECH
		{
			cstator 2
			seta[].blend 1
		}
		ifspawnedby LIZMAN
		{
			cstator 2
			seta[].blend 1
		}
		
		geta[].xvel xvel
		geta[].zvel z	
		shiftr z 4
		getangle tempb z xvel
		sub tempb 512
		
		div tempb 16
		seta[].yoffset tempb
		

	break
	case PLASPELPROJ
		state makespeedblur
		ife sprite[].yvel 1 ife initsprite 0
		{
			set initsprite 1
			geta[].xvel xvel div xvel 2 seta[].xvel xvel
			geta[].zvel xvel div xvel 2 seta[].zvel xvel
		}
	break
	
	case PLASROCKET
		ifn angvel 0
		{
			geta[].ang angvar
			add angvar angvel
			ifg angvel 2 sub angvel 2 else ifl angvel -2 add angvel 2
			seta[].ang angvar
			add countvar 1
			ifge countvar 12 { seta[].ang initsprite set angvel 0 }
		}
		ifn shotpitch 0
		{
			geta[].zvel z
			add z shotpitch
			ifg shotpitch 16 sub shotpitch 16 else ifl shotpitch -16 add shotpitch 16
			seta[].zvel z
			add countvarb 1
			ifge countvarb 12 { seta[].zvel lastangvel set shotpitch 0 }
		}
		ife angvel 0 ife shotpitch 0 spawn SPARKFALL
	break
	
	case PLASDISKPROJ
		state projectilehitscan
		ife countvar 0
		{
			set countvar 1
			ifrnd 128 cstator 4
			ifrnd 128 cstator 8
		}
		
		ifactioncount 5
		{
			
			resetactioncount
			geta[].cstat temp
			ife temp 130 set temp 134 else
			ife temp 134 set temp 138 else
			ife temp 138 set temp 142 else
			ife temp 142 set temp 130
			seta[].cstat temp
		}
	break
	
	case SMARTBOMB
		state projectilehitscan
		add countvar 1
		ifg countvar 19
		{
			spawn SMARTBOMB
			killit
		}
	break
	
	default
		ifl sprite[].extra 1
		{
		ifspritepal 1 ife sprite[].statnum 4 { setthisprojectile[].bsound GLASSTINK setthisprojectile[].trail -1 }
		ifspritepal 27 ife sprite[].statnum 4 { setthisprojectile[].bsound GLASSTINK setthisprojectile[].trail -1 }
		}
		geta[].htflags temp
		orvar temp 128
		seta[].htflags temp
	break
	endswitch
	ifvarand monstflags 1048576 ifn sprite[].picnum SHOCKPROJ spawn SPARKFALL
	
	set mysector sprite[].sectnum
	updatesector sprite[].x sprite[].y mysector
	ife mysector -1 
	{ 
		// al THISACTOR 
		killit 
	}
	
	break
}

switch sprite[].picnum

case 0
	ifand sprite[].cstat 16 nullop else
	ifand sprite[].cstat 32 nullop else
	{
		geta[].htpicnum picnum
		al picnum
		killit
	}
break

case SECTOREFFECTOR

	ifn myspawner -1
	{
		ifg sprite[myspawner].statnum 2 { set myspawner -1 killit }
		ifn sprite[myspawner].picnum mtype { set myspawner -1 killit }
		seta[].x sprite[myspawner].x
		seta[].y sprite[myspawner].y
		seta[].z sprite[myspawner].z
		changespritesect THISACTOR sprite[myspawner].sectnum
	}
	// SE61 reserved for collectibles
	ife sprite[].lotag 60 // floater
	{
		headspritesect spriteid sprite[].sectnum
		{
			whilevarn spriteid -1
			{
				switch sprite[spriteid].picnum
				case BULLETHOLE
				case DRIPBLOOD
				case BLOODSPLAT1 case BLOODSPLAT3 case BLOODSPLAT2 case BLOODSPLAT4 
				case WALLBLOOD1 case WALLBLOOD2 case WALLBLOOD3 case WALLBLOOD4 case WALLBLOOD5 
				case WALLBLOOD6 case WALLBLOOD7 case WALLBLOOD8 
				case CONCRETEHOLE case METALHOLE case METALHOLEINNER 
				case WOODHOLE case WOODHOLEINNER case ELECTRONICHOLE case ORGANICHOLE 
				case BLOODPOOL case BLOODPOOL2 case FOOTPRINTS case PUKE
				break
				default
				
				// ifvarand sprite[spriteid].cstat 32
				// {
					// getflorzofslope sprite[].sectnum sprite[spriteid].x sprite[spriteid].y z
					// sub z sprite[spriteid].z
					
				// }
				
				ldist xydist THISACTOR spriteid
				ifle xydist starty
				{
					set temp player[].player_par
					add temp initsprite
					shiftl temp 5
					sin tempb temp
					shiftr tempb 8
					geta[spriteid].z z
					sub z tempb
					ifvarand player[].player_par 1 
					{
						set temp player[].player_par
						modvar temp 13
						ife temp 0 nullop else sub z 1
					}
					seta[spriteid].z z
				}
				break
				endswitch
				nextspritesect spriteid spriteid
			}
		}
	}
	else
	ife sprite[].lotag 63
	{
		
		ife sprite[].hitag 1 // slow stars
		{
			addvar countvarb 1
			ifvarg countvarb 10
			ifrnd 10
			{
				// ifg player[].player_par 600
				setvar countvarb -40
				espawn STARFLY
				setactor[RETURN].htflags 128
				setav[RETURN].initsprite YES
			}
		}
		else
		{
			addvar countvarb 1
			ifvarg countvarb 10
			ifrnd 10
			{
				setvar countvarb 1
				espawn STARFLY
				setactor[RETURN].htflags 128
			}
		}
	}
	else
	ife sprite[].lotag 64 // jetpack refueler
	{
		ife player[].cursectnum sprite[].sectnum
		ifp palive
		ifl player[].jetpack_amount 1600
		ifp ponground
		ife player[].jetpack_on NO
		{
			ifl player[].fta 30 { setp[].ftq 1489 setp[].fta 90 }
			set temp player[].jetpack_amount
			add temp 8
			ifg temp 1600 set temp 1600
			setp[].jetpack_amount temp
			palfrom 28 0 63 0
			ifactorsound THISACTOR DUKE_JETPACK_IDLE nullop else sound DUKE_JETPACK_IDLE
			set temp player[].jetpack_amount
			sub temp 600
			setactorsoundpitch THISACTOR DUKE_JETPACK_IDLE temp
			setp[].inven_icon 4
		}
		else 
		{
			ifactorsound THISACTOR DUKE_JETPACK_IDLE stopactorsound THISACTOR DUKE_JETPACK_IDLE
			ife player[].ftq 1489 setp[].fta 0
		}
		ife initsprite 1
		{
			ife player[].horiz 299 
			ifp pfacing
			{
				set initsprite 0
				screensound MARIOSECRET
				screensound MARIOSECRET
				screensound MARIOSECRET
				palfrom 63 63 63 63
				lockplayer 12
				addphealth 200
				// ifl sprite[player[].i].extra player[].max_player_health
					// seta[player[].i].extra player[].max_player_health
			}
		}
	}
	else
	ife sprite[].lotag 88
	{
		
		ifpdistl 16384 // 32768
		{
			ifcansee
			{
				ifvarn portalcam -1 ifvarvarn portalcam THISACTOR
				{
					findplayer xydist
					dist xydist2 portalcam player[THISACTOR].i
					ifvarvarl xydist xydist2
					{
						ifn portalcam teamspawned
						{
							setvarvar portalcam teamspawned
							getp[].posz portalzoffset
						}
						setvar portalview 52
					}
				} 
				else
				{
					ifn portalcam teamspawned
					{
						setvarvar portalcam teamspawned
						getp[].posz portalzoffset
					}
					setvar portalview 52
				}
			}
			else ifpdistl 8192
			{
				ifn portalcam teamspawned
				{
					setvarvar portalcam teamspawned
					getp[].posz portalzoffset
				}
				setvar portalview 52
			}
		}
		
		
	}
	else
	ife sprite[].lotag 666 // SE of death
	{
	
		geta[].sectnum mysector
		headspritesect spriteid mysector
		whilevarn spriteid -1
		{
			geta[spriteid].picnum picnum
			setvar temp 0
			ifvare picnum APLAYER
			{	
				getactor[spriteid].yvel tempb
				getplayer[tempb].dead_flag tempc
				ifvare tempc 0 { setvar temp 1 set falldeath YES }
			}
			else ife sprite[spriteid].statnum 1
			ifn sprite[spriteid].picnum GUNSHIP
			ifn sprite[spriteid].picnum REPAIRDRONE
			{
				 ife actorvar[spriteid].monstatus 1
					set temp 1
				 ife actorvar[spriteid].monstatus 3
					set temp 1
			}
			
			ifvare temp 1
			{
				getactor[THISACTOR].z z
				getactor[spriteid].z z2
				ifvarvarg z2 z
				{
					set tempb YES
					
					ifn starty 0
					{
						set temp starty
						mul temp 10
						add z temp
						ifg z2 z set tempb NO
					}
					ife tempb YES
					{
						setactor[spriteid].htextra 999
						setactor[spriteid].htpicnum RADIUSEXPLOSION
						setactor[spriteid].htowner spriteid	
					}
				}
			}
			nextspritesect spriteid spriteid
		}
	}
	else
	ife sprite[].lotag 26 // escalator
		sectclearinterpolation sprite[].sectnum

break

case TOUCHPLATE

	ifn SPRITELOTAG 0
	{
		headspritesect spriteid sprite[].sectnum
		whilevarn spriteid -1
		{
			ife sprite[spriteid].statnum 1
			ife actorvar[spriteid].monstatus 1
				set mtype YES
			nextspritesect spriteid spriteid
		}
		
		ife mtype YES
		{
			al THISACTOR
			operateactivators SPRITELOTAG 0
			operatemasterswitches SPRITELOTAG
			operaterespawns SPRITELOTAG
			killit
		}
	}

break

case NAVSPRITE

	ifn debugaa NO cstat 514
	else cstat 32768
	
	ifp pfacing
	ifpdistl 1560
	{
		ifhitspace { set hudnumber bluebaseval set hudnumber2 blueflagval }
		else
		{
		set hudnumber redbaseval
		set hudnumber2 redflagval
		// set hudnumber thirdbaseval
		// set hudnumber2 redflagval
		}
	}
	
	ife monstatus 2 killit
	
	ifl countvar 1 // do all of below only when countdown reaches 0, for framerate
	{
		
	ifg redbaseval 0
	{
		getp[].player_par tempe
		add tempe 1
		
		headspritestat spriteid 979 // 980
		whilevarn spriteid -1
		{
			set B redbaseval
			// sub B 1024
			ifn spriteid THISACTOR
			ifle actorvar[spriteid].redbaseval B
			// ife sprite[spriteid].htpicnum NAVSPRITE
			ifl rediteration actorvar[spriteid].rediteration
			// ifn redowner spriteid
			{
				geta[].z z
				sub z 6144
				geta[spriteid].z z2
				sub z2 z
				abs z2
				
				set temp YES
				ifn SPRITELOTAG 0
				{
					ifl SPRITELOTAG 1000
					{
						ifn SPRITELOTAG actorvar[spriteid].initflags set temp NO
					}
					else 
					{
						ife mtype 0 // pal 0, the middle of lotag 1000+ path
						{
							set z2 0
							getav[spriteid].SPRITELOTAG tempb
							sub tempb SPRITELOTAG
							abs tempb
							ifn tempb 1 set temp NO
						}
					}
				}
				ife temp YES
				ifl z2 MAXHEIGHTDIFF // no big height difference allowed
				{
					ldist xydist THISACTOR spriteid
					ife sprite[spriteid].pal 8 set TMP_A HALFNAVDIST else set TMP_A MAXNAVDIST
					ifl xydist TMP_A
					{
						geta[].z z
						sub z 6144
						seta[].z z
						canseespr THISACTOR spriteid temp
						add z 6144
						seta[].z z
						
						ifn initsprite -1
						ife initsprite actorvar[spriteid].initsprite
							set temp YES // forced visibility feature
						
						ife temp YES
						{
							shiftl xydist 5
							sub B xydist
							ifle actorvar[spriteid].redbaseval B
							{
								setav[spriteid].redbaseval B
								setav[spriteid].redtimer tempe
								// setav[spriteid].redowner THISACTOR
								set temp rediteration
								add temp 1
								setav[spriteid].rediteration temp
							}
						}
					}
				
				}
			}
			nextspritestat spriteid spriteid
		}
	}

	ifg bluebaseval 0
	{
		getp[].player_par tempe
		add tempe 1
		
		headspritestat spriteid 979 // 980
		whilevarn spriteid -1
		{
			set B bluebaseval
			// sub B 1024
			ifn spriteid THISACTOR
			ifle actorvar[spriteid].bluebaseval B
			// ife sprite[spriteid].htpicnum NAVSPRITE
			ifl blueiteration actorvar[spriteid].blueiteration
			// ifn blueowner spriteid
			{
			
				geta[].z z
				sub z 6144
				geta[spriteid].z z2
				sub z2 z
				abs z2
				
				set temp YES
				ifn SPRITELOTAG 0
				{
					ifl SPRITELOTAG 1000
					{
						ifn SPRITELOTAG actorvar[spriteid].initflags set temp NO
					}
					else 
					{
						ife mtype 0 // pal 0, the middle of lotag 1000+ path
						{
							set z2 0
							getav[spriteid].SPRITELOTAG tempb
							sub tempb SPRITELOTAG
							abs tempb
							ifn tempb 1 set temp NO
						}
					}
				}

				ife temp YES
				ifl z2 MAXHEIGHTDIFF // no big height difference allowed
				{
					ldist xydist THISACTOR spriteid
					ife sprite[spriteid].pal 8 set TMP_A HALFNAVDIST else set TMP_A MAXNAVDIST
					ifl xydist TMP_A
					{
						geta[].z z
						sub z 6144
						seta[].z z
						canseespr THISACTOR spriteid temp
						add z 6144
						seta[].z z
						
						ifn initsprite -1
						ife initsprite actorvar[spriteid].initsprite
							set temp YES // forced visibility feature

						ife temp YES
						{
							shiftl xydist 5
							sub B xydist
							ifle actorvar[spriteid].bluebaseval B
							{
								setav[spriteid].bluebaseval B
								setav[spriteid].bluetimer tempe
								// setav[spriteid].blueowner THISACTOR
								set temp blueiteration
								add temp 1
								setav[spriteid].blueiteration temp
							}
						}
					}
				
				}
			}
			nextspritestat spriteid spriteid
		}
	}
	
	ifg thirdbaseval 0
	{
		getp[].player_par tempe
		add tempe 1
		
		headspritestat spriteid 979
		whilevarn spriteid -1
		{
			set B thirdbaseval
			ifn spriteid THISACTOR
			ifle actorvar[spriteid].thirdbaseval B
			ifl thirdbaseiteration actorvar[spriteid].thirdbaseiteration
			{
			
				geta[].z z
				sub z 6144
				geta[spriteid].z z2
				sub z2 z
				abs z2
				
				set temp YES
				ifn SPRITELOTAG 0
				{
					ifl SPRITELOTAG 1000
					{
						ifn SPRITELOTAG actorvar[spriteid].initflags set temp NO
					}
					else 
					{
						ife mtype 0 // pal 0, the middle of lotag 1000+ path
						{
							set z2 0
							getav[spriteid].SPRITELOTAG tempb
							sub tempb SPRITELOTAG
							abs tempb
							ifn tempb 1 set temp NO
						}
					}
				}

				ife temp YES
				ifl z2 MAXHEIGHTDIFF // no big height difference allowed
				{
					ldist xydist THISACTOR spriteid
					ife sprite[spriteid].pal 8 set TMP_A HALFNAVDIST else set TMP_A MAXNAVDIST
					ifl xydist TMP_A
					{
						geta[].z z
						sub z 6144
						seta[].z z
						canseespr THISACTOR spriteid temp
						add z 6144
						seta[].z z
						
						ifn initsprite -1
						ife initsprite actorvar[spriteid].initsprite
							set temp YES // forced visibility feature

						ife temp YES
						{
							shiftl xydist 5
							sub B xydist
							ifle actorvar[spriteid].thirdbaseval B
							{
								setav[spriteid].thirdbaseval B
								setav[spriteid].thirdbasetimer tempe
								set temp thirdbaseiteration
								add temp 1
								setav[spriteid].thirdbaseiteration temp
							}
							
							
						}
					}
				}
			}
			nextspritestat spriteid spriteid
		}
	}
	
	ife sprite[].statnum 979
	{
		ife gametype 0 changespritestat THISACTOR 980
		else
		ife gametype CTF // CTF
		{
			ifg bluebaseval 0 ifg redbaseval 0
			ifg player[].player_par 30
			{
				changespritestat THISACTOR 980
				set rediteration 99999
				set blueiteration 99999
			}
		}
		else	
		ife gametype -1 // arena complex
		{
			changespritestat THISACTOR 980
			set rediteration 99999
			set blueiteration 99999
		}
		ife gametype SURVIVAL 
		{
			changespritestat THISACTOR 980
			set rediteration 99999
			set blueiteration 99999
		}
		else
		ife gametype DM
		{
			changespritestat THISACTOR 980
			set rediteration 99999
			set blueiteration 99999
		}
		else
		ife gametype CONTROL
		{
			ifg bluebaseval 0 ifg redbaseval 0 ifg thirdbaseval 0
			ifg player[].player_par 30
			{
				changespritestat THISACTOR 980
				set rediteration 99999
				set blueiteration 99999
				set thirdbaseiteration 99999
			}
		}
	}
		
	ifg countvarc 0
	{
		sub countvarc 1
		ife countvarc 0 
		{
			seta[].htpicnum NAVSPRITE
			set blueiteration 99999
		}
	}
	
	ife countvarc 0
	ifg player[].player_par bluetimer
	ifn blueflagval 0
	{
		set blueflagval 0 
		set countvarc 6
	}
	ifg blueflagval 0
	{
		getp[].player_par tempe
		add tempe 1
		
		headspritestat spriteid 980
		whilevarn spriteid -1
		{
			set B blueflagval
			ifn spriteid THISACTOR
			ifle actorvar[spriteid].blueflagval B
			// ife sprite[spriteid].htpicnum NAVSPRITE
			ifl blueiteration actorvar[spriteid].blueiteration
			// ifn blueowner spriteid
			{
				geta[].z z
				sub z 6144
				geta[spriteid].z z2
				sub z2 z
				abs z2
				
				set temp YES
				ifn SPRITELOTAG 0
				{
					ifl SPRITELOTAG 1000
					{
						ifn SPRITELOTAG actorvar[spriteid].initflags set temp NO
					}
					else 
					{
						ife mtype 0 // pal 0, the middle of lotag 1000+ path
						{
							set z2 0
							getav[spriteid].SPRITELOTAG tempb
							sub tempb SPRITELOTAG
							abs tempb
							ifn tempb 1 set temp NO
						}
					}
				}

				ife temp YES
				ifl z2 MAXHEIGHTDIFF // no big height difference allowed
				{
					ldist xydist THISACTOR spriteid
					ife sprite[spriteid].pal 8 set TMP_A HALFNAVDIST else set TMP_A MAXNAVDIST
					ifl xydist TMP_A
					{
						geta[].z z
						sub z 6144
						seta[].z z
						canseespr THISACTOR spriteid temp
						add z 6144
						seta[].z z
						
						ifn initsprite -1
						ife initsprite actorvar[spriteid].initsprite
						set temp YES // forced visibility feature

						ife temp YES
						{
							shiftl xydist 5
							sub B xydist
							ifle actorvar[spriteid].blueflagval B
							{
								sub B 1024 ifl B 1 set B 1
								setav[spriteid].blueflagval B
								setav[spriteid].bluetimer tempe
								// setav[spriteid].blueowner THISACTOR
								set temp blueiteration
								add temp 1
								setav[spriteid].blueiteration temp
							}
						}
					}
				
				}
			}
			nextspritestat spriteid spriteid
		}
	}
	
	ifg countvarb 0
	{
		sub countvarb 1
		ife countvarb 0 
		{
			seta[].htpicnum NAVSPRITE
			set rediteration 99999
		}
	}
	
	ife countvarb 0
	ifg player[].player_par redtimer
	ifn redflagval 0
	{
		set redflagval 0 
		set countvarb 6
	}
	ifg redflagval 0
	{
		getp[].player_par curr_tick
		add curr_tick 1
		
		headspritestat spriteid 980
		whilevarn spriteid -1
		{
			set B redflagval
			ifn spriteid THISACTOR
			ifle actorvar[spriteid].redflagval B
			ifn spriteid mynavsprite
			// ife sprite[spriteid].htpicnum NAVSPRITE
			ifl rediteration actorvar[spriteid].rediteration
			{
				geta[].z z
				sub z 6144
				geta[spriteid].z z2
				sub z2 z
				abs z2
				
				set temp YES
				ifn SPRITELOTAG 0
				{
					ifl SPRITELOTAG 1000
					{
						ifn SPRITELOTAG actorvar[spriteid].initflags set temp NO
					}
					else 
					{
						ife mtype 0 // pal 0, the middle of lotag 1000+ path
						{
							set z2 0
							getav[spriteid].SPRITELOTAG tempb
							sub tempb SPRITELOTAG
							abs tempb
							ifn tempb 1 set temp NO
						}
					}
				}

				ife temp YES
				ifl z2 MAXHEIGHTDIFF // no big height difference allowed
				{
					ldist xydist THISACTOR spriteid
					ife sprite[spriteid].pal 8 set TMP_A HALFNAVDIST else set TMP_A MAXNAVDIST
					ifl xydist TMP_A
					{
						geta[].z z
						sub z 6144
						seta[].z z
						canseespr THISACTOR spriteid temp
						add z 6144
						seta[].z z
						
						ifn initsprite -1
						ife initsprite actorvar[spriteid].initsprite
							set temp YES // forced visibility feature

						ife temp YES
						{
							shiftl xydist 5
							sub B xydist
							ifle actorvar[spriteid].redflagval B
							{
								sub B 1024 ifl B 1 set B 1
								setav[spriteid].redflagval B
								setav[spriteid].redtimer curr_tick
								set temp rediteration
								add temp 1
								setav[spriteid].rediteration temp
							}
							
							
						}
					}
				
				}
			}
			nextspritestat spriteid spriteid
		}
	}
	
	set temp NO
	ife gametype DM set temp YES
	ife gametype SURVIVAL set temp YES
	ife temp YES // code for setting redflagvalue based on visible monsters
	{
		getp[].player_par curr_tick
		add curr_tick 1
		set B 0 // used as flag here
		headspritestat spriteid 1
		whilevarn spriteid -1
		{
			ife actorvar[spriteid].team 0
			ife actorvar[spriteid].monstatus 1
			{
				geta[spriteid].z z2
				sub z2 sprite[].z
				abs z2
				ifl z2 MAXHEIGHTDIFF
				{
					ldist xydist THISACTOR spriteid
					ifl xydist MAXNAVDIST
					{
						geta[].z z
						sub z 6144
						seta[].z z
						canseespr THISACTOR spriteid temp
						add z 6144
						seta[].z z
						ife temp YES
						{
							ife B 0 { set B 1 set redflagval 0 }
							shiftl xydist 5
							set TMP_B sprite[spriteid].extra
							add TMP_B 100
							shiftl TMP_B 13 // 14
							sub TMP_B xydist
							ifl TMP_B 1 set TMP_B 1
							ifg TMP_B 99000000 set TMP_B 99000000
						
							add redflagval TMP_B
							ifg redflagval 1073741823 set redflagval 1073741823 
							set rediteration 0
							set redtimer curr_tick
							seta[].htpicnum REDFLAG
						}
					}
				}
			}
			nextspritestat spriteid spriteid
		}
	}
		set countvar 5
	} // end of ife countvar 0 block
	else
	{
		sub countvar 1
		// ife gametype -1 sub countvar 4
	}

break

case CHECKPOINT
	ife initsprite 0
	ifp palive
	{
		
		ife player[].cursectnum sprite[].sectnum
		{
			set initsprite YES
			set bigmsgcount 90
			set bigmsg 1249
			ife SPRITELOTAG 0 save 0 else
			ife SPRITELOTAG 1 save 1 else
			ife SPRITELOTAG 2 save 2 else
			ife SPRITELOTAG 3 save 3 else
			ife SPRITELOTAG 4 save 4 else
			ife SPRITELOTAG 5 save 5 else
			ife SPRITELOTAG 6 save 6 else
			ife SPRITELOTAG 7 save 7 else
			ife SPRITELOTAG 8 save 8 else
			ife SPRITELOTAG 9 save 9 else
			save 0
			// save SPRITELOTAG
		}
	}
break

case TREE1 
	ifl sprite[].xrepeat startx 
	{
		set burning 90
		state imonfire
		set B startx
		sub B sprite[].xrepeat
		seta[].yrepeat starty
		ifg B 8
		{
			cactor BURNTPALM changespritestat THISACTOR 1
			move 0
			action 0
			geta[].cstat temp
			ifvarand temp 1 xorvar temp 1
			seta[].cstat temp
			seta[].htextra -1
			// set burning 90
			strength 60
			cstator 256
			seta[].xrepeat startx
			seta[].yrepeat starty
		}
	}
break

case DOMELITE
	ife initsprite 1
	ifspritepal 0
	{
		seta[].shade -80
		seta[].htflags 4
		ifpdistl 6144
		{
			ifn proxsound -1 ife sprite[proxsound].statnum 1024 set proxsound -1
			ife proxsound -1
			{
				ifactorsound THISACTOR ALARM2 nullop else 
				{
					sound ALARM2
					set proxsound THISACTOR
				}
			}
			else
			{
				dist xydist THISACTOR player[].i
				dist xydist2 proxsound player[].i
				sub xydist2 xydist
				ifg xydist2 512
				{
					stopactorsound proxsound ALARM2
					ifactorsound THISACTOR ALARM2 nullop else sound ALARM2
					set proxsound THISACTOR
				}
			}
			
		}
		ifpdistl 10240
			soundonce ALARM2
	}
	else
	{
		geta[].htflags temp
		orvar temp 128
		seta[].htflags temp
	}
break

case RAT
	ife initsprite 0
	{
		set initsprite 1
		seta[].mdflags 16
		rand x 2
		add x 18
		seta[].xrepeat x
		seta[].yrepeat x
		seta[].htflags 128
	}
break

case BLOODPOOL
	
	ifspritepal 0
	{
		ife sprite[].htpicnum BLOODPOOL spritepal 3 else
		spritepal 6
	}
		
	ifn mtype 0
	ifg sprite[].xrepeat 4
	{
		add countvar 1
		set temp countvar
		div temp 2, ifg temp 255 set temp 255
		seta[].alpha temp
		ifl countvar 300
		{
			sizeto 96 96
			sizeto 96 96
			
			ife mtype 2 ifrnd 2
			{
				ifrnd 128 espawn BURNING else espawn BURNING2
				rand x 844 sub x 422
				add x sprite[].x
				seta[RETURN].x x
				rand x 844 sub x 422
				add x sprite[].y
				seta[RETURN].y x
			}
			ife mtype 6
			{
				ifrnd 16
				{
					espawn BIGSMOKE
					seta[RETURN].pal 8
					seta[RETURN].htpicnum SMOKER
				}
				ifpdistl 1280
				ifvarand player[].player_par 1
				{
				  ifg player[].boot_amount 0
				  {
					  getp[].boot_amount temp
					  sub temp 1
					  setp[].boot_amount temp
					  // setp[].inven_icon 7
					  ife player[].fta 0 quote 75
				  }
				  else
				  {
					  getp[].i spriteid
					  getav[spriteid].bleeding temp
					  ifl temp 50 add temp 1
					  setav[spriteid].bleeding temp
					  palfrom 40 0 30
				  }
				}
			}
		}
	}
	else ifspritepal 6
	{
		add countvar 1
		ifge countvar 900
		{
			set temp player[].player_par
			modvar temp 5
			ife temp 0
			{
				sizeto 1 1
				ifle sprite[].xrepeat 4 { set initsprite 1 cstat 32768 }
			}
		}
		
		ife initsprite 0
		{
			ifpdistl 448
			{	
				set initsprite 1
				ifg player[].boot_amount 0
				{
				  getp[].boot_amount temp
				  sub temp 4, ifl temp 0 set temp 0
				  setp[].boot_amount temp
				  ife player[].fta 0 quote 75
				}
				else
				{	
					getav[player[].i].bleeding bleeding
					ife bleeding 0 
					{
						quote 1497
						sub bleeding 20
						setav[player[].i].bleeding bleeding
					}
				}
			}
			ifrnd 12
			{
				espawn BIGSMOKE
				seta[RETURN].pal 8
				seta[RETURN].htpicnum SMOKER
			}
		}
	
	}
break

case NUKEBUTTON
	ifn sprite[].lotag 0
	{
		ifpdistl 2048
		ifp pfacing
		ifcansee
		ifp palive
		ife player[].fist_incs 0
			set secretsfound 10
	}
break

case SLOTDOOR
case LIGHTSWITCH
case SPACEDOORSWITCH
case SPACELIGHTSWITCH
case FRANKENSTINESWITCH
case DIPSWITCH
case DIPSWITCH2
case DIPSWITCH3
case TECHSWITCH
case ALIENSWITCH
case POWERSWITCH1
case POWERSWITCH2
case LOCKSWITCH1
case LIGHTSWITCH2
case HANDSWITCH
case PULLSWITCH
	// ifand sprite[].cstat 64
	// {
		// ifand sprite[].cstat 32 nullop else
		// {
			// ife initsprite 0 geta[].cstat initsprite
			// ifangdiffl 480
				// cstator 32768
			// else
			// ifand sprite[].cstat 32768
				// seta[].cstat initsprite	
		// }
	// }
	
	ife mtype 0
	{
		geta[].picnum initsprite
		geta[].lotag SPRITELOTAG
		spriteflags 64
		ife sprite[].pal 0 set mtype 1
		else set mtype -1
	}
	
	ife initflags 29 // coop only
	{
		// switchmode 0 == characters swap positions, 1 == player stays in same plays
		ifn myshelly -1
		ife switchmode 0
		{
			seta[].cstat ikicked
			seta[].lotag droptile
		}
		else
		{
			cstator 32768
			seta[].lotag 0
		}
	
	}
	else
	ife initflags 30 // solo only
	{
		ifn myshelly -1
		ife switchmode 0
		{
			cstator 32768
			seta[].lotag 0
		}
		else
		{
			seta[].cstat ikicked
			seta[].lotag droptile
		}
	}
	
	ifg countvar 0
	{
		sub countvar 1
		ife countvar 0
		{
			geta[].cstat temp
			orvar temp 256
			seta[].cstat temp
		}
	}
	
	ifn SPRITELOTAG 0
	ifn sprite[].picnum initsprite
	{
		geta[].picnum initsprite
		state AActivation
		state se17activation
		ifvarand sprite[].cstat 256
		ifg scandist 1561
		{
			geta[].cstat temp
			xorvar temp 256
			seta[].cstat temp
			set countvar 4
		}
	}
	
	ife mtype 1
	{
		ifvare player[THISACTOR].heat_on YES
		{
			ifvare sprite[THISACTOR].hitag 1
				setactor[THISACTOR].pal 6
			else setactor[THISACTOR].pal 0
		}
		else
		ife aimbot_on YES
		{
			ifvare sprite[THISACTOR].hitag 1
				setactor[THISACTOR].pal 6
			else setactor[THISACTOR].pal 0
		}
		else setactor[THISACTOR].pal 0
	}
	
break

case 133
case 135
case 137
case 139
case 141
case 163
case 165
case 167
case 169
case 713
case 861
case 863
case 865
case 1112
case 1123
case 1143
	// ifand sprite[].cstat 64
	// {
		// ifand sprite[].cstat 32 nullop else
		// {
			// ife initsprite 0 geta[].cstat initsprite
			// ifangdiffl 564
				// cstator 32768
			// else
			// ifand sprite[].cstat 32768
				// seta[].cstat initsprite
		// }
	// }
	ife mtype 0
	{
		geta[].picnum initsprite
		geta[].lotag SPRITELOTAG
		spriteflags 64
		ife sprite[].pal 0 set mtype 1
		else set mtype -1
	}
	
	ife initflags 29 // coop only
	{
		// switchmode 0 == characters swap positions, 1 == player stays in same plays
		ifn myshelly -1
		ife switchmode 0
		{
			seta[].cstat ikicked
			seta[].lotag droptile
		}
		else
		{
			cstator 32768
			seta[].lotag 0
		}
	
	}
	else
	ife initflags 30 // solo only
	{
		ifn myshelly -1
		ife switchmode 0
		{
			cstator 32768
			seta[].lotag 0
		}
		else
		{
			seta[].cstat ikicked
			seta[].lotag droptile
		}
	}
	
	ifg countvar 0
	{
		sub countvar 1
		ife countvar 0
		{
			geta[].cstat temp
			orvar temp 256
			seta[].cstat temp
		}
	}
	
	ifn SPRITELOTAG 0
	ifn sprite[].picnum initsprite
	{
		geta[].picnum initsprite
		state AActivation
		state se17activation
		ifvarand sprite[].cstat 256
		ifg scandist 1561
		{
			geta[].cstat temp
			xorvar temp 256
			seta[].cstat temp
			set countvar 4
		}
	}
	
	ife mtype 1
	{
		ifvare player[THISACTOR].heat_on YES
		{
			ifvare sprite[THISACTOR].hitag 0 setactor[THISACTOR].pal 6
			else setactor[THISACTOR].pal 0
		}
		else setactor[THISACTOR].pal 0
	}
break

case CANWITHSOMETHING case CANWITHSOMETHING2
case CANWITHSOMETHING3 case CANWITHSOMETHING4
case NUKEBARREL case NUKEBARRELDENTED case NUKEBARRELLEAKED
case EXPLODINGBARREL case FIREBARREL case FIREVASE
case RUBBERCAN case GUNPOWDERBARREL
case TRIPODCAMERA case FLOORBASKET case HATRACK
case EGG case OSCAR
case VACUUM case CAMERALIGHT case IVUNIT case COFFEEMACHINE
case POT1 case POT2 case SCALE case MOVIECAMERA case CHAIR3
case GUMBALLMACHINE case WETFLOOR case BROOM case MOP
case BOWLINGPIN case JOLLYMEAL case SODA2LITER case 14858 case 14895
case 4443 // flag
case 7463 case 7453 case 7455 case 7451 case 14901 case RECYCLEBIN
case CHAIR1_AA case 16153 case 16154 case CHAIR4 case CHAIR5 case CHAIR6
case BLOWUPDOLL case 10223 case GAMERCHAIR case 16088 case PLANTER case PLANTER2
case BOTTLE7 
	ifn sprite[].pal 3
	state checkheldobject
break

case OOZFILTER case SEENINE
ife sprite[].lotag 0 ife sprite[].hitag 0
	state checkheldobject
break

case THROWNOBJECT break

case MOVECAM
case BLUEFLAGATBASE
case BLUEBASENOFLAG
case BLUEFLAG
case REDFLAGATBASE
case REDBASENOFLAG
case REDFLAG
case TEAMSPAWNER
case HIGHSOUND
case EMPERORSCREEN
case CONTROL_A case CONTROL_B case CONTROL_C
case SPEEDBLUR
case SECTORLIGHT
case SECTORPANNING
case WALLPANNING
case NPCNAV
case JUMPAD
case ANIMOPEN1
case ANIMOPEN2
case ANIMOPEN3
case UPDRAFT_SPAWNER
case LIGHTNING2
case BLACKHAWK
case COFFIN
case NAAMAH
case LILY
case NUKEENDING
case LEVELENDER
case STARFLY
case GRAVESNPC
case PORTALMANAGER
case SPEECHBRACCUS
case UFOFLOAT
case RAINSPRITE
	seta[].httimetosleep 0
	ifn sprite[].statnum 1 changespritestat THISACTOR 1
break


case BOSS1STATUE case BOSS2STATUE case BOSS3STATUE
	seta[].httimetosleep 0
	ife initsprite 5 ifn sprite[].statnum 1 changespritestat THISACTOR 1
break

case MUSICSECTOR

	ife player[].cursectnum sprite[].sectnum
	ife endlevel 0
	ife musicwait 0
	{
		getuserdef[].music_episode temp
		getuserdef[].music_level tempb
		ife temp mtype ife tempb SPRITELOTAG nullop else
		{
			starttrackslot mtype SPRITELOTAG
			setuserdef[].music_episode mtype
			setuserdef[].music_level tempb
		}
	}

break

case CUTSCENE_CAM


	// SPRITELOTAG == channel
	// myspawner == target sprite
	// initflags == length of scene in tics
	// mtype == sound to play
	// cutcam -1 0
	// cutcamtarget -1 0
	// cutcamtime 0 0
	// cutcamsound 0 0
	// cutcamchannel 0 0
	// pal 121 camera is the view point

	ife cutcamtime 0 // no cutscene is playing
	ife player[].cursectnum sprite[].sectnum
	ifl droptile 122
	{
		set cutcamchannel SPRITELOTAG
		set cutcamtime 30 // placeholder until pal 121 camera takes over
	}
	ife cutcamchannel SPRITELOTAG
	{
		ifge droptile 121
		{
			ife cutcam -1 
			{
				set cutcam THISACTOR
				set cutcamtarget myspawner
				ife cutcamsound 0 ifg mtype 0 globalsoundvar mtype
				set cutcamtime initflags
			}
			sub cutcamtime 1
		}
		
		ife cutcamtime 0 
		{
			ife cutcam THISACTOR { set cutcam -1 set cutcamtarget -1 }
			killit
		}
	}
	
break

case BOMBSECTOR

ife initsprite 1
{
	ifp pjetpack
	{
		set countvar 0
		sets[].floorpal droptile
	}
	else
	ife player[].cursectnum sprite[].sectnum
	ifp palive
	{
		add countvar 1
		ife countvar 60
		{
			sound WARNBEEP
			sets[].floorpal 2
		}
		ife countvar 64 sets[].floorpal droptile
		ife countvar 90
		{
			sound WARNBEEP
			sets[].floorpal 2
		}
		ife countvar 94 sets[].floorpal droptile
		ife countvar 116
		{
			sound WARNBEEP
			sets[].floorpal 2
		}
		ife countvar 120 sets[].floorpal droptile
		ife countvar 138
		{
			sound WARNBEEP
			sets[].floorpal 2
		}
		ife countvar 142 sets[].floorpal droptile
		ife countvar 156
		{
			sound WARNBEEP
			sets[].floorpal 2
		}
		ife countvar 160 sets[].floorpal droptile
		ife countvar 170
		{
			sound WARNBEEP
			sets[].floorpal 2
		}
		ife countvar 174 sets[].floorpal droptile
		ife countvar 180
		{
			set countvar 0
			spawn EXPLOSION2
			flash
			globalsound ROBOT_EXPLODE
			hitradius 4096 150 150 150 150
			debris SCRAP1 10
			debris SCRAP2 10
			palfrom 52 48 12 12
		}
	}
	else 
	{
		set countvar 0
		sets[].floorpal droptile
	}
	
}

break

case LEVELPLATE

	seta[].z float
	ife monstatus 0
	ife player[].cursectnum sprite[].sectnum
	{
		ifg initsprite 20 // time after elevator activation based level plate
		{
			ifn sector[].floorz float
			{
				sub initsprite 1
				ife initsprite 20
				{
					set checkpoints NO
					savemapstate
					startlevel initflags SPRITELOTAG
					setuserdef[].display_bonus_screen NO
				}
			}
			
		}
		else
		ife initsprite 10 // distance based level plate
		{
			findplayer xydist
			ifl xydist 6144
			{
				set checkpoints NO
				ife mtype 2 set monstflags 2 // one use only
				savemapstate
				startlevel initflags SPRITELOTAG
				setuserdef[].display_bonus_screen NO
			}
		}
		else
		{
			set checkpoints NO
			
			// setarray loadx[LEVEL] player[].posx
			// setarray loady[LEVEL] player[].posy
			// setarray loadz[LEVEL] player[].posz
			ife mtype 2 set monstatus 2
			setarray keycards[LEVEL] player[].got_access
			setarray secretrooms[LEVEL] player[].secret_rooms
			setarray playerpar[LEVEL] player[].player_par
			setarray actorskilled[LEVEL] killcount //  player[].actors_killed
			setarray savelevel[LEVEL] YES
			savemapstate
			ife mtype 2
			{
				// mtype 2 means pal 2
				// this setting is used only for a fake secret exit
				set monstatus 2 // one use only
				setuserdef[].level_number SPRITELOTAG
				setplayer[].timebeforeexit 4
				setuserdef[].display_bonus_screen NO
				// hack to get rid of companion since they will be resawned upon return
				ifn myshelly -1
				ife VOLUME 4
				{
					ife LEVEL 22 { seta[myshelly].picnum SMALLSMOKE set myshelly -1 } else
					ife LEVEL 24 { seta[myshelly].picnum SMALLSMOKE set myshelly -1 }
				}
			}
			else
			ife mtype 6
			{
				set secretexit YES
				set temp SPRITELOTAG sub temp 1
				setuserdef[].level_number temp
				setplayer[].timebeforeexit 4
				setuserdef[].display_bonus_screen YES
			}
			else
			{
				startlevel initflags SPRITELOTAG
				ifg initsprite 0 setuserdef[].display_bonus_screen YES
			}
		}
	}

break

case LEVELPLATE2

	ifn mtype 4 // not pal 4
	ife player[].cursectnum sprite[].sectnum
	{
		// reset ship cams array
		set temp 0
		whilevarn temp 100
		{
			setarray shipcams[temp] -1
			add temp 1
		}
		set shipcam -1
		
		set LOADMAP 0 // safety clear
		orvar LOADMAP 2 // trigger to search for pal 4 destination LEVELPLATE2
		set LAST_LEVEL LEVEL
		getp[].ang SAVEDANG
		set SAVEDANGCOUNT 7
		setuserdef[].display_bonus_screen NO
		setuserdef[].show_level_text NO
		ife initsprite YES
		{
			orvar LOADMAP 1
			savemapstate
		}

		startlevel initflags SPRITELOTAG
			
	}
	// pal 4 is destination only
	// lotag SPRITELOTAG = destination LEVEL; hitag initflags = volume
	// extra initsprite
	// if initsprite = 1, then save current level but not destination, 
	// otherwise load on destination but don't save current

break

case MATCHSTART

// SPRITELOTAG is the level it transports to
// initflags is the wave number the player must reach in order to be eligible
// checks to see if player is eligible for the level transport
// if so, and the player is in sector and close enough
// stops player with pop up asking if player is ready to start next match
// player can say yes, in which case it immediately starts that level, 
// or no, in which case it will not ask again unless player leaves sector and reeenters

ife mtype 1 // pal 1 at the elevator shaft
{
	ife player[].cursectnum sprite[].sectnum
	{
		findplayer xydist 
		switch wave
		case 3 ifl xydist 1560 set matchmenu 12164 else ife matchmenu 12164 set matchmenu NO break
		case 4 case 5
			ifl xydist 1560 set matchmenu 12165 else ife matchmenu 12165 set matchmenu NO break
		
		endswitch
	}
}
else
ife mtype 2 // pal 2 at the blue transporter
{
	ife player[].cursectnum sprite[].sectnum
	{
		findplayer xydist 
		switch wave
		case 10
		    ifl xydist 1560 set matchmenu 12163 else ife matchmenu 12163 set matchmenu NO break
		endswitch
	}
	else ife matchmenu 12163 set matchmenu NO
}
else
ife mtype 6
ife VOLUME 4
{
	ife player[].cursectnum sprite[].sectnum
	{
		ife menuoff NO
		ife matchmenu NO
		{
			switch LEVEL
			case 13 set matchmenu 14 set matchlevel 14 break
			case 15 set matchmenu 16 set matchlevel 16 break
			case 17 set matchmenu 18 set matchlevel 18 break
			case 19 set matchmenu 20 set matchlevel 20 break
			case 21 set matchmenu 22 set matchlevel 22 break
			case 23 set matchmenu 24 set matchlevel 24 break
			case 25 set matchmenu 26 set matchlevel 26 break
			case 27 set matchmenu 28 set matchlevel 28 break
			case 29 set matchmenu 30 set matchlevel 30 break
			endswitch
		}
	}
	else 
	{
		ifvarand player[].gm 8 nullop else
		set hublevel YES
		ifn matchmenu NO
		{
			set matchmenu NO
			setp[].movement_lock 0
		}
	}
		
}
else
ife wave initflags
{
	findplayer xydist 
	ifl xydist 1560
	{
		ife player[].cursectnum sprite[].sectnum
		{
			// this next bit is a hack to prevent the player from entering certain matches
			// without having completed the ancients fights first
			// eventually this whole system should be redone with fewer sprites and no hacks
			
			ife SPRITELOTAG 17 ife vrdone 0 set matchmenu 12184 else
			ife SPRITELOTAG 20 ifl vrdone 2 set matchmenu 12184 else
			ife SPRITELOTAG 21 ife ancients 0 set matchmenu 12162 else
			ife SPRITELOTAG 23 ifl vrdone 3 set matchmenu 12184 else
			ife SPRITELOTAG 25 ifl ancients 4 set matchmenu 12162 else
			ife SPRITELOTAG 26 ifl ancients 7 set matchmenu 12162 else
			{
				set matchlevel SPRITELOTAG
				ife menuoff NO
				ife matchmenu NO
				{
					set matchmenu YES
					state autosave
				}
			}
		}
	}
	else ife matchmenu 12162 // more hacking
	{ 
		ife SPRITELOTAG 21 set matchmenu NO
		ife SPRITELOTAG 25 set matchmenu NO
		ife SPRITELOTAG 26 set matchmenu NO
	}
	else ife matchmenu 12184
	{ 
		ife SPRITELOTAG 17 set matchmenu NO
		ife SPRITELOTAG 20 set matchmenu NO
		ife SPRITELOTAG 23 set matchmenu NO
	}
	
}

break

case VRSET

ifn SPRITELOTAG 0
{
	ifg initsprite 0 ifge ancients initsprite killit
	
	findplayer xydist 
	ife vrkilled SPRITELOTAG
	{
		ifg xydist 1024 ifn sprite[].sectnum player[].cursectnum
			set vrkilled 0
		else set xydist 99999
	}
	ifl xydist 1560
	{
		ife countvar 0
		{
			set temp NO
			ife player[].cursectnum sprite[].sectnum set temp YES
			ifl xydist 1024
			{
				set temp YES
				set osector -1
			}
			ife temp YES
			{
				ife menuoff NO
				ife matchmenu NO
				{
					set temp YES
					ifg initsprite 0 
					{
						// ancients must be exactly one less than initsprite
						set tempb ancients
						add tempb 1
						ifn tempb initsprite set temp NO
					}
					ife temp YES
					{
						set matchmenu SPRITELOTAG
						set matchlevel SPRITELOTAG
						ifg initsprite 0 { mul matchmenu -1 set ancients_transport 3 }
						savenn 9
					}
				}
			}
		}
	}
	else ifn countvar 0 set countvar 0
	
}

break

case SOUNDPLATE

	ife mtype 0
	{
		ife player[].cursectnum sprite[].sectnum
		ifn startmode -1
		{
			screensound SPRITELOTAG
			
			switch SPRITELOTAG
			case HEELTURN
			case ONLINEPOLL
			case DONTGO
			case ITSFINE
			case FUNNIEST
				ife initsprite -1
				{
					quote 1611
					set initflags 900
				}
				stopallsounds
				set emp_overlay_tile 12266
				set cutcamtime player[].player_par	
				set emp_overlay initsprite
				ifg SPRITELOTAG 1890
				{
					set musicwait initsprite
					stopallmusic
				}
				set soundstopper initsprite
			break
			
			case BRACCUS_SECURITY1 case BRACCUS_SECURITY2
			case BRACCUS_THEMEPARK
				ife initsprite -1
				{
					quote 1611
					set initsprite 900
				}
				stopallsounds
				set emp_overlay_tile 12270
				set cutcamtime player[].player_par	
				set emp_overlay initsprite
				ifg SPRITELOTAG 1890
				{
					set musicwait initsprite
					stopallmusic
				}
				set soundstopper initsprite
			break
	
			case GRAVES_HIGHRISE
			case GRAVES_STADIUM
			case GRAVES_VIOLET
			case GRAVES_ROSARIO
				ife initsprite -1
				{
					quote 1611
					set initsprite 900
				}
				stopallsounds
				set emp_overlay_tile GRAVESHUD
				set cutcamtime player[].player_par	
				set musicwait initsprite
				stopallmusic
				set emp_overlay initsprite
				set soundstopper initsprite
			break
			
			case PROT_INTRUDER1
			case PROT_INTRUDER2
				screensound SPRITELOTAG	screensound SPRITELOTAG	screensound SPRITELOTAG
				set cutcamtime player[].player_par	
				set emp_overlay_tile PROTONHUD
				set emp_overlay initsprite
			break
			
			case PROT_BIGSPEECH
				screensound SPRITELOTAG	screensound SPRITELOTAG	screensound SPRITELOTAG
				ifg player[].jetpack_amount 0
				{
					setp[].jetpack_amount 0
					setp[].jetpack_on NO
				}
				stopallsounds
				set emp_overlay_tile PROTONHUD
				set cutcamtime player[].player_par	
				set emp_overlay initsprite
				set soundstopper initsprite
				stopallmusic
				set subtitle_start 1642
				set subtitle_time 630
				set subtitle_numlines 5
			break
			endswitch
			
			

			ifn initflags 0
			{
				set musicwait initflags
				set soundstopper initflags
				stopallmusic
			}
			killit
		}
	}
	else // spawned sound maker
	{
		ifn initsprite 0
		{
			soundvar SPRITELOTAG
			setactorsoundpitch THISACTOR SPRITELOTAG initsprite
		}
		else
		screensound SPRITELOTAG
		
		killit
	}

break

case MULTIPLATE

	ife SPRITELOTAG 0 killit
	
	ifn countvar 0
	{
		ifg countvar 0
		sub countvar 1
		else add countvar 1
		ife countvar 0 
		{
			state activatechannel 
			killit 
		}
	}
	else
	ife mtype 2 // waits for channel activation
	{
		ife droptile NO
		{
			checkactivatormotion SPRITELOTAG
			ife RETURN YES set droptile YES
		}
		ife droptile YES
		{
			set SPRITELOTAG initsprite
			ife initflags 0 // no delay
			{
				state activatechannel 
				killit
			}
			else ife countvar 0 
			{
				set countvar initflags
				ife countvar 9999 // change to sector activation instead
				{
					set mtype 0
					set initflags 0
					set countvar 0
				}
			}
		}
	}
	else
	ife player[].cursectnum sprite[].sectnum
	{
		ife initflags 0 // no delay
		{
			state activatechannel 
			killit
		}
		else ife countvar 0 set countvar initflags
	}

break

case GLOBALKILLER

	headspritestat spriteid 1
	whilevarn spriteid -1
	{
		ifg sprite[spriteid].z sprite[].z
		{
			seta[spriteid].htextra 100
			seta[spriteid].htpicnum RPG
			seta[spriteid].htowner THISACTOR
			ife sprite[spriteid].picnum BLUEFLAG
			{
				set bluecarrier -1
				setav[spriteid].monstatus 2
				getav[spriteid].myspawner temp
				setav[temp].mtype 1
			}
			ife sprite[spriteid].picnum REDFLAG
			{
				set redcarrier -1
				setav[spriteid].monstatus 2
				getav[spriteid].myspawner temp
				setav[temp].mtype 1
			}
		}
		nextspritestat spriteid spriteid
	}

break

case REACTOR2SPARK
	ifspawnedby APLAYER
	{
		ife initsprite 0
		{	
			sizeat 8 16
			cstat 32
			spritepal 21
			set initsprite 1	
		}
	}
	ife initsprite 1
	{
		add countvar 1
		ifg countvar 4 cstator 2
		ifg countvar 6 cstator 512
		ifg countvar 8 killit
	}

break

case ACCESSSWITCH
case ACCESSSWITCH2
case REACTOR2
ife float 32768 
{
	ife sprite[myspawner].statnum 1024 killit else
	ifn sprite[myspawner].picnum sprite[].picnum killit else
	ife userdef[].overhead_on 2 
	{
		cstat 32
		geta[myspawner].ang angvar
		add angvar 1024
		seta[].ang angvar
	}
	else cstat 32768
}
break

case CRACK1
case CRACK2
case CRACK3
case CRACK4
	ife float 32768 
	{
		ife sprite[myspawner].statnum 1024 killit else
		ifn sprite[myspawner].picnum sprite[].picnum killit else
		ife userdef[].overhead_on 2 
		{
			cstat 32
			geta[myspawner].ang angvar
			add angvar 1024
			seta[].ang angvar
		}
		else cstat 32768
	}
	ife monstatus 2 killit
	
break

case ACCESSCARD 
	ife float 32768 
	{
		ife sprite[myspawner].statnum 1024 killit else
		ifn sprite[myspawner].picnum sprite[].picnum killit else
		ife userdef[].overhead_on 2 
		{
			cstat 32
			geta[myspawner].ang angvar
			add angvar 1024
			seta[].ang angvar
		}
		else cstat 32768
	}
	else
	{
		set monstatus 100 strength 1
		ife radaron YES
		{
		geta[].sectnum mysector
		ifn sector[mysector].lotag 32767
		ifn sprite[].statnum 1
		changespritestat THISACTOR 1
		}
	}
break

case BREADCRUMB
	cstat 32768
	add countvar 1
	ifg countvar 1800 
	{
		changespritestat THISACTOR 1
		killit
	}
	ifl player[].player_par mtype
	{
		changespritestat THISACTOR 1
		killit
	}
break


case TEAM_TARGET
	cstat 32768
	// ife sprite[mysignpost].statnum 1024 
	// {
		// setav[mysignpost].mysignpost -1
		// killit
	// }
	// ife actorvar[mysignpost].monstatus 2 
	// {
		// setav[mysignpost].mysignpost -1
		// killit
	// }
	// getav[mysignpost].team team
	// geta[mysignpost].z z
	// sub z 8192
	// setsprite THISACTOR sprite[mysignpost].x sprite[mysignpost].y z
	// getav[mysignpost].monstatus monstatus
break

case BULLETHOLE
ife mtype 1024 cstat 32768
break

case SABERSCORCH

	ife initsprite 0
	{
		ifn saberpos 10 ifn saberpos 26 ifn saberpos 42
		ifn saberpos 54 ifn saberpos 67 ifn saberpos 78 killit 
		else
		{
			ife saberpos 10 cstat 16 else
			
			ife saberpos 26 cstat 20 else
			
			ife saberpos 42 
			{
				ife pchar 4 cactor SABERSCORCH3 else
				cactor SABERSCORCH2 
			}
			else
			ife saberpos 54 
			{
				ife pchar 4 cactor SABERSCORCH2 else
				cstat 20 
			}
			else
			ife saberpos 67 
			{
				ife pchar 4 cactor SABERSCORCH2 else
				cstat 16
			}
			else
			ife saberpos 78
				cactor SABERSCORCH3
			
			cstator 192 // half-submerged plus one-sided
			set initsprite YES
			geta[].htflags temp
			orvar temp 128
			seta[].htflags temp
			
			ife pchar 2
			{
				headspritestat spriteid 0
				set B 0
				whilevarn spriteid -1
				{
					ife sprite[spriteid].picnum 19897
					ifactor SABERSCORCH
					{
						ife sprite[].cstat sprite[spriteid].cstat
						{
							dist temp THISACTOR spriteid
							ifl temp 128 set B 1
						}
					}
					else
					ife sprite[spriteid].picnum 19898
					ifactor SABERSCORCH2
					{
						dist temp THISACTOR spriteid
						ifl temp 128 set B 1
					}
					nextspritestat spriteid spriteid
				}
				ife B 1 killit else
				ifactor SABERSCORCH cactor 19897 else
				ifactor SABERSCORCH2 cactor 19898
			}
		}
	}
break


case APLAYER

	ife sprite[].statnum STATUESTAT changespritestat THISACTOR 10
	// ife pchar 1
	ifn player[].newowner -1
	{
		ife shellydummy -1
		{
			espawn SHELLYDUMMY
			set angvar sprite[player[].i].ang
			// add angvar 512
			setav[RETURN].angvel angvar
			seta[RETURN].mdflags 16
			set shellydummy RETURN
		}
	}
	else set shellydummy -1
	
	ife THISACTOR player[].holoduke_on
	{
		ife pchar 4
		{
			seta[].mdflags 16
			ife initsprite 0
			{
				globalsound HOLOBRAC1
				set initsprite 1
				espawn FAKEBRACCUS
			} else
			ife initsprite 1
			{
				ifsound HOLOBRAC1 nullop else
				{
					set initsprite 2
					globalsound HOLOBRAC2
				}
			} else
			ife initsprite 2
			{
				ifsound HOLOBRAC2 nullop else
				{
					set initsprite 1
					globalsound HOLOBRAC1
				}
			}
		}
		else
		ife pchar 2
		{
			espawn NAAMAH
			set mynaamah RETURN
			setp[].holoduke_on -1
			killit
		}
		else
		{
			set team 1
			cstator 2
			ifl pchar 3
			ifrnd 1 state holotaunts
			// initflags ==0 normal; 1==teleporting; 2-20=teabagging even numbers stand odd crouch
			
			ife pchar 3
			ifn mylily -1
			{
				seta[].mdflags 16
				setsprite THISACTOR sprite[mylily].x sprite[mylily].y sprite[mylily].z
			}
			else
			ifvarand inven_upgrades 4
			{
				ife initflags 0
				ifn bottarget -1
				ife actorvar[bottarget].monstatus 2
				{
					set initflags 1
					set startx sprite[bottarget].x
					set starty sprite[bottarget].y
					set float sprite[bottarget].z
					cstat 32768
					spawn TRANSPORTERSTAR
					sound TELEPORTER
					set countvarb 0
				}
				
				ife initflags 1
				{
					add countvarb 1
					ifge countvarb 10
					{
						
						setsprite THISACTOR startx starty float
						
						set bottarget -1
						spawn TRANSPORTERSTAR
						sound TELEPORTER
						set initflags 2
						set countvarb 0
						
						cstat 32768
						espawn HOLOBAGGER
						set myspawner RETURN
						seta[RETURN].xrepeat sprite[].xrepeat
						seta[RETURN].yrepeat sprite[].yrepeat
						seta[RETURN].ang sprite[].ang
						setav[RETURN].mtype THISACTOR
					}
				}
				
				ifge initflags 2 ifle initflags 20
				{
					cstat 32768
					fall
					add countvarb 1
					ifge countvarb 5 
					{ 
						add initflags 1 set countvarb 0
						ife initflags 21 setav[myspawner].mtype -1
					}
				}
				
				ife initflags 21
				{
					cstat 2
					set initflags 0
					set countvarb 0
					set countvar 0
				}
				
				ife initflags 0
				{
					cstator 2
					state targetsearch
					ifn bottarget -1
					{
						set spriteid bottarget
						state facesprite
						add countvar 1
						ifge countvar 3
						{
							cactor EDFSNIPER
							set countvar 0
							sound CHAINGUN_FIRE
							state hitscan_targetprep
							zshoot zdist CHAINGUN
							cactor APLAYER
							spawn AIRFLASH1
							getp[].holoduke_amount temp
							sub temp 3
							ifl temp 1 set temp 1
							setp[].holoduke_amount temp
						}
					}
				}
			}
		}
	}

break

case HEAVYHBOMB

ifg sprite[].xvel 32
{
	state projectilehitscan
	seta[].mdflags 16
	add countvar 1
	ifg countvar 3 set countvar -2
}

ife PIPEBOMB_CONTROL 2
{
	ife initsprite THERMAL
	{
		ife botclip 0
		{
			seta[].htg_t 7 GRENADE_LIFETIME
			ife burstfired THERMAL { seta[].htg_t 7 42 set burstfired NO }
			set botclip YES
		}
		ife sprite[].htg_t 7 40 { sound THERMALWARN sound THERMALWARN }
		

		ifvarand mandoupgrades[HANDBOMB_WEAPON] 1 // sticky
		ifl sprite[].htg_t 7 60
		{
			ifn myvictim -1
			{
				ifn sprite[myvictim].statnum 1 set myvictim -1 else
				ifn actorvar[myvictim].monstatus 1 set myvictim -1 else
				ife bottarget -1 // sticky check
				{
					set spriteid myvictim
					state facesprite
					dist xydist THISACTOR spriteid
					ifl xydist 844
					{
						sound MAGLOCK
						set bottarget myvictim
						
						ldist mtype THISACTOR spriteid
						ifg mtype 512 set mtype 512
						getactor[bottarget].z shotpitch
						subvarvar shotpitch sprite[].z
						iffloordistl 16 add shotpitch 3072
						
						getactor[].x x2
						getactor[].y y2
						getactor[bottarget].x x
						getactor[bottarget].y y
						subvarvar x2 x
						subvarvar y2 y
						getangle tempc x2 y2 // angle to make monster face detonator
						getincangle angvel tempc sprite[bottarget].ang
					}
				}
				ifn bottarget -1 // hold position
				{
					seta[].xvel 0
					seta[].zvel -256
					getactor[bottarget].x x
					getactor[bottarget].y y
					getactor[bottarget].ang angvar
					subvarvar angvar angvel
					setvarvar x2 x
					addvarvar x2 mtype
					rotatepoint x y x2 y angvar x y
					setactor[].x x
					setactor[].y y

					setactor[].ang angvar
					getactor[bottarget].z z
					subvarvar z shotpitch
					setactor[].z z
				}
			}
			else
			{
				headspritestat spriteid 1
				whilevarn spriteid -1
				{
					ife actorvar[spriteid].monstatus 1
					ife actorvar[spriteid].team 0
					{
						geta[spriteid].x x2
						geta[spriteid].y y2
						sub x2 sprite[].x
						sub y2 sprite[].y
						getangle angvar x2 y2
						getincangle temp angvar sprite[].ang
						abs temp
						ifl temp 512
						{
							dist xydist THISACTOR spriteid
							ifl xydist 1560
							{
								set myvictim spriteid
								seta[].ang angvar
							}
						}
						
					}
					nextspritestat spriteid spriteid
				}
			}
		}
	}
	else
	ifn sprite[].htmovflag 0 
	{
		geta[].htmovflag temp
		addvar temp 16384
		ifvarl temp 16384 ifvarg temp -1 
		{ 
			ife sprite[temp].statnum 1
			{
			seta[].htextra 10, seta[].htpicnum RPG seta[].htowner player[].i 
			}
		}
	}
}
break

case WALLARROW
	ifvare botclip 0
	{
		ifvare droptile APLAYER
		ifvarn bottarget -1
			state validatedecal
		
	}
	ifp pfacing ifpdistl 1280
	{
		ifvarand sprite[].cstat 16
		{
			ifl player[].fta 90 { setp[].ftq 1189 setp[].fta 100 }
			ifhitspace
			{
			add arrows 1
			ifg arrows player[].max_ammo_amount SHOTGUN_WEAPON set arrows player[].max_ammo_amount SHOTGUN_WEAPON
			globalsound DUKE_GET
			palfrom 16 0 32
			ife player[].ftq 1189 setp[].fta 0
			}
		}
		ifhitspace killit
	}
	add countvar 1
	ifge countvar 1800 killit
break

case VERTARROW 
	ifp pfacing ifpdistl 1024
	{
		ife initsprite APLAYER
		{
			ifl player[].fta 90 { setp[].ftq 1189 setp[].fta 100 }
			ifhitspace
			{
			add arrows 1
			ifg arrows player[].max_ammo_amount SHOTGUN_WEAPON set arrows player[].max_ammo_amount SHOTGUN_WEAPON
			globalsound DUKE_GET
			palfrom 16 0 32
			ife player[].ftq 1189 setp[].fta 0
			}
		}
		ifhitspace killit
	}
	add countvar 1
	ifge countvar 1800 killit
break

case STALL
    set temp NO
	ife pchar 1 set temp YES
	ife pchar 4 set temp YES
	ife temp YES
	ife player[].last_pissed_time 0	
	{
		ifangdiffl 512 nullop else
		ifpdistl 1780
		ifcansee
		setp[].last_pissed_time 30
	}
	
	ife droptile 0
	ifangdiffl 512 nullop else
	ifpdistl 1780
	ifcansee 
	ifp pfacing
	{
		set temp NO
		ifhitspace set temp YES
		ife player[].last_pissed_time 5690
			set temp YES
		ife temp YES
		ifsound FLUSH_TOILET
		{
			seta[].mdflags 16
			set droptile 9247
			set countvar 120
		}
	}
	ifg countvar 0
	{
		sub countvar 1
		ife countvar 0 set droptile 0
	}
break

case TRIPBOMB

	ifg sprite[].htg_t 2 0
	ifl cloak 0
	{
		cos mycos sprite[].ang
		sin mysin sprite[].ang
		hitscan sprite[].x sprite[].y sprite[].z sprite[].sectnum mycos mysin 0 hitsector hitwall hitsprite hitx hity hitz CLIPMASK1
		ifn hitsprite -1 ife sprite[hitsprite].picnum APLAYER
		{
			seta[].htg_t 2 0
			stopsound LASERTRIP_ARMING
		}
		
	}
	
	
add countvar 1
ifg countvar 20
{
	ifspawnedby APLAYER
	{
		ifp pfacing
		ifp palive
		ifpdistl 1024
		{
			ifhitspace
			{
			sound SWITCH_ON
			stopsound DUKE_GRUNT
			stopsound B_GRUNT2
			cactor TRIPBOMBSPRITE
			changespritestat THISACTOR 1
			set countvar 0
			cstat 0
			geta[].xrepeat x
			mul x 4
			seta[].xrepeat x
			geta[].yrepeat y
			mul y 4
			seta[].yrepeat y
			}
			else ifl player[].fta 30 quote 125
		}
		else ifg player[].fta 0 ife player[].ftq 125 setp[].fta 0
	}
	else
	{
		ifhitspace
		ifp pfacing
		ifp palive
		ifpdistl 1024
		ifl player[].fta 30 quote 126
	}
}
break

case LASERLINE
ifn myspawner -1
{
	ifn sprite[myspawner].picnum mtype
	{
		changespritestat THISACTOR 1
		killit
	}
}

break

case GREENSLIME
case 2371 case 2372 case 2373 case 2374 case 2375 case 2376 case 2377

	ifvarand monstflags 4096 // radiation aura
	ife monxp 0
	{
		set monxp 100
		espawn RADAURA
		setav[RETURN].myspawner THISACTOR
		// seta[RETURN].pal 22
	}
	set temp NO
	set burning 0
	ifg sidekick 2 set temp YES
	ifn qk_proxy 0 set temp YES
	ifn slidekick 0 set temp YES
	ifn jumpkick 0 set temp YES
	ifn juice_pos 0 set temp YES
	ifvarand extbits 64 set temp YES
	ife player[].somethingonplayer THISACTOR
	ife temp YES
	{
		// setvarvar x2 sprite[].x
		// addvar x2 644
		// rotatepoint sprite[].x sprite[].y x2 sprite[].y player[].ang x y
		// setactor[].x x
		// setactor[].y y
			
		spritepal 6
		guts JIBS3 4
		// sound SLIM_DYING
		seta[].htg_t 0 0
		seta[].htextra 10
		setp[].somethingonplayer -1
		
	}
break

case WALLBLOOD1
ifn mtype 0
{
	fall
	ife mtype 1 { changespritestat THISACTOR 1 insertspriteq set mtype 2 }
	sizeto 32 32
}
break

case WATERDRIP

ife initsprite 0
{
	state checkfloordist
	ifl temp 1024 // 3072
	{
		espawn WATERDRIPSPLASH
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		seta[RETURN].pal sprite[].pal
		changespritestat RETURN 1
	}
}

break

case JIBS1
case JIBS2
case JIBS3
case JIBS4
case JIBS5
	state randomturn

	ife mtype YES
	{
		set initsprite 15
		spritepal 2
		seta[].mdflags 16
		ifpdistl 844
		{
			getp[].i temp
			getav[temp].burning tempb
			add tempb 5
			setav[temp].burning tempb
			seta[temp].htowner THISACTOR
			seta[temp].htang sprite[].ang
			seta[temp].htpicnum FIRELASER
			killit
		}
	}

	ifvarl initsprite 15
	{
		ife initsprite 0
		{
			ifactor JIBS2 { geta[].xrepeat x mulvar x 2 seta[].xrepeat x seta[].yrepeat x }
		}
		ifvarn sprite[].pal 1
		ife shrunken 0
		{
			espawn JIBS6
			seta[RETURN].zvel 0
			seta[RETURN].xvel 24
			randvar temp 2047
			seta[RETURN].ang temp
			seta[RETURN].xrepeat 12 // 24
			seta[RETURN].yrepeat 12 // 24
			setav[RETURN].init_xrepeat 12
			setav[RETURN].init_yrepeat 12
			seta[RETURN].pal sprite[].pal
		}
		add initsprite 1
	}

	state checkfloordist
	ifvarl temp 2048
	{
		ife mtype YES
		{
			ifrnd 16 { ifrnd 128 spawn BURNING else spawn BURNING2 }
			killit
		}
		else
		{
		seta[].htflags 128
		geta[].picnum picnum
		add picnum 4
		espawnvar picnum
		seta[RETURN].xrepeat sprite[].xrepeat
		seta[RETURN].yrepeat sprite[].yrepeat
		seta[RETURN].pal sprite[].pal
		setav[RETURN].initsprite 1
		}
	}

break

case HEADJIB1
case ARMJIB1
case LEGJIB1
case LIZMANHEAD1
case LIZMANARM1
case LIZMANLEG1

	state randomturn

	ifvarl initsprite 15
	{
		ifvarn sprite[].pal 1
		{
			espawn JIBS6
			seta[RETURN].zvel 0
			seta[RETURN].xvel 24
			randvar temp 2047
			seta[RETURN].ang temp
			seta[RETURN].xrepeat 12 // 24
			seta[RETURN].yrepeat 12 // 24
			seta[RETURN].pal sprite[].pal
		}
		add initsprite 1
	}

	state checkfloordist
	ifvarl temp 2048
		state spawngroundjib
	else ifn sprite[].htmovflag 0 state spawngroundjib
	

break

case RECON

ifn monstatus 2
{
	state recontilt

	ifwasweapon SHRINKSPARK 
	{ 
		ife shrunken 0 set shrunken 1 
		sound ACTOR_SHRINKING 
		seta[].htpicnum SHOTSPARK1
	}
	ifg botclip 0
	{
		geta[].extra temp
		add temp botclip
		seta[].extra temp
		seta[].htextra botclip
		seta[].htowner player[].i
		set botclip 0
	}
	ifg sprite[].extra 0
	state monsterai
	else { set monstatus 2 set burning 0 }
	ifg shrunken 10 ifl shrunken SHRUNKCOUNT
	{
		ifactorsound THISACTOR RECO_ROAM { stopactorsound THISACTOR RECO_ROAM soundonce RECO_ROAMSHR }
		ifactorsound THISACTOR RECO_RECOG { stopactorsound THISACTOR RECO_RECOG sound RECO_RECOGSHR }
		ifactorsound THISACTOR RECO_ATTACK { stopactorsound THISACTOR RECO_ATTACK sound RECO_ATTACKSHR }
		ifactorsound THISACTOR RECO_PAIN { stopactorsound THISACTOR RECO_PAIN sound RECO_PAINSHR }
		ifactorsound THISACTOR RECO_DYING { stopactorsound THISACTOR RECO_DYING sound RECO_DYINGSHR }
	}
}
break

case LIZELITE
case LIZELITECROUCH
// case MANDOFETT
// case MANDOCROUCH
	ife stasis 0
	{
	ifg gametype 0
	ifn sprite[].statnum 1
	ifg burning -1
	changespritestat THISACTOR 1
	else ife THISACTOR myshelly changespritestat THISACTOR 1
	}
break

case MANDOFETT
case MANDOCROUCH
	ife stasis 0
	{
	ifg gametype 0
	ifn sprite[].statnum 1
	ifg burning -1
	changespritestat THISACTOR 1
	else ife THISACTOR myshelly changespritestat THISACTOR 1
	}
break

case PIGSUV
case PATROLSENTRY
case SHELLY
case SHELLYCROUCH
case DUKEBOT
case DUKEBOTCROUCH
case WESBOT
case WESBOTCROUCH
case DEABOT
case DEABOTCROUCH
case NEWRECON
case SMOKER
ife stasis 0
{
ifn sprite[].statnum 1
changespritestat THISACTOR 1
}
break

case SHELL
case SHOTGUNSHELL
ife initsprite 0
{
	ifspawnedby PIGBOSS sizeat 18 18
	ife mtype CLIPFALL { spawn CLIPFALL killit }
	ife mtype CLIPFALL2 { spawn CLIPFALL2 killit }
	ife mtype CLIPFALL3 { spawn CLIPFALL3 killit }
	geta[].sectnum mysector
	ifn mysector -1
	{
		getflorzofslope mysector sprite[].x sprite[].y z
		getactor[].z temp
		sub z temp
		ifvarl z 512
		{
			
			ifinwater nullop else
			{
				ifactor SHELL
				{
					ifrnd 128 sound SHELLFALL1 else sound SHELLFALL2
				}
				ifactor SHOTGUNSHELL
				{
					ifrnd 128 sound SHOTSHELLFALL1 else sound SHOTSHELLFALL2
				}
			}
			// changespritestat THISACTOR 1
			// cstat 32
			ifactor SHELL espawn NEWSHELL
			ifactor SHOTGUNSHELL espawn NEWSHOTGUNSHELL
			seta[RETURN].xrepeat sprite[].xrepeat
			seta[RETURN].yrepeat sprite[].yrepeat
			seta[RETURN].pal sprite[].pal
			seta[RETURN].blend sprite[].blend
			set initsprite 1
			cstat 32768
		}
	}
}
break


case SCRAP6 case 2391 case 2392 case 2393 case 2394 case 2395
case 2396 case 2397 case 2398 case 2399 case SCRAP1 case 2401 
case 2402 case 2403 case SCRAP2 case 2405 case 2406 case 2407


ife init_xrepeat 0
{
	geta[].xrepeat init_xrepeat
	div init_xrepeat 2
	seta[].xrepeat init_xrepeat
	geta[].yrepeat init_yrepeat
	div init_yrepeat 2
	seta[].yrepeat init_yrepeat
	
	ifg Numsprites 15616 ifrnd 128 killit
}

ife mtype 1
ifl Numsprites 15360
{
	espawn SMALLSMOKE
	seta[RETURN].pal 4
	seta[RETURN].cstat 130
}

// ifn sprite[].htpicnum SECTOREFFECTOR
// {
	// ifl framerate 20 killit
	// else
	// ifg framerate 35
	// ifl Numsprites 14000
	// {
		// findnearspritez EXPLOSION2 2048 16384 spriteid
		// ifn spriteid -1
		// {
			// espawn SMALLSMOKE
			// seta[RETURN].pal 4
			// seta[RETURN].cstat 130
		// }
		// else
		// {
			// findnearspritez MINEEXP 2048 16384 spriteid
			// ifn spriteid -1
			// {
				// espawn SMALLSMOKE
				// seta[RETURN].pal 4
				// seta[RETURN].cstat 130
			// }
		// }
	// }
// }

break

case SCRAP3 case SCRAP4 case SCRAP5
case 2409 case 2410 case 2411 case 2413 case 2414 case 2415 case 2417 case 2418

ife init_xrepeat 0
{
	geta[].xrepeat init_xrepeat
	div init_xrepeat 2
	seta[].xrepeat init_xrepeat
	geta[].yrepeat init_yrepeat
	div init_yrepeat 2
	seta[].yrepeat init_yrepeat
	
	ifg Numsprites 15616 ifrnd 128 killit
}
	ifspritepal 28
	{
		espawn SMALLSMOKE
		seta[RETURN].pal 28
		seta[RETURN].alpha 96
	}
break

case BLOCKONLY
	set temp initsprite
	orvar temp 32768
	seta[].cstat temp
	seta[].htflags 128
break


case AATELEPORTER

	// myspawner is matching teleporter
	// countvar will be used for player in sector
	// damflash is pal color if nonzero
	// initsprite is sound # if nonzero
	ifn myspawner -1
	{
		ife countvar 0
		{
			ife player[].cursectnum sprite[].sectnum
			{
				ifn initsprite 0 screensound initsprite
				ifspritepal 1 palfrom 42 0 0 63 else
				ifspritepal 2 palfrom 42 63 0 0 else
				ifspritepal 8 palfrom 42 0 63 0 else
				ifspritepal 7 palfrom 42 63 0 63
				
				setp[].posx sprite[myspawner].x
				setp[].posy sprite[myspawner].y
				set z sprite[myspawner].z, sub z 8192
				setp[].posz z
				add z 8192
				setsprite player[].i sprite[myspawner].x sprite[myspawner].y sprite[myspawner].z
				setp[].cursectnum sprite[myspawner].sectnum
				seta[player[].i].sectnum sprite[myspawner].sectnum
				setp[].ang sprite[myspawner].ang
				seta[player[].i].ang sprite[myspawner].ang
				lockplayer 2
				setav[myspawner].countvar 3
				setav[myspawner].countvarb 3
				setp[].posxv 0
				setp[].posyv 0
			}
		}
		else
		{
			ifn player[].cursectnum sprite[].sectnum sub countvar 1
			else ifg countvarb 0
			{
				sub countvarb 1
				cos kickfvel sprite[].ang
				sin kicksvel sprite[].ang
				
				mul kicksvel 100
				mul kickfvel 100
				
				setp[].posxv kickfvel
				setp[].posyv kicksvel
			}
			
		}
	}

break

case MOVESHIPCAM

	ifn initflags 0
	ife SPRITELOTAG 1
	{
	
		// the starting cam has an activation tag
		checkactivatormotion initflags
		ifvare RETURN YES set initflags 0
	}
	
	ife initflags 0
	ife shipcam -1
	ife SPRITELOTAG 1
	{
		getp[].posx startx
		getp[].posy starty
		getp[].posz droptile
		set shipcam THISACTOR
		set shipangoff countvarc
		changespritestat THISACTOR 1
		
		ife initsprite 0
		{
			ifmove 0
			move SHIPMOVE0 geth
			
		}
		set tempH sprite[].sectnum
		updatesector sprite[].x sprite[].y tempH
		ifg tempH -1 ifl tempH 4096 changespritesect THISACTOR tempH
		set spriteid 0
		whilevarn spriteid 16384
		{
			ife sprite[spriteid].picnum MOVESHIPCAM
			ife actorvar[spriteid].SPRITELOTAG 2
			{
				set bottarget spriteid 
				set spriteid 16383
			}
			add spriteid 1
		}
		geta[].ang mtype
	}
	ife shipcam THISACTOR 
	{
		seta[].htflags 18432
		ife monstatus 2
		{
			getactor[shipcam].z z
			getav[shipcam].droptile z2
			sub z2 player[].posz
			sub z z2
			setp[].posz z
			
			getp[].posx x2
			getp[].posy y2
			getav[shipcam].startx x
			getav[shipcam].starty y
			subvarvar x2 x
			subvarvar y2 y
			getangle angvar x2 y2 // angvar is now the displacement angle
			
			add angvar shipangoff
			
			set xydist x
			sub xydist player[].posx
			mul xydist xydist
			sub y player[].posy
			mul y y
			add xydist y
			sqrt xydist xydist
			set xvel sprite[shipcam].x
			add xvel xydist
			add angvar sprite[shipcam].ang
			rotatepoint sprite[shipcam].x sprite[shipcam].y xvel sprite[shipcam].y angvar x2 y2
			updatesector x2 y2 tempH
			set tempH sprite[shipcam].sectnum
			ife tempH -1 set tempH sprite[shipcam].sectnum
			setp[].posx x2
			setp[].posy y2
			setp[].cursectnum tempH
			getav[shipcam].mtype angvar
			add angvar player[].ang
			ifn shipangstart 999999
			sub angvar shipangstart
			setp[].ang angvar
			set shipcam -2
			//stopsound TRAINLOOP
			
			// ifn bottarget -1 setav[bottarget].monstatus 2
			set monstatus 0
			set transition 0
		}
		ifn monstflags 0
		ifn SPRITELOTAG 1
		{
			ife monstflags 1
			{
				setp[].ang sprite[].ang
				setp[].posx sprite[].x
				setp[].posy sprite[].y
				setp[].posz sprite[].z
				setp[].cursectnum sprite[].sectnum
				set shipcam -2
				stopsound TRAINLOOP
				// stopsound SHIPAIR
				setsprite THISACTOR countvar countvarb float
				move 0
				set transition 0
			}
			else
			{
				set spriteid 0
				whilevarn spriteid 16384
				{
					ife sprite[spriteid].picnum FAKEDOOR
					ife actorvar[spriteid].initsprite monstflags
					{
						seta[spriteid].pal 0
						seta[spriteid].cstat 16
					}
					add spriteid 1
				}
			}
		}
		else
		ife bottarget -1
		{
			set temp SPRITELOTAG
			add temp 1
			ifspritepal 23 set temp 1
			set spriteid 0
			whilevarn spriteid 16384
			{
				ife sprite[spriteid].picnum MOVESHIPCAM
				ife actorvar[spriteid].SPRITELOTAG temp
				{
					set bottarget spriteid 
					set spriteid 16383
				}
				add spriteid 1
			}
		}
		// iffloordistl 160 
		// ifg shipcam -1
		// {
			// ifsound SHIPWATER nullop else 
			// {
				// ife camerasprite -1
				// {
					// ife sector[].lotag 1 screensound SHIPWATER
					// else ifsound SHIPAIR nullop else
					// screensound SHIPAIR
				// }
			// }
		// }
		// else stopsound SHIPWATER
		
		// iffloordistl 128 stopsound SHIPAIR else 
		// ifg shipcam -1 { ifsound SHIPAIR nullop else ife camerasprite -1 screensound SHIPAIR }
					
	}
	else setsprite THISACTOR countvar countvarb float // maintain original coords
	
	ifg initsprite 0
	{
		ifg player[].player_par 2 ifn SPRITELOTAG 1 set initsprite 0
		set RETURN NO
		checkactivatormotion initsprite
		ifvare RETURN YES 
		{
			setvar initsprite 0
			ifmove 0
			{
				move SHIPMOVE0 geth
				set trainspeed 1
				set gamespeed TRAINTIMER
			}
		}
	}
	else ife initsprite -1
	{
		set initsprite 0
		ifmove 0
		{
			move SHIPMOVE0 geth
			set trainspeed 1
			set gamespeed TRAINTIMER
		}
	}
	
	ifn bottarget -1
	ife initsprite 0
	{
		ldist xydist THISACTOR bottarget
		seta[].ang mtype
		ifmove 0 nullop else
		{
			setp[].runspeed 44600
			setp[].jumping_counter 0
			setp[].kickback_pic 0
			set qk_proxy 0
			setp[].quick_kick 0
			
			getactor[bottarget].x x2
			getactor[bottarget].y y2
			getactor[].x x
			getactor[].y y
			subvarvar x2 x
			subvarvar y2 y
			getangle angvar x2 y2
			getactor[].ang tempb
			getincangle tempd angvar tempb
			
			set tempe tempd, abs tempe
			
			ifl tempe 8
			ifl xydist 32768
			ifcount 4
			{
				set temp actorvar[bottarget].SPRITELOTAG
				add temp 1
				set spriteid -1
				set spriteid shipcams[temp]
				ifn spriteid -1 ifn sprite[spriteid].statnum 1024
				{
					ldist xydist2 bottarget spriteid
					ifl xydist2 20480
					{
						getactor[spriteid].x x2
						getactor[spriteid].y y2
						getactor[bottarget].x x
						getactor[bottarget].y y
						subvarvar x2 x
						subvarvar y2 y
						getangle angle2 x2 y2
						getactor[].ang tempb
						getincangle tempe angle2 tempb
						abs tempe
						ifg tempe 6
						{
							ifmove SHIPMOVE8 { move SHIPMOVE7 geth set trainspeed 8 } else
							ifmove SHIPMOVE7 { move SHIPMOVE6 geth set trainspeed 7 } else
							ifmove SHIPMOVE6 { move SHIPMOVE5 geth set trainspeed 6 } else
							ifmove SHIPMOVE5 { move SHIPMOVE4 geth set trainspeed 5 } else
							ifmove SHIPMOVE4 { move SHIPMOVE3 geth set trainspeed 4 } else
							ifmove SHIPMOVE3 { move SHIPMOVE2 geth set trainspeed 3 } 
						}
					}
				}
			}
			
			ifvarl tempd 7 ifvarg tempd -7
			{
				setactor[].ang angvar
				// ifspritepal 2
				// {
					// ifcount 2
					// {
					    // ifmove SHIPMOVE8 { move SHIPMOVE6 geth set trainspeed 8 } else
						// ifmove SHIPMOVE7 { move SHIPMOVE6 geth set trainspeed 7 } else
						// ifmove SHIPMOVE6 { move SHIPMOVE5 geth set trainspeed 6 } else
						// ifmove SHIPMOVE5 { move SHIPMOVE4 geth set trainspeed 5 } else
						// ifmove SHIPMOVE4 { move SHIPMOVE3 geth set trainspeed 4 } else
						// ifmove SHIPMOVE3 { move SHIPMOVE2 geth set trainspeed 3 } else
						// ifmove SHIPMOVE2 { move SHIPMOVE1 geth set trainspeed 2 }
					// }
				// }
			}
			else
			{
				
				
				// shiftl tempd 8
				// div tempd xydist
				
				
				// set tempe tempd
				// ifg xydist 16384
				// {
					// sqrt tempd tempd
					// ifl tempe 0 mul tempd -1
				// }
				// else 
				div tempd 6
				
				ifg tempd 0 { ifl tempd 7 set tempd 7 }
				else ifl tempd 0 { ifg tempd -7 set tempd -7 }
				
				// ifg tempe 0 { ifl tempd 1 set tempd 1 }
				// else ifl tempe 0 { ifg tempd -1 set tempd -1 }
				
				sub tempb tempd
				
				// ife temp NO { ifg tempb angvar set tempb angvar }
				// ife temp YES { ifl tempb angvar set tempb angvar }
				
				
				setactor[].ang tempb
				ifcount 2
				{
					ifmove SHIPMOVE8 { move SHIPMOVE7 geth set trainspeed 8 } else
					ifmove SHIPMOVE7 { move SHIPMOVE6 geth set trainspeed 7 } else
					ifmove SHIPMOVE6 { move SHIPMOVE5 geth set trainspeed 6 } else
					ifmove SHIPMOVE5 { move SHIPMOVE4 geth set trainspeed 5 } else
					ifmove SHIPMOVE4 { move SHIPMOVE3 geth set trainspeed 4 } else
					ifmove SHIPMOVE3 { move SHIPMOVE2 geth set trainspeed 3 } 
					// else ifmove SHIPMOVE2 { move SHIPMOVE1 geth set trainspeed 2 } 
					// else ifmove SHIPMOVE1 { move SHIPMOVE0 geth set trainspeed 1 }
				}
				
			}
			// vertical movement
			geta[bottarget].z z2
			sub z2 sprite[].z
			// shiftl z2 10
			mul z2 768
			div z2 xydist
			movesprite THISACTOR 0 0 z2 CLIPMASK0 RETURN
			mul z2 -1
			set shotpitch z2
			
			
		}
		geta[].ang mtype
		
		ifn actorvar[bottarget].monstflags 0 // end of journey
		ifn actorvar[bottarget].SPRITELOTAG 1
		{
			ifl xydist 512 // disembark
			{
				stopsound TRAINLOOP
				set shipcam bottarget
				setav[bottarget].startx startx
				setav[bottarget].starty starty
				setav[bottarget].droptile droptile
				// palfrom 63 1 1 1
				setsprite THISACTOR countvar countvarb float
				move 0
				set gamespeed DEFAULTSPEED
				
			}
			else
			ifl xydist 1536
			{
				ifmove SHIPMOVE1
				{
					move SHIPMOVE0 geth
					set trainspeed 1
				}
			}
			else
			ifl xydist 6144
			{
				ifmove SHIPMOVE2
				{
					move SHIPMOVE1 geth
					set trainspeed 2
				}
			}
			else
			ifl xydist 12288 
			{
				ifmove SHIPMOVE4
				move SHIPMOVE3 geth
				ifmove SHIPMOVE3 ifcount 30
				move SHIPMOVE2 geth
			}
			else
			ifl xydist 20480
			{
				ifcount 6
				{
					ifmove SHIPMOVE6
					move SHIPMOVE6 geth
					else
					ifmove SHIPMOVE6
					move SHIPMOVE5 geth
					else
					ifmove SHIPMOVE5
					move SHIPMOVE4 geth
					else
					ifmove SHIPMOVE4
					move SHIPMOVE3 geth
				}
			}
			else
			{
				ifmove SHIPMOVE0 ifcount 30 { move SHIPMOVE1 geth set trainspeed 2 } else
				ifmove SHIPMOVE1 ifcount 30 { move SHIPMOVE2 geth set trainspeed 3 } else
				ifmove SHIPMOVE2 ifcount 30 { move SHIPMOVE3 geth set trainspeed 4 } else
				ifmove SHIPMOVE3 ifcount 30 { move SHIPMOVE4 geth set trainspeed 5 } else
				ifmove SHIPMOVE4 ifcount 30 { move SHIPMOVE5 geth set trainspeed 6 } else
				ifmove SHIPMOVE5 ifcount 30 { move SHIPMOVE6 geth set trainspeed 7 } else
				ifmove SHIPMOVE6 ifcount 30 { move SHIPMOVE7 geth set trainspeed 8 } else
				ifmove SHIPMOVE7 ifcount 30 { move SHIPMOVE8 geth set trainspeed 9 }
				
			}
		}
		else
		{
			ifl xydist 844 // 644
			{
				set shipcam bottarget
				setav[bottarget].startx startx
				setav[bottarget].starty starty
				setav[bottarget].droptile droptile
				seta[bottarget].ang sprite[].ang
				seta[bottarget].xvel sprite[].xvel
				setav[bottarget].mtype mtype
				setav[bottarget].ikicked ikicked
				setsprite bottarget sprite[].x sprite[].y sprite[].z
				setsprite THISACTOR countvar countvarb float
				seta[].x countvar, seta[].y countvarb, seta[].z float
				ifn botclip -1 changespritesect THISACTOR botclip
				move 0
				set bottarget -1
			}
			else
			{
				ifmove SHIPMOVE0 { ifcount 30 move SHIPMOVE1 geth set trainspeed 2 } else
				ifmove SHIPMOVE1 { ifcount 30 move SHIPMOVE2 geth set trainspeed 3 } else
				ifmove SHIPMOVE2 { ifcount 30 move SHIPMOVE3 geth set trainspeed 4 } else
				ifmove SHIPMOVE3 { ifcount 30 move SHIPMOVE4 geth set trainspeed 5 } else
				ifmove SHIPMOVE4 { ifcount 30 move SHIPMOVE5 geth set trainspeed 6 } else
				ifmove SHIPMOVE5 { ifcount 30 move SHIPMOVE6 geth set trainspeed 7 } else
				ifmove SHIPMOVE6 { ifcount 30 move SHIPMOVE7 geth set trainspeed 8 } else
				ifmove SHIPMOVE7 { ifcount 30 move SHIPMOVE8 geth set trainspeed 9 }
			}
		}
		ife shipcam THISACTOR
		ife initsprite 0 ifmove 0 
		{
			ife trainspeed 1
			move SHIPMOVE0 geth else
			ife trainspeed 2
			move SHIPMOVE1 geth else
			ife trainspeed 3
			move SHIPMOVE2 geth else
			ife trainspeed 4
			move SHIPMOVE3 geth else
			ife trainspeed 5
			move SHIPMOVE4 geth else
			ife trainspeed 6
			move SHIPMOVE5 geth else
			ife trainspeed 7
			move SHIPMOVE6 geth else
			ife trainspeed 8
			move SHIPMOVE7 geth else
			move SHIPMOVE8 geth
		}
		
		
			// ifmove 0 nullop else
			// ifactorsound THISACTOR TRAINLOOP nullop else sound TRAINLOOP
			ifg sprite[].xvel ikicked add ikicked 16 else
			ifl sprite[].xvel ikicked sub ikicked 16
			ifmove 0 set ikicked 0
			// setactorsoundpitch THISACTOR TRAINLOOP ikicked
		
	}
	
	
break

case WESCREDITS
	ife initsprite 0
	{
		set initsprite 1
		setuserdef[].display_bonus_screen 0
		set charsel 4
		set startmode 4
		set midscreen 14829
		set crawlfirstline 1288
		set cutend totalclock
		add cutend 18000
		set cutmash 0
		set crawlclock totalclock
		set crawlnumlines 62
		startscreen
		palfrom 63 0 0 0
		orvar charlocked 4
		savegamevar charlocked
		endofgame 2
	}
	break
	
case PODBODY
case PODTAIL
	ifn mysignpost -1
	ifn sprite[].statnum sprite[mysignpost].statnum
	changespritestat THISACTOR sprite[mysignpost].statnum
break

default

	ifg navmode 0 ifn gametype 0 
	{
		ifn sprite[].statnum 1 ife stasis 0 ifg burning -1 changespritestat THISACTOR 1
	}
	else
	ifn sprite[].statnum 4
	ife navmode 0
	{
		geta[].htflags temp
		orvar temp 128
		seta[].htflags temp
	}
break

endswitch

endevent

defstate switchbulletcode

    getactor[].htmovflag spriteid
	addvar spriteid 16384
	ifvarl spriteid 16384 ifvarg spriteid -1
	ife actorvar[spriteid].monstatus 1 break

	getp[].posx savx
	getp[].posy savy
	getp[].posz savz
	getp[].ang savedvalue
	getp[].horiz angvel
	
	geta[].picnum safecount
	cactor APLAYER
	setp[].posx sprite[].x
	setp[].posy sprite[].y
	setp[].posz sprite[].z
	// setp[].ang sprite[].ang
	ifg spriteid -1 ifl spriteid 16384
	{
		ifvarand sprite[spriteid].cstat 32
		{
			ifg player[].posz sprite[spriteid].z setp[].horiz 299
			else setp[].horiz -99
		}
	}
	else
	setp[].horiz 100
	shoot SWITCHBULLET
	geta[].z z
	sub z 768
	setp[].posz z
	shoot SWITCHBULLET
	seta[].picnum safecount
	setp[].posx savx
	setp[].posy savy
	setp[].posz savz
	setp[].ang savedvalue
	setp[].horiz angvel
	
ends

state arrowhitscan
	geta[].zvel z
	geta[].xvel xvel
	shiftvarl z 14
	ife xvel 0 set xvel 1
	divvarvar z xvel
	cos mycos sprite[].ang
	sin mysin sprite[].ang
	hitscan sprite[].x sprite[].y sprite[].z sprite[].sectnum mycos mysin z hitsector hitwall hitsprite hitx hity hitz 4294901808
ends

defstate spawnradwound

	espawn RADWOUND
	ifn hitsprite -1
	{
		setav[RETURN].myvictim hitsprite
		ldist xydist THISACTOR hitsprite
		// shiftr xydist 1
		setactorvar[RETURN].mtype xydist
		
		geta[].x x2
		geta[].y y2
		geta[hitsprite].x x
		geta[hitsprite].y y
		sub x2 x
		sub y2 y
		getangle tempc x2 y2 // angle to make monster face radwound
		getincangle angvel tempc sprite[hitsprite].ang
		setav[RETURN].angvel angvel
		
		geta[hitsprite].z shotpitch
		sub shotpitch sprite[].z
		setav[RETURN].shotpitch shotpitch
	}
	setav[RETURN].myspawner player[].i
	

ends

defstate arrow_killit_code

	sizeat 10 10
	
	ifspritepal 0
	ifspawnedby APLAYER
	ifactor ARROWPROJ
	{
		ife arrowtype 1 // burning
			 spritepal 2
		else
		ife arrowtype 2 // explosive
		{
			 spritepal 7
			 spawn EXPLOSION2
			 sound RPG_EXPLODE
			 hitradius 1792 60 100 140 180
		 }
		 else
		 ife arrowtype 3 // multi
			 spritepal 12
		 else
		 ife arrowtype 4 // freeze
			 spritepal 1
		 else
		 ife arrowtype 5 // spy
			 spritepal 15
		 else 
		 ife arrowtype 6 // electric
			spritepal 117
		 else
		 ife arrowtype 7 // blood
			spritepal 54
		 else
		 ife arrowtype 8 // radioactive
			spritepal 6
			
	}

	// ifspritepal 1 // freeze arrow
	// {
		// headspritestat temp 1
		// whilevarn temp -1
		// {
			// ifvare actorvar[temp].monstatus 1
			// {
				// dist tempb THISACTOR temp
				// ifvarl tempb 6144
				// {
					// setvar tempd 16384
					// getactor[temp].extra tempb
					// ifvarl tempb 1 setvar tempb 1
					// divvarvar tempd tempb
					// ifvarg tempd 130 setvar tempd 130
					// getactorvar[temp].burning tempc
					// subvarvar tempc tempd
					// setactorvar[temp].burning tempc
				// }
				
			// }
			// nextspritestat temp temp
		// }
	// }
	
	// ifspritepal 2 // burning arrow
	// {
		// espawn FIRESTARTER
		// ifvarg powcount 0 ifvarand pow 128 { setactor[RETURN].pal 1 setactorvar[RETURN].burning -30 spritepal 1 }
		// setactorvar[RETURN].myspawner sprite[THISACTOR].owner
		// setvar RETURN 0
	// }
	
	state switchbulletcode
	ifvarvare arrowview THISACTOR setvar arrowview -1
	// STICK IN MONSTER CODE
	getactor[THISACTOR].htmovflag spriteid
	addvar spriteid 16384
	ifvarl spriteid 16384 ifvarg spriteid -1
	{
		
		getactor[THISACTOR].htmovflag spriteid
		addvar spriteid 16384
		ifspritepal 7 // bomb arrow
		{
			setactor[spriteid].htpicnum RPG
			state arrow_bits
			seta[spriteid].htowner player[].i
			setvar RETURN 0 break
		}
		ifactor ARROWPROJ 
		{
			ifspritepal 1 // ice arrow
			setactor[spriteid].htpicnum FREEZEBLAST
			ifspritepal 2 // fire arrow
			{
				getav[spriteid].burning burning
				add burning 30
				setav[spriteid].burning burning
			}
			ifspritepal 6
			{
				set hitsprite spriteid
				set savedvalue spriteid
				
				state spawnradwound
				set spriteid savedvalue
				
				espawn RADIMPACT seta[RETURN].htowner player[].i setav[RETURN].myspawner player[].i 
				setav[RETURN].inithp healthbuff
				
				set RETURN 1
			}
		}
		set temp NO
		ife actorvar[spriteid].monstatus 1 set temp YES
		ife actorvar[spriteid].monstatus 3 set temp YES
		
		ife temp YES // live victim
		{
			ifactor BLADEPROJ // check for decapitation
			{
				set TMP_A 0
				switch sprite[spriteid].picnum
				case LIZTROOP case LIZMAN case LIZRANGER 
				case PIGCOP case NEWPIG case NEWPIGDIVE
				case NEWTROOP case NEWTROOPDUCKING
				case NEWTROOPONTOILET
				case PIGCOPDIVE case LIZRANGERDUCKING
				case LIZTROOPONTOILET case LIZTROOPJUSTSIT
				case NEWBEAST
				case CYBERBEAST case CRONEN case CRAZYLADY
				case ZOMBIE case ARMYANT case ARMYANTCRAWL
				case SPACEBULL
				case COMMANDER case NEWCOMM
				
					ifn sprite[spriteid].htpicnum HEADJIB1
					{
						set TMP_B sprite[spriteid].htextra
						mul TMP_B 4
						ifge TMP_B sprite[spriteid].extra
						{
							set picnum sprite[spriteid].picnum
							set zdist tiledata[picnum].ysize
							ife actorvar[spriteid].mtype 3 
							{
								ife picnum LIZTROOP 
									set zdist 52
								ife picnum NEWTROOP
									set zdist 70
							}
							mul zdist sprite[spriteid].yrepeat
							ife picnum PIGCOPDIVE mul zdist 6 else
							ife picnum NEWPIGDIVE mul zdist 6 else
							mul zdist 5
							div zdist 2 // distance up to the head
							geta[spriteid].z z
							sub z zdist
							ifle sprite[].z z
							{
								seta[spriteid].htpicnum HEADJIB1
								ife actorvar[spriteid].droptile 0 setav[spriteid].droptile NUKECOIN
								set TMP_A 1
							}
						}
					}
				break
				endswitch
				
				ife TMP_A 1
				{
					ifrnd 128 set RETURN 0
					else
					{
						set RETURN 1
						seta[].yvel 3
					}
					break
				}
			}
			geta[spriteid].picnum picnum
			set TILETYPE -1
			state tiletype
			ifge TILETYPE 2 ifle TILETYPE 4
			{
				spawn SPARKFALL spawn SPARKFALL
				spawn SPARKFALL spawn SPARKFALL
				ifrnd 128
				ifactor ARROWPROJ
				{
					state arrow_bits
					state hitmetalsounds 
					setvar RETURN 0
					break
				}
				else
				sound ARROWMETAL
			}
			else
			{
				ifrnd 128 sound ARROWFLESH
				else sound ARROWFLESH2
			}
			
			setvarvar x2 sprite[THISACTOR].x
			addvar x2 256
			rotatepoint sprite[THISACTOR].x sprite[THISACTOR].y x2 sprite[THISACTOR].y sprite[THISACTOR].ang x y
			setactor[THISACTOR].x x
			setactor[THISACTOR].y y
			ifactor BLADEPROJ espawn BLADEPROJSTUCK else
			ifactor STAKEPROJ espawn STAKESTUCK else
			espawn STUCKARROW
			setactor[RETURN].pal sprite[THISACTOR].pal
			setactor[RETURN].pitch sprite[].pitch
			setactorvar[RETURN].myspawner spriteid
			
			getactor[THISACTOR].ang angvar
			ifactor ARROWPROJ
			{
				addvar angvar 512
				
				// slightly randomized angle
				randvar tempb 256
				subvar tempb 128
				addvarvar angvar tempb
			}
			setactor[RETURN].ang angvar
			
			// spriteid is referred to as myspawner in the arrow/stake
			getincangle temp angvar sprite[spriteid].ang
			setactorvar[RETURN].botclip temp
			
			ldist xydist THISACTOR spriteid
			ifactor BLADEPROJ { mul xydist 2 div xydist 3  } else
			shiftvarr xydist 1
			setactorvar[RETURN].mtype xydist
			
			getactor[THISACTOR].x x2
			getactor[THISACTOR].y y2
			getactor[spriteid].x x
			getactor[spriteid].y y
			subvarvar x2 x
			subvarvar y2 y
			getangle tempc x2 y2 // angle to make monster face arrow
			getincangle angvel tempc sprite[spriteid].ang
			setactorvar[RETURN].angvel angvel
			
 			setactor[RETURN].xrepeat 10 // 12
 			setactor[RETURN].yrepeat 10 // 12
			
			setactor[RETURN].cstat 32
			getactor[THISACTOR].z z
			ifactor ARROWPROJ addvar z 424
			setactor[RETURN].z z
			
 			getactor[spriteid].z shotpitch
 			subvarvar shotpitch z
 			setactorvar[RETURN].shotpitch shotpitch
			ifactor BLADEPROJ
			{
				setvar RETURN 0
				break
			}
 			ifactor STAKEPROJ
			{
				setvar RETURN 0
				break
			}
			ifspritepal 117
			{
				espawn SHOCK_ACTOR
				setav[RETURN].myspawner spriteid
				setav[RETURN].mtype 1
				espawn SHOCK_ACTOR
				setav[RETURN].myspawner spriteid
				setav[RETURN].mtype 1
				espawn SHOCK_ACTOR
				setav[RETURN].myspawner spriteid
				setav[RETURN].mtype 1
			}
 			
 			espawn STUCKARROW
 			setactor[RETURN].pal sprite[THISACTOR].pal
			setactorvar[RETURN].myspawner spriteid
			subvar angvar 1024
			setactor[RETURN].ang angvar
			getincangle temp angvar sprite[spriteid].ang
			setactorvar[RETURN].botclip temp
 			setactor[RETURN].xrepeat 10 // 12
 			setactor[RETURN].yrepeat 10 // 12
 			setactor[RETURN].cstat 16
 			subvar shotpitch 600
 			setactorvar[RETURN].shotpitch shotpitch
 			setactorvar[RETURN].mtype xydist
 			setactorvar[RETURN].angvel angvel
			setvar RETURN 0
			break
		}
		else 
		{
			ifactor STAKEPROJ
			{
				state sawblade_bits 
				spawn SPARKFALL spawn SPARKFALL
				spawn SPARKFALL spawn SPARKFALL
				setvar RETURN 0
				break
			}
			ifactor BLADEPROJ
			{
				state sawblade_bits
				spawn SPARKFALL spawn SPARKFALL
				spawn SPARKFALL spawn SPARKFALL
				state hitmetalsounds 
				setvar RETURN 0
				break
			}
			ifspritepal 2
			{
				getactorvar[spriteid].burning temp
				addvar temp 90
				setactorvar[spriteid].burning temp
			}
			ifspritepal 117 spawn SHOCK_ACTOR
			
		}
	}
	else 
	ifactor ARROWPROJ
	{
		ifspritepal 117 spawn SHOCK_ACTOR
		ifspritepal 6 
		{ 
			espawn RADIMPACT seta[RETURN].htowner player[].i setav[RETURN].myspawner player[].i 
			setav[RETURN].inithp healthbuff
		}
	}
		
	
	


	ifceilingdistl 16 { setvar RETURN 0 break }
	
	state arrowhitscan
		
	ifvarn hitsprite -1
	{
		ifactor ARROWPROJ
		ifspritepal 7 // bomb arrow
		{ 
			setactor[spriteid].htpicnum RPG
			state arrow_bits
			seta[spriteid].htowner player[].i
			setvar RETURN 0 break
		}
		geta[hitsprite].picnum picnum
		set tempb NO
		ife sprite[hitsprite].picnum STUCKARROW set tempb YES
		ife sprite[hitsprite].picnum WALLARROW set tempb YES
		ife sprite[hitsprite].picnum VERTARROW set tempb YES
		ife sprite[hitsprite].picnum STAKESTUCK set tempb YES
		ife sprite[hitsprite].picnum BLADEPROJSTUCK set tempb YES
		
		ife tempb YES
		{
			// getactor[hitsprite].cstat temp
			// ifvarand temp 16
			// {
				getactor[hitsprite].xrepeat x2
				getactor[hitsprite].yrepeat y2
				setvarvar botclip hitsprite
				setactor[hitsprite].xrepeat 1
				setactor[hitsprite].yrepeat 1
				state arrowhitscan
				setactor[botclip].xrepeat x2
				setactor[botclip].yrepeat y2
			// }
		}
	}
	
	ifspritepal 7 { setvar RETURN 0 break }
	
	getactor[].x xydist
	getactor[].y y
	subvarvar xydist hitx
	mulvarvar xydist xydist
	subvarvar y hity
	mulvarvar y y
	addvarvar xydist y
	sqrt xydist xydist

	ifvarg xydist 1024 
	{
		ifvare mtype 1 ifvarl countvar 26 { setvar RETURN 1 break }
		setvar RETURN 0 
		break 
	}
	
	ifactor ARROWPROJ
	ifvarn mtype 1 // ifvarn droptile APLAYER
	{
		getactor[].owner temp
		ifvarn temp -1
		{
			dist tempb THISACTOR temp
			ifvarl tempb 2048 
			{
				state arrow_bits
				setvar RETURN 0 
				ifrnd 128 globalsound BREAKWOOD4 else globalsound BREAKWOOD5 
				break 
			}
		}
	}
			
	setvar temp 0
	ifvarn hitsprite -1
	{
		ifvarand sprite[hitsprite].cstat 16
			set temp 1
		else
		ife sprite[hitsprite].statnum 0
			set temp 1
	}
	ifvarn hitwall -1 
	{
		getwall[hitwall].cstat tempb
		ifvarand tempb 128 { setvar RETURN 0 break } // break on transparent
		ifvarand tempb 16 { setvar RETURN 0 break } // break on masking
		getw[hitwall].picnum picnum
		state tiletype
		ifge TILETYPE 2 ifle TILETYPE 4
		ifrnd 128
		{
			ifactor BLADEPROJ state sawblade_bits else
			state arrow_bits
			spawn SPARKFALL spawn SPARKFALL
			spawn SPARKFALL spawn SPARKFALL
			state hitmetalsounds 
			setvar RETURN 0
			break
		}
		setvar temp 1
	}
	ifvarn hitsector -1
	{
		getsector[hitsector].floorslope tempb
		ifn tempb 0 ifl sprite[].zvel 1024
		{
			gets[hitsector].floorpicnum picnum
			state tiletype
			ifge TILETYPE 2 ifle TILETYPE 4
			{
				ifactor BLADEPROJ state sawblade_bits else
				state arrow_bits
				spawn SPARKFALL spawn SPARKFALL
				spawn SPARKFALL spawn SPARKFALL
				state hitmetalsounds 
				setvar RETURN 0
				break
			}
			
			ifrnd 128 globalsound BREAKWOOD4 else globalsound BREAKWOOD5 
			setvar target -1
			ifactor ARROWPROJ
			{
				cactor WALLARROW
				cstat 32 // 33	
			}
			getactor[].ang angvar
			
			cos xvel angvar
			sin yvel angvar
				  
			ifactor BLADEPROJ
			{
				shiftvarr xvel 5
				shiftvarr yvel 5
			}
			else
			{
				shiftvarr xvel 4
				shiftvarr yvel 4
			}
					 
			movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN
						
			changespritestat THISACTOR 1
			ifactor STAKEPROJ
			{
				setvar RETURN 1 
				break
			}
			ifactor BLADEPROJ
			{
				setvar RETURN 1 
				cactor BLADEPROJSTUCK
				break
			}
			addvar angvar 512
			setactor[].ang angvar
			ifvare droptile APLAYER { espawn WALLARROW setactorvar[RETURN].droptile APLAYER setactorvar[RETURN].bottarget hitwall } else
			espawn WALLARROW
			setactor[RETURN].pal sprite[].pal
			setactor[RETURN].cstat 17
			subvar angvar 1024
			setactor[RETURN].ang angvar
			setactor[RETURN].xrepeat 10 // 12
			setactor[RETURN].yrepeat 10 // 12
			getactor[].z z
			subvar z 600 //768
			setactor[].z z
			setvar RETURN 1 break
		}
	}
	ifvare temp 1
	{
		ifrnd 128 globalsound BREAKWOOD4 else globalsound BREAKWOOD5 
		ifactor ARROWPROJ
		{
			setvar target -1
			cactor WALLARROW
			setvarvar bottarget hitwall
			cstat 32 // 33	
			
		}
		getactor[].ang angvar
		ifvare hitsprite -1
		{
			cos xvel angvar
			sin yvel angvar
				  
			shiftvarr xvel 4
			shiftvarr yvel 4
				     
			movesprite THISACTOR xvel yvel 0 CLIPMASK0 RETURN
		}		
		changespritestat THISACTOR 1
		ifactor STAKEPROJ
		{
			setvar RETURN 1 
			cactor STAKESTUCK
			break
		}
		ifactor BLADEPROJ
		{
			setvar RETURN 1 
			cactor BLADEPROJSTUCK
			break
		}
		addvar angvar 512
		setactor[].ang angvar
		ifvare droptile APLAYER { espawn WALLARROW setactorvar[RETURN].droptile APLAYER setactorvar[RETURN].bottarget hitwall } else
 		espawn WALLARROW
 		setactor[RETURN].pal sprite[].pal
 		setactor[RETURN].cstat 17
 		subvar angvar 1024
 		setactor[RETURN].ang angvar
 		setactor[RETURN].xrepeat 10 // 12
 		setactor[RETURN].yrepeat 10 // 12

 		getactor[].z z
 		subvar z 304
 		setactor[].z z
 		setvar RETURN 1 break
    }
    else 
    {
	    ifvarn hitsector -1
	    {
		    getceilzofslope hitsector hitx hity temp
		    setvarvar z hitz
		    subvarvar z temp
		    shiftvarr z 8
		    subvar z 1
		    setvarvar z2 z
		    
		    getflorzofslope hitsector hitx hity z
		    setvarvar temp hitz
		    subvarvar z temp
		    shiftvarr z 8
		    subvar z 1
		    ifvarl z 1
		    {
				ifactor STAKEPROJ
				{
					cactor STAKESPRITE
					changespritestat THISACTOR 1
					set RETURN 1
					break
				}
				
				gets[].floorpicnum picnum
				state tiletype
				ifge TILETYPE 2 ifle TILETYPE 4
				{
					ifactor BLADEPROJ state sawblade_bits else
					state arrow_bits
					spawn SPARKFALL spawn SPARKFALL
					spawn SPARKFALL spawn SPARKFALL
					state hitmetalsounds 
					setvar RETURN 0
					break
				}
				ifactor BLADEPROJ
				{
					cactor BLADEPROJSTUCK
					changespritestat THISACTOR 1
					set RETURN 1
					break
				}
			    getsector[].floorstat tempb
			    ifvarand tempb 1 nullop else ifvarand tempb 2 nullop else
			    {
					ifn sector[].floorslope 0
					{
						getflorzofslope sprite[].sectnum sprite[].x sprite[].y z
						add z 512
						seta[].z z
					}
					
				    ifrnd 128 globalsound BREAKWOOD4 else globalsound BREAKWOOD5 
				    // ground arrow
				    cactor VERTARROW
					cstat 153
					getactor[THISACTOR].ang angvar			
					changespritestat THISACTOR 1
					set initsprite APLAYER
			 		espawn VERTARROW
			 		setactor[RETURN].pal sprite[THISACTOR].pal
			 		setactor[RETURN].cstat 153
			 		subvar angvar 512
			 		setactor[RETURN].ang angvar
			 		setactor[RETURN].xrepeat 10 // 12
			 		setactor[RETURN].yrepeat 10 // 12
					changespritestat RETURN 1
					
					add angvar 256
					getactor[THISACTOR].x x
					getactor[THISACTOR].y y
					setvarvar x2 x
					add x2 6
					rotatepoint x y x2 y angvar x2 y2
					
					setsprite RETURN x2 y2 sprite[].z
					
			 		setvar RETURN 1 
			 		break
			    }
			    
			} else
		    ifvarl z2 0 
		    {
			   getsector[mysector].ceilingstat tempb
			   ifvarand tempb 1 { setvar RETURN 0 break } else
			   {
				   // shatter to bits
				   setvar RETURN 0
				   break
			   } 
			}
		}
    }
    ifvare mtype 1 ifvarl countvar 26 { setvar RETURN 1 break }
	
	setvar RETURN 0


ends

state sticky_killit_code

	ifoutside ifceilingdistl 32 { set RETURN 0 break }
	
	getactor[THISACTOR].htmovflag spriteid
	addvar spriteid 16384
	ifvarl spriteid 16384 ifvarg spriteid -1
	{
		espawn STICKYBOMB
		setav[RETURN].team team
		setactor[RETURN].pal sprite[THISACTOR].pal
		setactorvar[RETURN].myvictim spriteid
		ifn myspawner -1 setav[RETURN].myspawner myspawner
		getactor[THISACTOR].ang angvar
		
		
		getincangle temp angvar sprite[spriteid].ang
		setactorvar[RETURN].botclip temp
		
		ldist xydist THISACTOR spriteid
		shiftvarr xydist 1
		setactorvar[RETURN].mtype xydist
		
		getactor[THISACTOR].x x2
		getactor[THISACTOR].y y2
		getactor[spriteid].x x
		getactor[spriteid].y y
		subvarvar x2 x
		subvarvar y2 y
		getangle tempc x2 y2 // angle to make monster face stickybomb
		getincangle angvel tempc sprite[spriteid].ang
		setactorvar[RETURN].angvel angvel
		
		set temp NO
		ife actorvar[spriteid].monstatus 1 set temp YES
		ife spriteid myshelly set temp YES
		ife temp YES
		{
			getav[spriteid].stun temp
			add temp 3
			setav[spriteid].stun temp
			ife sprite[spriteid].htextra -1
			{
				seta[spriteid].htextra 1
				seta[spriteid].htpicnum SHOTSPARK1
				seta[spriteid].htowner sprite[].owner
				seta[spriteid].htang sprite[].ang
			}
		}
		
		getactor[spriteid].z shotpitch
		subvarvar shotpitch sprite[].z
		setactorvar[RETURN].shotpitch shotpitch
		
		setvar RETURN 0
		break
	}
	else
	{
		state arrowhitscan
		ifvarn hitsprite -1
		{
			getactor[hitsprite].xrepeat x2
			getactor[hitsprite].yrepeat y2
			setvarvar botclip hitsprite
			setactor[hitsprite].xrepeat 1
			setactor[hitsprite].yrepeat 1
			state arrowhitscan
			setactor[botclip].xrepeat x2
			setactor[botclip].yrepeat y2
		}

		getactor[].x xydist
		getactor[].y y
		subvarvar xydist hitx
		mulvarvar xydist xydist
		subvarvar y hity
		mulvarvar y y
		addvarvar xydist y
		sqrt xydist xydist

		
		setvar temp 0
		ifvarn hitsprite -1
			set temp 1
		
		ifvarn hitwall -1 
			setvar temp 1
		

		ifvare temp 1
		{
			espawn STICKYBOMB
			ifn myspawner -1 setav[RETURN].myspawner myspawner
			set spriteid RETURN
			getactor[].ang angvar
			cos xvel angvar
			sin yvel angvar
				  
			shiftvarr xvel 4
			shiftvarr yvel 4			 
			movesprite spriteid xvel yvel 0 CLIPMASK0 RETURN
			
			setvarvar x2 sprite[].x
			add x2 192
			rotatepoint sprite[].x sprite[].y x2 sprite[].y sprite[].ang x2 y2
			set temp sprite[].sectnum
			updatesector x2 y2 temp
			ife temp sprite[].sectnum
				setsprite spriteid x2 y2 sprite[].z
			
			setvar RETURN 0 break
		}
		else 
		{
			ifvarn hitsector -1
			{
				getceilzofslope hitsector hitx hity temp
				setvarvar z hitz
				subvarvar z temp
				shiftvarr z 8
				subvar z 1
				setvarvar z2 z
				
				getflorzofslope hitsector hitx hity z
				setvarvar temp hitz
				subvarvar z temp
				shiftvarr z 8
				subvar z 1
				ifvarl z 1
				{
					getsector[].floorstat tempb
					ifvarand tempb 1 nullop else
					{
						espawn STICKYBOMB
						ifn myspawner -1 setav[RETURN].myspawner myspawner
						set spriteid RETURN
						getactor[].ang angvar
						cos xvel angvar
						sin yvel angvar
							  
						shiftvarr xvel 4
						shiftvarr yvel 4			 
						movesprite spriteid xvel yvel 0 CLIPMASK0 RETURN
						setvar RETURN 0 break
					}
					
				} 
				else
				ifvarl z2 0 
				{
				   getsector[mysector].ceilingstat tempb
				   ifvarand tempb 1 { setvar RETURN 0 break } else
				   {
					    espawn STICKYBOMB
						ifn myspawner -1 setav[RETURN].myspawner myspawner
						set spriteid RETURN
						getactor[].ang angvar
						cos xvel angvar
						sin yvel angvar
							  
						shiftvarr xvel 4
						shiftvarr yvel 4			 
						movesprite spriteid xvel yvel 0 CLIPMASK0 RETURN
						setvar RETURN 0 break
				   } 
				}
			}
		}
		setvar RETURN 0
	}

ends

onevent EVENT_KILLIT

ife sprite[].statnum 1
ife monstatus 1
{
	state enemy_death
	set monstatus 2
	set RETURN 0
}

ife heldobject THISACTOR set heldobject -1
// else
// set monstatus 0

switch sprite[].picnum

	case BOTTLE1 case BOTTLE2 case BOTTLE3
	case BOTTLE4 case BOTTLE5 case BOTTLE6
	case BOTTLE7 case BOTTLE8 case BOTTLE10
	case BOTTLE13 case BOTTLE14 case BOTTLE15 case BOTTLE16
	case BOTTLE17 case BOTTLE18 case BOTTLE19
	case BOTTLE20 case BOTTLE21 case BOTTLE22
		espawn PART_EXP
		seta[RETURN].pal sprite[].pal
		set RETURN 0
	break
	
	case OCEANSPRITE1 case OCEANSPRITE2 case OCEANSPRITE3
		ifwasweapon RPG add initsprite 3 else
		ifwasweapon RADIUSEXPLOSION add initsprite 3
		add initsprite 1
		set x sprite[].xrepeat
		shiftr x 4
		ifg initsprite x
		{
			sound BREAKROCK sound BREAKROCK sound BREAKROCK
			debris SCRAP5 10
			spawn BIGSMOKE
		}
		else set RETURN 1
	break
	
	case DOMELITE
		ifactorsound THISACTOR ALARM2 stopactorsound THISACTOR ALARM2
	break
	
	case VASE
		ifspritepal 0 spritepal 93
		state pottery_debris
		ifspritepal 93 getlastpal
		set RETURN 0
	break
	
	case FIREVASE
		ifspritepal 0 spritepal 50
		state pottery_debris
		ifspritepal 50 getlastpal
		set RETURN 0
	break
	
	case STATUE
		state pottery_debris
		set RETURN 0
	break
	
	case FETUS
		seta[].alpha 84
		state pottery_debris
		set RETURN 0
	break
	
	case FIRELASER
	case NEWFIRELASER
		ifvarn sprite[].htmovflag 0
		{

			spawn SPARKFALL
			spawn SPARKFALL
			spawn SPARKFALL
			spawn SPARKFALL
			spawn SPARKFALL
			set RETURN 0
		}
	break
	case RECON
		ifg player[].player_par 1
		{
			set monstatus 1
			espawn RECONWRECK
			seta[RETURN].pal sprite[].pal
			set RETURN 0
		}
	break
	// case GREENSLIME
		// ifn attmode NO
		// {
			
			// ife monxp 0 set monxp 25
			// ife SHOWPOINTS YES state showpoints
			// add totalxp monxp
			// add playerxp monxp
		// }
		// set RETURN 0
	// break
	case SPIT
		ifvarand initflags 8
		{
			spawn POISONGAS
			spawn POISONGAS
			spawn POISONGAS
			spawn POISONGAS
			spawn POISONGAS
			spawn POISONGAS
			spawn POISONGAS
			set RETURN 0
		}
	break
	
	case CRACK1
	case CRACK2
	case CRACK3
	case CRACK4
		ifn monstatus 2
		ifg SPRITELOTAG 0
		{
			headspritestat spriteid 6
			whilevarn spriteid -1
			{
				ife SPRITELOTAG actorvar[temp].SPRITELOTAG
					setav[spriteid].monstatus 2
				nextspritestat spriteid spriteid
			}
		}
	break
	
	case CANWITHSOMETHING
	case CANWITHSOMETHING2
	case CANWITHSOMETHING3
	case CANWITHSOMETHING4
	ifn attmode 0
	{
		ife sprite[].lotag 0
		set value 4
		state spawnimpcoins
		set RETURN 0
	}
	break

	case GRENADEPROJ
	case WESGRENADE
	case BIGGRENADEPROJ
		ifoutside ifceilingdistl 32 nullop
		else
		{
			debris SCRAP1 5
			debris SCRAP2 5
			iffloordistl 16 spawn EXPLOSION2BOT
			set RETURN 0
		}
	break
	case STICKYPROJ
		state sticky_killit_code
	break
	case RPG
		ifspritepal 47 spawn NUKEEXPLOSION
	break
	// case BEACHBALLPROJ
	case SPIDERMINEFALLING
		ifceilingdistl 4 ifvarand sector[].ceilingstat 1 
		{
			geta[].zvel z
			ifl z 0
			{
				abs z
				seta[].zvel z
			}
		}
		ifg sprite[].yvel 0
		ifn monstatus 2
		set RETURN 1
		break
	case SHRINKSPARK
		
	    headspritestat spriteid 1
		set B -1
		whilevarn spriteid -1
		{
			dist xydist THISACTOR spriteid
			ifle xydist SHRINKERBLASTRADIUS
			{
				seta[spriteid].htpicnum SHRINKSPARK
				ifl sprite[spriteid].htextra 0 seta[spriteid].htextra 1
				seta[spriteid].htowner sprite[].owner
				ife sprite[spriteid].statnum 1 set B spriteid
			}
			nextspritestat spriteid spriteid
		}
		ife B -1 ifpdistl SHRINKERBLASTRADIUS
		{
			seta[player[].i].htpicnum SHRINKSPARK
			seta[player[].i].htextra 0
			seta[player[].i].htowner sprite[].owner
		}
	break
		
	case PIGHEADPROJ 
	case TROOPHEADPROJ 
	case NEWTROOPHEADPROJ 
	case LIZHEADPROJ 
	case COMMHEADPROJ 
	case NEWCOMMHEADPROJ 
	case ZOMBIEHEADPROJ case CRAZYHEADPROJ
	case RANGERHEADPROJ 
	case BEASTHEADPROJ 
	case ANTHEADPROJ 
	case BULLHEADPROJ 
	case MANDOHEADPROJ 
		add countvarc 1
	set RETURN 0
	break
	
	case ARROWPROJ
	case STAKEPROJ
	case BLADEPROJ
		state arrow_killit_code
	break
	
	case SHOCK_ACTOR ifn mtype 0 { sub TOTALSHOCKS 1 ifl TOTALSHOCKS 0 set TOTALSHOCKS 0 } 
	break
	
	case KINETICPROJ
		geta[].htmovflag spriteid
		add spriteid 16384
		ife spriteid player[].i
		{
			screensound SUBWOOF
			screensound SUBWOOF
			screensound SUBWOOF
			screensound SUBWOOF
			screensound SUBWOOF
			set x2 player[].posx
			set y2 player[].posy
			sub x2 sprite[].x
			sub y2 sprite[].y
			getangle angvar x2 y2
			cos xvel angvar
			sin yvel angvar
			shiftvarl xvel 8
			shiftvarl yvel 8
			add xvel player[].posxv
			add yvel player[].posyv
			setplayer[].posxv xvel
			setplayer[].posyv yvel
		}	
	break
	
	case GOOBULLET
		geta[].htmovflag spriteid
		add spriteid 16384
		ifge spriteid 0 ifl spriteid 16384
		{
			ife sprite[spriteid].statnum 1
			ife actorvar[spriteid].monstatus 1
			{
				espawn DRIPBLOOD
				seta[RETURN].cstat 16
				seta[RETURN].pal 126
				set myvictim spriteid
				setav[RETURN].myvictim spriteid
				setav[RETURN].myspawner spriteid
				setav[RETURN].startx sprite[spriteid].x
				setav[RETURN].starty sprite[spriteid].y
				setav[RETURN].float sprite[spriteid].z
				
				ldist xydist THISACTOR spriteid
				
				sub xydist 128

				state facesprite
				set x2 sprite[].x
				add x2 xydist
				rotatepoint sprite[].x sprite[].y x2 sprite[].y sprite[].ang x y
				setsprite RETURN x y sprite[RETURN].z
				
				set RETURN 0
			}
		}
		else 
		{
			add spriteid 16384
			ifge spriteid 0 ifl spriteid 16384 // hit a wall
			{
				set hitwall spriteid
			
				espawn DRIPBLOOD
				seta[RETURN].clipdist 0
				getactor[].ang angvar
				cos xvel angvar
				sin yvel angvar
				shiftvarr xvel 4
				shiftvarr yvel 4
				movesprite RETURN xvel yvel 0 CLIPMASK0 temp
				geta[RETURN].z z add z 384 seta[RETURN].z z
				seta[RETURN].cstat 16
				seta[RETURN].pal 126
				
				getwall[hitwall].point2 B
				getwall[hitwall].x x2
				getwall[hitwall].y y2
				getwall[B].x x
				getwall[B].y y
				subvarvar x2 x
				subvarvar y2 y
				getangle angvar x2 y2
				add angvar 512
				seta[RETURN].ang angvar
				
				set RETURN 0
			}
		}
		headspritestat target 1
		whilevarn target -1
		{
			ife actorvar[target].monstatus 1
			ifn target myvictim
			{
				dist xydist THISACTOR target
				ifle xydist 1560
				ifg actorvar[target].gooify -1
				{
					set gooify 48
					set TMP_A nweaplevel[FREEZE_WEAPON]
					mul TMP_A 4
					add gooify TMP_A
					add gooify actorvar[target].gooify
					setav[target].gooify gooify
					ife sprite[target].htextra -1
						seta[target].htextra 2
					seta[target].htowner sprite[].owner
					seta[target].htpicnum GOOBULLET
				}
			}
			nextspritestat target target
		}
	break
	
	case GRAVESNPC
	ifn monstatus 666
	{
		set RETURN 1
		al monstatus
		al initsprite
		geta[].x x al x
		geta[].y y al y
		geta[].z z al z
		geta[].sectnum mysector al mysector
		al countvarb
		al countvarc
		al myvictim
		al mysignpost
	}
	break

	default break

endswitch

ife sprite[].statnum 4
{
	ifspawnedby APLAYER
	{
		ifactor FIRELASER2
			state switchbulletcode
		else
		ifactor PLAYERPLASMA
			state switchbulletcode
		else
		ifactor MANDOLASER
			state switchbulletcode
		else
		ifactor MINIBOLT
			state switchbulletcode
		else
		ifactor DEALASER
			state switchbulletcode
		else
		ifactor NOVAPLASBOLT
			state switchbulletcode
	}	
	set RETURN 0
	ifactor IMPCOINPROJ break
	geta[].htmovflag spriteid
	add spriteid 16384
	ifg spriteid -1 ifl spriteid 16384
	{
		ifactor NOVAPLASBOLT
		ifspawnedby APLAYER
		ife sprite[spriteid].statnum 1
		ife actorvar[spriteid].team 0
		{
			ifspritepal 3
			{
				ife es_type 0
				{
					set tempb 1
					add tempb nweaplevel[SHOTGUN_WEAPON]
					div tempb 2, clamp tempb 1 4
					getp[].shield_amount temp
					ifl temp 150
					{
						add temp tempb
						clamp temp 1 150
						setp[].shield_amount temp
					}
				}
				else 
				{
					set tempb 1
					add tempb nweaplevel[SHOTGUN_WEAPON]
					div tempb 2, clamp tempb 1 4
					add es_hp tempb
					set tempb es_hpmax[es_type]
					mul tempb 3 div tempb 2
					ifg es_hp tempb set es_hp tempb
				}
				ifvarand novaupgrades[SHOTGUN_WEAPON] 2
				{
					add leach 8
					add leach nweaplevel[SHOTGUN_WEAPON]
					add leach nweaplevel[SHOTGUN_WEAPON]
				}
				
				espawn CAPTUREPLUS
				ifn RETURN -1
				{
					rand x2 256
					add x2 384
					ifrnd 128 mul x2 -1
					add x2 sprite[spriteid].x
					seta[RETURN].x x2
					
					rand x2 256
					add x2 384
					ifrnd 128 mul x2 -1
					add x2 sprite[spriteid].y
					seta[RETURN].y x2
					
				}
				set RETURN 0
				
			}
			else
			ifspritepal 23
			{
				getav[spriteid].burning burning
				add burning 4
				set tempb nweaplevel[SHOTGUN_WEAPON]
				add burning tempb
				setav[spriteid].burning burning
				espawn STICKYFIRE
				setav[RETURN].mtype sprite[spriteid].picnum
				setav[RETURN].myspawner spriteid
				seta[RETURN].pal 118
				setsprite RETURN sprite[spriteid].x sprite[spriteid].y sprite[spriteid].z
				ifvarand novaupgrades[SHOTGUN_WEAPON] 1
				{
					getav[spriteid].stun stun
					add stun 1
					// ife sprite[spriteid].htextra -1
					ifl actorvar[spriteid].stun 30
					{
						add stun nweaplevel[SHOTGUN_WEAPON]
						add stun nweaplevel[SHOTGUN_WEAPON]
					}
					setav[spriteid].stun stun
					seta[spriteid].htpicnum SABERSCORCH3
				}
				set RETURN 0
			}
		}
		
		ifactor CBPROJ
		ifspawnedby APLAYER
		ife sprite[spriteid].statnum 1
		{
			seta[spriteid].htpicnum RPG
			getav[spriteid].burning temp
			add temp 40
			setav[spriteid].burning temp
		}
		ife sprite[spriteid].picnum SHOCKBALL2
			setav[spriteid].monstatus 2
		
		ifge sprite[].picnum FLAMEPROJ2 ifle sprite[].picnum FLAMEPROJ
		// ifactor FLAMEPROJ
		ifn actorvar[spriteid].monstatus 100
		ifg sprite[spriteid].statnum 0
		{
			ifspritepal 0
			{
				getav[spriteid].burning temp
				ife sprite[].picnum FLAMEPROJ
				add temp 30
				else
				{
					add temp 4
					set tempb mweaplevel[PISTOL_WEAPON]
					mul tempb 2
					add temp tempb
				}
				setav[spriteid].burning temp
			}
			else
			ifspritepal 1
			{
				seta[spriteid].htpicnum FREEZEBLAST
			}
			else
			ifspritepal 27
			{
				seta[spriteid].htpicnum FREEZEBLAST
				getav[spriteid].burning temp
				sub temp 4
				set tempb mweaplevel[FREEZE_WEAPON]
				mul tempb 2
				sub temp tempb
				setav[spriteid].burning temp
				ife actorvar[spriteid].padmove 0
					setav[spriteid].padang 131313
			}
		}
		
		// sticky RPG
		ifactor RPG
		ifspawnedby APLAYER
		ifvarand mandoupgrades[RPG_WEAPON] 1
		ife player[].curr_weapon RPG_WEAPON
		ife pchar 3
		// ife actorvar[spriteid].monstatus 1
		{
			changespritestat THISACTOR 1
			
			set myvictim spriteid
			ldist mtype THISACTOR spriteid
			ifg mtype 512 set mtype 512
			getactor[myvictim].z shotpitch
			subvarvar shotpitch sprite[].z
			iffloordistl 16 add shotpitch 3072
			getactor[].x x2
			getactor[].y y2
			getactor[myvictim].x x
			getactor[myvictim].y y
			subvarvar x2 x
			subvarvar y2 y
			getangle tempc x2 y2
			getincangle angvel tempc sprite[myvictim].ang
			set countvar 0
			set RETURN 1
		}
		
		ifactor SHOCKBALL2
		{
			seta[spriteid].htpicnum RPG
			espawn SHOCK_ACTOR
			setav[RETURN].myspawner spriteid
			set RETURN 0
		}
		ifactor BIGBOIPROJ
		ife myspawner player[].i
		{
			set hitsprite spriteid
			state spawnradwound
			set RETURN 0
		}
		ifactor GENERICBOLT
		{
			ife actorvar[sprite[].owner].team 1
			ife actorvar[spriteid].team 1
			ifvarand perks 8 nullop else
			{
			
				ifn actorvar[spriteid].monstatus 2
				ifn spriteid sprite[].owner
				{
					getav[spriteid].burning burning
					ifspritepal 1 { sub burning 30 seta[spriteid].htpicnum FREEZEBLAST }
					ifspritepal 21 add burning 30
					setav[spriteid].burning burning
					ifspritepal 11
					{
						getav[spriteid].bleeding bleeding
						add bleeding 20
						setav[spriteid].bleeding bleeding
					}
				}
			}
			set RETURN 0
		}
		ifactor BLASTBALL
		ifvarand mandoupgrades[DEVISTATOR_WEAPON] 1
		ife mtype BLASTBALL
		{
			espawn SHOCK_ACTOR
			seta[RETURN].pal 96
			setav[RETURN].myspawner spriteid
			seta[RETURN].htowner player[].i
			setav[RETURN].mtype 1
			set RETURN 0
		}
		
		ifactor PLASDISKPROJ
		{
			set newx sprite[].x
			add newx 128
			
			rotatepoint sprite[].x sprite[].y newx sprite[].y sprite[].ang x y
			setsprite THISACTOR x y sprite[].z
			set RETURN 1
		}
		
		geta[].xvel xvel
		// ifn sprite[].picnum RPG
		// ife sprite[spriteid].picnum BARRIER
		// {
			// geta[spriteid].ang angvar
			// getincangle temp angvar sprite[].ang
			// sub angvar temp
			// add angvar 1024
			// seta[].ang angvar
			// seta[].owner player[].i
			// set RETURN 1
			// break
		// }
		
		switch sprite[spriteid].picnum
		case SITH case SYTH
		ife actorvar[spriteid].mtype 1 // blocking
		ife myvictim -1
		{
			seta[spriteid].htextra -1
			set damflash 0
			geta[spriteid].ang angvar
			getincangle temp angvar sprite[].ang
			sub angvar temp
			add angvar 1024
			seta[].ang angvar
			globalsound BLASTERBOUNCE
			add countvarc 1
			ifl countvarc 2
			set RETURN 1
		}
		break
		case EBARRIER
		case BARRICADE
			ife sprite[spriteid].pal 21
			ife myvictim -1
			{
				ifg sprite[spriteid].htextra 0
				{
					set temp sprite[spriteid].htextra
					div temp 3
					seta[spriteid].htextra temp
				}
				geta[spriteid].ang angvar
				getincangle temp angvar sprite[].ang
				sub angvar temp
				add angvar 1024
				seta[].ang angvar
				globalsound BLASTERBOUNCE
				add countvarc 1
				ifl countvarc 2
				set RETURN 1
			}
		break
		endswitch
		
		ife RETURN 1 break
		
		ifg saberpos 0 ifl saberpos 85 nullop else
		ifangdiffl 512 nullop else	
		ife sprite[spriteid].picnum APLAYER
		ife player[].curr_weapon KNEE_WEAPON
		ifn gotsaber 0 ife player[].weapon_pos 0
		ifn sprite[].picnum RPG
		ifn sprite[].picnum SHOCKBALL
		ifl rage 1
		ifg sprite[].extra 0
		{
			// set knockvel -1
			seta[spriteid].htextra -1
			geta[].owner B
			seta[].owner spriteid
			getp[].ang angvar
			getincangle blockang angvar sprite[].ang
			sub angvar blockang
			add angvar 1024
			seta[].ang angvar
			ifl blockang 0 set blockang -9 else set blockang 9
			getp[].horiz z
			sub z 100
			mul z -100
			seta[].zvel z
			shiftr z 4
			getangle tempb xvel z
			seta[].pitch tempb
			
			ifrnd 128
			ifg sprite[].extra 4
			{
				ifg gotsaber 0 
				ifn halfpoint 0 set halfpoint 0 else
				{ 
					ife pchar 2 addphealth -2 else
					ife pchar 4 addphealth -2 else
					sub gotsaber 1 
					set halfpoint 1 
				}
			}
			
			flash
			ife pchar 4
			{
				rand temp 2
				ife temp 0 screensound DEABLOCK else
				ife temp 1 screensound DEABLOCK2 else
				screensound DEABLOCK3
			}
			else
			globalsound BLASTERBOUNCE
			
			// redirect to sender if possible
			ifn B -1
			ife actorvar[B].monstatus 1
			{
				set bottarget B
				geta[bottarget].x x2
				geta[bottarget].y y2
				sub x2 sprite[].x
				sub y2 sprite[].y
				getangle angvar x2 y2
				
				ifn holdinteract 0
				ifl holdinteract 8 
				{
					stopsound BLASTERBOUNCE
					screensound REFLECT
					screensound REFLECT
					screensound REFLECT
					seta[].ang angvar set justblocked 8 
					ifvarand gametips 128 { xorvar gametips 128 savegamevar gametips }
					geta[].extra temp, mul temp 3 div temp 2 seta[].extra temp
				}
				else
				{
					rand tempb 64
					sub tempb 32
					add angvar tempb
					seta[].ang angvar
				}
				
				geta[bottarget].z zdist
				ifactor MORTER sub zdist 8192
				sub zdist sprite[].z 
				
				geta[bottarget].picnum picnum
				
				set z2 tiledata[picnum].ysize
				mul z2 sprite[bottarget].yrepeat
				shiftl z2 1
				// z2 is proportional to height of enemy sprite
				
				sub zdist z2

				mul zdist sprite[].xvel
				ldist xydist THISACTOR bottarget
				ifvare xydist 0 setvar xydist 1 
				divvarvar zdist xydist
				
				ifn holdinteract 0  
				ifl holdinteract 8 
					seta[].zvel zdist 
				else
				{
					rand tempb 2048
					sub tempb 1024
					add zdist tempb
					seta[].zvel zdist
				}
			}

			set RETURN 1
			break
		}
		
		set RETURN 0
	}
	else ifactor PLASDISKPROJ
	{
		sound SHOCKBALLIMPACT
		spawn SHOCKBALL_EXP
	}
	set RETURN 0
}

endevent


// Advances the random number generator seed a bit since EDuke32 currently never calls srand().

defstate advance_rand
    getticks temp
    andvar temp 255
    whilevarn temp 0
    {
        displayrand tempb
        subvar temp 1
    }
ends

damageeventtilerange CRACK1 CRACK4

// onevent EVENT_DAMAGESPRITE

// getuserdef[].return 0 temp al temp
// getuserdef[].return 1 tempb al tempb

// geta[temp].htpicnum picnum
// al picnum
// geta[temp].htextra tempc
// al tempc

// endevent

onevent EVENT_POSTDAMAGESPRITE

	getuserdef[].return 0 spriteid

	geta[spriteid].picnum picnum
	ifge sprite[spriteid].picnum CRACK1 ifle sprite[spriteid].picnum CRACK4
	{
		set temp sprite[spriteid].htextra
		ifl temp -1
		{
			abs temp
			seta[spriteid].htextra temp
		}
	}


// geta[temp].htpicnum picnum
// al picnum
// geta[temp].htextra tempc
// al tempc

// THISACTOR == ID of the projectile or source of damage.
// RETURN == the ID of what is being damaged.
// The userdef return 1 through 5 equals the hitradius parameters. If there's no radius damage, return 1 equals -1.

	ife sprite[RETURN].picnum RECON
	// ife sprite[RETURN].htowner player[0].i
		setav[RETURN].botclip sprite[RETURN].htextra
	
endevent

appendevent EVENT_LOADGAME

// ife RANDOMTRACK YES
    // state apply_music

ifn music_position -1
	setmusicposition music_position
	
ife pchar 0 
{
	setp[].palookup dukepal
	setuserdef[].color dukepal
}
else
ife pchar 1 
{ 
	setp[].palookup shellypal
	setuserdef[].color shellypal
}
else
ife pchar 2
{ 
	setp[].palookup wespal
	setuserdef[].color wespal
}
else
ife pchar 3
{ 
	setp[].palookup mandopal
	setuserdef[].color mandopal
}
else
ife pchar 4
{
	setp[].palookup novapal
	setuserdef[].color novapal
}

endevent

appendevent EVENT_SAVEGAME
    getmusicposition music_position
	ife challenge YES
	ifg player[].player_par 30
	{
		ifg leveltoken 0 
		{
			sub leveltoken 1
			set bigmsg 1113
			set bigmsgcount 90
		}
		else
		{
			mul totalxp 9
			div totalxp 10
			set bigmsg 3108
			set bigmsgcount 90
		}
	}
endevent

include scripts/AAPLAYER.CON
include scripts/SECTORLIGHT.CON
include scripts/AAITEMS.CON
include scripts/NOTENEMY.CON
include scripts/INTERACT.CON
include scripts/AAPRELOAD.CON
include scripts/OLDENEMIES.CON
include scripts/PIGBOSS.CON
include scripts/LIZBOSS.CON
include scripts/LIZRANGER.CON
include scripts/ZOMBIE.CON
include scripts/CORRUPT.CON
include scripts/SITH.CON
include scripts/CRAZYLADY.CON
include scripts/CIVILIAN.CON
include scripts/BOMBSHELL.CON
include scripts/DUKEBOT.CON
include scripts/ROLLYTURRET.CON
include scripts/ARMPIG.CON
include scripts/MEGABRAIN.CON
include scripts/BOSS2FLY.CON
include scripts/TERMINATOR.CON
include scripts/CYBERBEAST.CON
include scripts/DEVOURER.CON
include scripts/VEHICLES.CON
include scripts/SCUBATROOP.CON
include scripts/MECHBRAIN.CON
include scripts/DRPROTON.CON
include scripts/LIZTURRET.CON
include scripts/EDFTROOP.CON
include scripts/ARMEDF.CON
include scripts/EDFSNIPER.CON
include scripts/SCHOOLGIRL.CON
include scripts/GUARD.CON
include scripts/LIZELITE.CON
include scripts/MANDO.CON
include scripts/ARMYANT.CON
include scripts/SPACEBULL.CON
include scripts/DEANOVA.CON
include scripts/CANHEAD.CON
include scripts/SPIDERMINE.CON
include scripts/WARMAGEDDON.CON
include scripts/NPCQUOTES.CON
include scripts/NEWVACA.CON
include scripts/LITTLEBIGMEN.CON
include scripts/CYCLOIDMAX.CON
include scripts/ANCIENTS.CON
include scripts/NEWTROOP.CON
include scripts/NEWPIG.CON
include scripts/NEWCOMM.CON
include scripts/ARMLIZTROOP.CON
include scripts/NEWBATLORD.CON
include scripts/QUEEN.CON
include scripts/NURGLE.CON
include scripts/LIZDOG.CON
include scripts/ROBOSHARK.CON
include scripts/POLYMORPH.CON
include scripts/PODHEAD.CON
include scripts/WESBOT.CON
include scripts/NAAMAH.CON
include scripts/LILY.CON
include scripts/BATBOSS.CON
include scripts/CHEERBOT.CON
include scripts/NEWMECH.CON
include scripts/RESFIGHTERS.CON
include scripts/GRAVES.CON
include scripts/DEABOT.CON
