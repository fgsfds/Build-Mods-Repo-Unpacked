// MAP INVERTER
// CODE BY PLAGMAN, with additions by DeeperThought

gamevar I 0 0
gamevar J 0 0
gamevar K 0 0
gamevar L 0 0
gamevar M 0 0
gamevar A 0 0
gamevar B 0 0
gamevar C 0 0
gamevar D 0 0
gamevar E 0 0
gamevar DONE 0 0

gamearray SWAPWALLS 16384

gamevar NEXTWALL1 0 0
gamevar NEXTSECTOR1 0 0

gamevar NEXTWALL2 0 0
gamevar NEXTSECTOR2 0 0

gamevar initcstat -1 2
gamevar initsect 0 2
gamevar temp 0 0
gamevar tempb 0 0
gamevar x 0 0
gamevar y 0 0
gamevar z 0 0
gamevar picnum 0 0


state swapwall
	ifvarvarn J K
	{
		getwall[J].x temp
		getwall[K].x tempb
		setwall[J].x tempb
		setwall[K].x temp
		getwall[J].y temp
		getwall[K].y tempb
		setwall[J].y tempb
		setwall[K].y temp
		getwall[J].cstat temp
		getwall[K].cstat tempb
		setwall[J].cstat tempb
		setwall[K].cstat temp
		getwall[J].picnum temp
		getwall[K].picnum tempb
		setwall[J].picnum tempb
		setwall[K].picnum temp
		getwall[J].overpicnum temp
		getwall[K].overpicnum tempb
		setwall[J].overpicnum tempb
		setwall[K].overpicnum temp
		getwall[J].shade temp
		getwall[K].shade tempb
		setwall[J].shade tempb
		setwall[K].shade temp
		getwall[J].pal temp
		getwall[K].pal tempb
		setwall[J].pal tempb
		setwall[K].pal temp
		getwall[J].xrepeat temp
		getwall[K].xrepeat tempb
		setwall[J].xrepeat tempb
		setwall[K].xrepeat temp
		getwall[J].yrepeat temp
		getwall[K].yrepeat tempb
		setwall[J].yrepeat tempb
		setwall[K].yrepeat temp
		getwall[J].xpanning temp
		getwall[K].xpanning tempb
		setwall[J].xpanning tempb
		setwall[K].xpanning temp
		getwall[J].ypanning temp
		getwall[K].ypanning tempb
		setwall[J].ypanning tempb
		setwall[K].ypanning temp
		getwall[J].lotag temp
		getwall[K].lotag tempb
		setwall[J].lotag tempb
		setwall[K].lotag temp
		getwall[J].hitag temp
		getwall[K].hitag tempb
		setwall[J].hitag tempb
		setwall[K].hitag temp
		getwall[J].extra temp
		getwall[K].extra tempb
		setwall[J].extra tempb
		setwall[K].extra temp
		getwall[J].nextwall temp
		getwall[K].nextwall tempb
		setwall[J].nextwall tempb
		setwall[K].nextwall temp
		getwall[J].nextsector temp
		getwall[K].nextsector tempb
		setwall[J].nextsector tempb
		setwall[K].nextsector temp
	}
ends

appendevent EVENT_LOADACTOR

ife userdef.player_skill 6
{
	ife VOLUME 2
	ife userdef.player_skill 6
	ife userdef.level_number 11
		set DONE 1
	
	ifactor SECTOREFFECTOR
		getactor[THISACTOR].sectnum initsect
	
	ifvare DONE 0
	{
		setvar I 0
		whilevarvarn I NUMWALLS
		{
			getwall[I].x A
			mulvar A -1
			setwall[I].x A
			setarray SWAPWALLS[I] -1
			getwall[I].picnum temp
			switch temp
			case 277 case 394 case 415 case 498 case 499
			case 500 case 502 case 518 case 519 case 520 case 521 case 522 case 523 case 524 case 525
			case 526 case 527 case 528 case 529 case 530 case 531 case 532 case 533 case 534 case 535
			case 568 case 593 case 594 case 598 case 599 case 600 case 612 case 613 case 614 case 639
			case 657 case 666 case 667 case 687 case 699 case 721 case 728 case 736 case 766 case 776 
			case 777 case 778 case 784 case 817 case 818 case 822 case 826 case 835 case 838 case 837
			case 841 case 839 case 848 case 849 case 856 case 858 case 871 case 872 case 937 case 938 
			case 945 case 946 case 949 case 961 case 963 case 964 case 965 case 966 case 967 case 968
			case 970 case 980 case 992 case 1043 case 1044 case 1046 case 1047 case 1064 case 1065 case 1066
			case 1072 case 1210 case 1211 case 1212 case 1214 case 1215 case 1217 case 1244 case 1245
			case 2486 case 2492 case 2493 case 2500 case 2504 case 2505 case 2506 case 3370 case 3371 case 3372
			case 3373 case 3374 case 3382 case 3383 case 3391 case 3402 case 3403 case 3421 case 3422 case 3423
			case 4096 case 4108 case 4125 case 4126 case 4238 case 4306 case 4307 case 4318 case 4323
			case 4329 case 4447 case 4450 case 4451 case 4477 case 4472 case 4475 case 4476
			case 4478 case 4479 case 4484 case 4485 case 4486 case 4487 case 4488 case 4492 case 4499
			case 4494 case 4504 case 4505 case 4506 case 4507 case 4508 case 4553 case 4564 case 4565
			case 4578 case 4579 case 4597 case 4598 case 4599 case 4889 case 4891 case 4892 case 4896 
			case 4897 case 4898 case 4899 case 4903 case 4904 case 4905 case 4906 case 4907 case 4908
			case 4924 case 4925 case 4926 case 4927 case 4928 case 4929 case 4930 case 4931 case 4932
			case 4933 case 4934 case 4937 case 4938 case 4939 case 4942 case 4945 case 4947 case 4948
			case 4950 case 4951 case 4952 case 4956
			break
			default
				getwall[I].cstat temp
				ifvarand temp 8 subvar temp 8 else orvar temp 8
				setwall[I].cstat temp
			break
			endswitch
			addvar I 1
		}

		setvar I 0
		whilevarvarn I NUMWALLS
		{
			setvarvar A I
			getwall[I].point2 B
			setvarvar K I
			whilevarvarn A B
			{
				addvar K 1
				getwall[K].point2 B
			}
			setvarvar A K
			setvarvar J I
			setvarvar L K
			subvarvar L J
			divvar L 2
			addvar J 1
			whilevarn L 0
			{
				state swapwall
				setarray SWAPWALLS[J] K
				setarray SWAPWALLS[K] J
				addvar J 1
				addvar K -1
				addvar L -1
			}

			setvarvar J I
			whilevarvarn I A
			{
				setvarvar K I
				addvar K 1
				getwall[J].x B
				getwall[J].y C
				getwall[K].x D
				getwall[K].y E
				setwall[J].x D
				setwall[J].y E
				setwall[K].x B
				setwall[K].y C

				addvar I 1
			}

			addvar I 1
		}

		setvar I 0
		whilevarvarn I NUMWALLS
		{
			getwall[I].nextwall A
			ifvarn A -1
				ifvarn SWAPWALLS[A] -1
					setwall[I].nextwall SWAPWALLS[A]

			addvar I 1
		}
		
		setvar I 0
		whilevarn I 16384
		{	
			getactor[I].x A
			mulvar A -1
			setactor[I].x A
			getactor[I].picnum picnum
			
			getactor[I].ang A
			ifvarg A 1024
			{
				setvar B 1536
			} else {
				setvar B 512
			}
			subvarvar B A
			mulvar B 2
			addvarvar A B
			
			setactor[I].ang A
			
			geta[I].angoff B
			ifn B 0
			{
				sub A B
				setactor[I].angoff A
			}
			
			getactor[I].lotag temp
			ifvare picnum SECTOREFFECTOR ifvare temp 0
			{
				getactor[I].pal temp
				ifvare temp 2 setactor[I].pal 0 else
				ifvare temp 0 setactor[I].pal 2
			}
			ifvare picnum SECTOREFFECTOR ifvare temp 11
			{
			
				ifge A 1 ifle A 1024
					add A 513 
				else
					add A 1025
				
				
				ifg A 2047
					sub A 2048
				
				seta[I].ang A
			}

			addvar I 1
		}
		
		set I 0
		whilen I NUMSECTORS
		{	
			ifand sector[I].floorstat 4
			{
				getsector[I].floorstat A
				or A 32
				setsector[I].floorstat A
			}
			else ifand sector[I].floorstat 48
			{
				getsector[I].floorstat A
				xor A 16
				setsector[I].floorstat A
			}
			else
			{
				getsector[I].floorxpanning A
				mul A -1
				setsector[I].floorxpanning A
			}
			
			ifand sector[I].ceilingstat 4
			{
				getsector[I].ceilingstat A
				or A 32
				setsector[I].ceilingstat A
			}
			else ifand sector[I].ceilingstat 48
			{
				getsector[I].ceilingstat A
				xor A 16
				setsector[I].ceilingstat A
			}
			else
			{
				getsector[I].ceilingxpanning A
				mul A -1
				setsector[I].ceilingxpanning A
			}

			add I 1
		}
		
		setvar DONE 1
		
	}
}

endevent


appendevent EVENT_EGS

ife userdef.player_skill 6
{
	ife VOLUME 2
	ife userdef.player_skill 6
	ife userdef.level_number 11
		set DONE 0

	ifmultiplayer nullop else
	ifactor APLAYER ifvare DONE 1
	{
		getactor[THISACTOR].x x
		
		ife BOSSFIGHT_LEVEL 0
			mulvar x -1
			
		setactor[THISACTOR].x x
		getactor[THISACTOR].y y
		getactor[THISACTOR].z z
		//updatesectorz x y z temp
		setsprite THISACTOR x y z
		//changespritesect THISACTOR temp
		getactor[THISACTOR].ang A
		ifvarg A 1024
		{
			setvar B 1536
		} else {
			setvar B 512
		}
		subvarvar B A
		mulvar B 2
		addvarvar A B
		
		setactor[THISACTOR].ang A
		
		setvar DONE 0
	}
}

endevent

state fliplist

getactor[THISACTOR].picnum picnum
switch picnum
case 255 case 341 case 387 case 391 case 479 case 487
case 489 case 515 case 516 case 544 case 546 case 547
case 548 case 549 case 594 case 631 case 798 case 860 case 861
case 913 case 918 case 993 case 1009 case 1011 case 1022 case 1049
case 1050 case 1148 case 1149 case 1150 case 1175 case 1225
case 1337 case 1338 case 1345 case 1346 case 1356 case 1357 case 2491
case 3426 case 3427 case 3428 case 4352 case 4364 case 4365
case 4416 case 4417 case 4423 case 4424 case 4430 case 4431
case 4432 case 4433 case 4434 case 4435 case 4456 case 4457
case 4480 case 4481 case 4482 case 4533 case 4558 case 4588
case 4589 case 4600 case 4601 case 4602 case 4603 case 4604
case 4605 case 4954
ifvarand initcstat 4 subvar initcstat 4 else orvar initcstat 4
setactor[THISACTOR].cstat initcstat
break

endswitch

ends

appendevent EVENT_GAME

ife userdef.player_skill 6
{
	ifvare initcstat -1
	{
		getactor[THISACTOR].cstat initcstat
		state fliplist
	}

	ifactor SECTOREFFECTOR setactor[THISACTOR].sectnum initsect
}

endevent

appendevent EVENT_ENTERLEVEL

	ife userdef.player_skill 6
	ife DONE 1
		set DONE 0
		
endevent
