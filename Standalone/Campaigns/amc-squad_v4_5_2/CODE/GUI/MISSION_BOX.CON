// Flags determine which mission is playable by which character
// Flag 0 => any character
// Any other flags: only those characters
defstate mission_charportrait
	// input: temp2 = character to display
	set temp3 temp2
	ifand temp3 FLAG_JAMES
	{
		ife VOLUME 4 ife LEVEL 1 {
			// James is actually KIA, but it's illogical to show him as such here, default to bionic arm portrait
			rotatesprite x y INVENSIZE 0 25566 0 0 8 0 0 xdim ydim  // bionic arm
			// rotatesprite x y INVENSIZE 0 25569 0 0 8 0 0 xdim ydim // KIA
		}
		else ifand CHAR_APP 64 rotatesprite x y INVENSIZE 0 25565 0 0 8 0 0 xdim ydim // ringworld
		else ifand CHAR_APP 1 rotatesprite x y INVENSIZE 0 25566 0 0 8 0 0 xdim ydim  // bionic arm
		else rotatesprite x y INVENSIZE 0 3589 0 0 8 0 0 xdim ydim

		xor temp3 FLAG_JAMES
		set temp7 C_JAMES
	}
	else ifand temp3 FLAG_ZAXTOR
	{
		rotatesprite x y INVENSIZE 0 3590 0 0 0 0 0 xdim ydim // Zaxtor
		xor temp3 FLAG_ZAXTOR
		set temp7 C_ZAXTOR
	}
	else ifand temp3 FLAG_MERLIJN
	{
		ifand CHAR_APP 4 rotatesprite x y INVENSIZE 0 25567 0 0 0 0 0 xdim ydim
		else rotatesprite x y INVENSIZE 0 3591 0 0 0 0 0 xdim ydim // Merlijn

		xor temp3 FLAG_MERLIJN
		set temp7 C_MERLIJN
	}
	else ifand temp3 FLAG_HIGHWIRE
	{
		ifand CHAR_APP 16 rotatesprite x y INVENSIZE 0 25568 0 0 0 0 0 xdim ydim
		else rotatesprite x y INVENSIZE 0 3593 0 0 0 0 0 xdim ydim // Highwire

		xor temp3 FLAG_HIGHWIRE
		set temp7 C_HIGHWIRE
	}
	else ifand temp3 FLAG_SANG
	{
		ifand CHAR_APP 2 rotatesprite x y INVENSIZE 0 23835 0 0 0 0 0 xdim ydim
		else rotatesprite x y INVENSIZE 0 3598 0 0 0 0 0 xdim ydim // Sang
		xor temp3 FLAG_SANG
		set temp7 C_SANG
	}
	else ifand temp3 FLAG_RUSTY
	{
		ifand CHAR_APP 32 rotatesprite x y INVENSIZE 0 25564 0 0 0 0 0 xdim ydim
		else rotatesprite x y INVENSIZE 0 3600 0 0 0 0 0 xdim ydim // Rusty

		xor temp3 FLAG_RUSTY
		set temp7 C_RUSTY
	}
	else ifand temp3 FLAG_GEOFFREY
	{
		rotatesprite x y INVENSIZE 0 3603 0 0 0 0 0 xdim ydim // Geoffrey
		xor temp3 FLAG_GEOFFREY
		set temp7 C_GEOFFREY
	}
	else ifand temp3 FLAG_MIKKO
	{
		rotatesprite x y INVENSIZE 0 3606 0 0 0 0 0 xdim ydim // Mikko
		xor temp3 FLAG_MIKKO
		set temp7 C_MIKKO
	}
	else ifand temp3 FLAG_CULTIST
	{
		rotatesprite x y INVENSIZE 0 7768 0 0 0 0 0 xdim ydim // Cultist
		xor temp3 FLAG_CULTIST
		set temp7 C_CULTIST
	}
	else ifand temp3 FLAG_BOMBSHELL
	{
		rotatesprite x y INVENSIZE 0 5368 0 0 0 0 0 xdim ydim // Bombshell
		xor temp3 FLAG_BOMBSHELL
		set temp7 C_BOMBSHELL
	}
	else ifand temp3 FLAG_MAARTEN
	{
		rotatesprite x y INVENSIZE 0 5488 0 0 0 0 0 xdim ydim // Maarten
		xor temp3 FLAG_MAARTEN
		set temp7 C_MAARTEN
	}
	else ifand temp3 FLAG_JANE
	{
		rotatesprite x y INVENSIZE 0 5366 0 0 0 0 0 xdim ydim // Jane
		xor temp3 FLAG_JANE
		set temp7 C_JANE
	}
	else ifand temp3 FLAG_MICKY
	{
		ifand CHAR_APP 256 rotatesprite x y INVENSIZE 0 18472 0 0 0 0 0 xdim ydim
		else ifand CHAR_APP 128 rotatesprite x y INVENSIZE 0 18542 0 0 0 0 0 xdim ydim
		else rotatesprite x y INVENSIZE 0 16600 0 0 0 0 0 xdim ydim // Micky
		xor temp3 FLAG_MICKY
		set temp7 C_MICKY
	}
	else ifand temp3 FLAG_SNOWFALL
	{
		rotatesprite x y INVENSIZE 0 20984 0 0 0 0 0 xdim ydim // Snowfall
		xor temp3 FLAG_SNOWFALL
		set temp7 C_SNOWFALL
	}
	else ifand temp3 FLAG_KAGURA
	{
		rotatesprite x y INVENSIZE 0 27262 0 0 0 0 0 xdim ydim // Kagura
		xor temp3 FLAG_KAGURA
		set temp7 C_KAGURA
	}

	add x 8
	add y 10
	ifn MEAL_BUFF[temp7] 0 rotatesprite x y 8192 0 13687 disp_pulse 67 0 0 0 xdim ydim // meal buffed?
	sub x 8
	sub y 10
	ifg SKILL_LEVEL 2 // fatigue?
	{
			ifg AGENT_FATIGUE[temp7] 5000 // tired?
			set disp_temp4 32
			else
			ifg AGENT_FATIGUE[temp7] 10000 // exhausted?
			set disp_temp4 2
			else
			set disp_temp4 16
	}
	else
	set disp_temp4 16


	ife PCINTER 14 rotatesprite x y INVENSIZE 0 22711 0 0 0 0 0 xdim ydim // character played box (Elysion version)
	else rotatesprite x y 19000 0 14749 0 disp_temp4 0 0 0 xdim ydim // character played box (regular AMC base version)


ends

defstate mission_charsel_first
	// Return the first selectable character based on flags
	set RETURN -1

	set temp3 FLAG_JAMES
	set temp4 FLAG_JAMES // First flag
	set temp5 0 // While loop control var, should be set to 1 if char found
	whilevarn temp5 1
	{
		ife m_charselect_flags FLAG_ALL
		{
			ife VOLUME 4 ife LEVEL 1 // James is KIA, next char is first
			{
				mul temp4 2
				set temp5 1
				set RETURN temp4
			}
			else
			{
				set RETURN FLAG_JAMES
				set temp5 1
			}
		}
		else
		{
			set temp3 temp4
			and temp3 m_charselect_flags

			ifn temp3 0
			{
				set RETURN temp3
				set temp5 1
			}
			else
				mul temp4 2
		}
	}
ends

var CHAR_IN 0 0
var CHAR_ALLOWED 0 0
defstate mission_charsel_CHAR_ALLOWED
	set CHAR_ALLOWED 1

	ifand CHAR_IN FLAG_KAGURA { ife ep4_new_char 1 nullop else set CHAR_ALLOWED 0 }
	else ifand CHAR_IN FLAG_SNOWFALL { ife ep3_new_char 1 nullop else set CHAR_ALLOWED 0 }
	else ifand CHAR_IN FLAG_MICKY { ife ep2_new_char 1 nullop else set CHAR_ALLOWED 0 }
	else ifand CHAR_IN FLAG_JANE { ifand allow_temp_characters 8 nullop else set CHAR_ALLOWED 0 }
	else ifand CHAR_IN FLAG_MAARTEN { ifand allow_temp_characters 4 nullop else set CHAR_ALLOWED 0 }
	else ifand CHAR_IN FLAG_BOMBSHELL { ifand allow_temp_characters 2 nullop else set CHAR_ALLOWED 0 }
	else ifand CHAR_IN FLAG_CULTIST { ifand allow_temp_characters 1 nullop else set CHAR_ALLOWED 0 }
ends

defstate mission_charsel_last
	// Return the last selectable character based on flags

	set temp3 FLAG_MAARTEN
	set temp4 FLAG_MAARTEN // Last flag
	set temp5 0 // While loop control var, should be set to 1 if char found
	whilevarn temp5 1
	{
		ife m_charselect_flags FLAG_ALL
		{
			set CHAR_IN temp4
			state mission_charsel_CHAR_ALLOWED
			ife CHAR_ALLOWED 1
			{
				set RETURN temp4
				set temp5 1
			}
			else
				div temp4 2
		}
		else
		{
			// Assume that the passed in flags are unlocked, just find out who is passed in
			set temp3 temp4
			and temp3 m_charselect_flags

			ifn temp3 0
			{
				set RETURN temp3
				set temp5 1
			}
			else
				div temp4 2
		}
	}
ends

defstate mission_charsel_next
	state mission_charsel_last

	ife temp2 RETURN
	{
		state mission_charsel_first
		set temp2 RETURN
	}
	else
	{
		// go to next available character
		set temp4 0

		whilevarn temp4 1
		{
			mul temp2 2
			set temp3 temp2

			set CHAR_IN temp3
			state mission_charsel_CHAR_ALLOWED

			ife CHAR_ALLOWED 0
				set temp4 0
			else
			{
				ifand temp3 m_charselect_flags
					set temp4 1
				else ife m_charselect_flags FLAG_ALL
					set temp4 1
			}
		}

	}

	set m_charselect_current temp2
ends

defstate mission_charsel_prev
	state mission_charsel_first

	ife temp2 RETURN
	{
		state mission_charsel_last
		set temp2 RETURN
	}
	else
	{
		// go to previous available character
		set temp4 0

		whilevarn temp4 1
		{
			div temp2 2
			set temp3 temp2

			set CHAR_IN temp3
			state mission_charsel_CHAR_ALLOWED

			ife CHAR_ALLOWED 0
				set temp4 0
			else
			{
				ifand temp3 m_charselect_flags
					set temp4 1
				else ife m_charselect_flags FLAG_ALL
					set temp4 1
			}
		}
	}

	set m_charselect_current temp2
ends

defstate mission_charsel_prevbutton
	set gui_pos_x x
	set gui_pos_y y
	state CURSOR_OVER_ITEM

	ifl gui_pos_x_temp 7
	 ifg gui_pos_x_temp -7
	  ifl gui_pos_y_temp 20
	   ifg gui_pos_y_temp -20
	{
		rotatesprite x y 16384 1024 13576 disp_pulse 0 12 0 0 xdim ydim

		state handle_click

		ife clicked 1
		{
			sound RES_INT2
			state mission_charsel_prev
		}
	}
	else
		rotatesprite x y 16384 1024 13575 0 0 12 0 0 xdim ydim
ends

defstate mission_charsel_nextbutton
	set gui_pos_x x
	set gui_pos_y y
	state CURSOR_OVER_ITEM

	ifl gui_pos_x_temp 7
	 ifg gui_pos_x_temp -7
	  ifl gui_pos_y_temp 20
	   ifg gui_pos_y_temp -20
	{
		rotatesprite x y 16384 0 13576 disp_pulse 0 8 0 0 xdim ydim

		state handle_click

		ife clicked 1
		{
			sound RES_INT2
			state mission_charsel_next
		}
	}
	else
		rotatesprite x y 16384 0 13575 0 0 8 0 0 xdim ydim
ends

defstate mission_currentplayerchar
	switch CHAR
		case C_JAMES
			set m_charselect_current FLAG_JAMES
			break
		case C_ZAXTOR
			set m_charselect_current FLAG_ZAXTOR
			break
		case C_MERLIJN
			set m_charselect_current FLAG_MERLIJN
			break
		case C_HIGHWIRE
			set m_charselect_current FLAG_HIGHWIRE
			break
		case C_SANG
			set m_charselect_current FLAG_SANG
			break
		case C_RUSTY
			set m_charselect_current FLAG_RUSTY
			break
		case C_GEOFFREY
			set m_charselect_current FLAG_GEOFFREY
			break
		case C_MIKKO
			set m_charselect_current FLAG_MIKKO
			break
		case C_CULTIST
			set m_charselect_current FLAG_CULTIST
			break
		case C_BOMBSHELL
			set m_charselect_current FLAG_BOMBSHELL
			break
		case C_MAARTEN
			set m_charselect_current FLAG_MAARTEN
			break
		case C_JANE
			set m_charselect_current FLAG_JANE
			break
		case C_MICKY
			set m_charselect_current FLAG_MICKY
			break
		case C_SNOWFALL
			set m_charselect_current FLAG_SNOWFALL
			break
		case C_KAGURA
			set m_charselect_current FLAG_KAGURA
			break
	endswitch
ends

defstate mission_setcharfromselect					 
	ifand m_charselect_current FLAG_JAMES
		set CHAR C_JAMES
	else ifand m_charselect_current FLAG_ZAXTOR
		set CHAR C_ZAXTOR
	else ifand m_charselect_current FLAG_MERLIJN
		set CHAR C_MERLIJN
	else ifand m_charselect_current FLAG_HIGHWIRE
		set CHAR C_HIGHWIRE
	else ifand m_charselect_current FLAG_SANG
		set CHAR C_SANG
	else ifand m_charselect_current FLAG_RUSTY
		set CHAR C_RUSTY
	else ifand m_charselect_current FLAG_GEOFFREY
		set CHAR C_GEOFFREY
	else ifand m_charselect_current FLAG_MIKKO
		set CHAR C_MIKKO
	else ifand m_charselect_current FLAG_CULTIST
		set CHAR C_CULTIST
	else ifand m_charselect_current FLAG_BOMBSHELL
		set CHAR C_BOMBSHELL
	else ifand m_charselect_current FLAG_MAARTEN
		set CHAR C_MAARTEN
	else ifand m_charselect_current FLAG_JANE
		set CHAR C_JANE
	else ifand m_charselect_current FLAG_MICKY
		set CHAR C_MICKY
	else ifand m_charselect_current FLAG_SNOWFALL
		set CHAR C_SNOWFALL
	else ifand m_charselect_current FLAG_KAGURA
		set CHAR C_KAGURA
	addphealth 1000
	state SELECTEDCHAR
	addphealth 1000
ends

defstate mission_charselector
	set m_charselect_used 1

	set x 240
	set y 80

	// Not forced -> display only one character portrait with arrows to select character
	ife m_charselect_forced 0
	{
		ife m_charselect_current FLAG_ALL
		  ifn m_charselect_flags FLAG_ALL
		{
			state mission_charsel_first
			set m_charselect_current RETURN
		}
		else ife m_charselect_current FLAG_ALL
			// To current played character
			state mission_currentplayerchar

		set temp2 m_charselect_current

		state mission_charsel_prevbutton

		add x 20
		state mission_charportrait

		add x 20
		state mission_charsel_nextbutton
	}
	// forced character mission (flags denote which characters) -> display as many portraits below eachother as there are characters flagged
	else ife m_charselect_forced 1
	{
		set temp2 m_charselect_flags
		whilevarn temp2 0
		{
			state mission_charportrait
			set temp2 temp3

			// 2 columns 2 rows
			ife y 80
				add y 30
			else
			{
				set y 80
				add x 30
			}
		}
	}
ends
